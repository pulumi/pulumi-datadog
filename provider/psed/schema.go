// Copyright 2016-2024, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// psed - Pulumi Schema EDitor.
//
// psed is a utility library for manipulating schemas generated by the pulumi-terraform-bridge.
package psed

import (
	"encoding/json"
	"errors"
	"fmt"
	"strings"

	"github.com/pulumi/pulumi/pkg/v3/codegen/schema"
	"github.com/pulumi/pulumi/sdk/v3/go/common/tokens"

	"github.com/pulumi/pulumi/sdk/v3/go/common/util/contract"
)

func CopyType(spec *schema.PackageSpec, from, to tokens.Type) {
	src, ok := spec.Types[from.String()]
	contract.Assertf(ok, "could not find type to copy: %q", from)

	// Deep copy
	b, err := json.Marshal(src)
	contract.AssertNoErrorf(err, "deep copy failed")
	src = schema.ComplexTypeSpec{}
	err = json.Unmarshal(b, &src)
	contract.AssertNoErrorf(err, "deep copy failed")

	// Move any subtypes
	TraverseTypes(&src, func(t *schema.TypeSpec) {
		const prefix = "#/types/"
		tokStr, ok := strings.CutPrefix(t.Ref, prefix)
		if !ok {
			return
		}

		typ, err := tokens.ParseTypeToken(tokStr)
		contract.AssertNoErrorf(err, "invalid schem")

		if rest, ok := strings.CutPrefix(typ.Name().String(), from.Name().String()); ok {
			nestedTo := typeToken{to}.WithLogicalName(tokens.TypeName(to.Name().String() + rest))
			CopyType(spec, typ, nestedTo.Type)

			t.Ref = "#/types/" + nestedTo.String()
		}
	})

	spec.Types[to.String()] = src
}

// DeleteType recursively deletes a type from a package.
func DeleteType(spec *schema.PackageSpec, typ tokens.Type) {
	t, ok := spec.Types[string(typ)]
	if !ok {
		// This type may have already been deleted, so we return early.
		return
	}

	for _, prop := range t.ObjectTypeSpec.Properties {
		prop := prop
		deleteTypeSpec(spec, &prop.TypeSpec)
	}

	delete(spec.Types, string(typ))
}

func deleteTypeSpec(spec *schema.PackageSpec, typ *schema.TypeSpec) {
	if typ == nil {
		return
	}
	deleteTypeSpec(spec, typ.AdditionalProperties)
	deleteTypeSpec(spec, typ.Items)

	if propRef, ok := strings.CutPrefix(typ.Ref, "#/types/"); ok {
		propRefTok, err := tokens.ParseTypeToken(propRef)
		contract.AssertNoErrorf(err, "invalid type token")
		DeleteType(spec, propRefTok)
	}
}

func TraverseTypes(t *schema.ComplexTypeSpec, f func(*schema.TypeSpec)) {
	traverseObjectTypes(&t.ObjectTypeSpec, f)
}

func traverseObjectTypes(o *schema.ObjectTypeSpec, f func(*schema.TypeSpec)) {
	for k, v := range o.Properties {
		v := v
		traversePropertyTypes(&v, f)
		o.Properties[k] = v
	}
}

func traversePropertyTypes(o *schema.PropertySpec, f func(*schema.TypeSpec)) {
	f(&o.TypeSpec)
	if o.Items != nil {
		f(o.Items)
	}
	if o.AdditionalProperties != nil {
		f(o.AdditionalProperties)
	}
}

func TraverseResourceTypes(r *schema.ResourceSpec, f func(*schema.TypeSpec)) {
	for k, v := range r.InputProperties {
		v := v
		traversePropertyTypes(&v, f)
		r.InputProperties[k] = v
	}
	if r.StateInputs != nil {
		traverseObjectTypes(r.StateInputs, f)
	}
	traverseObjectTypes(&r.ObjectTypeSpec, f)
}

func TraverseFunctionTypes(t *schema.FunctionSpec, f func(*schema.TypeSpec)) {
	if t.Inputs != nil {
		traverseObjectTypes(t.Inputs, f)
	}
	if t.Outputs != nil {
		traverseObjectTypes(t.Outputs, f)
	}
	if t.ReturnType != nil {
		traverseObjectTypes(t.ReturnType.ObjectTypeSpec, f)
		f(t.ReturnType.TypeSpec)
	}
}

// AssertSuperSetOf checks that `smaller` is is indeed smaller then `larger`.
//
// That means that it is always safe to substitute an instance of `larger` for an instance
// of `smaller`, given a structural type system. In effect, this will check that users
// only need to fix up type names to migrate from `smaller` to `larger`.
func AssertSuperSetOf(spec *schema.PackageSpec, smaller, larger tokens.Type) error {
	if err := (superSetChecker{}.assertSuperSetOf(spec, smaller, larger)); err != nil {
		return fmt.Errorf("%s ! <= %s: %w", smaller.String(), larger.String(), err)
	}
	return nil
}

// superSetChecker map[K]V should be interpreted as:
//
// K has been (or is being) checked to be a subset of {v where v in V}
type superSetChecker map[tokens.Type][]tokens.Type

func (s superSetChecker) alreadyChecking(smaller, larger tokens.Type) bool {
	for _, v := range s[smaller] {
		if v == larger {
			return true
		}
	}
	s[smaller] = append(s[smaller], larger)
	return false
}

func (s superSetChecker) assertSuperSetOf(spec *schema.PackageSpec, smaller, larger tokens.Type) error {
	if s.alreadyChecking(smaller, larger) {
		return nil
	}

	smallerSpec, ok := spec.Types[smaller.String()]
	contract.Assertf(ok, "invalid schema: dangling ref %q", smaller.String())
	largerSpec, ok := spec.Types[larger.String()]
	contract.Assertf(ok, "invalid schema: dangling ref %q", larger.String())

	var errs []error
	for k, prop := range smallerSpec.Properties {
		v, ok := largerSpec.Properties[k]
		if !ok {
			errs = append(errs, fmt.Errorf("missing property %q", k))
			continue
		}
		if err := s.assertTypeSuperSetOf(spec, prop.TypeSpec, v.TypeSpec); err != nil {
			errs = append(errs, fmt.Errorf("%s: %w", k, err))
		}
	}

	return errors.Join(errs...)
}

func (s superSetChecker) assertTypeSuperSetOf(spec *schema.PackageSpec, smaller, larger schema.TypeSpec) error {
	var errs []error
	if smaller.Type != larger.Type {
		errs = append(errs, fmt.Errorf(".Type mismatch: %q != %q", smaller.Type, larger.Type))
	}
	if smaller.Ref != larger.Ref {
		if err := s.assertSuperSetOf(spec,
			tokens.Type(strings.TrimPrefix(smaller.Ref, typePrefix)),
			tokens.Type(strings.TrimPrefix(larger.Ref, typePrefix)),
		); err != nil {
			errs = append(errs, fmt.Errorf(".Ref mismatch: %w", err))
		}
	}

	errs = append(errs,
		s.assertTypeExtensionSuperSetOf(spec, "AdditionalProperties",
			smaller.AdditionalProperties, larger.AdditionalProperties),
		s.assertTypeExtensionSuperSetOf(spec, "Items",
			smaller.Items, larger.Items),
	)

	return errors.Join(errs...)
}

func (s superSetChecker) assertTypeExtensionSuperSetOf(spec *schema.PackageSpec, extension string, smaller, larger *schema.TypeSpec) error {
	switch {
	case smaller == nil && larger == nil:
		return nil
	case smaller != nil && larger != nil:
		return s.assertTypeSuperSetOf(spec, *smaller, *larger)
	case larger != nil:
		contract.Assertf(smaller == nil, "smaller was already checked")
		return fmt.Errorf("missing .%s: %#v", extension, *larger.AdditionalProperties)
	default: // smaller != nil
		return fmt.Errorf("extra .%s: %#v", extension, *smaller)
	}
}

const typePrefix = "#/types/"

// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package datadog

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Resource for interacting with the logsMetric API
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := datadog.NewLogsMetric(ctx, "testing_logs_metric", &datadog.LogsMetricArgs{
//				Name: pulumi.String("testing.logs.metric"),
//				Compute: &datadog.LogsMetricComputeArgs{
//					AggregationType: pulumi.String("distribution"),
//					Path:            pulumi.String("@duration"),
//				},
//				Filter: &datadog.LogsMetricFilterArgs{
//					Query: pulumi.String("service:test"),
//				},
//				GroupBies: datadog.LogsMetricGroupByArray{
//					&datadog.LogsMetricGroupByArgs{
//						Path:    pulumi.String("@status"),
//						TagName: pulumi.String("status"),
//					},
//					&datadog.LogsMetricGroupByArgs{
//						Path:    pulumi.String("@version"),
//						TagName: pulumi.String("version"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import datadog:index/logsMetric:LogsMetric testing_logs_metric testing.logs.metric
// ```
type LogsMetric struct {
	pulumi.CustomResourceState

	// The compute rule to compute the log-based metric. This field can't be updated after creation.
	Compute LogsMetricComputeOutput `pulumi:"compute"`
	// The log-based metric filter. Logs matching this filter will be aggregated in this metric.
	Filter LogsMetricFilterOutput `pulumi:"filter"`
	// The rules for the group by.
	GroupBies LogsMetricGroupByArrayOutput `pulumi:"groupBies"`
	// The name of the log-based metric. This field can't be updated after creation.
	Name pulumi.StringOutput `pulumi:"name"`
}

// NewLogsMetric registers a new resource with the given unique name, arguments, and options.
func NewLogsMetric(ctx *pulumi.Context,
	name string, args *LogsMetricArgs, opts ...pulumi.ResourceOption) (*LogsMetric, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Compute == nil {
		return nil, errors.New("invalid value for required argument 'Compute'")
	}
	if args.Filter == nil {
		return nil, errors.New("invalid value for required argument 'Filter'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LogsMetric
	err := ctx.RegisterResource("datadog:index/logsMetric:LogsMetric", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLogsMetric gets an existing LogsMetric resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLogsMetric(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LogsMetricState, opts ...pulumi.ResourceOption) (*LogsMetric, error) {
	var resource LogsMetric
	err := ctx.ReadResource("datadog:index/logsMetric:LogsMetric", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LogsMetric resources.
type logsMetricState struct {
	// The compute rule to compute the log-based metric. This field can't be updated after creation.
	Compute *LogsMetricCompute `pulumi:"compute"`
	// The log-based metric filter. Logs matching this filter will be aggregated in this metric.
	Filter *LogsMetricFilter `pulumi:"filter"`
	// The rules for the group by.
	GroupBies []LogsMetricGroupBy `pulumi:"groupBies"`
	// The name of the log-based metric. This field can't be updated after creation.
	Name *string `pulumi:"name"`
}

type LogsMetricState struct {
	// The compute rule to compute the log-based metric. This field can't be updated after creation.
	Compute LogsMetricComputePtrInput
	// The log-based metric filter. Logs matching this filter will be aggregated in this metric.
	Filter LogsMetricFilterPtrInput
	// The rules for the group by.
	GroupBies LogsMetricGroupByArrayInput
	// The name of the log-based metric. This field can't be updated after creation.
	Name pulumi.StringPtrInput
}

func (LogsMetricState) ElementType() reflect.Type {
	return reflect.TypeOf((*logsMetricState)(nil)).Elem()
}

type logsMetricArgs struct {
	// The compute rule to compute the log-based metric. This field can't be updated after creation.
	Compute LogsMetricCompute `pulumi:"compute"`
	// The log-based metric filter. Logs matching this filter will be aggregated in this metric.
	Filter LogsMetricFilter `pulumi:"filter"`
	// The rules for the group by.
	GroupBies []LogsMetricGroupBy `pulumi:"groupBies"`
	// The name of the log-based metric. This field can't be updated after creation.
	Name string `pulumi:"name"`
}

// The set of arguments for constructing a LogsMetric resource.
type LogsMetricArgs struct {
	// The compute rule to compute the log-based metric. This field can't be updated after creation.
	Compute LogsMetricComputeInput
	// The log-based metric filter. Logs matching this filter will be aggregated in this metric.
	Filter LogsMetricFilterInput
	// The rules for the group by.
	GroupBies LogsMetricGroupByArrayInput
	// The name of the log-based metric. This field can't be updated after creation.
	Name pulumi.StringInput
}

func (LogsMetricArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*logsMetricArgs)(nil)).Elem()
}

type LogsMetricInput interface {
	pulumi.Input

	ToLogsMetricOutput() LogsMetricOutput
	ToLogsMetricOutputWithContext(ctx context.Context) LogsMetricOutput
}

func (*LogsMetric) ElementType() reflect.Type {
	return reflect.TypeOf((**LogsMetric)(nil)).Elem()
}

func (i *LogsMetric) ToLogsMetricOutput() LogsMetricOutput {
	return i.ToLogsMetricOutputWithContext(context.Background())
}

func (i *LogsMetric) ToLogsMetricOutputWithContext(ctx context.Context) LogsMetricOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsMetricOutput)
}

// LogsMetricArrayInput is an input type that accepts LogsMetricArray and LogsMetricArrayOutput values.
// You can construct a concrete instance of `LogsMetricArrayInput` via:
//
//	LogsMetricArray{ LogsMetricArgs{...} }
type LogsMetricArrayInput interface {
	pulumi.Input

	ToLogsMetricArrayOutput() LogsMetricArrayOutput
	ToLogsMetricArrayOutputWithContext(context.Context) LogsMetricArrayOutput
}

type LogsMetricArray []LogsMetricInput

func (LogsMetricArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogsMetric)(nil)).Elem()
}

func (i LogsMetricArray) ToLogsMetricArrayOutput() LogsMetricArrayOutput {
	return i.ToLogsMetricArrayOutputWithContext(context.Background())
}

func (i LogsMetricArray) ToLogsMetricArrayOutputWithContext(ctx context.Context) LogsMetricArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsMetricArrayOutput)
}

// LogsMetricMapInput is an input type that accepts LogsMetricMap and LogsMetricMapOutput values.
// You can construct a concrete instance of `LogsMetricMapInput` via:
//
//	LogsMetricMap{ "key": LogsMetricArgs{...} }
type LogsMetricMapInput interface {
	pulumi.Input

	ToLogsMetricMapOutput() LogsMetricMapOutput
	ToLogsMetricMapOutputWithContext(context.Context) LogsMetricMapOutput
}

type LogsMetricMap map[string]LogsMetricInput

func (LogsMetricMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogsMetric)(nil)).Elem()
}

func (i LogsMetricMap) ToLogsMetricMapOutput() LogsMetricMapOutput {
	return i.ToLogsMetricMapOutputWithContext(context.Background())
}

func (i LogsMetricMap) ToLogsMetricMapOutputWithContext(ctx context.Context) LogsMetricMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsMetricMapOutput)
}

type LogsMetricOutput struct{ *pulumi.OutputState }

func (LogsMetricOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogsMetric)(nil)).Elem()
}

func (o LogsMetricOutput) ToLogsMetricOutput() LogsMetricOutput {
	return o
}

func (o LogsMetricOutput) ToLogsMetricOutputWithContext(ctx context.Context) LogsMetricOutput {
	return o
}

// The compute rule to compute the log-based metric. This field can't be updated after creation.
func (o LogsMetricOutput) Compute() LogsMetricComputeOutput {
	return o.ApplyT(func(v *LogsMetric) LogsMetricComputeOutput { return v.Compute }).(LogsMetricComputeOutput)
}

// The log-based metric filter. Logs matching this filter will be aggregated in this metric.
func (o LogsMetricOutput) Filter() LogsMetricFilterOutput {
	return o.ApplyT(func(v *LogsMetric) LogsMetricFilterOutput { return v.Filter }).(LogsMetricFilterOutput)
}

// The rules for the group by.
func (o LogsMetricOutput) GroupBies() LogsMetricGroupByArrayOutput {
	return o.ApplyT(func(v *LogsMetric) LogsMetricGroupByArrayOutput { return v.GroupBies }).(LogsMetricGroupByArrayOutput)
}

// The name of the log-based metric. This field can't be updated after creation.
func (o LogsMetricOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *LogsMetric) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

type LogsMetricArrayOutput struct{ *pulumi.OutputState }

func (LogsMetricArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogsMetric)(nil)).Elem()
}

func (o LogsMetricArrayOutput) ToLogsMetricArrayOutput() LogsMetricArrayOutput {
	return o
}

func (o LogsMetricArrayOutput) ToLogsMetricArrayOutputWithContext(ctx context.Context) LogsMetricArrayOutput {
	return o
}

func (o LogsMetricArrayOutput) Index(i pulumi.IntInput) LogsMetricOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LogsMetric {
		return vs[0].([]*LogsMetric)[vs[1].(int)]
	}).(LogsMetricOutput)
}

type LogsMetricMapOutput struct{ *pulumi.OutputState }

func (LogsMetricMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogsMetric)(nil)).Elem()
}

func (o LogsMetricMapOutput) ToLogsMetricMapOutput() LogsMetricMapOutput {
	return o
}

func (o LogsMetricMapOutput) ToLogsMetricMapOutputWithContext(ctx context.Context) LogsMetricMapOutput {
	return o
}

func (o LogsMetricMapOutput) MapIndex(k pulumi.StringInput) LogsMetricOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LogsMetric {
		return vs[0].(map[string]*LogsMetric)[vs[1].(string)]
	}).(LogsMetricOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LogsMetricInput)(nil)).Elem(), &LogsMetric{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogsMetricArrayInput)(nil)).Elem(), LogsMetricArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogsMetricMapInput)(nil)).Elem(), LogsMetricMap{})
	pulumi.RegisterOutputType(LogsMetricOutput{})
	pulumi.RegisterOutputType(LogsMetricArrayOutput{})
	pulumi.RegisterOutputType(LogsMetricMapOutput{})
}

// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package datadog

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// Provides a Datadog DowntimeSchedule resource. This can be used to create and manage Datadog downtimes.
//
// ## Import
//
// ```sh
//
//	$ pulumi import datadog:index/downtimeSchedule:DowntimeSchedule new_list "00e000000-0000-1234-0000-000000000000"
//
// ```
type DowntimeSchedule struct {
	pulumi.CustomResourceState

	// The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
	DisplayTimezone pulumi.StringOutput `pulumi:"displayTimezone"`
	// A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same `@username` notation as events.
	Message           pulumi.StringPtrOutput                     `pulumi:"message"`
	MonitorIdentifier DowntimeScheduleMonitorIdentifierPtrOutput `pulumi:"monitorIdentifier"`
	// If the first recovery notification during a downtime should be muted.
	MuteFirstRecoveryNotification pulumi.BoolOutput `pulumi:"muteFirstRecoveryNotification"`
	// States that will trigger a monitor notification when the `notifyEndTypes` action occurs.
	NotifyEndStates pulumi.StringArrayOutput `pulumi:"notifyEndStates"`
	// Actions that will trigger a monitor notification if the downtime is in the `notifyEndTypes` state.
	NotifyEndTypes    pulumi.StringArrayOutput                   `pulumi:"notifyEndTypes"`
	OneTimeSchedule   DowntimeScheduleOneTimeSchedulePtrOutput   `pulumi:"oneTimeSchedule"`
	RecurringSchedule DowntimeScheduleRecurringSchedulePtrOutput `pulumi:"recurringSchedule"`
	// The scope to which the downtime applies. Must follow the [common search syntax](https://docs.datadoghq.com/logs/explorer/search_syntax/).
	Scope pulumi.StringOutput `pulumi:"scope"`
}

// NewDowntimeSchedule registers a new resource with the given unique name, arguments, and options.
func NewDowntimeSchedule(ctx *pulumi.Context,
	name string, args *DowntimeScheduleArgs, opts ...pulumi.ResourceOption) (*DowntimeSchedule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Scope == nil {
		return nil, errors.New("invalid value for required argument 'Scope'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DowntimeSchedule
	err := ctx.RegisterResource("datadog:index/downtimeSchedule:DowntimeSchedule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDowntimeSchedule gets an existing DowntimeSchedule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDowntimeSchedule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DowntimeScheduleState, opts ...pulumi.ResourceOption) (*DowntimeSchedule, error) {
	var resource DowntimeSchedule
	err := ctx.ReadResource("datadog:index/downtimeSchedule:DowntimeSchedule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DowntimeSchedule resources.
type downtimeScheduleState struct {
	// The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
	DisplayTimezone *string `pulumi:"displayTimezone"`
	// A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same `@username` notation as events.
	Message           *string                            `pulumi:"message"`
	MonitorIdentifier *DowntimeScheduleMonitorIdentifier `pulumi:"monitorIdentifier"`
	// If the first recovery notification during a downtime should be muted.
	MuteFirstRecoveryNotification *bool `pulumi:"muteFirstRecoveryNotification"`
	// States that will trigger a monitor notification when the `notifyEndTypes` action occurs.
	NotifyEndStates []string `pulumi:"notifyEndStates"`
	// Actions that will trigger a monitor notification if the downtime is in the `notifyEndTypes` state.
	NotifyEndTypes    []string                           `pulumi:"notifyEndTypes"`
	OneTimeSchedule   *DowntimeScheduleOneTimeSchedule   `pulumi:"oneTimeSchedule"`
	RecurringSchedule *DowntimeScheduleRecurringSchedule `pulumi:"recurringSchedule"`
	// The scope to which the downtime applies. Must follow the [common search syntax](https://docs.datadoghq.com/logs/explorer/search_syntax/).
	Scope *string `pulumi:"scope"`
}

type DowntimeScheduleState struct {
	// The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
	DisplayTimezone pulumi.StringPtrInput
	// A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same `@username` notation as events.
	Message           pulumi.StringPtrInput
	MonitorIdentifier DowntimeScheduleMonitorIdentifierPtrInput
	// If the first recovery notification during a downtime should be muted.
	MuteFirstRecoveryNotification pulumi.BoolPtrInput
	// States that will trigger a monitor notification when the `notifyEndTypes` action occurs.
	NotifyEndStates pulumi.StringArrayInput
	// Actions that will trigger a monitor notification if the downtime is in the `notifyEndTypes` state.
	NotifyEndTypes    pulumi.StringArrayInput
	OneTimeSchedule   DowntimeScheduleOneTimeSchedulePtrInput
	RecurringSchedule DowntimeScheduleRecurringSchedulePtrInput
	// The scope to which the downtime applies. Must follow the [common search syntax](https://docs.datadoghq.com/logs/explorer/search_syntax/).
	Scope pulumi.StringPtrInput
}

func (DowntimeScheduleState) ElementType() reflect.Type {
	return reflect.TypeOf((*downtimeScheduleState)(nil)).Elem()
}

type downtimeScheduleArgs struct {
	// The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
	DisplayTimezone *string `pulumi:"displayTimezone"`
	// A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same `@username` notation as events.
	Message           *string                            `pulumi:"message"`
	MonitorIdentifier *DowntimeScheduleMonitorIdentifier `pulumi:"monitorIdentifier"`
	// If the first recovery notification during a downtime should be muted.
	MuteFirstRecoveryNotification *bool `pulumi:"muteFirstRecoveryNotification"`
	// States that will trigger a monitor notification when the `notifyEndTypes` action occurs.
	NotifyEndStates []string `pulumi:"notifyEndStates"`
	// Actions that will trigger a monitor notification if the downtime is in the `notifyEndTypes` state.
	NotifyEndTypes    []string                           `pulumi:"notifyEndTypes"`
	OneTimeSchedule   *DowntimeScheduleOneTimeSchedule   `pulumi:"oneTimeSchedule"`
	RecurringSchedule *DowntimeScheduleRecurringSchedule `pulumi:"recurringSchedule"`
	// The scope to which the downtime applies. Must follow the [common search syntax](https://docs.datadoghq.com/logs/explorer/search_syntax/).
	Scope string `pulumi:"scope"`
}

// The set of arguments for constructing a DowntimeSchedule resource.
type DowntimeScheduleArgs struct {
	// The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
	DisplayTimezone pulumi.StringPtrInput
	// A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same `@username` notation as events.
	Message           pulumi.StringPtrInput
	MonitorIdentifier DowntimeScheduleMonitorIdentifierPtrInput
	// If the first recovery notification during a downtime should be muted.
	MuteFirstRecoveryNotification pulumi.BoolPtrInput
	// States that will trigger a monitor notification when the `notifyEndTypes` action occurs.
	NotifyEndStates pulumi.StringArrayInput
	// Actions that will trigger a monitor notification if the downtime is in the `notifyEndTypes` state.
	NotifyEndTypes    pulumi.StringArrayInput
	OneTimeSchedule   DowntimeScheduleOneTimeSchedulePtrInput
	RecurringSchedule DowntimeScheduleRecurringSchedulePtrInput
	// The scope to which the downtime applies. Must follow the [common search syntax](https://docs.datadoghq.com/logs/explorer/search_syntax/).
	Scope pulumi.StringInput
}

func (DowntimeScheduleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*downtimeScheduleArgs)(nil)).Elem()
}

type DowntimeScheduleInput interface {
	pulumi.Input

	ToDowntimeScheduleOutput() DowntimeScheduleOutput
	ToDowntimeScheduleOutputWithContext(ctx context.Context) DowntimeScheduleOutput
}

func (*DowntimeSchedule) ElementType() reflect.Type {
	return reflect.TypeOf((**DowntimeSchedule)(nil)).Elem()
}

func (i *DowntimeSchedule) ToDowntimeScheduleOutput() DowntimeScheduleOutput {
	return i.ToDowntimeScheduleOutputWithContext(context.Background())
}

func (i *DowntimeSchedule) ToDowntimeScheduleOutputWithContext(ctx context.Context) DowntimeScheduleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DowntimeScheduleOutput)
}

func (i *DowntimeSchedule) ToOutput(ctx context.Context) pulumix.Output[*DowntimeSchedule] {
	return pulumix.Output[*DowntimeSchedule]{
		OutputState: i.ToDowntimeScheduleOutputWithContext(ctx).OutputState,
	}
}

// DowntimeScheduleArrayInput is an input type that accepts DowntimeScheduleArray and DowntimeScheduleArrayOutput values.
// You can construct a concrete instance of `DowntimeScheduleArrayInput` via:
//
//	DowntimeScheduleArray{ DowntimeScheduleArgs{...} }
type DowntimeScheduleArrayInput interface {
	pulumi.Input

	ToDowntimeScheduleArrayOutput() DowntimeScheduleArrayOutput
	ToDowntimeScheduleArrayOutputWithContext(context.Context) DowntimeScheduleArrayOutput
}

type DowntimeScheduleArray []DowntimeScheduleInput

func (DowntimeScheduleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DowntimeSchedule)(nil)).Elem()
}

func (i DowntimeScheduleArray) ToDowntimeScheduleArrayOutput() DowntimeScheduleArrayOutput {
	return i.ToDowntimeScheduleArrayOutputWithContext(context.Background())
}

func (i DowntimeScheduleArray) ToDowntimeScheduleArrayOutputWithContext(ctx context.Context) DowntimeScheduleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DowntimeScheduleArrayOutput)
}

func (i DowntimeScheduleArray) ToOutput(ctx context.Context) pulumix.Output[[]*DowntimeSchedule] {
	return pulumix.Output[[]*DowntimeSchedule]{
		OutputState: i.ToDowntimeScheduleArrayOutputWithContext(ctx).OutputState,
	}
}

// DowntimeScheduleMapInput is an input type that accepts DowntimeScheduleMap and DowntimeScheduleMapOutput values.
// You can construct a concrete instance of `DowntimeScheduleMapInput` via:
//
//	DowntimeScheduleMap{ "key": DowntimeScheduleArgs{...} }
type DowntimeScheduleMapInput interface {
	pulumi.Input

	ToDowntimeScheduleMapOutput() DowntimeScheduleMapOutput
	ToDowntimeScheduleMapOutputWithContext(context.Context) DowntimeScheduleMapOutput
}

type DowntimeScheduleMap map[string]DowntimeScheduleInput

func (DowntimeScheduleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DowntimeSchedule)(nil)).Elem()
}

func (i DowntimeScheduleMap) ToDowntimeScheduleMapOutput() DowntimeScheduleMapOutput {
	return i.ToDowntimeScheduleMapOutputWithContext(context.Background())
}

func (i DowntimeScheduleMap) ToDowntimeScheduleMapOutputWithContext(ctx context.Context) DowntimeScheduleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DowntimeScheduleMapOutput)
}

func (i DowntimeScheduleMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*DowntimeSchedule] {
	return pulumix.Output[map[string]*DowntimeSchedule]{
		OutputState: i.ToDowntimeScheduleMapOutputWithContext(ctx).OutputState,
	}
}

type DowntimeScheduleOutput struct{ *pulumi.OutputState }

func (DowntimeScheduleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DowntimeSchedule)(nil)).Elem()
}

func (o DowntimeScheduleOutput) ToDowntimeScheduleOutput() DowntimeScheduleOutput {
	return o
}

func (o DowntimeScheduleOutput) ToDowntimeScheduleOutputWithContext(ctx context.Context) DowntimeScheduleOutput {
	return o
}

func (o DowntimeScheduleOutput) ToOutput(ctx context.Context) pulumix.Output[*DowntimeSchedule] {
	return pulumix.Output[*DowntimeSchedule]{
		OutputState: o.OutputState,
	}
}

// The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
func (o DowntimeScheduleOutput) DisplayTimezone() pulumi.StringOutput {
	return o.ApplyT(func(v *DowntimeSchedule) pulumi.StringOutput { return v.DisplayTimezone }).(pulumi.StringOutput)
}

// A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same `@username` notation as events.
func (o DowntimeScheduleOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DowntimeSchedule) pulumi.StringPtrOutput { return v.Message }).(pulumi.StringPtrOutput)
}

func (o DowntimeScheduleOutput) MonitorIdentifier() DowntimeScheduleMonitorIdentifierPtrOutput {
	return o.ApplyT(func(v *DowntimeSchedule) DowntimeScheduleMonitorIdentifierPtrOutput { return v.MonitorIdentifier }).(DowntimeScheduleMonitorIdentifierPtrOutput)
}

// If the first recovery notification during a downtime should be muted.
func (o DowntimeScheduleOutput) MuteFirstRecoveryNotification() pulumi.BoolOutput {
	return o.ApplyT(func(v *DowntimeSchedule) pulumi.BoolOutput { return v.MuteFirstRecoveryNotification }).(pulumi.BoolOutput)
}

// States that will trigger a monitor notification when the `notifyEndTypes` action occurs.
func (o DowntimeScheduleOutput) NotifyEndStates() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DowntimeSchedule) pulumi.StringArrayOutput { return v.NotifyEndStates }).(pulumi.StringArrayOutput)
}

// Actions that will trigger a monitor notification if the downtime is in the `notifyEndTypes` state.
func (o DowntimeScheduleOutput) NotifyEndTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DowntimeSchedule) pulumi.StringArrayOutput { return v.NotifyEndTypes }).(pulumi.StringArrayOutput)
}

func (o DowntimeScheduleOutput) OneTimeSchedule() DowntimeScheduleOneTimeSchedulePtrOutput {
	return o.ApplyT(func(v *DowntimeSchedule) DowntimeScheduleOneTimeSchedulePtrOutput { return v.OneTimeSchedule }).(DowntimeScheduleOneTimeSchedulePtrOutput)
}

func (o DowntimeScheduleOutput) RecurringSchedule() DowntimeScheduleRecurringSchedulePtrOutput {
	return o.ApplyT(func(v *DowntimeSchedule) DowntimeScheduleRecurringSchedulePtrOutput { return v.RecurringSchedule }).(DowntimeScheduleRecurringSchedulePtrOutput)
}

// The scope to which the downtime applies. Must follow the [common search syntax](https://docs.datadoghq.com/logs/explorer/search_syntax/).
func (o DowntimeScheduleOutput) Scope() pulumi.StringOutput {
	return o.ApplyT(func(v *DowntimeSchedule) pulumi.StringOutput { return v.Scope }).(pulumi.StringOutput)
}

type DowntimeScheduleArrayOutput struct{ *pulumi.OutputState }

func (DowntimeScheduleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DowntimeSchedule)(nil)).Elem()
}

func (o DowntimeScheduleArrayOutput) ToDowntimeScheduleArrayOutput() DowntimeScheduleArrayOutput {
	return o
}

func (o DowntimeScheduleArrayOutput) ToDowntimeScheduleArrayOutputWithContext(ctx context.Context) DowntimeScheduleArrayOutput {
	return o
}

func (o DowntimeScheduleArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*DowntimeSchedule] {
	return pulumix.Output[[]*DowntimeSchedule]{
		OutputState: o.OutputState,
	}
}

func (o DowntimeScheduleArrayOutput) Index(i pulumi.IntInput) DowntimeScheduleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DowntimeSchedule {
		return vs[0].([]*DowntimeSchedule)[vs[1].(int)]
	}).(DowntimeScheduleOutput)
}

type DowntimeScheduleMapOutput struct{ *pulumi.OutputState }

func (DowntimeScheduleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DowntimeSchedule)(nil)).Elem()
}

func (o DowntimeScheduleMapOutput) ToDowntimeScheduleMapOutput() DowntimeScheduleMapOutput {
	return o
}

func (o DowntimeScheduleMapOutput) ToDowntimeScheduleMapOutputWithContext(ctx context.Context) DowntimeScheduleMapOutput {
	return o
}

func (o DowntimeScheduleMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*DowntimeSchedule] {
	return pulumix.Output[map[string]*DowntimeSchedule]{
		OutputState: o.OutputState,
	}
}

func (o DowntimeScheduleMapOutput) MapIndex(k pulumi.StringInput) DowntimeScheduleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DowntimeSchedule {
		return vs[0].(map[string]*DowntimeSchedule)[vs[1].(string)]
	}).(DowntimeScheduleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DowntimeScheduleInput)(nil)).Elem(), &DowntimeSchedule{})
	pulumi.RegisterInputType(reflect.TypeOf((*DowntimeScheduleArrayInput)(nil)).Elem(), DowntimeScheduleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DowntimeScheduleMapInput)(nil)).Elem(), DowntimeScheduleMap{})
	pulumi.RegisterOutputType(DowntimeScheduleOutput{})
	pulumi.RegisterOutputType(DowntimeScheduleArrayOutput{})
	pulumi.RegisterOutputType(DowntimeScheduleMapOutput{})
}

// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package datadog

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Datadog DowntimeSchedule resource. This can be used to create and manage Datadog downtimes.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Create new downtime_schedule resource
//			_, err := datadog.NewDowntimeSchedule(ctx, "downtime_schedule_example", &datadog.DowntimeScheduleArgs{
//				Scope: pulumi.String("env:us9-prod7 AND team:test123"),
//				MonitorIdentifier: datadog.DowntimeScheduleMonitorIdentifierArgs{
//					map[string]interface{}{
//						"monitorTags": []string{
//							"test:123",
//							"data:test",
//						},
//					},
//				},
//				RecurringSchedule: datadog.DowntimeScheduleRecurringScheduleArgs{
//					map[string]interface{}{
//						"recurrences": []map[string]interface{}{
//							map[string]interface{}{
//								"duration": "1h",
//								"rrule":    "FREQ=DAILY;INTERVAL=1",
//								"start":    "2050-01-02T03:04:05",
//							},
//						},
//						"timezone": "America/New_York",
//					},
//				},
//				DisplayTimezone:               pulumi.String("America/New_York"),
//				Message:                       pulumi.String("Message about the downtime"),
//				MuteFirstRecoveryNotification: pulumi.Bool(true),
//				NotifyEndStates: pulumi.StringArray{
//					pulumi.String("alert"),
//					pulumi.String("warn"),
//				},
//				NotifyEndTypes: pulumi.StringArray{
//					pulumi.String("canceled"),
//					pulumi.String("expired"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// The `pulumi import` command can be used, for example:
//
// ```sh
// $ pulumi import datadog:index/downtimeSchedule:DowntimeSchedule new_list "00e000000-0000-1234-0000-000000000000"
// ```
type DowntimeSchedule struct {
	pulumi.CustomResourceState

	// The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
	DisplayTimezone pulumi.StringOutput `pulumi:"displayTimezone"`
	// A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same `@username` notation as events.
	Message           pulumi.StringPtrOutput                  `pulumi:"message"`
	MonitorIdentifier DowntimeScheduleMonitorIdentifierOutput `pulumi:"monitorIdentifier"`
	// If the first recovery notification during a downtime should be muted.
	MuteFirstRecoveryNotification pulumi.BoolOutput `pulumi:"muteFirstRecoveryNotification"`
	// States that will trigger a monitor notification when the `notifyEndTypes` action occurs.
	NotifyEndStates pulumi.StringArrayOutput `pulumi:"notifyEndStates"`
	// Actions that will trigger a monitor notification if the downtime is in the `notifyEndTypes` state.
	NotifyEndTypes    pulumi.StringArrayOutput                   `pulumi:"notifyEndTypes"`
	OneTimeSchedule   DowntimeScheduleOneTimeSchedulePtrOutput   `pulumi:"oneTimeSchedule"`
	RecurringSchedule DowntimeScheduleRecurringSchedulePtrOutput `pulumi:"recurringSchedule"`
	// The scope to which the downtime applies. Must follow the [common search syntax](https://docs.datadoghq.com/logs/explorer/search_syntax/).
	Scope pulumi.StringOutput `pulumi:"scope"`
}

// NewDowntimeSchedule registers a new resource with the given unique name, arguments, and options.
func NewDowntimeSchedule(ctx *pulumi.Context,
	name string, args *DowntimeScheduleArgs, opts ...pulumi.ResourceOption) (*DowntimeSchedule, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.MonitorIdentifier == nil {
		return nil, errors.New("invalid value for required argument 'MonitorIdentifier'")
	}
	if args.Scope == nil {
		return nil, errors.New("invalid value for required argument 'Scope'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DowntimeSchedule
	err := ctx.RegisterResource("datadog:index/downtimeSchedule:DowntimeSchedule", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDowntimeSchedule gets an existing DowntimeSchedule resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDowntimeSchedule(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DowntimeScheduleState, opts ...pulumi.ResourceOption) (*DowntimeSchedule, error) {
	var resource DowntimeSchedule
	err := ctx.ReadResource("datadog:index/downtimeSchedule:DowntimeSchedule", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DowntimeSchedule resources.
type downtimeScheduleState struct {
	// The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
	DisplayTimezone *string `pulumi:"displayTimezone"`
	// A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same `@username` notation as events.
	Message           *string                            `pulumi:"message"`
	MonitorIdentifier *DowntimeScheduleMonitorIdentifier `pulumi:"monitorIdentifier"`
	// If the first recovery notification during a downtime should be muted.
	MuteFirstRecoveryNotification *bool `pulumi:"muteFirstRecoveryNotification"`
	// States that will trigger a monitor notification when the `notifyEndTypes` action occurs.
	NotifyEndStates []string `pulumi:"notifyEndStates"`
	// Actions that will trigger a monitor notification if the downtime is in the `notifyEndTypes` state.
	NotifyEndTypes    []string                           `pulumi:"notifyEndTypes"`
	OneTimeSchedule   *DowntimeScheduleOneTimeSchedule   `pulumi:"oneTimeSchedule"`
	RecurringSchedule *DowntimeScheduleRecurringSchedule `pulumi:"recurringSchedule"`
	// The scope to which the downtime applies. Must follow the [common search syntax](https://docs.datadoghq.com/logs/explorer/search_syntax/).
	Scope *string `pulumi:"scope"`
}

type DowntimeScheduleState struct {
	// The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
	DisplayTimezone pulumi.StringPtrInput
	// A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same `@username` notation as events.
	Message           pulumi.StringPtrInput
	MonitorIdentifier DowntimeScheduleMonitorIdentifierPtrInput
	// If the first recovery notification during a downtime should be muted.
	MuteFirstRecoveryNotification pulumi.BoolPtrInput
	// States that will trigger a monitor notification when the `notifyEndTypes` action occurs.
	NotifyEndStates pulumi.StringArrayInput
	// Actions that will trigger a monitor notification if the downtime is in the `notifyEndTypes` state.
	NotifyEndTypes    pulumi.StringArrayInput
	OneTimeSchedule   DowntimeScheduleOneTimeSchedulePtrInput
	RecurringSchedule DowntimeScheduleRecurringSchedulePtrInput
	// The scope to which the downtime applies. Must follow the [common search syntax](https://docs.datadoghq.com/logs/explorer/search_syntax/).
	Scope pulumi.StringPtrInput
}

func (DowntimeScheduleState) ElementType() reflect.Type {
	return reflect.TypeOf((*downtimeScheduleState)(nil)).Elem()
}

type downtimeScheduleArgs struct {
	// The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
	DisplayTimezone *string `pulumi:"displayTimezone"`
	// A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same `@username` notation as events.
	Message           *string                           `pulumi:"message"`
	MonitorIdentifier DowntimeScheduleMonitorIdentifier `pulumi:"monitorIdentifier"`
	// If the first recovery notification during a downtime should be muted.
	MuteFirstRecoveryNotification *bool `pulumi:"muteFirstRecoveryNotification"`
	// States that will trigger a monitor notification when the `notifyEndTypes` action occurs.
	NotifyEndStates []string `pulumi:"notifyEndStates"`
	// Actions that will trigger a monitor notification if the downtime is in the `notifyEndTypes` state.
	NotifyEndTypes    []string                           `pulumi:"notifyEndTypes"`
	OneTimeSchedule   *DowntimeScheduleOneTimeSchedule   `pulumi:"oneTimeSchedule"`
	RecurringSchedule *DowntimeScheduleRecurringSchedule `pulumi:"recurringSchedule"`
	// The scope to which the downtime applies. Must follow the [common search syntax](https://docs.datadoghq.com/logs/explorer/search_syntax/).
	Scope string `pulumi:"scope"`
}

// The set of arguments for constructing a DowntimeSchedule resource.
type DowntimeScheduleArgs struct {
	// The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
	DisplayTimezone pulumi.StringPtrInput
	// A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same `@username` notation as events.
	Message           pulumi.StringPtrInput
	MonitorIdentifier DowntimeScheduleMonitorIdentifierInput
	// If the first recovery notification during a downtime should be muted.
	MuteFirstRecoveryNotification pulumi.BoolPtrInput
	// States that will trigger a monitor notification when the `notifyEndTypes` action occurs.
	NotifyEndStates pulumi.StringArrayInput
	// Actions that will trigger a monitor notification if the downtime is in the `notifyEndTypes` state.
	NotifyEndTypes    pulumi.StringArrayInput
	OneTimeSchedule   DowntimeScheduleOneTimeSchedulePtrInput
	RecurringSchedule DowntimeScheduleRecurringSchedulePtrInput
	// The scope to which the downtime applies. Must follow the [common search syntax](https://docs.datadoghq.com/logs/explorer/search_syntax/).
	Scope pulumi.StringInput
}

func (DowntimeScheduleArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*downtimeScheduleArgs)(nil)).Elem()
}

type DowntimeScheduleInput interface {
	pulumi.Input

	ToDowntimeScheduleOutput() DowntimeScheduleOutput
	ToDowntimeScheduleOutputWithContext(ctx context.Context) DowntimeScheduleOutput
}

func (*DowntimeSchedule) ElementType() reflect.Type {
	return reflect.TypeOf((**DowntimeSchedule)(nil)).Elem()
}

func (i *DowntimeSchedule) ToDowntimeScheduleOutput() DowntimeScheduleOutput {
	return i.ToDowntimeScheduleOutputWithContext(context.Background())
}

func (i *DowntimeSchedule) ToDowntimeScheduleOutputWithContext(ctx context.Context) DowntimeScheduleOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DowntimeScheduleOutput)
}

// DowntimeScheduleArrayInput is an input type that accepts DowntimeScheduleArray and DowntimeScheduleArrayOutput values.
// You can construct a concrete instance of `DowntimeScheduleArrayInput` via:
//
//	DowntimeScheduleArray{ DowntimeScheduleArgs{...} }
type DowntimeScheduleArrayInput interface {
	pulumi.Input

	ToDowntimeScheduleArrayOutput() DowntimeScheduleArrayOutput
	ToDowntimeScheduleArrayOutputWithContext(context.Context) DowntimeScheduleArrayOutput
}

type DowntimeScheduleArray []DowntimeScheduleInput

func (DowntimeScheduleArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DowntimeSchedule)(nil)).Elem()
}

func (i DowntimeScheduleArray) ToDowntimeScheduleArrayOutput() DowntimeScheduleArrayOutput {
	return i.ToDowntimeScheduleArrayOutputWithContext(context.Background())
}

func (i DowntimeScheduleArray) ToDowntimeScheduleArrayOutputWithContext(ctx context.Context) DowntimeScheduleArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DowntimeScheduleArrayOutput)
}

// DowntimeScheduleMapInput is an input type that accepts DowntimeScheduleMap and DowntimeScheduleMapOutput values.
// You can construct a concrete instance of `DowntimeScheduleMapInput` via:
//
//	DowntimeScheduleMap{ "key": DowntimeScheduleArgs{...} }
type DowntimeScheduleMapInput interface {
	pulumi.Input

	ToDowntimeScheduleMapOutput() DowntimeScheduleMapOutput
	ToDowntimeScheduleMapOutputWithContext(context.Context) DowntimeScheduleMapOutput
}

type DowntimeScheduleMap map[string]DowntimeScheduleInput

func (DowntimeScheduleMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DowntimeSchedule)(nil)).Elem()
}

func (i DowntimeScheduleMap) ToDowntimeScheduleMapOutput() DowntimeScheduleMapOutput {
	return i.ToDowntimeScheduleMapOutputWithContext(context.Background())
}

func (i DowntimeScheduleMap) ToDowntimeScheduleMapOutputWithContext(ctx context.Context) DowntimeScheduleMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DowntimeScheduleMapOutput)
}

type DowntimeScheduleOutput struct{ *pulumi.OutputState }

func (DowntimeScheduleOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DowntimeSchedule)(nil)).Elem()
}

func (o DowntimeScheduleOutput) ToDowntimeScheduleOutput() DowntimeScheduleOutput {
	return o
}

func (o DowntimeScheduleOutput) ToDowntimeScheduleOutputWithContext(ctx context.Context) DowntimeScheduleOutput {
	return o
}

// The timezone in which to display the downtime's start and end times in Datadog applications. This is not used as an offset for scheduling.
func (o DowntimeScheduleOutput) DisplayTimezone() pulumi.StringOutput {
	return o.ApplyT(func(v *DowntimeSchedule) pulumi.StringOutput { return v.DisplayTimezone }).(pulumi.StringOutput)
}

// A message to include with notifications for this downtime. Email notifications can be sent to specific users by using the same `@username` notation as events.
func (o DowntimeScheduleOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DowntimeSchedule) pulumi.StringPtrOutput { return v.Message }).(pulumi.StringPtrOutput)
}

func (o DowntimeScheduleOutput) MonitorIdentifier() DowntimeScheduleMonitorIdentifierOutput {
	return o.ApplyT(func(v *DowntimeSchedule) DowntimeScheduleMonitorIdentifierOutput { return v.MonitorIdentifier }).(DowntimeScheduleMonitorIdentifierOutput)
}

// If the first recovery notification during a downtime should be muted.
func (o DowntimeScheduleOutput) MuteFirstRecoveryNotification() pulumi.BoolOutput {
	return o.ApplyT(func(v *DowntimeSchedule) pulumi.BoolOutput { return v.MuteFirstRecoveryNotification }).(pulumi.BoolOutput)
}

// States that will trigger a monitor notification when the `notifyEndTypes` action occurs.
func (o DowntimeScheduleOutput) NotifyEndStates() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DowntimeSchedule) pulumi.StringArrayOutput { return v.NotifyEndStates }).(pulumi.StringArrayOutput)
}

// Actions that will trigger a monitor notification if the downtime is in the `notifyEndTypes` state.
func (o DowntimeScheduleOutput) NotifyEndTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *DowntimeSchedule) pulumi.StringArrayOutput { return v.NotifyEndTypes }).(pulumi.StringArrayOutput)
}

func (o DowntimeScheduleOutput) OneTimeSchedule() DowntimeScheduleOneTimeSchedulePtrOutput {
	return o.ApplyT(func(v *DowntimeSchedule) DowntimeScheduleOneTimeSchedulePtrOutput { return v.OneTimeSchedule }).(DowntimeScheduleOneTimeSchedulePtrOutput)
}

func (o DowntimeScheduleOutput) RecurringSchedule() DowntimeScheduleRecurringSchedulePtrOutput {
	return o.ApplyT(func(v *DowntimeSchedule) DowntimeScheduleRecurringSchedulePtrOutput { return v.RecurringSchedule }).(DowntimeScheduleRecurringSchedulePtrOutput)
}

// The scope to which the downtime applies. Must follow the [common search syntax](https://docs.datadoghq.com/logs/explorer/search_syntax/).
func (o DowntimeScheduleOutput) Scope() pulumi.StringOutput {
	return o.ApplyT(func(v *DowntimeSchedule) pulumi.StringOutput { return v.Scope }).(pulumi.StringOutput)
}

type DowntimeScheduleArrayOutput struct{ *pulumi.OutputState }

func (DowntimeScheduleArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DowntimeSchedule)(nil)).Elem()
}

func (o DowntimeScheduleArrayOutput) ToDowntimeScheduleArrayOutput() DowntimeScheduleArrayOutput {
	return o
}

func (o DowntimeScheduleArrayOutput) ToDowntimeScheduleArrayOutputWithContext(ctx context.Context) DowntimeScheduleArrayOutput {
	return o
}

func (o DowntimeScheduleArrayOutput) Index(i pulumi.IntInput) DowntimeScheduleOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DowntimeSchedule {
		return vs[0].([]*DowntimeSchedule)[vs[1].(int)]
	}).(DowntimeScheduleOutput)
}

type DowntimeScheduleMapOutput struct{ *pulumi.OutputState }

func (DowntimeScheduleMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DowntimeSchedule)(nil)).Elem()
}

func (o DowntimeScheduleMapOutput) ToDowntimeScheduleMapOutput() DowntimeScheduleMapOutput {
	return o
}

func (o DowntimeScheduleMapOutput) ToDowntimeScheduleMapOutputWithContext(ctx context.Context) DowntimeScheduleMapOutput {
	return o
}

func (o DowntimeScheduleMapOutput) MapIndex(k pulumi.StringInput) DowntimeScheduleOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DowntimeSchedule {
		return vs[0].(map[string]*DowntimeSchedule)[vs[1].(string)]
	}).(DowntimeScheduleOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DowntimeScheduleInput)(nil)).Elem(), &DowntimeSchedule{})
	pulumi.RegisterInputType(reflect.TypeOf((*DowntimeScheduleArrayInput)(nil)).Elem(), DowntimeScheduleArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DowntimeScheduleMapInput)(nil)).Elem(), DowntimeScheduleMap{})
	pulumi.RegisterOutputType(DowntimeScheduleOutput{})
	pulumi.RegisterOutputType(DowntimeScheduleArrayOutput{})
	pulumi.RegisterOutputType(DowntimeScheduleMapOutput{})
}

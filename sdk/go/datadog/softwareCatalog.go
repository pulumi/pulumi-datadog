// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package datadog

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Datadog Software Catalog Entity resource. This can be used to create and manage entities in Datadog Software Catalog using the YAML/JSON definition.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// v3 service entity
//			_, err := datadog.NewSoftwareCatalog(ctx, "service_v3", &datadog.SoftwareCatalogArgs{
//				Entity: pulumi.String(`apiVersion: v3
//
// kind: service
// metadata:
//
//	name: shopping-cart
//	displayName: Shopping Cart
//	inheritFrom: service:otherService
//	tags:
//	  - tag:value
//	links:
//	  - name: shopping-cart runbook
//	    type: runbook
//	    url: https://runbook/shopping-cart
//	  - name: shopping-cart architecture
//	    provider: gdoc
//	    url: https://google.drive/shopping-cart-architecture
//	    type: doc
//	  - name: shopping-cart Wiki
//	    provider: wiki
//	    url: https://wiki/shopping-cart
//	    type: doc
//	  - name: shopping-cart source code
//	    provider: github
//	    url: http://github/shopping-cart
//	    type: repo
//	contacts:
//	  - name: Support Email
//	    type: email
//	    contact: team@shopping.com
//	  - name: Support Slack
//	    type: slack
//	    contact: https://www.slack.com/archives/shopping-cart
//	owner: myteam
//	additionalOwners:
//	  - name: opsTeam
//	    type: operator
//
// integrations:
//
//	pagerduty:
//	  serviceURL: https://www.pagerduty.com/service-directory/Pshopping-cart
//	opsgenie:
//	  serviceURL: https://www.opsgenie.com/service/shopping-cart
//	  region: US
//
// extensions:
//
//	datadoghq.com/shopping-cart:
//	  customField: customValue
//
// spec:
//
//	lifecycle: production
//	tier: "1"
//	type: web
//	languages:
//	  - go
//	  - python
//	dependsOn:
//	  - service:serviceA
//	  - service:serviceB
//
// datadog:
//
//	performanceData:
//	  tags:
//	    - 'service:shopping-cart'
//	    - 'hostname:shopping-cart'
//	events:
//	  - name: "deployment events"
//	    query: "app:myapp AND type:github"
//	  - name: "event type B"
//	    query: "app:myapp AND type:github"
//	logs:
//	  - name: "critical logs"
//	    query: "app:myapp AND type:github"
//	  - name: "ops logs"
//	    query: "app:myapp AND type:github"
//	pipelines:
//	  fingerprints:
//	    - fp1
//	    - fp2
//	codeLocations:
//	  - repositoryURL: http://github/shopping-cart.git
//	    paths:
//	      - baz/*.c
//	      - bat/**/*
//	      - ../plop/*.java
//	  - repositoryURL: http://github/shopping-cart-2.git
//	    paths:
//	      - baz/*.c
//	      - bat/**/*
//	      - ../plop/*.java
//
// `),
//
//	})
//	if err != nil {
//		return err
//	}
//	// v3 datastore entity
//	_, err = datadog.NewSoftwareCatalog(ctx, "datastore_v3", &datadog.SoftwareCatalogArgs{
//		Entity: pulumi.String(`apiVersion: v3
//
// kind: datastore
// metadata:
//
//	name: shopping-cart-db
//	tags:
//	  - tag:value
//	links:
//	  - name: shopping-cart-db runbook
//	    type: runbook
//	    url: https://runbook/shopping-cart
//	contacts:
//	  - name: Support Email
//	    type: email
//	    contact: team@shopping.com
//	  - name: Support Slack
//	    type: slack
//	    contact: https://www.slack.com/archives/shopping-cart
//	owner: myteam
//	additionalOwners:
//	  - name: opsTeam
//	    type: operator
//
// integrations:
//
//	pagerduty:
//	  serviceURL: https://www.pagerduty.com/service-directory/Pshopping-cart
//	opsgenie:
//	  serviceURL: https://www.opsgenie.com/service/shopping-cart
//	  region: US
//
// extensions:
//
//	datadoghq.com/shopping-cart-db:
//	  customField: customValue
//
// spec:
//
//	lifecycle: production
//	tier: "1"
//	type: "postgres"
//
// datadog:
//
//	performanceData:
//	  tags: ['tag:random']
//
// `),
//
//	})
//	if err != nil {
//		return err
//	}
//	// v3 queue entity
//	_, err = datadog.NewSoftwareCatalog(ctx, "queue_v3", &datadog.SoftwareCatalogArgs{
//		Entity: pulumi.String(`apiVersion: v3
//
// kind: queue
// metadata:
//
//	name: order-queue
//	tags:
//	  - tag:value
//	links:
//	  - name: order-queue runbook
//	    type: runbook
//	    url: https://runbook/order-queue
//	contacts:
//	  - name: Support Email
//	    type: email
//	    contact: team@shopping.com
//	  - name: Support Slack
//	    type: slack
//	    contact: https://www.slack.com/archives/shopping-cart
//	owner: myteam
//	additionalOwners:
//	  - name: opsTeam
//	    type: operator
//
// integrations:
//
//	pagerduty:
//	  serviceURL: https://www.pagerduty.com/service-directory/Pshopping-cart
//	opsgenie:
//	  serviceURL: https://www.opsgenie.com/service/shopping-cart
//	  region: US
//
// extensions:
//
//	datadoghq.com/order-queue:
//	  customField: customValue
//
// spec:
//
//	lifecycle: production
//	tier: "1"
//	type: kafka
//
// datadog:
//
//	performanceData:
//	  tags: ['tag:random']
//
// `),
//
//	})
//	if err != nil {
//		return err
//	}
//	// v3 system entity
//	_, err = datadog.NewSoftwareCatalog(ctx, "system_v3", &datadog.SoftwareCatalogArgs{
//		Entity: pulumi.String(`apiVersion: v3
//
// kind: system
// metadata:
//
//	name: shopping-system
//	displayName: Shopping System
//	tags:
//	  - tag:value
//	links:
//	  - name: shopping-system runbook
//	    type: runbook
//	    url: https://runbook/shopping-system
//	contacts:
//	  - name: Support Email
//	    type: email
//	    contact: team@shopping.com
//	  - name: Support Slack
//	    type: slack
//	    contact: https://www.slack.com/archives/shopping-cart
//	owner: myteam
//	additionalOwners:
//	  - name: opsTeam
//	    type: operator
//
// integrations:
//
//	pagerduty:
//	  serviceURL: https://www.pagerduty.com/service-directory/Pshopping-cart
//	opsgenie:
//	  serviceURL: https://www.opsgenie.com/service/shopping-cart
//	  region: US
//
// spec:
//
//	components:
//	  - service:shopping-cart
//	  - queue:order-queue
//	  - database:shopping-cart-db
//
// extensions:
//
//	datadoghq.com/shopping-system:
//	  customField: customValue
//
// datadog:
//
//	events:
//	  - name: "deployment events"
//	    query: "app:myapp AND type:github"
//	  - name: "event type B"
//	    query: "app:myapp AND type:github"
//	logs:
//	  - name: "critical logs"
//	    query: "app:myapp AND type:github"
//	  - name: "ops logs"
//	    query: "app:myapp AND type:github"
//
// `),
//
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
// $ pulumi import datadog:index/softwareCatalog:SoftwareCatalog this <name>
// ```
type SoftwareCatalog struct {
	pulumi.CustomResourceState

	// The catalog entity definition.
	Entity pulumi.StringOutput `pulumi:"entity"`
}

// NewSoftwareCatalog registers a new resource with the given unique name, arguments, and options.
func NewSoftwareCatalog(ctx *pulumi.Context,
	name string, args *SoftwareCatalogArgs, opts ...pulumi.ResourceOption) (*SoftwareCatalog, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Entity == nil {
		return nil, errors.New("invalid value for required argument 'Entity'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SoftwareCatalog
	err := ctx.RegisterResource("datadog:index/softwareCatalog:SoftwareCatalog", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSoftwareCatalog gets an existing SoftwareCatalog resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSoftwareCatalog(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SoftwareCatalogState, opts ...pulumi.ResourceOption) (*SoftwareCatalog, error) {
	var resource SoftwareCatalog
	err := ctx.ReadResource("datadog:index/softwareCatalog:SoftwareCatalog", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SoftwareCatalog resources.
type softwareCatalogState struct {
	// The catalog entity definition.
	Entity *string `pulumi:"entity"`
}

type SoftwareCatalogState struct {
	// The catalog entity definition.
	Entity pulumi.StringPtrInput
}

func (SoftwareCatalogState) ElementType() reflect.Type {
	return reflect.TypeOf((*softwareCatalogState)(nil)).Elem()
}

type softwareCatalogArgs struct {
	// The catalog entity definition.
	Entity string `pulumi:"entity"`
}

// The set of arguments for constructing a SoftwareCatalog resource.
type SoftwareCatalogArgs struct {
	// The catalog entity definition.
	Entity pulumi.StringInput
}

func (SoftwareCatalogArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*softwareCatalogArgs)(nil)).Elem()
}

type SoftwareCatalogInput interface {
	pulumi.Input

	ToSoftwareCatalogOutput() SoftwareCatalogOutput
	ToSoftwareCatalogOutputWithContext(ctx context.Context) SoftwareCatalogOutput
}

func (*SoftwareCatalog) ElementType() reflect.Type {
	return reflect.TypeOf((**SoftwareCatalog)(nil)).Elem()
}

func (i *SoftwareCatalog) ToSoftwareCatalogOutput() SoftwareCatalogOutput {
	return i.ToSoftwareCatalogOutputWithContext(context.Background())
}

func (i *SoftwareCatalog) ToSoftwareCatalogOutputWithContext(ctx context.Context) SoftwareCatalogOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SoftwareCatalogOutput)
}

// SoftwareCatalogArrayInput is an input type that accepts SoftwareCatalogArray and SoftwareCatalogArrayOutput values.
// You can construct a concrete instance of `SoftwareCatalogArrayInput` via:
//
//	SoftwareCatalogArray{ SoftwareCatalogArgs{...} }
type SoftwareCatalogArrayInput interface {
	pulumi.Input

	ToSoftwareCatalogArrayOutput() SoftwareCatalogArrayOutput
	ToSoftwareCatalogArrayOutputWithContext(context.Context) SoftwareCatalogArrayOutput
}

type SoftwareCatalogArray []SoftwareCatalogInput

func (SoftwareCatalogArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SoftwareCatalog)(nil)).Elem()
}

func (i SoftwareCatalogArray) ToSoftwareCatalogArrayOutput() SoftwareCatalogArrayOutput {
	return i.ToSoftwareCatalogArrayOutputWithContext(context.Background())
}

func (i SoftwareCatalogArray) ToSoftwareCatalogArrayOutputWithContext(ctx context.Context) SoftwareCatalogArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SoftwareCatalogArrayOutput)
}

// SoftwareCatalogMapInput is an input type that accepts SoftwareCatalogMap and SoftwareCatalogMapOutput values.
// You can construct a concrete instance of `SoftwareCatalogMapInput` via:
//
//	SoftwareCatalogMap{ "key": SoftwareCatalogArgs{...} }
type SoftwareCatalogMapInput interface {
	pulumi.Input

	ToSoftwareCatalogMapOutput() SoftwareCatalogMapOutput
	ToSoftwareCatalogMapOutputWithContext(context.Context) SoftwareCatalogMapOutput
}

type SoftwareCatalogMap map[string]SoftwareCatalogInput

func (SoftwareCatalogMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SoftwareCatalog)(nil)).Elem()
}

func (i SoftwareCatalogMap) ToSoftwareCatalogMapOutput() SoftwareCatalogMapOutput {
	return i.ToSoftwareCatalogMapOutputWithContext(context.Background())
}

func (i SoftwareCatalogMap) ToSoftwareCatalogMapOutputWithContext(ctx context.Context) SoftwareCatalogMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SoftwareCatalogMapOutput)
}

type SoftwareCatalogOutput struct{ *pulumi.OutputState }

func (SoftwareCatalogOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SoftwareCatalog)(nil)).Elem()
}

func (o SoftwareCatalogOutput) ToSoftwareCatalogOutput() SoftwareCatalogOutput {
	return o
}

func (o SoftwareCatalogOutput) ToSoftwareCatalogOutputWithContext(ctx context.Context) SoftwareCatalogOutput {
	return o
}

// The catalog entity definition.
func (o SoftwareCatalogOutput) Entity() pulumi.StringOutput {
	return o.ApplyT(func(v *SoftwareCatalog) pulumi.StringOutput { return v.Entity }).(pulumi.StringOutput)
}

type SoftwareCatalogArrayOutput struct{ *pulumi.OutputState }

func (SoftwareCatalogArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SoftwareCatalog)(nil)).Elem()
}

func (o SoftwareCatalogArrayOutput) ToSoftwareCatalogArrayOutput() SoftwareCatalogArrayOutput {
	return o
}

func (o SoftwareCatalogArrayOutput) ToSoftwareCatalogArrayOutputWithContext(ctx context.Context) SoftwareCatalogArrayOutput {
	return o
}

func (o SoftwareCatalogArrayOutput) Index(i pulumi.IntInput) SoftwareCatalogOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SoftwareCatalog {
		return vs[0].([]*SoftwareCatalog)[vs[1].(int)]
	}).(SoftwareCatalogOutput)
}

type SoftwareCatalogMapOutput struct{ *pulumi.OutputState }

func (SoftwareCatalogMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SoftwareCatalog)(nil)).Elem()
}

func (o SoftwareCatalogMapOutput) ToSoftwareCatalogMapOutput() SoftwareCatalogMapOutput {
	return o
}

func (o SoftwareCatalogMapOutput) ToSoftwareCatalogMapOutputWithContext(ctx context.Context) SoftwareCatalogMapOutput {
	return o
}

func (o SoftwareCatalogMapOutput) MapIndex(k pulumi.StringInput) SoftwareCatalogOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SoftwareCatalog {
		return vs[0].(map[string]*SoftwareCatalog)[vs[1].(string)]
	}).(SoftwareCatalogOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SoftwareCatalogInput)(nil)).Elem(), &SoftwareCatalog{})
	pulumi.RegisterInputType(reflect.TypeOf((*SoftwareCatalogArrayInput)(nil)).Elem(), SoftwareCatalogArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SoftwareCatalogMapInput)(nil)).Elem(), SoftwareCatalogMap{})
	pulumi.RegisterOutputType(SoftwareCatalogOutput{})
	pulumi.RegisterOutputType(SoftwareCatalogArrayOutput{})
	pulumi.RegisterOutputType(SoftwareCatalogMapOutput{})
}

// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package confluent

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Datadog IntegrationConfluentResource resource. This can be used to create and manage Datadog integration_confluent_resource.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog/confluent"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			fooIntegrationAccount, err := confluent.NewIntegrationAccount(ctx, "fooIntegrationAccount", &confluent.IntegrationAccountArgs{
//				ApiKey:    pulumi.String("TESTAPIKEY123"),
//				ApiSecret: pulumi.String("test-api-secret-123"),
//				Tags: pulumi.StringArray{
//					pulumi.String("mytag"),
//					pulumi.String("mytag2:myvalue"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = confluent.NewIntegrationResource(ctx, "fooIntegrationResource", &confluent.IntegrationResourceArgs{
//				AccountId:    fooIntegrationAccount.ID(),
//				ResourceId:   pulumi.String("123456"),
//				ResourceType: pulumi.String("kafka"),
//				Tags: pulumi.StringArray{
//					pulumi.String("mytag"),
//					pulumi.String("mytag2:myvalue"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
//
//	$ pulumi import datadog:confluent/integrationResource:IntegrationResource new_list "confluent_account_id:confluent_resource_id"
//
// ```
type IntegrationResource struct {
	pulumi.CustomResourceState

	// Confluent Account ID.
	AccountId pulumi.StringOutput `pulumi:"accountId"`
	// Enable the `custom.consumer_lag_offset` metric, which contains extra metric tags.
	EnableCustomMetrics pulumi.BoolOutput `pulumi:"enableCustomMetrics"`
	// The ID associated with a Confluent resource.
	ResourceId pulumi.StringOutput `pulumi:"resourceId"`
	// The resource type of the Resource. Can be `kafka`, `connector`, `ksql`, or `schemaRegistry`.
	ResourceType pulumi.StringPtrOutput `pulumi:"resourceType"`
	// A list of strings representing tags. Can be a single key, or key-value pairs separated by a colon.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
}

// NewIntegrationResource registers a new resource with the given unique name, arguments, and options.
func NewIntegrationResource(ctx *pulumi.Context,
	name string, args *IntegrationResourceArgs, opts ...pulumi.ResourceOption) (*IntegrationResource, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.AccountId == nil {
		return nil, errors.New("invalid value for required argument 'AccountId'")
	}
	if args.ResourceId == nil {
		return nil, errors.New("invalid value for required argument 'ResourceId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource IntegrationResource
	err := ctx.RegisterResource("datadog:confluent/integrationResource:IntegrationResource", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetIntegrationResource gets an existing IntegrationResource resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetIntegrationResource(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *IntegrationResourceState, opts ...pulumi.ResourceOption) (*IntegrationResource, error) {
	var resource IntegrationResource
	err := ctx.ReadResource("datadog:confluent/integrationResource:IntegrationResource", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering IntegrationResource resources.
type integrationResourceState struct {
	// Confluent Account ID.
	AccountId *string `pulumi:"accountId"`
	// Enable the `custom.consumer_lag_offset` metric, which contains extra metric tags.
	EnableCustomMetrics *bool `pulumi:"enableCustomMetrics"`
	// The ID associated with a Confluent resource.
	ResourceId *string `pulumi:"resourceId"`
	// The resource type of the Resource. Can be `kafka`, `connector`, `ksql`, or `schemaRegistry`.
	ResourceType *string `pulumi:"resourceType"`
	// A list of strings representing tags. Can be a single key, or key-value pairs separated by a colon.
	Tags []string `pulumi:"tags"`
}

type IntegrationResourceState struct {
	// Confluent Account ID.
	AccountId pulumi.StringPtrInput
	// Enable the `custom.consumer_lag_offset` metric, which contains extra metric tags.
	EnableCustomMetrics pulumi.BoolPtrInput
	// The ID associated with a Confluent resource.
	ResourceId pulumi.StringPtrInput
	// The resource type of the Resource. Can be `kafka`, `connector`, `ksql`, or `schemaRegistry`.
	ResourceType pulumi.StringPtrInput
	// A list of strings representing tags. Can be a single key, or key-value pairs separated by a colon.
	Tags pulumi.StringArrayInput
}

func (IntegrationResourceState) ElementType() reflect.Type {
	return reflect.TypeOf((*integrationResourceState)(nil)).Elem()
}

type integrationResourceArgs struct {
	// Confluent Account ID.
	AccountId string `pulumi:"accountId"`
	// Enable the `custom.consumer_lag_offset` metric, which contains extra metric tags.
	EnableCustomMetrics *bool `pulumi:"enableCustomMetrics"`
	// The ID associated with a Confluent resource.
	ResourceId string `pulumi:"resourceId"`
	// The resource type of the Resource. Can be `kafka`, `connector`, `ksql`, or `schemaRegistry`.
	ResourceType *string `pulumi:"resourceType"`
	// A list of strings representing tags. Can be a single key, or key-value pairs separated by a colon.
	Tags []string `pulumi:"tags"`
}

// The set of arguments for constructing a IntegrationResource resource.
type IntegrationResourceArgs struct {
	// Confluent Account ID.
	AccountId pulumi.StringInput
	// Enable the `custom.consumer_lag_offset` metric, which contains extra metric tags.
	EnableCustomMetrics pulumi.BoolPtrInput
	// The ID associated with a Confluent resource.
	ResourceId pulumi.StringInput
	// The resource type of the Resource. Can be `kafka`, `connector`, `ksql`, or `schemaRegistry`.
	ResourceType pulumi.StringPtrInput
	// A list of strings representing tags. Can be a single key, or key-value pairs separated by a colon.
	Tags pulumi.StringArrayInput
}

func (IntegrationResourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*integrationResourceArgs)(nil)).Elem()
}

type IntegrationResourceInput interface {
	pulumi.Input

	ToIntegrationResourceOutput() IntegrationResourceOutput
	ToIntegrationResourceOutputWithContext(ctx context.Context) IntegrationResourceOutput
}

func (*IntegrationResource) ElementType() reflect.Type {
	return reflect.TypeOf((**IntegrationResource)(nil)).Elem()
}

func (i *IntegrationResource) ToIntegrationResourceOutput() IntegrationResourceOutput {
	return i.ToIntegrationResourceOutputWithContext(context.Background())
}

func (i *IntegrationResource) ToIntegrationResourceOutputWithContext(ctx context.Context) IntegrationResourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntegrationResourceOutput)
}

// IntegrationResourceArrayInput is an input type that accepts IntegrationResourceArray and IntegrationResourceArrayOutput values.
// You can construct a concrete instance of `IntegrationResourceArrayInput` via:
//
//	IntegrationResourceArray{ IntegrationResourceArgs{...} }
type IntegrationResourceArrayInput interface {
	pulumi.Input

	ToIntegrationResourceArrayOutput() IntegrationResourceArrayOutput
	ToIntegrationResourceArrayOutputWithContext(context.Context) IntegrationResourceArrayOutput
}

type IntegrationResourceArray []IntegrationResourceInput

func (IntegrationResourceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IntegrationResource)(nil)).Elem()
}

func (i IntegrationResourceArray) ToIntegrationResourceArrayOutput() IntegrationResourceArrayOutput {
	return i.ToIntegrationResourceArrayOutputWithContext(context.Background())
}

func (i IntegrationResourceArray) ToIntegrationResourceArrayOutputWithContext(ctx context.Context) IntegrationResourceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntegrationResourceArrayOutput)
}

// IntegrationResourceMapInput is an input type that accepts IntegrationResourceMap and IntegrationResourceMapOutput values.
// You can construct a concrete instance of `IntegrationResourceMapInput` via:
//
//	IntegrationResourceMap{ "key": IntegrationResourceArgs{...} }
type IntegrationResourceMapInput interface {
	pulumi.Input

	ToIntegrationResourceMapOutput() IntegrationResourceMapOutput
	ToIntegrationResourceMapOutputWithContext(context.Context) IntegrationResourceMapOutput
}

type IntegrationResourceMap map[string]IntegrationResourceInput

func (IntegrationResourceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IntegrationResource)(nil)).Elem()
}

func (i IntegrationResourceMap) ToIntegrationResourceMapOutput() IntegrationResourceMapOutput {
	return i.ToIntegrationResourceMapOutputWithContext(context.Background())
}

func (i IntegrationResourceMap) ToIntegrationResourceMapOutputWithContext(ctx context.Context) IntegrationResourceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(IntegrationResourceMapOutput)
}

type IntegrationResourceOutput struct{ *pulumi.OutputState }

func (IntegrationResourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**IntegrationResource)(nil)).Elem()
}

func (o IntegrationResourceOutput) ToIntegrationResourceOutput() IntegrationResourceOutput {
	return o
}

func (o IntegrationResourceOutput) ToIntegrationResourceOutputWithContext(ctx context.Context) IntegrationResourceOutput {
	return o
}

// Confluent Account ID.
func (o IntegrationResourceOutput) AccountId() pulumi.StringOutput {
	return o.ApplyT(func(v *IntegrationResource) pulumi.StringOutput { return v.AccountId }).(pulumi.StringOutput)
}

// Enable the `custom.consumer_lag_offset` metric, which contains extra metric tags.
func (o IntegrationResourceOutput) EnableCustomMetrics() pulumi.BoolOutput {
	return o.ApplyT(func(v *IntegrationResource) pulumi.BoolOutput { return v.EnableCustomMetrics }).(pulumi.BoolOutput)
}

// The ID associated with a Confluent resource.
func (o IntegrationResourceOutput) ResourceId() pulumi.StringOutput {
	return o.ApplyT(func(v *IntegrationResource) pulumi.StringOutput { return v.ResourceId }).(pulumi.StringOutput)
}

// The resource type of the Resource. Can be `kafka`, `connector`, `ksql`, or `schemaRegistry`.
func (o IntegrationResourceOutput) ResourceType() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *IntegrationResource) pulumi.StringPtrOutput { return v.ResourceType }).(pulumi.StringPtrOutput)
}

// A list of strings representing tags. Can be a single key, or key-value pairs separated by a colon.
func (o IntegrationResourceOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *IntegrationResource) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

type IntegrationResourceArrayOutput struct{ *pulumi.OutputState }

func (IntegrationResourceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*IntegrationResource)(nil)).Elem()
}

func (o IntegrationResourceArrayOutput) ToIntegrationResourceArrayOutput() IntegrationResourceArrayOutput {
	return o
}

func (o IntegrationResourceArrayOutput) ToIntegrationResourceArrayOutputWithContext(ctx context.Context) IntegrationResourceArrayOutput {
	return o
}

func (o IntegrationResourceArrayOutput) Index(i pulumi.IntInput) IntegrationResourceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *IntegrationResource {
		return vs[0].([]*IntegrationResource)[vs[1].(int)]
	}).(IntegrationResourceOutput)
}

type IntegrationResourceMapOutput struct{ *pulumi.OutputState }

func (IntegrationResourceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*IntegrationResource)(nil)).Elem()
}

func (o IntegrationResourceMapOutput) ToIntegrationResourceMapOutput() IntegrationResourceMapOutput {
	return o
}

func (o IntegrationResourceMapOutput) ToIntegrationResourceMapOutputWithContext(ctx context.Context) IntegrationResourceMapOutput {
	return o
}

func (o IntegrationResourceMapOutput) MapIndex(k pulumi.StringInput) IntegrationResourceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *IntegrationResource {
		return vs[0].(map[string]*IntegrationResource)[vs[1].(string)]
	}).(IntegrationResourceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*IntegrationResourceInput)(nil)).Elem(), &IntegrationResource{})
	pulumi.RegisterInputType(reflect.TypeOf((*IntegrationResourceArrayInput)(nil)).Elem(), IntegrationResourceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*IntegrationResourceMapInput)(nil)).Elem(), IntegrationResourceMap{})
	pulumi.RegisterOutputType(IntegrationResourceOutput{})
	pulumi.RegisterOutputType(IntegrationResourceArrayOutput{})
	pulumi.RegisterOutputType(IntegrationResourceMapOutput{})
}

// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package datadog

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Resource for interacting with the sloCorrection API.
//
// ## Example Usage
//
// <!--Start PulumiCodeChooser -->
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Create a new Datadog SLO correction. slo_id can be derived from slo resource or specify an slo id of an existing SLO.
//			exampleSlo, err := datadog.NewServiceLevelObjective(ctx, "example_slo", &datadog.ServiceLevelObjectiveArgs{
//				Name:        pulumi.String("example slo"),
//				Type:        pulumi.String("metric"),
//				Description: pulumi.String("some updated description about example_slo SLO"),
//				Query: &datadog.ServiceLevelObjectiveQueryArgs{
//					Numerator:   pulumi.String("sum:my.metric{type:good}.as_count()"),
//					Denominator: pulumi.String("sum:my.metric{type:good}.as_count() + sum:my.metric{type:bad}.as_count()"),
//				},
//				Thresholds: datadog.ServiceLevelObjectiveThresholdArray{
//					&datadog.ServiceLevelObjectiveThresholdArgs{
//						Timeframe: pulumi.String("7d"),
//						Target:    pulumi.Float64(99.5),
//						Warning:   pulumi.Float64(99.8),
//					},
//				},
//				Tags: pulumi.StringArray{
//					pulumi.String("foo:bar"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = datadog.NewSloCorrection(ctx, "example_slo_correction", &datadog.SloCorrectionArgs{
//				Category:    pulumi.String("Scheduled Maintenance"),
//				Description: pulumi.String("correction example"),
//				Start:       pulumi.Int(1735707000),
//				End:         pulumi.Int(1735718600),
//				SloId:       exampleSlo.ID(),
//				Timezone:    pulumi.String("UTC"),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = datadog.NewSloCorrection(ctx, "example_slo_correction_with_recurrence", &datadog.SloCorrectionArgs{
//				Category:    pulumi.String("Scheduled Maintenance"),
//				Description: pulumi.String("correction example with recurrence"),
//				Start:       pulumi.Int(1735707000),
//				Rrule:       pulumi.String("FREQ=DAILY;INTERVAL=3;COUNT=3"),
//				Duration:    pulumi.Int(3600),
//				SloId:       exampleSlo.ID(),
//				Timezone:    pulumi.String("UTC"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// <!--End PulumiCodeChooser -->
//
// ## Import
//
// ```sh
// $ pulumi import datadog:index/sloCorrection:SloCorrection testing_slo_correction 11111111-3fee-11eb-8a13-77cd9f15119e
// ```
type SloCorrection struct {
	pulumi.CustomResourceState

	// Category the SLO correction belongs to. Valid values are `Scheduled Maintenance`, `Outside Business Hours`, `Deployment`, `Other`.
	Category pulumi.StringOutput `pulumi:"category"`
	// Description of the correction being made.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Length of time in seconds for a specified `rrule` recurring SLO correction (required if specifying `rrule`)
	Duration pulumi.IntPtrOutput `pulumi:"duration"`
	// Ending time of the correction in epoch seconds. Required for one time corrections, but optional if `rrule` is specified
	End pulumi.IntPtrOutput `pulumi:"end"`
	// Recurrence rules as defined in the iCalendar RFC 5545. Supported rules for SLO corrections are `FREQ`, `INTERVAL`, `COUNT` and `UNTIL`.
	Rrule pulumi.StringPtrOutput `pulumi:"rrule"`
	// ID of the SLO that this correction will be applied to.
	SloId pulumi.StringOutput `pulumi:"sloId"`
	// Starting time of the correction in epoch seconds.
	Start pulumi.IntOutput `pulumi:"start"`
	// The timezone to display in the UI for the correction times (defaults to "UTC")
	Timezone pulumi.StringPtrOutput `pulumi:"timezone"`
}

// NewSloCorrection registers a new resource with the given unique name, arguments, and options.
func NewSloCorrection(ctx *pulumi.Context,
	name string, args *SloCorrectionArgs, opts ...pulumi.ResourceOption) (*SloCorrection, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Category == nil {
		return nil, errors.New("invalid value for required argument 'Category'")
	}
	if args.SloId == nil {
		return nil, errors.New("invalid value for required argument 'SloId'")
	}
	if args.Start == nil {
		return nil, errors.New("invalid value for required argument 'Start'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource SloCorrection
	err := ctx.RegisterResource("datadog:index/sloCorrection:SloCorrection", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSloCorrection gets an existing SloCorrection resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSloCorrection(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SloCorrectionState, opts ...pulumi.ResourceOption) (*SloCorrection, error) {
	var resource SloCorrection
	err := ctx.ReadResource("datadog:index/sloCorrection:SloCorrection", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering SloCorrection resources.
type sloCorrectionState struct {
	// Category the SLO correction belongs to. Valid values are `Scheduled Maintenance`, `Outside Business Hours`, `Deployment`, `Other`.
	Category *string `pulumi:"category"`
	// Description of the correction being made.
	Description *string `pulumi:"description"`
	// Length of time in seconds for a specified `rrule` recurring SLO correction (required if specifying `rrule`)
	Duration *int `pulumi:"duration"`
	// Ending time of the correction in epoch seconds. Required for one time corrections, but optional if `rrule` is specified
	End *int `pulumi:"end"`
	// Recurrence rules as defined in the iCalendar RFC 5545. Supported rules for SLO corrections are `FREQ`, `INTERVAL`, `COUNT` and `UNTIL`.
	Rrule *string `pulumi:"rrule"`
	// ID of the SLO that this correction will be applied to.
	SloId *string `pulumi:"sloId"`
	// Starting time of the correction in epoch seconds.
	Start *int `pulumi:"start"`
	// The timezone to display in the UI for the correction times (defaults to "UTC")
	Timezone *string `pulumi:"timezone"`
}

type SloCorrectionState struct {
	// Category the SLO correction belongs to. Valid values are `Scheduled Maintenance`, `Outside Business Hours`, `Deployment`, `Other`.
	Category pulumi.StringPtrInput
	// Description of the correction being made.
	Description pulumi.StringPtrInput
	// Length of time in seconds for a specified `rrule` recurring SLO correction (required if specifying `rrule`)
	Duration pulumi.IntPtrInput
	// Ending time of the correction in epoch seconds. Required for one time corrections, but optional if `rrule` is specified
	End pulumi.IntPtrInput
	// Recurrence rules as defined in the iCalendar RFC 5545. Supported rules for SLO corrections are `FREQ`, `INTERVAL`, `COUNT` and `UNTIL`.
	Rrule pulumi.StringPtrInput
	// ID of the SLO that this correction will be applied to.
	SloId pulumi.StringPtrInput
	// Starting time of the correction in epoch seconds.
	Start pulumi.IntPtrInput
	// The timezone to display in the UI for the correction times (defaults to "UTC")
	Timezone pulumi.StringPtrInput
}

func (SloCorrectionState) ElementType() reflect.Type {
	return reflect.TypeOf((*sloCorrectionState)(nil)).Elem()
}

type sloCorrectionArgs struct {
	// Category the SLO correction belongs to. Valid values are `Scheduled Maintenance`, `Outside Business Hours`, `Deployment`, `Other`.
	Category string `pulumi:"category"`
	// Description of the correction being made.
	Description *string `pulumi:"description"`
	// Length of time in seconds for a specified `rrule` recurring SLO correction (required if specifying `rrule`)
	Duration *int `pulumi:"duration"`
	// Ending time of the correction in epoch seconds. Required for one time corrections, but optional if `rrule` is specified
	End *int `pulumi:"end"`
	// Recurrence rules as defined in the iCalendar RFC 5545. Supported rules for SLO corrections are `FREQ`, `INTERVAL`, `COUNT` and `UNTIL`.
	Rrule *string `pulumi:"rrule"`
	// ID of the SLO that this correction will be applied to.
	SloId string `pulumi:"sloId"`
	// Starting time of the correction in epoch seconds.
	Start int `pulumi:"start"`
	// The timezone to display in the UI for the correction times (defaults to "UTC")
	Timezone *string `pulumi:"timezone"`
}

// The set of arguments for constructing a SloCorrection resource.
type SloCorrectionArgs struct {
	// Category the SLO correction belongs to. Valid values are `Scheduled Maintenance`, `Outside Business Hours`, `Deployment`, `Other`.
	Category pulumi.StringInput
	// Description of the correction being made.
	Description pulumi.StringPtrInput
	// Length of time in seconds for a specified `rrule` recurring SLO correction (required if specifying `rrule`)
	Duration pulumi.IntPtrInput
	// Ending time of the correction in epoch seconds. Required for one time corrections, but optional if `rrule` is specified
	End pulumi.IntPtrInput
	// Recurrence rules as defined in the iCalendar RFC 5545. Supported rules for SLO corrections are `FREQ`, `INTERVAL`, `COUNT` and `UNTIL`.
	Rrule pulumi.StringPtrInput
	// ID of the SLO that this correction will be applied to.
	SloId pulumi.StringInput
	// Starting time of the correction in epoch seconds.
	Start pulumi.IntInput
	// The timezone to display in the UI for the correction times (defaults to "UTC")
	Timezone pulumi.StringPtrInput
}

func (SloCorrectionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*sloCorrectionArgs)(nil)).Elem()
}

type SloCorrectionInput interface {
	pulumi.Input

	ToSloCorrectionOutput() SloCorrectionOutput
	ToSloCorrectionOutputWithContext(ctx context.Context) SloCorrectionOutput
}

func (*SloCorrection) ElementType() reflect.Type {
	return reflect.TypeOf((**SloCorrection)(nil)).Elem()
}

func (i *SloCorrection) ToSloCorrectionOutput() SloCorrectionOutput {
	return i.ToSloCorrectionOutputWithContext(context.Background())
}

func (i *SloCorrection) ToSloCorrectionOutputWithContext(ctx context.Context) SloCorrectionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloCorrectionOutput)
}

// SloCorrectionArrayInput is an input type that accepts SloCorrectionArray and SloCorrectionArrayOutput values.
// You can construct a concrete instance of `SloCorrectionArrayInput` via:
//
//	SloCorrectionArray{ SloCorrectionArgs{...} }
type SloCorrectionArrayInput interface {
	pulumi.Input

	ToSloCorrectionArrayOutput() SloCorrectionArrayOutput
	ToSloCorrectionArrayOutputWithContext(context.Context) SloCorrectionArrayOutput
}

type SloCorrectionArray []SloCorrectionInput

func (SloCorrectionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SloCorrection)(nil)).Elem()
}

func (i SloCorrectionArray) ToSloCorrectionArrayOutput() SloCorrectionArrayOutput {
	return i.ToSloCorrectionArrayOutputWithContext(context.Background())
}

func (i SloCorrectionArray) ToSloCorrectionArrayOutputWithContext(ctx context.Context) SloCorrectionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloCorrectionArrayOutput)
}

// SloCorrectionMapInput is an input type that accepts SloCorrectionMap and SloCorrectionMapOutput values.
// You can construct a concrete instance of `SloCorrectionMapInput` via:
//
//	SloCorrectionMap{ "key": SloCorrectionArgs{...} }
type SloCorrectionMapInput interface {
	pulumi.Input

	ToSloCorrectionMapOutput() SloCorrectionMapOutput
	ToSloCorrectionMapOutputWithContext(context.Context) SloCorrectionMapOutput
}

type SloCorrectionMap map[string]SloCorrectionInput

func (SloCorrectionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SloCorrection)(nil)).Elem()
}

func (i SloCorrectionMap) ToSloCorrectionMapOutput() SloCorrectionMapOutput {
	return i.ToSloCorrectionMapOutputWithContext(context.Background())
}

func (i SloCorrectionMap) ToSloCorrectionMapOutputWithContext(ctx context.Context) SloCorrectionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloCorrectionMapOutput)
}

type SloCorrectionOutput struct{ *pulumi.OutputState }

func (SloCorrectionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**SloCorrection)(nil)).Elem()
}

func (o SloCorrectionOutput) ToSloCorrectionOutput() SloCorrectionOutput {
	return o
}

func (o SloCorrectionOutput) ToSloCorrectionOutputWithContext(ctx context.Context) SloCorrectionOutput {
	return o
}

// Category the SLO correction belongs to. Valid values are `Scheduled Maintenance`, `Outside Business Hours`, `Deployment`, `Other`.
func (o SloCorrectionOutput) Category() pulumi.StringOutput {
	return o.ApplyT(func(v *SloCorrection) pulumi.StringOutput { return v.Category }).(pulumi.StringOutput)
}

// Description of the correction being made.
func (o SloCorrectionOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SloCorrection) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Length of time in seconds for a specified `rrule` recurring SLO correction (required if specifying `rrule`)
func (o SloCorrectionOutput) Duration() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SloCorrection) pulumi.IntPtrOutput { return v.Duration }).(pulumi.IntPtrOutput)
}

// Ending time of the correction in epoch seconds. Required for one time corrections, but optional if `rrule` is specified
func (o SloCorrectionOutput) End() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *SloCorrection) pulumi.IntPtrOutput { return v.End }).(pulumi.IntPtrOutput)
}

// Recurrence rules as defined in the iCalendar RFC 5545. Supported rules for SLO corrections are `FREQ`, `INTERVAL`, `COUNT` and `UNTIL`.
func (o SloCorrectionOutput) Rrule() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SloCorrection) pulumi.StringPtrOutput { return v.Rrule }).(pulumi.StringPtrOutput)
}

// ID of the SLO that this correction will be applied to.
func (o SloCorrectionOutput) SloId() pulumi.StringOutput {
	return o.ApplyT(func(v *SloCorrection) pulumi.StringOutput { return v.SloId }).(pulumi.StringOutput)
}

// Starting time of the correction in epoch seconds.
func (o SloCorrectionOutput) Start() pulumi.IntOutput {
	return o.ApplyT(func(v *SloCorrection) pulumi.IntOutput { return v.Start }).(pulumi.IntOutput)
}

// The timezone to display in the UI for the correction times (defaults to "UTC")
func (o SloCorrectionOutput) Timezone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *SloCorrection) pulumi.StringPtrOutput { return v.Timezone }).(pulumi.StringPtrOutput)
}

type SloCorrectionArrayOutput struct{ *pulumi.OutputState }

func (SloCorrectionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*SloCorrection)(nil)).Elem()
}

func (o SloCorrectionArrayOutput) ToSloCorrectionArrayOutput() SloCorrectionArrayOutput {
	return o
}

func (o SloCorrectionArrayOutput) ToSloCorrectionArrayOutputWithContext(ctx context.Context) SloCorrectionArrayOutput {
	return o
}

func (o SloCorrectionArrayOutput) Index(i pulumi.IntInput) SloCorrectionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *SloCorrection {
		return vs[0].([]*SloCorrection)[vs[1].(int)]
	}).(SloCorrectionOutput)
}

type SloCorrectionMapOutput struct{ *pulumi.OutputState }

func (SloCorrectionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*SloCorrection)(nil)).Elem()
}

func (o SloCorrectionMapOutput) ToSloCorrectionMapOutput() SloCorrectionMapOutput {
	return o
}

func (o SloCorrectionMapOutput) ToSloCorrectionMapOutputWithContext(ctx context.Context) SloCorrectionMapOutput {
	return o
}

func (o SloCorrectionMapOutput) MapIndex(k pulumi.StringInput) SloCorrectionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *SloCorrection {
		return vs[0].(map[string]*SloCorrection)[vs[1].(string)]
	}).(SloCorrectionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SloCorrectionInput)(nil)).Elem(), &SloCorrection{})
	pulumi.RegisterInputType(reflect.TypeOf((*SloCorrectionArrayInput)(nil)).Elem(), SloCorrectionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SloCorrectionMapInput)(nil)).Elem(), SloCorrectionMap{})
	pulumi.RegisterOutputType(SloCorrectionOutput{})
	pulumi.RegisterOutputType(SloCorrectionArrayOutput{})
	pulumi.RegisterOutputType(SloCorrectionMapOutput{})
}

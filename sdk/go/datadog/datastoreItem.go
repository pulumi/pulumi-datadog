// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package datadog

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Datadog Datastore Item resource. This can be used to create and manage items in a Datadog datastore.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			// Create a datastore and add items to it
//			example, err := datadog.NewDatastore(ctx, "example", &datadog.DatastoreArgs{
//				Name:                         pulumi.String("users-datastore"),
//				Description:                  pulumi.String("Datastore for user data"),
//				PrimaryColumnName:            pulumi.String("id"),
//				PrimaryKeyGenerationStrategy: pulumi.String("none"),
//			})
//			if err != nil {
//				return err
//			}
//			// Create a datastore item with the primary key specified in the value map
//			_, err = datadog.NewDatastoreItem(ctx, "user1", &datadog.DatastoreItemArgs{
//				DatastoreId: example.ID(),
//				ItemKey:     pulumi.String("user-123"),
//				Value: pulumi.StringMap{
//					"id":       pulumi.String("user-123"),
//					"username": pulumi.String("john_doe"),
//					"email":    pulumi.String("john@example.com"),
//					"status":   pulumi.String("active"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			// Create another datastore item
//			_, err = datadog.NewDatastoreItem(ctx, "user2", &datadog.DatastoreItemArgs{
//				DatastoreId: example.ID(),
//				ItemKey:     pulumi.String("user-456"),
//				Value: pulumi.StringMap{
//					"id":       pulumi.String("user-456"),
//					"username": pulumi.String("jane_doe"),
//					"email":    pulumi.String("jane@example.com"),
//					"status":   pulumi.String("active"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// The `pulumi import` command can be used, for example:
//
// ```sh
// $ pulumi import datadog:index/datastoreItem:DatastoreItem foo "datastore-id:item-key"
// ```
type DatastoreItem struct {
	pulumi.CustomResourceState

	// The unique identifier of the datastore containing this item.
	DatastoreId pulumi.StringOutput `pulumi:"datastoreId"`
	// The primary key value that identifies this item. Cannot exceed 256 characters.
	ItemKey pulumi.StringOutput `pulumi:"itemKey"`
	// The data content (as key-value pairs) of the datastore item.
	Value pulumi.StringMapOutput `pulumi:"value"`
}

// NewDatastoreItem registers a new resource with the given unique name, arguments, and options.
func NewDatastoreItem(ctx *pulumi.Context,
	name string, args *DatastoreItemArgs, opts ...pulumi.ResourceOption) (*DatastoreItem, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.DatastoreId == nil {
		return nil, errors.New("invalid value for required argument 'DatastoreId'")
	}
	if args.ItemKey == nil {
		return nil, errors.New("invalid value for required argument 'ItemKey'")
	}
	if args.Value == nil {
		return nil, errors.New("invalid value for required argument 'Value'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DatastoreItem
	err := ctx.RegisterResource("datadog:index/datastoreItem:DatastoreItem", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDatastoreItem gets an existing DatastoreItem resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDatastoreItem(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DatastoreItemState, opts ...pulumi.ResourceOption) (*DatastoreItem, error) {
	var resource DatastoreItem
	err := ctx.ReadResource("datadog:index/datastoreItem:DatastoreItem", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DatastoreItem resources.
type datastoreItemState struct {
	// The unique identifier of the datastore containing this item.
	DatastoreId *string `pulumi:"datastoreId"`
	// The primary key value that identifies this item. Cannot exceed 256 characters.
	ItemKey *string `pulumi:"itemKey"`
	// The data content (as key-value pairs) of the datastore item.
	Value map[string]string `pulumi:"value"`
}

type DatastoreItemState struct {
	// The unique identifier of the datastore containing this item.
	DatastoreId pulumi.StringPtrInput
	// The primary key value that identifies this item. Cannot exceed 256 characters.
	ItemKey pulumi.StringPtrInput
	// The data content (as key-value pairs) of the datastore item.
	Value pulumi.StringMapInput
}

func (DatastoreItemState) ElementType() reflect.Type {
	return reflect.TypeOf((*datastoreItemState)(nil)).Elem()
}

type datastoreItemArgs struct {
	// The unique identifier of the datastore containing this item.
	DatastoreId string `pulumi:"datastoreId"`
	// The primary key value that identifies this item. Cannot exceed 256 characters.
	ItemKey string `pulumi:"itemKey"`
	// The data content (as key-value pairs) of the datastore item.
	Value map[string]string `pulumi:"value"`
}

// The set of arguments for constructing a DatastoreItem resource.
type DatastoreItemArgs struct {
	// The unique identifier of the datastore containing this item.
	DatastoreId pulumi.StringInput
	// The primary key value that identifies this item. Cannot exceed 256 characters.
	ItemKey pulumi.StringInput
	// The data content (as key-value pairs) of the datastore item.
	Value pulumi.StringMapInput
}

func (DatastoreItemArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*datastoreItemArgs)(nil)).Elem()
}

type DatastoreItemInput interface {
	pulumi.Input

	ToDatastoreItemOutput() DatastoreItemOutput
	ToDatastoreItemOutputWithContext(ctx context.Context) DatastoreItemOutput
}

func (*DatastoreItem) ElementType() reflect.Type {
	return reflect.TypeOf((**DatastoreItem)(nil)).Elem()
}

func (i *DatastoreItem) ToDatastoreItemOutput() DatastoreItemOutput {
	return i.ToDatastoreItemOutputWithContext(context.Background())
}

func (i *DatastoreItem) ToDatastoreItemOutputWithContext(ctx context.Context) DatastoreItemOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatastoreItemOutput)
}

// DatastoreItemArrayInput is an input type that accepts DatastoreItemArray and DatastoreItemArrayOutput values.
// You can construct a concrete instance of `DatastoreItemArrayInput` via:
//
//	DatastoreItemArray{ DatastoreItemArgs{...} }
type DatastoreItemArrayInput interface {
	pulumi.Input

	ToDatastoreItemArrayOutput() DatastoreItemArrayOutput
	ToDatastoreItemArrayOutputWithContext(context.Context) DatastoreItemArrayOutput
}

type DatastoreItemArray []DatastoreItemInput

func (DatastoreItemArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DatastoreItem)(nil)).Elem()
}

func (i DatastoreItemArray) ToDatastoreItemArrayOutput() DatastoreItemArrayOutput {
	return i.ToDatastoreItemArrayOutputWithContext(context.Background())
}

func (i DatastoreItemArray) ToDatastoreItemArrayOutputWithContext(ctx context.Context) DatastoreItemArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatastoreItemArrayOutput)
}

// DatastoreItemMapInput is an input type that accepts DatastoreItemMap and DatastoreItemMapOutput values.
// You can construct a concrete instance of `DatastoreItemMapInput` via:
//
//	DatastoreItemMap{ "key": DatastoreItemArgs{...} }
type DatastoreItemMapInput interface {
	pulumi.Input

	ToDatastoreItemMapOutput() DatastoreItemMapOutput
	ToDatastoreItemMapOutputWithContext(context.Context) DatastoreItemMapOutput
}

type DatastoreItemMap map[string]DatastoreItemInput

func (DatastoreItemMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DatastoreItem)(nil)).Elem()
}

func (i DatastoreItemMap) ToDatastoreItemMapOutput() DatastoreItemMapOutput {
	return i.ToDatastoreItemMapOutputWithContext(context.Background())
}

func (i DatastoreItemMap) ToDatastoreItemMapOutputWithContext(ctx context.Context) DatastoreItemMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatastoreItemMapOutput)
}

type DatastoreItemOutput struct{ *pulumi.OutputState }

func (DatastoreItemOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DatastoreItem)(nil)).Elem()
}

func (o DatastoreItemOutput) ToDatastoreItemOutput() DatastoreItemOutput {
	return o
}

func (o DatastoreItemOutput) ToDatastoreItemOutputWithContext(ctx context.Context) DatastoreItemOutput {
	return o
}

// The unique identifier of the datastore containing this item.
func (o DatastoreItemOutput) DatastoreId() pulumi.StringOutput {
	return o.ApplyT(func(v *DatastoreItem) pulumi.StringOutput { return v.DatastoreId }).(pulumi.StringOutput)
}

// The primary key value that identifies this item. Cannot exceed 256 characters.
func (o DatastoreItemOutput) ItemKey() pulumi.StringOutput {
	return o.ApplyT(func(v *DatastoreItem) pulumi.StringOutput { return v.ItemKey }).(pulumi.StringOutput)
}

// The data content (as key-value pairs) of the datastore item.
func (o DatastoreItemOutput) Value() pulumi.StringMapOutput {
	return o.ApplyT(func(v *DatastoreItem) pulumi.StringMapOutput { return v.Value }).(pulumi.StringMapOutput)
}

type DatastoreItemArrayOutput struct{ *pulumi.OutputState }

func (DatastoreItemArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DatastoreItem)(nil)).Elem()
}

func (o DatastoreItemArrayOutput) ToDatastoreItemArrayOutput() DatastoreItemArrayOutput {
	return o
}

func (o DatastoreItemArrayOutput) ToDatastoreItemArrayOutputWithContext(ctx context.Context) DatastoreItemArrayOutput {
	return o
}

func (o DatastoreItemArrayOutput) Index(i pulumi.IntInput) DatastoreItemOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DatastoreItem {
		return vs[0].([]*DatastoreItem)[vs[1].(int)]
	}).(DatastoreItemOutput)
}

type DatastoreItemMapOutput struct{ *pulumi.OutputState }

func (DatastoreItemMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DatastoreItem)(nil)).Elem()
}

func (o DatastoreItemMapOutput) ToDatastoreItemMapOutput() DatastoreItemMapOutput {
	return o
}

func (o DatastoreItemMapOutput) ToDatastoreItemMapOutputWithContext(ctx context.Context) DatastoreItemMapOutput {
	return o
}

func (o DatastoreItemMapOutput) MapIndex(k pulumi.StringInput) DatastoreItemOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DatastoreItem {
		return vs[0].(map[string]*DatastoreItem)[vs[1].(string)]
	}).(DatastoreItemOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DatastoreItemInput)(nil)).Elem(), &DatastoreItem{})
	pulumi.RegisterInputType(reflect.TypeOf((*DatastoreItemArrayInput)(nil)).Elem(), DatastoreItemArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DatastoreItemMapInput)(nil)).Elem(), DatastoreItemMap{})
	pulumi.RegisterOutputType(DatastoreItemOutput{})
	pulumi.RegisterOutputType(DatastoreItemArrayOutput{})
	pulumi.RegisterOutputType(DatastoreItemMapOutput{})
}

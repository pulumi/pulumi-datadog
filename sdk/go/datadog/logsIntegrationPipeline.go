// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package datadog

import (
	"context"
	"reflect"

	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Datadog Logs Pipeline API resource to manage the integrations. Integration pipelines are the pipelines that are automatically installed for your organization when sending the logs with specific sources. You don't need to maintain or update these types of pipelines. Keeping them as resources, however, allows you to manage the order of your pipelines by referencing them in your `LogsPipelineOrder` resource. If you don't need the `pipelineOrder` feature, this resource declaration can be omitted.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-datadog/sdk/v3/go/datadog"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := datadog.NewLogsIntegrationPipeline(ctx, "python", &datadog.LogsIntegrationPipelineArgs{
// 			IsEnabled: pulumi.Bool(true),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// ```sh
//  $ pulumi import datadog:index/logsIntegrationPipeline:LogsIntegrationPipeline name> <pipelineID>
// ```
type LogsIntegrationPipeline struct {
	pulumi.CustomResourceState

	// Boolean value to enable your pipeline.
	IsEnabled pulumi.BoolPtrOutput `pulumi:"isEnabled"`
}

// NewLogsIntegrationPipeline registers a new resource with the given unique name, arguments, and options.
func NewLogsIntegrationPipeline(ctx *pulumi.Context,
	name string, args *LogsIntegrationPipelineArgs, opts ...pulumi.ResourceOption) (*LogsIntegrationPipeline, error) {
	if args == nil {
		args = &LogsIntegrationPipelineArgs{}
	}

	var resource LogsIntegrationPipeline
	err := ctx.RegisterResource("datadog:index/logsIntegrationPipeline:LogsIntegrationPipeline", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLogsIntegrationPipeline gets an existing LogsIntegrationPipeline resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLogsIntegrationPipeline(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LogsIntegrationPipelineState, opts ...pulumi.ResourceOption) (*LogsIntegrationPipeline, error) {
	var resource LogsIntegrationPipeline
	err := ctx.ReadResource("datadog:index/logsIntegrationPipeline:LogsIntegrationPipeline", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LogsIntegrationPipeline resources.
type logsIntegrationPipelineState struct {
	// Boolean value to enable your pipeline.
	IsEnabled *bool `pulumi:"isEnabled"`
}

type LogsIntegrationPipelineState struct {
	// Boolean value to enable your pipeline.
	IsEnabled pulumi.BoolPtrInput
}

func (LogsIntegrationPipelineState) ElementType() reflect.Type {
	return reflect.TypeOf((*logsIntegrationPipelineState)(nil)).Elem()
}

type logsIntegrationPipelineArgs struct {
	// Boolean value to enable your pipeline.
	IsEnabled *bool `pulumi:"isEnabled"`
}

// The set of arguments for constructing a LogsIntegrationPipeline resource.
type LogsIntegrationPipelineArgs struct {
	// Boolean value to enable your pipeline.
	IsEnabled pulumi.BoolPtrInput
}

func (LogsIntegrationPipelineArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*logsIntegrationPipelineArgs)(nil)).Elem()
}

type LogsIntegrationPipelineInput interface {
	pulumi.Input

	ToLogsIntegrationPipelineOutput() LogsIntegrationPipelineOutput
	ToLogsIntegrationPipelineOutputWithContext(ctx context.Context) LogsIntegrationPipelineOutput
}

func (*LogsIntegrationPipeline) ElementType() reflect.Type {
	return reflect.TypeOf((*LogsIntegrationPipeline)(nil))
}

func (i *LogsIntegrationPipeline) ToLogsIntegrationPipelineOutput() LogsIntegrationPipelineOutput {
	return i.ToLogsIntegrationPipelineOutputWithContext(context.Background())
}

func (i *LogsIntegrationPipeline) ToLogsIntegrationPipelineOutputWithContext(ctx context.Context) LogsIntegrationPipelineOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsIntegrationPipelineOutput)
}

func (i *LogsIntegrationPipeline) ToLogsIntegrationPipelinePtrOutput() LogsIntegrationPipelinePtrOutput {
	return i.ToLogsIntegrationPipelinePtrOutputWithContext(context.Background())
}

func (i *LogsIntegrationPipeline) ToLogsIntegrationPipelinePtrOutputWithContext(ctx context.Context) LogsIntegrationPipelinePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsIntegrationPipelinePtrOutput)
}

type LogsIntegrationPipelinePtrInput interface {
	pulumi.Input

	ToLogsIntegrationPipelinePtrOutput() LogsIntegrationPipelinePtrOutput
	ToLogsIntegrationPipelinePtrOutputWithContext(ctx context.Context) LogsIntegrationPipelinePtrOutput
}

type logsIntegrationPipelinePtrType LogsIntegrationPipelineArgs

func (*logsIntegrationPipelinePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**LogsIntegrationPipeline)(nil))
}

func (i *logsIntegrationPipelinePtrType) ToLogsIntegrationPipelinePtrOutput() LogsIntegrationPipelinePtrOutput {
	return i.ToLogsIntegrationPipelinePtrOutputWithContext(context.Background())
}

func (i *logsIntegrationPipelinePtrType) ToLogsIntegrationPipelinePtrOutputWithContext(ctx context.Context) LogsIntegrationPipelinePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsIntegrationPipelinePtrOutput)
}

// LogsIntegrationPipelineArrayInput is an input type that accepts LogsIntegrationPipelineArray and LogsIntegrationPipelineArrayOutput values.
// You can construct a concrete instance of `LogsIntegrationPipelineArrayInput` via:
//
//          LogsIntegrationPipelineArray{ LogsIntegrationPipelineArgs{...} }
type LogsIntegrationPipelineArrayInput interface {
	pulumi.Input

	ToLogsIntegrationPipelineArrayOutput() LogsIntegrationPipelineArrayOutput
	ToLogsIntegrationPipelineArrayOutputWithContext(context.Context) LogsIntegrationPipelineArrayOutput
}

type LogsIntegrationPipelineArray []LogsIntegrationPipelineInput

func (LogsIntegrationPipelineArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*LogsIntegrationPipeline)(nil))
}

func (i LogsIntegrationPipelineArray) ToLogsIntegrationPipelineArrayOutput() LogsIntegrationPipelineArrayOutput {
	return i.ToLogsIntegrationPipelineArrayOutputWithContext(context.Background())
}

func (i LogsIntegrationPipelineArray) ToLogsIntegrationPipelineArrayOutputWithContext(ctx context.Context) LogsIntegrationPipelineArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsIntegrationPipelineArrayOutput)
}

// LogsIntegrationPipelineMapInput is an input type that accepts LogsIntegrationPipelineMap and LogsIntegrationPipelineMapOutput values.
// You can construct a concrete instance of `LogsIntegrationPipelineMapInput` via:
//
//          LogsIntegrationPipelineMap{ "key": LogsIntegrationPipelineArgs{...} }
type LogsIntegrationPipelineMapInput interface {
	pulumi.Input

	ToLogsIntegrationPipelineMapOutput() LogsIntegrationPipelineMapOutput
	ToLogsIntegrationPipelineMapOutputWithContext(context.Context) LogsIntegrationPipelineMapOutput
}

type LogsIntegrationPipelineMap map[string]LogsIntegrationPipelineInput

func (LogsIntegrationPipelineMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*LogsIntegrationPipeline)(nil))
}

func (i LogsIntegrationPipelineMap) ToLogsIntegrationPipelineMapOutput() LogsIntegrationPipelineMapOutput {
	return i.ToLogsIntegrationPipelineMapOutputWithContext(context.Background())
}

func (i LogsIntegrationPipelineMap) ToLogsIntegrationPipelineMapOutputWithContext(ctx context.Context) LogsIntegrationPipelineMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsIntegrationPipelineMapOutput)
}

type LogsIntegrationPipelineOutput struct {
	*pulumi.OutputState
}

func (LogsIntegrationPipelineOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*LogsIntegrationPipeline)(nil))
}

func (o LogsIntegrationPipelineOutput) ToLogsIntegrationPipelineOutput() LogsIntegrationPipelineOutput {
	return o
}

func (o LogsIntegrationPipelineOutput) ToLogsIntegrationPipelineOutputWithContext(ctx context.Context) LogsIntegrationPipelineOutput {
	return o
}

func (o LogsIntegrationPipelineOutput) ToLogsIntegrationPipelinePtrOutput() LogsIntegrationPipelinePtrOutput {
	return o.ToLogsIntegrationPipelinePtrOutputWithContext(context.Background())
}

func (o LogsIntegrationPipelineOutput) ToLogsIntegrationPipelinePtrOutputWithContext(ctx context.Context) LogsIntegrationPipelinePtrOutput {
	return o.ApplyT(func(v LogsIntegrationPipeline) *LogsIntegrationPipeline {
		return &v
	}).(LogsIntegrationPipelinePtrOutput)
}

type LogsIntegrationPipelinePtrOutput struct {
	*pulumi.OutputState
}

func (LogsIntegrationPipelinePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogsIntegrationPipeline)(nil))
}

func (o LogsIntegrationPipelinePtrOutput) ToLogsIntegrationPipelinePtrOutput() LogsIntegrationPipelinePtrOutput {
	return o
}

func (o LogsIntegrationPipelinePtrOutput) ToLogsIntegrationPipelinePtrOutputWithContext(ctx context.Context) LogsIntegrationPipelinePtrOutput {
	return o
}

type LogsIntegrationPipelineArrayOutput struct{ *pulumi.OutputState }

func (LogsIntegrationPipelineArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]LogsIntegrationPipeline)(nil))
}

func (o LogsIntegrationPipelineArrayOutput) ToLogsIntegrationPipelineArrayOutput() LogsIntegrationPipelineArrayOutput {
	return o
}

func (o LogsIntegrationPipelineArrayOutput) ToLogsIntegrationPipelineArrayOutputWithContext(ctx context.Context) LogsIntegrationPipelineArrayOutput {
	return o
}

func (o LogsIntegrationPipelineArrayOutput) Index(i pulumi.IntInput) LogsIntegrationPipelineOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) LogsIntegrationPipeline {
		return vs[0].([]LogsIntegrationPipeline)[vs[1].(int)]
	}).(LogsIntegrationPipelineOutput)
}

type LogsIntegrationPipelineMapOutput struct{ *pulumi.OutputState }

func (LogsIntegrationPipelineMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]LogsIntegrationPipeline)(nil))
}

func (o LogsIntegrationPipelineMapOutput) ToLogsIntegrationPipelineMapOutput() LogsIntegrationPipelineMapOutput {
	return o
}

func (o LogsIntegrationPipelineMapOutput) ToLogsIntegrationPipelineMapOutputWithContext(ctx context.Context) LogsIntegrationPipelineMapOutput {
	return o
}

func (o LogsIntegrationPipelineMapOutput) MapIndex(k pulumi.StringInput) LogsIntegrationPipelineOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) LogsIntegrationPipeline {
		return vs[0].(map[string]LogsIntegrationPipeline)[vs[1].(string)]
	}).(LogsIntegrationPipelineOutput)
}

func init() {
	pulumi.RegisterOutputType(LogsIntegrationPipelineOutput{})
	pulumi.RegisterOutputType(LogsIntegrationPipelinePtrOutput{})
	pulumi.RegisterOutputType(LogsIntegrationPipelineArrayOutput{})
	pulumi.RegisterOutputType(LogsIntegrationPipelineMapOutput{})
}

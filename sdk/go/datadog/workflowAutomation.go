// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package datadog

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"encoding/json"
//
//	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			tmpJSON0, err := json.Marshal(map[string]interface{}{
//				"triggers": []map[string]interface{}{
//					map[string]interface{}{
//						"startStepNames": []string{
//							"Send_Email",
//						},
//						"monitorTrigger": map[string]interface{}{},
//					},
//				},
//				"steps": []map[string]interface{}{
//					map[string]interface{}{
//						"name":     "Send_Email",
//						"actionId": "com.datadoghq.email.send",
//						"parameters": []map[string]interface{}{
//							map[string]interface{}{
//								"name":  "to",
//								"value": "REPLACE_ME",
//							},
//							map[string]interface{}{
//								"name":  "subject",
//								"value": "Monitor \"{{ Source.monitor.name }}\" alerted",
//							},
//							map[string]interface{}{
//								"name":  "message",
//								"value": "This message is from {{ WorkflowName }}. \n\nYou can find a link to the monitor here: {{ Source.url }}.",
//							},
//						},
//						"display": map[string]interface{}{
//							"bounds": map[string]interface{}{
//								"x": 0,
//								"y": 216,
//							},
//						},
//					},
//				},
//				"handle": "my-handle",
//			})
//			if err != nil {
//				return err
//			}
//			json0 := string(tmpJSON0)
//			_, err = datadog.NewWorkflowAutomation(ctx, "workflow", &datadog.WorkflowAutomationArgs{
//				Name:        pulumi.String("Send Email when Monitor Alerts"),
//				Description: pulumi.String("This workflow alerts me by email when my monitor goes off. "),
//				Tags: pulumi.StringArray{
//					pulumi.String("service:foo"),
//					pulumi.String("source:alert"),
//					pulumi.String("team:bar"),
//				},
//				Published: pulumi.Bool(true),
//				SpecJson:  pulumi.String(json0),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// The `pulumi import` command can be used, for example:
//
// ```sh
// $ pulumi import datadog:index/workflowAutomation:WorkflowAutomation my_workflow 11111111-2222-3333-4444-555555555555
// ```
type WorkflowAutomation struct {
	pulumi.CustomResourceState

	// Description of the workflow.
	Description pulumi.StringOutput `pulumi:"description"`
	// Name of the workflow. String length must be at least 1.
	Name pulumi.StringOutput `pulumi:"name"`
	// Set the workflow to published or unpublished. Workflows in an unpublished state are only executable through manual runs. Automatic triggers such as Schedule do not execute the workflow until it is published.
	Published pulumi.BoolOutput `pulumi:"published"`
	// The spec defines what the workflow does.
	SpecJson pulumi.StringOutput `pulumi:"specJson"`
	// Tags of the workflow.
	Tags pulumi.StringArrayOutput `pulumi:"tags"`
	// If a webhook trigger is defined on this workflow, a webhookSecret is required and should be provided here. String length must be at least 16.
	WebhookSecret pulumi.StringPtrOutput `pulumi:"webhookSecret"`
}

// NewWorkflowAutomation registers a new resource with the given unique name, arguments, and options.
func NewWorkflowAutomation(ctx *pulumi.Context,
	name string, args *WorkflowAutomationArgs, opts ...pulumi.ResourceOption) (*WorkflowAutomation, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Description == nil {
		return nil, errors.New("invalid value for required argument 'Description'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	if args.Published == nil {
		return nil, errors.New("invalid value for required argument 'Published'")
	}
	if args.SpecJson == nil {
		return nil, errors.New("invalid value for required argument 'SpecJson'")
	}
	if args.Tags == nil {
		return nil, errors.New("invalid value for required argument 'Tags'")
	}
	if args.WebhookSecret != nil {
		args.WebhookSecret = pulumi.ToSecret(args.WebhookSecret).(pulumi.StringPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"webhookSecret",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource WorkflowAutomation
	err := ctx.RegisterResource("datadog:index/workflowAutomation:WorkflowAutomation", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetWorkflowAutomation gets an existing WorkflowAutomation resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetWorkflowAutomation(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *WorkflowAutomationState, opts ...pulumi.ResourceOption) (*WorkflowAutomation, error) {
	var resource WorkflowAutomation
	err := ctx.ReadResource("datadog:index/workflowAutomation:WorkflowAutomation", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering WorkflowAutomation resources.
type workflowAutomationState struct {
	// Description of the workflow.
	Description *string `pulumi:"description"`
	// Name of the workflow. String length must be at least 1.
	Name *string `pulumi:"name"`
	// Set the workflow to published or unpublished. Workflows in an unpublished state are only executable through manual runs. Automatic triggers such as Schedule do not execute the workflow until it is published.
	Published *bool `pulumi:"published"`
	// The spec defines what the workflow does.
	SpecJson *string `pulumi:"specJson"`
	// Tags of the workflow.
	Tags []string `pulumi:"tags"`
	// If a webhook trigger is defined on this workflow, a webhookSecret is required and should be provided here. String length must be at least 16.
	WebhookSecret *string `pulumi:"webhookSecret"`
}

type WorkflowAutomationState struct {
	// Description of the workflow.
	Description pulumi.StringPtrInput
	// Name of the workflow. String length must be at least 1.
	Name pulumi.StringPtrInput
	// Set the workflow to published or unpublished. Workflows in an unpublished state are only executable through manual runs. Automatic triggers such as Schedule do not execute the workflow until it is published.
	Published pulumi.BoolPtrInput
	// The spec defines what the workflow does.
	SpecJson pulumi.StringPtrInput
	// Tags of the workflow.
	Tags pulumi.StringArrayInput
	// If a webhook trigger is defined on this workflow, a webhookSecret is required and should be provided here. String length must be at least 16.
	WebhookSecret pulumi.StringPtrInput
}

func (WorkflowAutomationState) ElementType() reflect.Type {
	return reflect.TypeOf((*workflowAutomationState)(nil)).Elem()
}

type workflowAutomationArgs struct {
	// Description of the workflow.
	Description string `pulumi:"description"`
	// Name of the workflow. String length must be at least 1.
	Name string `pulumi:"name"`
	// Set the workflow to published or unpublished. Workflows in an unpublished state are only executable through manual runs. Automatic triggers such as Schedule do not execute the workflow until it is published.
	Published bool `pulumi:"published"`
	// The spec defines what the workflow does.
	SpecJson string `pulumi:"specJson"`
	// Tags of the workflow.
	Tags []string `pulumi:"tags"`
	// If a webhook trigger is defined on this workflow, a webhookSecret is required and should be provided here. String length must be at least 16.
	WebhookSecret *string `pulumi:"webhookSecret"`
}

// The set of arguments for constructing a WorkflowAutomation resource.
type WorkflowAutomationArgs struct {
	// Description of the workflow.
	Description pulumi.StringInput
	// Name of the workflow. String length must be at least 1.
	Name pulumi.StringInput
	// Set the workflow to published or unpublished. Workflows in an unpublished state are only executable through manual runs. Automatic triggers such as Schedule do not execute the workflow until it is published.
	Published pulumi.BoolInput
	// The spec defines what the workflow does.
	SpecJson pulumi.StringInput
	// Tags of the workflow.
	Tags pulumi.StringArrayInput
	// If a webhook trigger is defined on this workflow, a webhookSecret is required and should be provided here. String length must be at least 16.
	WebhookSecret pulumi.StringPtrInput
}

func (WorkflowAutomationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*workflowAutomationArgs)(nil)).Elem()
}

type WorkflowAutomationInput interface {
	pulumi.Input

	ToWorkflowAutomationOutput() WorkflowAutomationOutput
	ToWorkflowAutomationOutputWithContext(ctx context.Context) WorkflowAutomationOutput
}

func (*WorkflowAutomation) ElementType() reflect.Type {
	return reflect.TypeOf((**WorkflowAutomation)(nil)).Elem()
}

func (i *WorkflowAutomation) ToWorkflowAutomationOutput() WorkflowAutomationOutput {
	return i.ToWorkflowAutomationOutputWithContext(context.Background())
}

func (i *WorkflowAutomation) ToWorkflowAutomationOutputWithContext(ctx context.Context) WorkflowAutomationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WorkflowAutomationOutput)
}

// WorkflowAutomationArrayInput is an input type that accepts WorkflowAutomationArray and WorkflowAutomationArrayOutput values.
// You can construct a concrete instance of `WorkflowAutomationArrayInput` via:
//
//	WorkflowAutomationArray{ WorkflowAutomationArgs{...} }
type WorkflowAutomationArrayInput interface {
	pulumi.Input

	ToWorkflowAutomationArrayOutput() WorkflowAutomationArrayOutput
	ToWorkflowAutomationArrayOutputWithContext(context.Context) WorkflowAutomationArrayOutput
}

type WorkflowAutomationArray []WorkflowAutomationInput

func (WorkflowAutomationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*WorkflowAutomation)(nil)).Elem()
}

func (i WorkflowAutomationArray) ToWorkflowAutomationArrayOutput() WorkflowAutomationArrayOutput {
	return i.ToWorkflowAutomationArrayOutputWithContext(context.Background())
}

func (i WorkflowAutomationArray) ToWorkflowAutomationArrayOutputWithContext(ctx context.Context) WorkflowAutomationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WorkflowAutomationArrayOutput)
}

// WorkflowAutomationMapInput is an input type that accepts WorkflowAutomationMap and WorkflowAutomationMapOutput values.
// You can construct a concrete instance of `WorkflowAutomationMapInput` via:
//
//	WorkflowAutomationMap{ "key": WorkflowAutomationArgs{...} }
type WorkflowAutomationMapInput interface {
	pulumi.Input

	ToWorkflowAutomationMapOutput() WorkflowAutomationMapOutput
	ToWorkflowAutomationMapOutputWithContext(context.Context) WorkflowAutomationMapOutput
}

type WorkflowAutomationMap map[string]WorkflowAutomationInput

func (WorkflowAutomationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*WorkflowAutomation)(nil)).Elem()
}

func (i WorkflowAutomationMap) ToWorkflowAutomationMapOutput() WorkflowAutomationMapOutput {
	return i.ToWorkflowAutomationMapOutputWithContext(context.Background())
}

func (i WorkflowAutomationMap) ToWorkflowAutomationMapOutputWithContext(ctx context.Context) WorkflowAutomationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(WorkflowAutomationMapOutput)
}

type WorkflowAutomationOutput struct{ *pulumi.OutputState }

func (WorkflowAutomationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**WorkflowAutomation)(nil)).Elem()
}

func (o WorkflowAutomationOutput) ToWorkflowAutomationOutput() WorkflowAutomationOutput {
	return o
}

func (o WorkflowAutomationOutput) ToWorkflowAutomationOutputWithContext(ctx context.Context) WorkflowAutomationOutput {
	return o
}

// Description of the workflow.
func (o WorkflowAutomationOutput) Description() pulumi.StringOutput {
	return o.ApplyT(func(v *WorkflowAutomation) pulumi.StringOutput { return v.Description }).(pulumi.StringOutput)
}

// Name of the workflow. String length must be at least 1.
func (o WorkflowAutomationOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *WorkflowAutomation) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Set the workflow to published or unpublished. Workflows in an unpublished state are only executable through manual runs. Automatic triggers such as Schedule do not execute the workflow until it is published.
func (o WorkflowAutomationOutput) Published() pulumi.BoolOutput {
	return o.ApplyT(func(v *WorkflowAutomation) pulumi.BoolOutput { return v.Published }).(pulumi.BoolOutput)
}

// The spec defines what the workflow does.
func (o WorkflowAutomationOutput) SpecJson() pulumi.StringOutput {
	return o.ApplyT(func(v *WorkflowAutomation) pulumi.StringOutput { return v.SpecJson }).(pulumi.StringOutput)
}

// Tags of the workflow.
func (o WorkflowAutomationOutput) Tags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *WorkflowAutomation) pulumi.StringArrayOutput { return v.Tags }).(pulumi.StringArrayOutput)
}

// If a webhook trigger is defined on this workflow, a webhookSecret is required and should be provided here. String length must be at least 16.
func (o WorkflowAutomationOutput) WebhookSecret() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *WorkflowAutomation) pulumi.StringPtrOutput { return v.WebhookSecret }).(pulumi.StringPtrOutput)
}

type WorkflowAutomationArrayOutput struct{ *pulumi.OutputState }

func (WorkflowAutomationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*WorkflowAutomation)(nil)).Elem()
}

func (o WorkflowAutomationArrayOutput) ToWorkflowAutomationArrayOutput() WorkflowAutomationArrayOutput {
	return o
}

func (o WorkflowAutomationArrayOutput) ToWorkflowAutomationArrayOutputWithContext(ctx context.Context) WorkflowAutomationArrayOutput {
	return o
}

func (o WorkflowAutomationArrayOutput) Index(i pulumi.IntInput) WorkflowAutomationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *WorkflowAutomation {
		return vs[0].([]*WorkflowAutomation)[vs[1].(int)]
	}).(WorkflowAutomationOutput)
}

type WorkflowAutomationMapOutput struct{ *pulumi.OutputState }

func (WorkflowAutomationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*WorkflowAutomation)(nil)).Elem()
}

func (o WorkflowAutomationMapOutput) ToWorkflowAutomationMapOutput() WorkflowAutomationMapOutput {
	return o
}

func (o WorkflowAutomationMapOutput) ToWorkflowAutomationMapOutputWithContext(ctx context.Context) WorkflowAutomationMapOutput {
	return o
}

func (o WorkflowAutomationMapOutput) MapIndex(k pulumi.StringInput) WorkflowAutomationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *WorkflowAutomation {
		return vs[0].(map[string]*WorkflowAutomation)[vs[1].(string)]
	}).(WorkflowAutomationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*WorkflowAutomationInput)(nil)).Elem(), &WorkflowAutomation{})
	pulumi.RegisterInputType(reflect.TypeOf((*WorkflowAutomationArrayInput)(nil)).Elem(), WorkflowAutomationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*WorkflowAutomationMapInput)(nil)).Elem(), WorkflowAutomationMap{})
	pulumi.RegisterOutputType(WorkflowAutomationOutput{})
	pulumi.RegisterOutputType(WorkflowAutomationArrayOutput{})
	pulumi.RegisterOutputType(WorkflowAutomationMapOutput{})
}

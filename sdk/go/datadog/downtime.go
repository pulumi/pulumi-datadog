// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package datadog

import (
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Provides a Datadog downtime resource. This can be used to create and manage Datadog downtimes.
//
// ## Example: downtime for a specific monitor
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-datadog/sdk/v2/go/datadog"
// 	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := datadog.NewDowntime(ctx, "foo", &datadog.DowntimeArgs{
// 			End:       pulumi.Int(1483365600),
// 			MonitorId: pulumi.Int(12345),
// 			Recurrence: &datadog.DowntimeRecurrenceArgs{
// 				Period: pulumi.Int(1),
// 				Type:   pulumi.String("days"),
// 			},
// 			Scopes: pulumi.StringArray{
// 				pulumi.String("*"),
// 			},
// 			Start: pulumi.Int(1483308000),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Example: downtime for all monitors
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-datadog/sdk/v2/go/datadog"
// 	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := datadog.NewDowntime(ctx, "foo", &datadog.DowntimeArgs{
// 			End: pulumi.Int(1483365600),
// 			Recurrence: &datadog.DowntimeRecurrenceArgs{
// 				Period: pulumi.Int(1),
// 				Type:   pulumi.String("days"),
// 			},
// 			Scopes: pulumi.StringArray{
// 				pulumi.String("*"),
// 			},
// 			Start: pulumi.Int(1483308000),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
type Downtime struct {
	pulumi.CustomResourceState

	// A flag indicating if the downtime is active now.
	Active pulumi.BoolPtrOutput `pulumi:"active"`
	// A flag indicating if the downtime was disabled.
	Disabled pulumi.BoolPtrOutput `pulumi:"disabled"`
	// POSIX timestamp to end the downtime.
	End pulumi.IntPtrOutput `pulumi:"end"`
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate pulumi.StringPtrOutput `pulumi:"endDate"`
	// A message to include with notifications for this downtime.
	Message pulumi.StringPtrOutput `pulumi:"message"`
	// Reference to which monitor this downtime is applied. When scheduling downtime for a given monitor, datadog changes `silenced` property of the monitor to match the `end` POSIX timestamp. **Note:** this will effectively change the `silenced` attribute of the referenced monitor. If that monitor is also tracked by this provider and you don't want it to be unmuted on the next `pulumi up`, see `silencing-by-hand-and-by-downtimes` in the monitor resource documentation. This option also conflicts with `monitorTags` use none or one or the other.
	MonitorId pulumi.IntPtrOutput `pulumi:"monitorId"`
	// A list of monitor tags to match. The resulting downtime applies to monitors that match **all** provided monitor tags. This option conflicts with `monitorId` as it will match all monitors that match these tags.
	MonitorTags pulumi.StringArrayOutput `pulumi:"monitorTags"`
	// A dictionary to configure the downtime to be recurring.
	Recurrence DowntimeRecurrencePtrOutput `pulumi:"recurrence"`
	// The scope(s) to which the downtime applies, e.g. host:app2. Provide multiple scopes as a comma-separated list, e.g. env:dev,env:prod. The resulting downtime applies to sources that matches ALL provided scopes (i.e. env:dev AND env:prod), NOT any of them.
	Scopes pulumi.StringArrayOutput `pulumi:"scopes"`
	// POSIX timestamp to start the downtime.
	Start pulumi.IntPtrOutput `pulumi:"start"`
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate pulumi.StringPtrOutput `pulumi:"startDate"`
	// The timezone for the downtime, default UTC. It must be a valid IANA Time Zone.
	Timezone pulumi.StringPtrOutput `pulumi:"timezone"`
}

// NewDowntime registers a new resource with the given unique name, arguments, and options.
func NewDowntime(ctx *pulumi.Context,
	name string, args *DowntimeArgs, opts ...pulumi.ResourceOption) (*Downtime, error) {
	if args == nil || args.Scopes == nil {
		return nil, errors.New("missing required argument 'Scopes'")
	}
	if args == nil {
		args = &DowntimeArgs{}
	}
	var resource Downtime
	err := ctx.RegisterResource("datadog:index/downtime:Downtime", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDowntime gets an existing Downtime resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDowntime(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DowntimeState, opts ...pulumi.ResourceOption) (*Downtime, error) {
	var resource Downtime
	err := ctx.ReadResource("datadog:index/downtime:Downtime", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Downtime resources.
type downtimeState struct {
	// A flag indicating if the downtime is active now.
	Active *bool `pulumi:"active"`
	// A flag indicating if the downtime was disabled.
	Disabled *bool `pulumi:"disabled"`
	// POSIX timestamp to end the downtime.
	End *int `pulumi:"end"`
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate *string `pulumi:"endDate"`
	// A message to include with notifications for this downtime.
	Message *string `pulumi:"message"`
	// Reference to which monitor this downtime is applied. When scheduling downtime for a given monitor, datadog changes `silenced` property of the monitor to match the `end` POSIX timestamp. **Note:** this will effectively change the `silenced` attribute of the referenced monitor. If that monitor is also tracked by this provider and you don't want it to be unmuted on the next `pulumi up`, see `silencing-by-hand-and-by-downtimes` in the monitor resource documentation. This option also conflicts with `monitorTags` use none or one or the other.
	MonitorId *int `pulumi:"monitorId"`
	// A list of monitor tags to match. The resulting downtime applies to monitors that match **all** provided monitor tags. This option conflicts with `monitorId` as it will match all monitors that match these tags.
	MonitorTags []string `pulumi:"monitorTags"`
	// A dictionary to configure the downtime to be recurring.
	Recurrence *DowntimeRecurrence `pulumi:"recurrence"`
	// The scope(s) to which the downtime applies, e.g. host:app2. Provide multiple scopes as a comma-separated list, e.g. env:dev,env:prod. The resulting downtime applies to sources that matches ALL provided scopes (i.e. env:dev AND env:prod), NOT any of them.
	Scopes []string `pulumi:"scopes"`
	// POSIX timestamp to start the downtime.
	Start *int `pulumi:"start"`
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate *string `pulumi:"startDate"`
	// The timezone for the downtime, default UTC. It must be a valid IANA Time Zone.
	Timezone *string `pulumi:"timezone"`
}

type DowntimeState struct {
	// A flag indicating if the downtime is active now.
	Active pulumi.BoolPtrInput
	// A flag indicating if the downtime was disabled.
	Disabled pulumi.BoolPtrInput
	// POSIX timestamp to end the downtime.
	End pulumi.IntPtrInput
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate pulumi.StringPtrInput
	// A message to include with notifications for this downtime.
	Message pulumi.StringPtrInput
	// Reference to which monitor this downtime is applied. When scheduling downtime for a given monitor, datadog changes `silenced` property of the monitor to match the `end` POSIX timestamp. **Note:** this will effectively change the `silenced` attribute of the referenced monitor. If that monitor is also tracked by this provider and you don't want it to be unmuted on the next `pulumi up`, see `silencing-by-hand-and-by-downtimes` in the monitor resource documentation. This option also conflicts with `monitorTags` use none or one or the other.
	MonitorId pulumi.IntPtrInput
	// A list of monitor tags to match. The resulting downtime applies to monitors that match **all** provided monitor tags. This option conflicts with `monitorId` as it will match all monitors that match these tags.
	MonitorTags pulumi.StringArrayInput
	// A dictionary to configure the downtime to be recurring.
	Recurrence DowntimeRecurrencePtrInput
	// The scope(s) to which the downtime applies, e.g. host:app2. Provide multiple scopes as a comma-separated list, e.g. env:dev,env:prod. The resulting downtime applies to sources that matches ALL provided scopes (i.e. env:dev AND env:prod), NOT any of them.
	Scopes pulumi.StringArrayInput
	// POSIX timestamp to start the downtime.
	Start pulumi.IntPtrInput
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate pulumi.StringPtrInput
	// The timezone for the downtime, default UTC. It must be a valid IANA Time Zone.
	Timezone pulumi.StringPtrInput
}

func (DowntimeState) ElementType() reflect.Type {
	return reflect.TypeOf((*downtimeState)(nil)).Elem()
}

type downtimeArgs struct {
	// A flag indicating if the downtime is active now.
	Active *bool `pulumi:"active"`
	// A flag indicating if the downtime was disabled.
	Disabled *bool `pulumi:"disabled"`
	// POSIX timestamp to end the downtime.
	End *int `pulumi:"end"`
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate *string `pulumi:"endDate"`
	// A message to include with notifications for this downtime.
	Message *string `pulumi:"message"`
	// Reference to which monitor this downtime is applied. When scheduling downtime for a given monitor, datadog changes `silenced` property of the monitor to match the `end` POSIX timestamp. **Note:** this will effectively change the `silenced` attribute of the referenced monitor. If that monitor is also tracked by this provider and you don't want it to be unmuted on the next `pulumi up`, see `silencing-by-hand-and-by-downtimes` in the monitor resource documentation. This option also conflicts with `monitorTags` use none or one or the other.
	MonitorId *int `pulumi:"monitorId"`
	// A list of monitor tags to match. The resulting downtime applies to monitors that match **all** provided monitor tags. This option conflicts with `monitorId` as it will match all monitors that match these tags.
	MonitorTags []string `pulumi:"monitorTags"`
	// A dictionary to configure the downtime to be recurring.
	Recurrence *DowntimeRecurrence `pulumi:"recurrence"`
	// The scope(s) to which the downtime applies, e.g. host:app2. Provide multiple scopes as a comma-separated list, e.g. env:dev,env:prod. The resulting downtime applies to sources that matches ALL provided scopes (i.e. env:dev AND env:prod), NOT any of them.
	Scopes []string `pulumi:"scopes"`
	// POSIX timestamp to start the downtime.
	Start *int `pulumi:"start"`
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate *string `pulumi:"startDate"`
	// The timezone for the downtime, default UTC. It must be a valid IANA Time Zone.
	Timezone *string `pulumi:"timezone"`
}

// The set of arguments for constructing a Downtime resource.
type DowntimeArgs struct {
	// A flag indicating if the downtime is active now.
	Active pulumi.BoolPtrInput
	// A flag indicating if the downtime was disabled.
	Disabled pulumi.BoolPtrInput
	// POSIX timestamp to end the downtime.
	End pulumi.IntPtrInput
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate pulumi.StringPtrInput
	// A message to include with notifications for this downtime.
	Message pulumi.StringPtrInput
	// Reference to which monitor this downtime is applied. When scheduling downtime for a given monitor, datadog changes `silenced` property of the monitor to match the `end` POSIX timestamp. **Note:** this will effectively change the `silenced` attribute of the referenced monitor. If that monitor is also tracked by this provider and you don't want it to be unmuted on the next `pulumi up`, see `silencing-by-hand-and-by-downtimes` in the monitor resource documentation. This option also conflicts with `monitorTags` use none or one or the other.
	MonitorId pulumi.IntPtrInput
	// A list of monitor tags to match. The resulting downtime applies to monitors that match **all** provided monitor tags. This option conflicts with `monitorId` as it will match all monitors that match these tags.
	MonitorTags pulumi.StringArrayInput
	// A dictionary to configure the downtime to be recurring.
	Recurrence DowntimeRecurrencePtrInput
	// The scope(s) to which the downtime applies, e.g. host:app2. Provide multiple scopes as a comma-separated list, e.g. env:dev,env:prod. The resulting downtime applies to sources that matches ALL provided scopes (i.e. env:dev AND env:prod), NOT any of them.
	Scopes pulumi.StringArrayInput
	// POSIX timestamp to start the downtime.
	Start pulumi.IntPtrInput
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate pulumi.StringPtrInput
	// The timezone for the downtime, default UTC. It must be a valid IANA Time Zone.
	Timezone pulumi.StringPtrInput
}

func (DowntimeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*downtimeArgs)(nil)).Elem()
}

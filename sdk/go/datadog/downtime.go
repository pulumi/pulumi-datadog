// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package datadog

import (
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

// Provides a Datadog downtime resource. This can be used to create and manage Datadog downtimes.
type Downtime struct {
	pulumi.CustomResourceState

	// A flag indicating if the downtime is active now.
	Active pulumi.BoolPtrOutput `pulumi:"active"`
	// A flag indicating if the downtime was disabled.
	Disabled pulumi.BoolPtrOutput `pulumi:"disabled"`
	// POSIX timestamp to end the downtime.
	End pulumi.IntPtrOutput `pulumi:"end"`
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate pulumi.StringPtrOutput `pulumi:"endDate"`
	// A message to include with notifications for this downtime.
	Message pulumi.StringPtrOutput `pulumi:"message"`
	// When specified, this downtime will only apply to this monitor
	MonitorId pulumi.IntPtrOutput `pulumi:"monitorId"`
	// A list of monitor tags to match. The resulting downtime applies to monitors that match **all** provided monitor tags. This option conflicts with `monitorId` as it will match all monitors that match these tags.
	MonitorTags pulumi.StringArrayOutput `pulumi:"monitorTags"`
	// A dictionary to configure the downtime to be recurring.
	Recurrence DowntimeRecurrencePtrOutput `pulumi:"recurrence"`
	// A list of items to apply the downtime to, e.g. host:X
	Scopes pulumi.StringArrayOutput `pulumi:"scopes"`
	// POSIX timestamp to start the downtime.
	Start pulumi.IntPtrOutput `pulumi:"start"`
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate pulumi.StringPtrOutput `pulumi:"startDate"`
	// The timezone for the downtime, default UTC. It must be a valid IANA Time Zone.
	Timezone pulumi.StringPtrOutput `pulumi:"timezone"`
}

// NewDowntime registers a new resource with the given unique name, arguments, and options.
func NewDowntime(ctx *pulumi.Context,
	name string, args *DowntimeArgs, opts ...pulumi.ResourceOption) (*Downtime, error) {
	if args == nil || args.Scopes == nil {
		return nil, errors.New("missing required argument 'Scopes'")
	}
	if args == nil {
		args = &DowntimeArgs{}
	}
	var resource Downtime
	err := ctx.RegisterResource("datadog:index/downtime:Downtime", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDowntime gets an existing Downtime resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDowntime(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DowntimeState, opts ...pulumi.ResourceOption) (*Downtime, error) {
	var resource Downtime
	err := ctx.ReadResource("datadog:index/downtime:Downtime", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Downtime resources.
type downtimeState struct {
	// A flag indicating if the downtime is active now.
	Active *bool `pulumi:"active"`
	// A flag indicating if the downtime was disabled.
	Disabled *bool `pulumi:"disabled"`
	// POSIX timestamp to end the downtime.
	End *int `pulumi:"end"`
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate *string `pulumi:"endDate"`
	// A message to include with notifications for this downtime.
	Message *string `pulumi:"message"`
	// When specified, this downtime will only apply to this monitor
	MonitorId *int `pulumi:"monitorId"`
	// A list of monitor tags to match. The resulting downtime applies to monitors that match **all** provided monitor tags. This option conflicts with `monitorId` as it will match all monitors that match these tags.
	MonitorTags []string `pulumi:"monitorTags"`
	// A dictionary to configure the downtime to be recurring.
	Recurrence *DowntimeRecurrence `pulumi:"recurrence"`
	// A list of items to apply the downtime to, e.g. host:X
	Scopes []string `pulumi:"scopes"`
	// POSIX timestamp to start the downtime.
	Start *int `pulumi:"start"`
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate *string `pulumi:"startDate"`
	// The timezone for the downtime, default UTC. It must be a valid IANA Time Zone.
	Timezone *string `pulumi:"timezone"`
}

type DowntimeState struct {
	// A flag indicating if the downtime is active now.
	Active pulumi.BoolPtrInput
	// A flag indicating if the downtime was disabled.
	Disabled pulumi.BoolPtrInput
	// POSIX timestamp to end the downtime.
	End pulumi.IntPtrInput
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate pulumi.StringPtrInput
	// A message to include with notifications for this downtime.
	Message pulumi.StringPtrInput
	// When specified, this downtime will only apply to this monitor
	MonitorId pulumi.IntPtrInput
	// A list of monitor tags to match. The resulting downtime applies to monitors that match **all** provided monitor tags. This option conflicts with `monitorId` as it will match all monitors that match these tags.
	MonitorTags pulumi.StringArrayInput
	// A dictionary to configure the downtime to be recurring.
	Recurrence DowntimeRecurrencePtrInput
	// A list of items to apply the downtime to, e.g. host:X
	Scopes pulumi.StringArrayInput
	// POSIX timestamp to start the downtime.
	Start pulumi.IntPtrInput
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate pulumi.StringPtrInput
	// The timezone for the downtime, default UTC. It must be a valid IANA Time Zone.
	Timezone pulumi.StringPtrInput
}

func (DowntimeState) ElementType() reflect.Type {
	return reflect.TypeOf((*downtimeState)(nil)).Elem()
}

type downtimeArgs struct {
	// A flag indicating if the downtime is active now.
	Active *bool `pulumi:"active"`
	// A flag indicating if the downtime was disabled.
	Disabled *bool `pulumi:"disabled"`
	// POSIX timestamp to end the downtime.
	End *int `pulumi:"end"`
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate *string `pulumi:"endDate"`
	// A message to include with notifications for this downtime.
	Message *string `pulumi:"message"`
	// When specified, this downtime will only apply to this monitor
	MonitorId *int `pulumi:"monitorId"`
	// A list of monitor tags to match. The resulting downtime applies to monitors that match **all** provided monitor tags. This option conflicts with `monitorId` as it will match all monitors that match these tags.
	MonitorTags []string `pulumi:"monitorTags"`
	// A dictionary to configure the downtime to be recurring.
	Recurrence *DowntimeRecurrence `pulumi:"recurrence"`
	// A list of items to apply the downtime to, e.g. host:X
	Scopes []string `pulumi:"scopes"`
	// POSIX timestamp to start the downtime.
	Start *int `pulumi:"start"`
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate *string `pulumi:"startDate"`
	// The timezone for the downtime, default UTC. It must be a valid IANA Time Zone.
	Timezone *string `pulumi:"timezone"`
}

// The set of arguments for constructing a Downtime resource.
type DowntimeArgs struct {
	// A flag indicating if the downtime is active now.
	Active pulumi.BoolPtrInput
	// A flag indicating if the downtime was disabled.
	Disabled pulumi.BoolPtrInput
	// POSIX timestamp to end the downtime.
	End pulumi.IntPtrInput
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate pulumi.StringPtrInput
	// A message to include with notifications for this downtime.
	Message pulumi.StringPtrInput
	// When specified, this downtime will only apply to this monitor
	MonitorId pulumi.IntPtrInput
	// A list of monitor tags to match. The resulting downtime applies to monitors that match **all** provided monitor tags. This option conflicts with `monitorId` as it will match all monitors that match these tags.
	MonitorTags pulumi.StringArrayInput
	// A dictionary to configure the downtime to be recurring.
	Recurrence DowntimeRecurrencePtrInput
	// A list of items to apply the downtime to, e.g. host:X
	Scopes pulumi.StringArrayInput
	// POSIX timestamp to start the downtime.
	Start pulumi.IntPtrInput
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate pulumi.StringPtrInput
	// The timezone for the downtime, default UTC. It must be a valid IANA Time Zone.
	Timezone pulumi.StringPtrInput
}

func (DowntimeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*downtimeArgs)(nil)).Elem()
}

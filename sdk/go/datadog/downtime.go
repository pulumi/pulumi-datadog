// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package datadog

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// This resource is deprecated â€” use the `DowntimeSchedule resource` instead. Provides a Datadog downtime resource. This can be used to create and manage Datadog downtimes.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := datadog.NewDowntime(ctx, "foo", &datadog.DowntimeArgs{
//				End: pulumi.Int(1483365600),
//				Recurrence: &datadog.DowntimeRecurrenceArgs{
//					Period: pulumi.Int(1),
//					Type:   pulumi.String("days"),
//				},
//				Scopes: pulumi.StringArray{
//					pulumi.String("*"),
//				},
//				Start: pulumi.Int(1483308000),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// ```sh
//
//	$ pulumi import datadog:index/downtime:Downtime bytes_received_localhost 2081
//
// ```
type Downtime struct {
	pulumi.CustomResourceState

	// When true indicates this downtime is being actively applied
	Active pulumi.BoolOutput `pulumi:"active"`
	// The id corresponding to the downtime object definition of the active child for the original parent recurring downtime. This field will only exist on recurring downtimes.
	ActiveChildId pulumi.IntOutput `pulumi:"activeChildId"`
	// When true indicates this downtime is not being applied
	Disabled pulumi.BoolOutput `pulumi:"disabled"`
	// Optionally specify an end date when this downtime should expire. Accepts a Unix timestamp in UTC.
	End pulumi.IntPtrOutput `pulumi:"end"`
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate pulumi.StringPtrOutput `pulumi:"endDate"`
	// An optional message to provide when creating the downtime, can include notification handles
	Message pulumi.StringPtrOutput `pulumi:"message"`
	// When specified, this downtime will only apply to this monitor
	MonitorId pulumi.IntPtrOutput `pulumi:"monitorId"`
	// A list of monitor tags (up to 32) to base the scheduled downtime on. Only monitors that have all selected tags are silenced
	MonitorTags pulumi.StringArrayOutput `pulumi:"monitorTags"`
	// When true the first recovery notification during the downtime will be muted
	MuteFirstRecoveryNotification pulumi.BoolPtrOutput `pulumi:"muteFirstRecoveryNotification"`
	// Optional recurring schedule for this downtime
	Recurrence DowntimeRecurrencePtrOutput `pulumi:"recurrence"`
	// specify the group scope to which this downtime applies. For everything use '*'
	Scopes pulumi.StringArrayOutput `pulumi:"scopes"`
	// Specify when this downtime should start. Accepts a Unix timestamp in UTC.
	Start pulumi.IntPtrOutput `pulumi:"start"`
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate pulumi.StringPtrOutput `pulumi:"startDate"`
	// The timezone for the downtime, default UTC. Follows IANA timezone database identifiers.
	Timezone pulumi.StringPtrOutput `pulumi:"timezone"`
}

// NewDowntime registers a new resource with the given unique name, arguments, and options.
func NewDowntime(ctx *pulumi.Context,
	name string, args *DowntimeArgs, opts ...pulumi.ResourceOption) (*Downtime, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Scopes == nil {
		return nil, errors.New("invalid value for required argument 'Scopes'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Downtime
	err := ctx.RegisterResource("datadog:index/downtime:Downtime", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDowntime gets an existing Downtime resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDowntime(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DowntimeState, opts ...pulumi.ResourceOption) (*Downtime, error) {
	var resource Downtime
	err := ctx.ReadResource("datadog:index/downtime:Downtime", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Downtime resources.
type downtimeState struct {
	// When true indicates this downtime is being actively applied
	Active *bool `pulumi:"active"`
	// The id corresponding to the downtime object definition of the active child for the original parent recurring downtime. This field will only exist on recurring downtimes.
	ActiveChildId *int `pulumi:"activeChildId"`
	// When true indicates this downtime is not being applied
	Disabled *bool `pulumi:"disabled"`
	// Optionally specify an end date when this downtime should expire. Accepts a Unix timestamp in UTC.
	End *int `pulumi:"end"`
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate *string `pulumi:"endDate"`
	// An optional message to provide when creating the downtime, can include notification handles
	Message *string `pulumi:"message"`
	// When specified, this downtime will only apply to this monitor
	MonitorId *int `pulumi:"monitorId"`
	// A list of monitor tags (up to 32) to base the scheduled downtime on. Only monitors that have all selected tags are silenced
	MonitorTags []string `pulumi:"monitorTags"`
	// When true the first recovery notification during the downtime will be muted
	MuteFirstRecoveryNotification *bool `pulumi:"muteFirstRecoveryNotification"`
	// Optional recurring schedule for this downtime
	Recurrence *DowntimeRecurrence `pulumi:"recurrence"`
	// specify the group scope to which this downtime applies. For everything use '*'
	Scopes []string `pulumi:"scopes"`
	// Specify when this downtime should start. Accepts a Unix timestamp in UTC.
	Start *int `pulumi:"start"`
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate *string `pulumi:"startDate"`
	// The timezone for the downtime, default UTC. Follows IANA timezone database identifiers.
	Timezone *string `pulumi:"timezone"`
}

type DowntimeState struct {
	// When true indicates this downtime is being actively applied
	Active pulumi.BoolPtrInput
	// The id corresponding to the downtime object definition of the active child for the original parent recurring downtime. This field will only exist on recurring downtimes.
	ActiveChildId pulumi.IntPtrInput
	// When true indicates this downtime is not being applied
	Disabled pulumi.BoolPtrInput
	// Optionally specify an end date when this downtime should expire. Accepts a Unix timestamp in UTC.
	End pulumi.IntPtrInput
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate pulumi.StringPtrInput
	// An optional message to provide when creating the downtime, can include notification handles
	Message pulumi.StringPtrInput
	// When specified, this downtime will only apply to this monitor
	MonitorId pulumi.IntPtrInput
	// A list of monitor tags (up to 32) to base the scheduled downtime on. Only monitors that have all selected tags are silenced
	MonitorTags pulumi.StringArrayInput
	// When true the first recovery notification during the downtime will be muted
	MuteFirstRecoveryNotification pulumi.BoolPtrInput
	// Optional recurring schedule for this downtime
	Recurrence DowntimeRecurrencePtrInput
	// specify the group scope to which this downtime applies. For everything use '*'
	Scopes pulumi.StringArrayInput
	// Specify when this downtime should start. Accepts a Unix timestamp in UTC.
	Start pulumi.IntPtrInput
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate pulumi.StringPtrInput
	// The timezone for the downtime, default UTC. Follows IANA timezone database identifiers.
	Timezone pulumi.StringPtrInput
}

func (DowntimeState) ElementType() reflect.Type {
	return reflect.TypeOf((*downtimeState)(nil)).Elem()
}

type downtimeArgs struct {
	// Optionally specify an end date when this downtime should expire. Accepts a Unix timestamp in UTC.
	End *int `pulumi:"end"`
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate *string `pulumi:"endDate"`
	// An optional message to provide when creating the downtime, can include notification handles
	Message *string `pulumi:"message"`
	// When specified, this downtime will only apply to this monitor
	MonitorId *int `pulumi:"monitorId"`
	// A list of monitor tags (up to 32) to base the scheduled downtime on. Only monitors that have all selected tags are silenced
	MonitorTags []string `pulumi:"monitorTags"`
	// When true the first recovery notification during the downtime will be muted
	MuteFirstRecoveryNotification *bool `pulumi:"muteFirstRecoveryNotification"`
	// Optional recurring schedule for this downtime
	Recurrence *DowntimeRecurrence `pulumi:"recurrence"`
	// specify the group scope to which this downtime applies. For everything use '*'
	Scopes []string `pulumi:"scopes"`
	// Specify when this downtime should start. Accepts a Unix timestamp in UTC.
	Start *int `pulumi:"start"`
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate *string `pulumi:"startDate"`
	// The timezone for the downtime, default UTC. Follows IANA timezone database identifiers.
	Timezone *string `pulumi:"timezone"`
}

// The set of arguments for constructing a Downtime resource.
type DowntimeArgs struct {
	// Optionally specify an end date when this downtime should expire. Accepts a Unix timestamp in UTC.
	End pulumi.IntPtrInput
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate pulumi.StringPtrInput
	// An optional message to provide when creating the downtime, can include notification handles
	Message pulumi.StringPtrInput
	// When specified, this downtime will only apply to this monitor
	MonitorId pulumi.IntPtrInput
	// A list of monitor tags (up to 32) to base the scheduled downtime on. Only monitors that have all selected tags are silenced
	MonitorTags pulumi.StringArrayInput
	// When true the first recovery notification during the downtime will be muted
	MuteFirstRecoveryNotification pulumi.BoolPtrInput
	// Optional recurring schedule for this downtime
	Recurrence DowntimeRecurrencePtrInput
	// specify the group scope to which this downtime applies. For everything use '*'
	Scopes pulumi.StringArrayInput
	// Specify when this downtime should start. Accepts a Unix timestamp in UTC.
	Start pulumi.IntPtrInput
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate pulumi.StringPtrInput
	// The timezone for the downtime, default UTC. Follows IANA timezone database identifiers.
	Timezone pulumi.StringPtrInput
}

func (DowntimeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*downtimeArgs)(nil)).Elem()
}

type DowntimeInput interface {
	pulumi.Input

	ToDowntimeOutput() DowntimeOutput
	ToDowntimeOutputWithContext(ctx context.Context) DowntimeOutput
}

func (*Downtime) ElementType() reflect.Type {
	return reflect.TypeOf((**Downtime)(nil)).Elem()
}

func (i *Downtime) ToDowntimeOutput() DowntimeOutput {
	return i.ToDowntimeOutputWithContext(context.Background())
}

func (i *Downtime) ToDowntimeOutputWithContext(ctx context.Context) DowntimeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DowntimeOutput)
}

func (i *Downtime) ToOutput(ctx context.Context) pulumix.Output[*Downtime] {
	return pulumix.Output[*Downtime]{
		OutputState: i.ToDowntimeOutputWithContext(ctx).OutputState,
	}
}

// DowntimeArrayInput is an input type that accepts DowntimeArray and DowntimeArrayOutput values.
// You can construct a concrete instance of `DowntimeArrayInput` via:
//
//	DowntimeArray{ DowntimeArgs{...} }
type DowntimeArrayInput interface {
	pulumi.Input

	ToDowntimeArrayOutput() DowntimeArrayOutput
	ToDowntimeArrayOutputWithContext(context.Context) DowntimeArrayOutput
}

type DowntimeArray []DowntimeInput

func (DowntimeArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Downtime)(nil)).Elem()
}

func (i DowntimeArray) ToDowntimeArrayOutput() DowntimeArrayOutput {
	return i.ToDowntimeArrayOutputWithContext(context.Background())
}

func (i DowntimeArray) ToDowntimeArrayOutputWithContext(ctx context.Context) DowntimeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DowntimeArrayOutput)
}

func (i DowntimeArray) ToOutput(ctx context.Context) pulumix.Output[[]*Downtime] {
	return pulumix.Output[[]*Downtime]{
		OutputState: i.ToDowntimeArrayOutputWithContext(ctx).OutputState,
	}
}

// DowntimeMapInput is an input type that accepts DowntimeMap and DowntimeMapOutput values.
// You can construct a concrete instance of `DowntimeMapInput` via:
//
//	DowntimeMap{ "key": DowntimeArgs{...} }
type DowntimeMapInput interface {
	pulumi.Input

	ToDowntimeMapOutput() DowntimeMapOutput
	ToDowntimeMapOutputWithContext(context.Context) DowntimeMapOutput
}

type DowntimeMap map[string]DowntimeInput

func (DowntimeMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Downtime)(nil)).Elem()
}

func (i DowntimeMap) ToDowntimeMapOutput() DowntimeMapOutput {
	return i.ToDowntimeMapOutputWithContext(context.Background())
}

func (i DowntimeMap) ToDowntimeMapOutputWithContext(ctx context.Context) DowntimeMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DowntimeMapOutput)
}

func (i DowntimeMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*Downtime] {
	return pulumix.Output[map[string]*Downtime]{
		OutputState: i.ToDowntimeMapOutputWithContext(ctx).OutputState,
	}
}

type DowntimeOutput struct{ *pulumi.OutputState }

func (DowntimeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Downtime)(nil)).Elem()
}

func (o DowntimeOutput) ToDowntimeOutput() DowntimeOutput {
	return o
}

func (o DowntimeOutput) ToDowntimeOutputWithContext(ctx context.Context) DowntimeOutput {
	return o
}

func (o DowntimeOutput) ToOutput(ctx context.Context) pulumix.Output[*Downtime] {
	return pulumix.Output[*Downtime]{
		OutputState: o.OutputState,
	}
}

// When true indicates this downtime is being actively applied
func (o DowntimeOutput) Active() pulumi.BoolOutput {
	return o.ApplyT(func(v *Downtime) pulumi.BoolOutput { return v.Active }).(pulumi.BoolOutput)
}

// The id corresponding to the downtime object definition of the active child for the original parent recurring downtime. This field will only exist on recurring downtimes.
func (o DowntimeOutput) ActiveChildId() pulumi.IntOutput {
	return o.ApplyT(func(v *Downtime) pulumi.IntOutput { return v.ActiveChildId }).(pulumi.IntOutput)
}

// When true indicates this downtime is not being applied
func (o DowntimeOutput) Disabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *Downtime) pulumi.BoolOutput { return v.Disabled }).(pulumi.BoolOutput)
}

// Optionally specify an end date when this downtime should expire. Accepts a Unix timestamp in UTC.
func (o DowntimeOutput) End() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Downtime) pulumi.IntPtrOutput { return v.End }).(pulumi.IntPtrOutput)
}

// String representing date and time to end the downtime in RFC3339 format.
func (o DowntimeOutput) EndDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Downtime) pulumi.StringPtrOutput { return v.EndDate }).(pulumi.StringPtrOutput)
}

// An optional message to provide when creating the downtime, can include notification handles
func (o DowntimeOutput) Message() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Downtime) pulumi.StringPtrOutput { return v.Message }).(pulumi.StringPtrOutput)
}

// When specified, this downtime will only apply to this monitor
func (o DowntimeOutput) MonitorId() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Downtime) pulumi.IntPtrOutput { return v.MonitorId }).(pulumi.IntPtrOutput)
}

// A list of monitor tags (up to 32) to base the scheduled downtime on. Only monitors that have all selected tags are silenced
func (o DowntimeOutput) MonitorTags() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Downtime) pulumi.StringArrayOutput { return v.MonitorTags }).(pulumi.StringArrayOutput)
}

// When true the first recovery notification during the downtime will be muted
func (o DowntimeOutput) MuteFirstRecoveryNotification() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Downtime) pulumi.BoolPtrOutput { return v.MuteFirstRecoveryNotification }).(pulumi.BoolPtrOutput)
}

// Optional recurring schedule for this downtime
func (o DowntimeOutput) Recurrence() DowntimeRecurrencePtrOutput {
	return o.ApplyT(func(v *Downtime) DowntimeRecurrencePtrOutput { return v.Recurrence }).(DowntimeRecurrencePtrOutput)
}

// specify the group scope to which this downtime applies. For everything use '*'
func (o DowntimeOutput) Scopes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *Downtime) pulumi.StringArrayOutput { return v.Scopes }).(pulumi.StringArrayOutput)
}

// Specify when this downtime should start. Accepts a Unix timestamp in UTC.
func (o DowntimeOutput) Start() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *Downtime) pulumi.IntPtrOutput { return v.Start }).(pulumi.IntPtrOutput)
}

// String representing date and time to start the downtime in RFC3339 format.
func (o DowntimeOutput) StartDate() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Downtime) pulumi.StringPtrOutput { return v.StartDate }).(pulumi.StringPtrOutput)
}

// The timezone for the downtime, default UTC. Follows IANA timezone database identifiers.
func (o DowntimeOutput) Timezone() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Downtime) pulumi.StringPtrOutput { return v.Timezone }).(pulumi.StringPtrOutput)
}

type DowntimeArrayOutput struct{ *pulumi.OutputState }

func (DowntimeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Downtime)(nil)).Elem()
}

func (o DowntimeArrayOutput) ToDowntimeArrayOutput() DowntimeArrayOutput {
	return o
}

func (o DowntimeArrayOutput) ToDowntimeArrayOutputWithContext(ctx context.Context) DowntimeArrayOutput {
	return o
}

func (o DowntimeArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*Downtime] {
	return pulumix.Output[[]*Downtime]{
		OutputState: o.OutputState,
	}
}

func (o DowntimeArrayOutput) Index(i pulumi.IntInput) DowntimeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Downtime {
		return vs[0].([]*Downtime)[vs[1].(int)]
	}).(DowntimeOutput)
}

type DowntimeMapOutput struct{ *pulumi.OutputState }

func (DowntimeMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Downtime)(nil)).Elem()
}

func (o DowntimeMapOutput) ToDowntimeMapOutput() DowntimeMapOutput {
	return o
}

func (o DowntimeMapOutput) ToDowntimeMapOutputWithContext(ctx context.Context) DowntimeMapOutput {
	return o
}

func (o DowntimeMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*Downtime] {
	return pulumix.Output[map[string]*Downtime]{
		OutputState: o.OutputState,
	}
}

func (o DowntimeMapOutput) MapIndex(k pulumi.StringInput) DowntimeOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Downtime {
		return vs[0].(map[string]*Downtime)[vs[1].(string)]
	}).(DowntimeOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DowntimeInput)(nil)).Elem(), &Downtime{})
	pulumi.RegisterInputType(reflect.TypeOf((*DowntimeArrayInput)(nil)).Elem(), DowntimeArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DowntimeMapInput)(nil)).Elem(), DowntimeMap{})
	pulumi.RegisterOutputType(DowntimeOutput{})
	pulumi.RegisterOutputType(DowntimeArrayOutput{})
	pulumi.RegisterOutputType(DowntimeMapOutput{})
}

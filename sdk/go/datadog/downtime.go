// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package datadog

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Datadog downtime resource. This can be used to create and manage Datadog downtimes.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-datadog/sdk/v3/go/datadog"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := datadog.NewDowntime(ctx, "foo", &datadog.DowntimeArgs{
// 			End: pulumi.Int(1483365600),
// 			Recurrence: &datadog.DowntimeRecurrenceArgs{
// 				Period: pulumi.Int(1),
// 				Type:   pulumi.String("days"),
// 			},
// 			Scopes: pulumi.StringArray{
// 				pulumi.String("*"),
// 			},
// 			Start: pulumi.Int(1483308000),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// <!-- schema generated by tfplugindocs -->
// ## Schema
//
// ### Required
//
// - **scope** (List of String) specify the group scope to which this downtime applies. For everything use '*'
//
// ### Optional
//
// - **end** (Number) Optionally specify an end date when this downtime should expire
// - **end_date** (String) String representing date and time to end the downtime in RFC3339 format.
// - **message** (String) An optional message to provide when creating the downtime, can include notification handles
// - **monitor_id** (Number) When specified, this downtime will only apply to this monitor
// - **monitor_tags** (Set of String) A list of monitor tags (up to 25), i.e. tags that are applied directly to monitors to which the downtime applies
// - **recurrence** (Block List, Max: 1) Optional recurring schedule for this downtime (see below for nested schema)
// - **start** (Number) Specify when this downtime should start
// - **start_date** (String) String representing date and time to start the downtime in RFC3339 format.
// - **timezone** (String) The timezone for the downtime, default UTC
//
// ### Read-Only
//
// - **active** (Boolean) When true indicates this downtime is being actively applied
// - **disabled** (Boolean) When true indicates this downtime is not being applied
// - **id** (String) The ID of this resource.
//
// <a id="nestedblock--recurrence"></a>
//
// ## Import
//
// Import is supported using the following syntax
//
// ```sh
//  $ pulumi import datadog:index/downtime:Downtime bytes_received_localhost 2081
// ```
type Downtime struct {
	pulumi.CustomResourceState

	// When true indicates this downtime is being actively applied
	Active pulumi.BoolOutput `pulumi:"active"`
	// When true indicates this downtime is not being applied
	Disabled pulumi.BoolOutput `pulumi:"disabled"`
	// Optionally specify an end date when this downtime should expire
	End pulumi.IntPtrOutput `pulumi:"end"`
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate pulumi.StringPtrOutput `pulumi:"endDate"`
	// An optional message to provide when creating the downtime, can include notification handles
	Message pulumi.StringPtrOutput `pulumi:"message"`
	// When specified, this downtime will only apply to this monitor
	MonitorId pulumi.IntPtrOutput `pulumi:"monitorId"`
	// A list of monitor tags (up to 25), i.e. tags that are applied directly to monitors to which the downtime applies
	MonitorTags pulumi.StringArrayOutput `pulumi:"monitorTags"`
	// Optional recurring schedule for this downtime
	Recurrence DowntimeRecurrencePtrOutput `pulumi:"recurrence"`
	// specify the group scope to which this downtime applies. For everything use '*'
	Scopes pulumi.StringArrayOutput `pulumi:"scopes"`
	// Specify when this downtime should start
	Start pulumi.IntPtrOutput `pulumi:"start"`
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate pulumi.StringPtrOutput `pulumi:"startDate"`
	// The timezone for the downtime, default UTC
	Timezone pulumi.StringPtrOutput `pulumi:"timezone"`
}

// NewDowntime registers a new resource with the given unique name, arguments, and options.
func NewDowntime(ctx *pulumi.Context,
	name string, args *DowntimeArgs, opts ...pulumi.ResourceOption) (*Downtime, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Scopes == nil {
		return nil, errors.New("invalid value for required argument 'Scopes'")
	}
	var resource Downtime
	err := ctx.RegisterResource("datadog:index/downtime:Downtime", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDowntime gets an existing Downtime resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDowntime(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DowntimeState, opts ...pulumi.ResourceOption) (*Downtime, error) {
	var resource Downtime
	err := ctx.ReadResource("datadog:index/downtime:Downtime", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Downtime resources.
type downtimeState struct {
	// When true indicates this downtime is being actively applied
	Active *bool `pulumi:"active"`
	// When true indicates this downtime is not being applied
	Disabled *bool `pulumi:"disabled"`
	// Optionally specify an end date when this downtime should expire
	End *int `pulumi:"end"`
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate *string `pulumi:"endDate"`
	// An optional message to provide when creating the downtime, can include notification handles
	Message *string `pulumi:"message"`
	// When specified, this downtime will only apply to this monitor
	MonitorId *int `pulumi:"monitorId"`
	// A list of monitor tags (up to 25), i.e. tags that are applied directly to monitors to which the downtime applies
	MonitorTags []string `pulumi:"monitorTags"`
	// Optional recurring schedule for this downtime
	Recurrence *DowntimeRecurrence `pulumi:"recurrence"`
	// specify the group scope to which this downtime applies. For everything use '*'
	Scopes []string `pulumi:"scopes"`
	// Specify when this downtime should start
	Start *int `pulumi:"start"`
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate *string `pulumi:"startDate"`
	// The timezone for the downtime, default UTC
	Timezone *string `pulumi:"timezone"`
}

type DowntimeState struct {
	// When true indicates this downtime is being actively applied
	Active pulumi.BoolPtrInput
	// When true indicates this downtime is not being applied
	Disabled pulumi.BoolPtrInput
	// Optionally specify an end date when this downtime should expire
	End pulumi.IntPtrInput
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate pulumi.StringPtrInput
	// An optional message to provide when creating the downtime, can include notification handles
	Message pulumi.StringPtrInput
	// When specified, this downtime will only apply to this monitor
	MonitorId pulumi.IntPtrInput
	// A list of monitor tags (up to 25), i.e. tags that are applied directly to monitors to which the downtime applies
	MonitorTags pulumi.StringArrayInput
	// Optional recurring schedule for this downtime
	Recurrence DowntimeRecurrencePtrInput
	// specify the group scope to which this downtime applies. For everything use '*'
	Scopes pulumi.StringArrayInput
	// Specify when this downtime should start
	Start pulumi.IntPtrInput
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate pulumi.StringPtrInput
	// The timezone for the downtime, default UTC
	Timezone pulumi.StringPtrInput
}

func (DowntimeState) ElementType() reflect.Type {
	return reflect.TypeOf((*downtimeState)(nil)).Elem()
}

type downtimeArgs struct {
	// Optionally specify an end date when this downtime should expire
	End *int `pulumi:"end"`
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate *string `pulumi:"endDate"`
	// An optional message to provide when creating the downtime, can include notification handles
	Message *string `pulumi:"message"`
	// When specified, this downtime will only apply to this monitor
	MonitorId *int `pulumi:"monitorId"`
	// A list of monitor tags (up to 25), i.e. tags that are applied directly to monitors to which the downtime applies
	MonitorTags []string `pulumi:"monitorTags"`
	// Optional recurring schedule for this downtime
	Recurrence *DowntimeRecurrence `pulumi:"recurrence"`
	// specify the group scope to which this downtime applies. For everything use '*'
	Scopes []string `pulumi:"scopes"`
	// Specify when this downtime should start
	Start *int `pulumi:"start"`
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate *string `pulumi:"startDate"`
	// The timezone for the downtime, default UTC
	Timezone *string `pulumi:"timezone"`
}

// The set of arguments for constructing a Downtime resource.
type DowntimeArgs struct {
	// Optionally specify an end date when this downtime should expire
	End pulumi.IntPtrInput
	// String representing date and time to end the downtime in RFC3339 format.
	EndDate pulumi.StringPtrInput
	// An optional message to provide when creating the downtime, can include notification handles
	Message pulumi.StringPtrInput
	// When specified, this downtime will only apply to this monitor
	MonitorId pulumi.IntPtrInput
	// A list of monitor tags (up to 25), i.e. tags that are applied directly to monitors to which the downtime applies
	MonitorTags pulumi.StringArrayInput
	// Optional recurring schedule for this downtime
	Recurrence DowntimeRecurrencePtrInput
	// specify the group scope to which this downtime applies. For everything use '*'
	Scopes pulumi.StringArrayInput
	// Specify when this downtime should start
	Start pulumi.IntPtrInput
	// String representing date and time to start the downtime in RFC3339 format.
	StartDate pulumi.StringPtrInput
	// The timezone for the downtime, default UTC
	Timezone pulumi.StringPtrInput
}

func (DowntimeArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*downtimeArgs)(nil)).Elem()
}

type DowntimeInput interface {
	pulumi.Input

	ToDowntimeOutput() DowntimeOutput
	ToDowntimeOutputWithContext(ctx context.Context) DowntimeOutput
}

func (*Downtime) ElementType() reflect.Type {
	return reflect.TypeOf((*Downtime)(nil))
}

func (i *Downtime) ToDowntimeOutput() DowntimeOutput {
	return i.ToDowntimeOutputWithContext(context.Background())
}

func (i *Downtime) ToDowntimeOutputWithContext(ctx context.Context) DowntimeOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DowntimeOutput)
}

func (i *Downtime) ToDowntimePtrOutput() DowntimePtrOutput {
	return i.ToDowntimePtrOutputWithContext(context.Background())
}

func (i *Downtime) ToDowntimePtrOutputWithContext(ctx context.Context) DowntimePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DowntimePtrOutput)
}

type DowntimePtrInput interface {
	pulumi.Input

	ToDowntimePtrOutput() DowntimePtrOutput
	ToDowntimePtrOutputWithContext(ctx context.Context) DowntimePtrOutput
}

type downtimePtrType DowntimeArgs

func (*downtimePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Downtime)(nil))
}

func (i *downtimePtrType) ToDowntimePtrOutput() DowntimePtrOutput {
	return i.ToDowntimePtrOutputWithContext(context.Background())
}

func (i *downtimePtrType) ToDowntimePtrOutputWithContext(ctx context.Context) DowntimePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DowntimePtrOutput)
}

// DowntimeArrayInput is an input type that accepts DowntimeArray and DowntimeArrayOutput values.
// You can construct a concrete instance of `DowntimeArrayInput` via:
//
//          DowntimeArray{ DowntimeArgs{...} }
type DowntimeArrayInput interface {
	pulumi.Input

	ToDowntimeArrayOutput() DowntimeArrayOutput
	ToDowntimeArrayOutputWithContext(context.Context) DowntimeArrayOutput
}

type DowntimeArray []DowntimeInput

func (DowntimeArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*Downtime)(nil))
}

func (i DowntimeArray) ToDowntimeArrayOutput() DowntimeArrayOutput {
	return i.ToDowntimeArrayOutputWithContext(context.Background())
}

func (i DowntimeArray) ToDowntimeArrayOutputWithContext(ctx context.Context) DowntimeArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DowntimeArrayOutput)
}

// DowntimeMapInput is an input type that accepts DowntimeMap and DowntimeMapOutput values.
// You can construct a concrete instance of `DowntimeMapInput` via:
//
//          DowntimeMap{ "key": DowntimeArgs{...} }
type DowntimeMapInput interface {
	pulumi.Input

	ToDowntimeMapOutput() DowntimeMapOutput
	ToDowntimeMapOutputWithContext(context.Context) DowntimeMapOutput
}

type DowntimeMap map[string]DowntimeInput

func (DowntimeMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*Downtime)(nil))
}

func (i DowntimeMap) ToDowntimeMapOutput() DowntimeMapOutput {
	return i.ToDowntimeMapOutputWithContext(context.Background())
}

func (i DowntimeMap) ToDowntimeMapOutputWithContext(ctx context.Context) DowntimeMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DowntimeMapOutput)
}

type DowntimeOutput struct {
	*pulumi.OutputState
}

func (DowntimeOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Downtime)(nil))
}

func (o DowntimeOutput) ToDowntimeOutput() DowntimeOutput {
	return o
}

func (o DowntimeOutput) ToDowntimeOutputWithContext(ctx context.Context) DowntimeOutput {
	return o
}

func (o DowntimeOutput) ToDowntimePtrOutput() DowntimePtrOutput {
	return o.ToDowntimePtrOutputWithContext(context.Background())
}

func (o DowntimeOutput) ToDowntimePtrOutputWithContext(ctx context.Context) DowntimePtrOutput {
	return o.ApplyT(func(v Downtime) *Downtime {
		return &v
	}).(DowntimePtrOutput)
}

type DowntimePtrOutput struct {
	*pulumi.OutputState
}

func (DowntimePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Downtime)(nil))
}

func (o DowntimePtrOutput) ToDowntimePtrOutput() DowntimePtrOutput {
	return o
}

func (o DowntimePtrOutput) ToDowntimePtrOutputWithContext(ctx context.Context) DowntimePtrOutput {
	return o
}

type DowntimeArrayOutput struct{ *pulumi.OutputState }

func (DowntimeArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Downtime)(nil))
}

func (o DowntimeArrayOutput) ToDowntimeArrayOutput() DowntimeArrayOutput {
	return o
}

func (o DowntimeArrayOutput) ToDowntimeArrayOutputWithContext(ctx context.Context) DowntimeArrayOutput {
	return o
}

func (o DowntimeArrayOutput) Index(i pulumi.IntInput) DowntimeOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Downtime {
		return vs[0].([]Downtime)[vs[1].(int)]
	}).(DowntimeOutput)
}

type DowntimeMapOutput struct{ *pulumi.OutputState }

func (DowntimeMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Downtime)(nil))
}

func (o DowntimeMapOutput) ToDowntimeMapOutput() DowntimeMapOutput {
	return o
}

func (o DowntimeMapOutput) ToDowntimeMapOutputWithContext(ctx context.Context) DowntimeMapOutput {
	return o
}

func (o DowntimeMapOutput) MapIndex(k pulumi.StringInput) DowntimeOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) Downtime {
		return vs[0].(map[string]Downtime)[vs[1].(string)]
	}).(DowntimeOutput)
}

func init() {
	pulumi.RegisterOutputType(DowntimeOutput{})
	pulumi.RegisterOutputType(DowntimePtrOutput{})
	pulumi.RegisterOutputType(DowntimeArrayOutput{})
	pulumi.RegisterOutputType(DowntimeMapOutput{})
}

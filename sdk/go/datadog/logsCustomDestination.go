// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package datadog

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Datadog Logs Custom Destination API resource, which is used to create and manage Datadog log forwarding.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-datadog/sdk/v4/go/datadog"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := datadog.NewLogsCustomDestination(ctx, "sample_destination", &datadog.LogsCustomDestinationArgs{
//				Name:    pulumi.String("sample destination"),
//				Query:   pulumi.String("service:my-service"),
//				Enabled: pulumi.Bool(true),
//				HttpDestination: &datadog.LogsCustomDestinationHttpDestinationArgs{
//					Endpoint: pulumi.String("https://example.org"),
//					BasicAuth: &datadog.LogsCustomDestinationHttpDestinationBasicAuthArgs{
//						Username: pulumi.String("my-username"),
//						Password: pulumi.String("my-password"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Custom destinations can be imported using the destination ID. Caution: auth credentials can not be imported.
//
// ```sh
// $ pulumi import datadog:index/logsCustomDestination:LogsCustomDestination sample_destination "destination-id"
// ```
type LogsCustomDestination struct {
	pulumi.CustomResourceState

	// The Elasticsearch destination.
	ElasticsearchDestination LogsCustomDestinationElasticsearchDestinationPtrOutput `pulumi:"elasticsearchDestination"`
	// Whether logs matching this custom destination should be forwarded or not.
	Enabled pulumi.BoolOutput `pulumi:"enabled"`
	// Whether tags from the forwarded logs should be forwarded or not.
	ForwardTags pulumi.BoolOutput `pulumi:"forwardTags"`
	// How the `forwardTagsRestrictionList` parameter should be interpreted.
	// 			If `ALLOW_LIST`, then only tags whose keys on the forwarded logs match the ones on the restriction list
	// 			are forwarded.
	// 			`BLOCK_LIST` works the opposite way. It does not forward the tags matching the ones on the list. Valid values are `ALLOW_LIST`, `BLOCK_LIST`.
	ForwardTagsRestrictionListType pulumi.StringOutput `pulumi:"forwardTagsRestrictionListType"`
	// List of [tag keys](https://docs.datadoghq.com/getting_started/tagging/#define-tags) to be filtered.
	// 			An empty list represents no restriction is in place and either all or no tags will be
	// 			forwarded depending on `forwardTagsRestrictionListType` parameter.
	ForwardTagsRestrictionLists pulumi.StringArrayOutput `pulumi:"forwardTagsRestrictionLists"`
	// The HTTP destination.
	HttpDestination LogsCustomDestinationHttpDestinationPtrOutput `pulumi:"httpDestination"`
	// The custom destination name.
	Name pulumi.StringOutput `pulumi:"name"`
	// The custom destination query filter. Logs matching this query are forwarded to the destination.
	Query pulumi.StringOutput `pulumi:"query"`
	// The Splunk HTTP Event Collector (HEC) destination.
	SplunkDestination LogsCustomDestinationSplunkDestinationPtrOutput `pulumi:"splunkDestination"`
}

// NewLogsCustomDestination registers a new resource with the given unique name, arguments, and options.
func NewLogsCustomDestination(ctx *pulumi.Context,
	name string, args *LogsCustomDestinationArgs, opts ...pulumi.ResourceOption) (*LogsCustomDestination, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LogsCustomDestination
	err := ctx.RegisterResource("datadog:index/logsCustomDestination:LogsCustomDestination", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLogsCustomDestination gets an existing LogsCustomDestination resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLogsCustomDestination(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LogsCustomDestinationState, opts ...pulumi.ResourceOption) (*LogsCustomDestination, error) {
	var resource LogsCustomDestination
	err := ctx.ReadResource("datadog:index/logsCustomDestination:LogsCustomDestination", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LogsCustomDestination resources.
type logsCustomDestinationState struct {
	// The Elasticsearch destination.
	ElasticsearchDestination *LogsCustomDestinationElasticsearchDestination `pulumi:"elasticsearchDestination"`
	// Whether logs matching this custom destination should be forwarded or not.
	Enabled *bool `pulumi:"enabled"`
	// Whether tags from the forwarded logs should be forwarded or not.
	ForwardTags *bool `pulumi:"forwardTags"`
	// How the `forwardTagsRestrictionList` parameter should be interpreted.
	// 			If `ALLOW_LIST`, then only tags whose keys on the forwarded logs match the ones on the restriction list
	// 			are forwarded.
	// 			`BLOCK_LIST` works the opposite way. It does not forward the tags matching the ones on the list. Valid values are `ALLOW_LIST`, `BLOCK_LIST`.
	ForwardTagsRestrictionListType *string `pulumi:"forwardTagsRestrictionListType"`
	// List of [tag keys](https://docs.datadoghq.com/getting_started/tagging/#define-tags) to be filtered.
	// 			An empty list represents no restriction is in place and either all or no tags will be
	// 			forwarded depending on `forwardTagsRestrictionListType` parameter.
	ForwardTagsRestrictionLists []string `pulumi:"forwardTagsRestrictionLists"`
	// The HTTP destination.
	HttpDestination *LogsCustomDestinationHttpDestination `pulumi:"httpDestination"`
	// The custom destination name.
	Name *string `pulumi:"name"`
	// The custom destination query filter. Logs matching this query are forwarded to the destination.
	Query *string `pulumi:"query"`
	// The Splunk HTTP Event Collector (HEC) destination.
	SplunkDestination *LogsCustomDestinationSplunkDestination `pulumi:"splunkDestination"`
}

type LogsCustomDestinationState struct {
	// The Elasticsearch destination.
	ElasticsearchDestination LogsCustomDestinationElasticsearchDestinationPtrInput
	// Whether logs matching this custom destination should be forwarded or not.
	Enabled pulumi.BoolPtrInput
	// Whether tags from the forwarded logs should be forwarded or not.
	ForwardTags pulumi.BoolPtrInput
	// How the `forwardTagsRestrictionList` parameter should be interpreted.
	// 			If `ALLOW_LIST`, then only tags whose keys on the forwarded logs match the ones on the restriction list
	// 			are forwarded.
	// 			`BLOCK_LIST` works the opposite way. It does not forward the tags matching the ones on the list. Valid values are `ALLOW_LIST`, `BLOCK_LIST`.
	ForwardTagsRestrictionListType pulumi.StringPtrInput
	// List of [tag keys](https://docs.datadoghq.com/getting_started/tagging/#define-tags) to be filtered.
	// 			An empty list represents no restriction is in place and either all or no tags will be
	// 			forwarded depending on `forwardTagsRestrictionListType` parameter.
	ForwardTagsRestrictionLists pulumi.StringArrayInput
	// The HTTP destination.
	HttpDestination LogsCustomDestinationHttpDestinationPtrInput
	// The custom destination name.
	Name pulumi.StringPtrInput
	// The custom destination query filter. Logs matching this query are forwarded to the destination.
	Query pulumi.StringPtrInput
	// The Splunk HTTP Event Collector (HEC) destination.
	SplunkDestination LogsCustomDestinationSplunkDestinationPtrInput
}

func (LogsCustomDestinationState) ElementType() reflect.Type {
	return reflect.TypeOf((*logsCustomDestinationState)(nil)).Elem()
}

type logsCustomDestinationArgs struct {
	// The Elasticsearch destination.
	ElasticsearchDestination *LogsCustomDestinationElasticsearchDestination `pulumi:"elasticsearchDestination"`
	// Whether logs matching this custom destination should be forwarded or not.
	Enabled *bool `pulumi:"enabled"`
	// Whether tags from the forwarded logs should be forwarded or not.
	ForwardTags *bool `pulumi:"forwardTags"`
	// How the `forwardTagsRestrictionList` parameter should be interpreted.
	// 			If `ALLOW_LIST`, then only tags whose keys on the forwarded logs match the ones on the restriction list
	// 			are forwarded.
	// 			`BLOCK_LIST` works the opposite way. It does not forward the tags matching the ones on the list. Valid values are `ALLOW_LIST`, `BLOCK_LIST`.
	ForwardTagsRestrictionListType *string `pulumi:"forwardTagsRestrictionListType"`
	// List of [tag keys](https://docs.datadoghq.com/getting_started/tagging/#define-tags) to be filtered.
	// 			An empty list represents no restriction is in place and either all or no tags will be
	// 			forwarded depending on `forwardTagsRestrictionListType` parameter.
	ForwardTagsRestrictionLists []string `pulumi:"forwardTagsRestrictionLists"`
	// The HTTP destination.
	HttpDestination *LogsCustomDestinationHttpDestination `pulumi:"httpDestination"`
	// The custom destination name.
	Name string `pulumi:"name"`
	// The custom destination query filter. Logs matching this query are forwarded to the destination.
	Query *string `pulumi:"query"`
	// The Splunk HTTP Event Collector (HEC) destination.
	SplunkDestination *LogsCustomDestinationSplunkDestination `pulumi:"splunkDestination"`
}

// The set of arguments for constructing a LogsCustomDestination resource.
type LogsCustomDestinationArgs struct {
	// The Elasticsearch destination.
	ElasticsearchDestination LogsCustomDestinationElasticsearchDestinationPtrInput
	// Whether logs matching this custom destination should be forwarded or not.
	Enabled pulumi.BoolPtrInput
	// Whether tags from the forwarded logs should be forwarded or not.
	ForwardTags pulumi.BoolPtrInput
	// How the `forwardTagsRestrictionList` parameter should be interpreted.
	// 			If `ALLOW_LIST`, then only tags whose keys on the forwarded logs match the ones on the restriction list
	// 			are forwarded.
	// 			`BLOCK_LIST` works the opposite way. It does not forward the tags matching the ones on the list. Valid values are `ALLOW_LIST`, `BLOCK_LIST`.
	ForwardTagsRestrictionListType pulumi.StringPtrInput
	// List of [tag keys](https://docs.datadoghq.com/getting_started/tagging/#define-tags) to be filtered.
	// 			An empty list represents no restriction is in place and either all or no tags will be
	// 			forwarded depending on `forwardTagsRestrictionListType` parameter.
	ForwardTagsRestrictionLists pulumi.StringArrayInput
	// The HTTP destination.
	HttpDestination LogsCustomDestinationHttpDestinationPtrInput
	// The custom destination name.
	Name pulumi.StringInput
	// The custom destination query filter. Logs matching this query are forwarded to the destination.
	Query pulumi.StringPtrInput
	// The Splunk HTTP Event Collector (HEC) destination.
	SplunkDestination LogsCustomDestinationSplunkDestinationPtrInput
}

func (LogsCustomDestinationArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*logsCustomDestinationArgs)(nil)).Elem()
}

type LogsCustomDestinationInput interface {
	pulumi.Input

	ToLogsCustomDestinationOutput() LogsCustomDestinationOutput
	ToLogsCustomDestinationOutputWithContext(ctx context.Context) LogsCustomDestinationOutput
}

func (*LogsCustomDestination) ElementType() reflect.Type {
	return reflect.TypeOf((**LogsCustomDestination)(nil)).Elem()
}

func (i *LogsCustomDestination) ToLogsCustomDestinationOutput() LogsCustomDestinationOutput {
	return i.ToLogsCustomDestinationOutputWithContext(context.Background())
}

func (i *LogsCustomDestination) ToLogsCustomDestinationOutputWithContext(ctx context.Context) LogsCustomDestinationOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsCustomDestinationOutput)
}

// LogsCustomDestinationArrayInput is an input type that accepts LogsCustomDestinationArray and LogsCustomDestinationArrayOutput values.
// You can construct a concrete instance of `LogsCustomDestinationArrayInput` via:
//
//	LogsCustomDestinationArray{ LogsCustomDestinationArgs{...} }
type LogsCustomDestinationArrayInput interface {
	pulumi.Input

	ToLogsCustomDestinationArrayOutput() LogsCustomDestinationArrayOutput
	ToLogsCustomDestinationArrayOutputWithContext(context.Context) LogsCustomDestinationArrayOutput
}

type LogsCustomDestinationArray []LogsCustomDestinationInput

func (LogsCustomDestinationArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogsCustomDestination)(nil)).Elem()
}

func (i LogsCustomDestinationArray) ToLogsCustomDestinationArrayOutput() LogsCustomDestinationArrayOutput {
	return i.ToLogsCustomDestinationArrayOutputWithContext(context.Background())
}

func (i LogsCustomDestinationArray) ToLogsCustomDestinationArrayOutputWithContext(ctx context.Context) LogsCustomDestinationArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsCustomDestinationArrayOutput)
}

// LogsCustomDestinationMapInput is an input type that accepts LogsCustomDestinationMap and LogsCustomDestinationMapOutput values.
// You can construct a concrete instance of `LogsCustomDestinationMapInput` via:
//
//	LogsCustomDestinationMap{ "key": LogsCustomDestinationArgs{...} }
type LogsCustomDestinationMapInput interface {
	pulumi.Input

	ToLogsCustomDestinationMapOutput() LogsCustomDestinationMapOutput
	ToLogsCustomDestinationMapOutputWithContext(context.Context) LogsCustomDestinationMapOutput
}

type LogsCustomDestinationMap map[string]LogsCustomDestinationInput

func (LogsCustomDestinationMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogsCustomDestination)(nil)).Elem()
}

func (i LogsCustomDestinationMap) ToLogsCustomDestinationMapOutput() LogsCustomDestinationMapOutput {
	return i.ToLogsCustomDestinationMapOutputWithContext(context.Background())
}

func (i LogsCustomDestinationMap) ToLogsCustomDestinationMapOutputWithContext(ctx context.Context) LogsCustomDestinationMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogsCustomDestinationMapOutput)
}

type LogsCustomDestinationOutput struct{ *pulumi.OutputState }

func (LogsCustomDestinationOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogsCustomDestination)(nil)).Elem()
}

func (o LogsCustomDestinationOutput) ToLogsCustomDestinationOutput() LogsCustomDestinationOutput {
	return o
}

func (o LogsCustomDestinationOutput) ToLogsCustomDestinationOutputWithContext(ctx context.Context) LogsCustomDestinationOutput {
	return o
}

// The Elasticsearch destination.
func (o LogsCustomDestinationOutput) ElasticsearchDestination() LogsCustomDestinationElasticsearchDestinationPtrOutput {
	return o.ApplyT(func(v *LogsCustomDestination) LogsCustomDestinationElasticsearchDestinationPtrOutput {
		return v.ElasticsearchDestination
	}).(LogsCustomDestinationElasticsearchDestinationPtrOutput)
}

// Whether logs matching this custom destination should be forwarded or not.
func (o LogsCustomDestinationOutput) Enabled() pulumi.BoolOutput {
	return o.ApplyT(func(v *LogsCustomDestination) pulumi.BoolOutput { return v.Enabled }).(pulumi.BoolOutput)
}

// Whether tags from the forwarded logs should be forwarded or not.
func (o LogsCustomDestinationOutput) ForwardTags() pulumi.BoolOutput {
	return o.ApplyT(func(v *LogsCustomDestination) pulumi.BoolOutput { return v.ForwardTags }).(pulumi.BoolOutput)
}

// How the `forwardTagsRestrictionList` parameter should be interpreted.
//
//	If `ALLOW_LIST`, then only tags whose keys on the forwarded logs match the ones on the restriction list
//	are forwarded.
//	`BLOCK_LIST` works the opposite way. It does not forward the tags matching the ones on the list. Valid values are `ALLOW_LIST`, `BLOCK_LIST`.
func (o LogsCustomDestinationOutput) ForwardTagsRestrictionListType() pulumi.StringOutput {
	return o.ApplyT(func(v *LogsCustomDestination) pulumi.StringOutput { return v.ForwardTagsRestrictionListType }).(pulumi.StringOutput)
}

// List of [tag keys](https://docs.datadoghq.com/getting_started/tagging/#define-tags) to be filtered.
//
//	An empty list represents no restriction is in place and either all or no tags will be
//	forwarded depending on `forwardTagsRestrictionListType` parameter.
func (o LogsCustomDestinationOutput) ForwardTagsRestrictionLists() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *LogsCustomDestination) pulumi.StringArrayOutput { return v.ForwardTagsRestrictionLists }).(pulumi.StringArrayOutput)
}

// The HTTP destination.
func (o LogsCustomDestinationOutput) HttpDestination() LogsCustomDestinationHttpDestinationPtrOutput {
	return o.ApplyT(func(v *LogsCustomDestination) LogsCustomDestinationHttpDestinationPtrOutput { return v.HttpDestination }).(LogsCustomDestinationHttpDestinationPtrOutput)
}

// The custom destination name.
func (o LogsCustomDestinationOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *LogsCustomDestination) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The custom destination query filter. Logs matching this query are forwarded to the destination.
func (o LogsCustomDestinationOutput) Query() pulumi.StringOutput {
	return o.ApplyT(func(v *LogsCustomDestination) pulumi.StringOutput { return v.Query }).(pulumi.StringOutput)
}

// The Splunk HTTP Event Collector (HEC) destination.
func (o LogsCustomDestinationOutput) SplunkDestination() LogsCustomDestinationSplunkDestinationPtrOutput {
	return o.ApplyT(func(v *LogsCustomDestination) LogsCustomDestinationSplunkDestinationPtrOutput {
		return v.SplunkDestination
	}).(LogsCustomDestinationSplunkDestinationPtrOutput)
}

type LogsCustomDestinationArrayOutput struct{ *pulumi.OutputState }

func (LogsCustomDestinationArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogsCustomDestination)(nil)).Elem()
}

func (o LogsCustomDestinationArrayOutput) ToLogsCustomDestinationArrayOutput() LogsCustomDestinationArrayOutput {
	return o
}

func (o LogsCustomDestinationArrayOutput) ToLogsCustomDestinationArrayOutputWithContext(ctx context.Context) LogsCustomDestinationArrayOutput {
	return o
}

func (o LogsCustomDestinationArrayOutput) Index(i pulumi.IntInput) LogsCustomDestinationOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LogsCustomDestination {
		return vs[0].([]*LogsCustomDestination)[vs[1].(int)]
	}).(LogsCustomDestinationOutput)
}

type LogsCustomDestinationMapOutput struct{ *pulumi.OutputState }

func (LogsCustomDestinationMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogsCustomDestination)(nil)).Elem()
}

func (o LogsCustomDestinationMapOutput) ToLogsCustomDestinationMapOutput() LogsCustomDestinationMapOutput {
	return o
}

func (o LogsCustomDestinationMapOutput) ToLogsCustomDestinationMapOutputWithContext(ctx context.Context) LogsCustomDestinationMapOutput {
	return o
}

func (o LogsCustomDestinationMapOutput) MapIndex(k pulumi.StringInput) LogsCustomDestinationOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LogsCustomDestination {
		return vs[0].(map[string]*LogsCustomDestination)[vs[1].(string)]
	}).(LogsCustomDestinationOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LogsCustomDestinationInput)(nil)).Elem(), &LogsCustomDestination{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogsCustomDestinationArrayInput)(nil)).Elem(), LogsCustomDestinationArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogsCustomDestinationMapInput)(nil)).Elem(), LogsCustomDestinationMap{})
	pulumi.RegisterOutputType(LogsCustomDestinationOutput{})
	pulumi.RegisterOutputType(LogsCustomDestinationArrayOutput{})
	pulumi.RegisterOutputType(LogsCustomDestinationMapOutput{})
}

// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.datadog.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.datadog.outputs.CustomAllocationRuleStrategyAllocatedBy;
import com.pulumi.datadog.outputs.CustomAllocationRuleStrategyAllocatedByFilter;
import com.pulumi.datadog.outputs.CustomAllocationRuleStrategyBasedOnCost;
import com.pulumi.datadog.outputs.CustomAllocationRuleStrategyBasedOnTimeseries;
import com.pulumi.datadog.outputs.CustomAllocationRuleStrategyEvaluateGroupedByFilter;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class CustomAllocationRuleStrategy {
    private @Nullable List<CustomAllocationRuleStrategyAllocatedBy> allocatedBies;
    private @Nullable List<CustomAllocationRuleStrategyAllocatedByFilter> allocatedByFilters;
    /**
     * @return List of tag keys used to allocate costs (e.g., `[&#34;team&#34;, &#34;project&#34;]`). Costs will be distributed across unique values of these tags.
     * 
     */
    private @Nullable List<String> allocatedByTagKeys;
    private @Nullable List<CustomAllocationRuleStrategyBasedOnCost> basedOnCosts;
    private @Nullable CustomAllocationRuleStrategyBasedOnTimeseries basedOnTimeseries;
    private @Nullable List<CustomAllocationRuleStrategyEvaluateGroupedByFilter> evaluateGroupedByFilters;
    /**
     * @return List of tag keys used to group costs before allocation. Costs are grouped by these tag values before applying the allocation strategy.
     * 
     */
    private @Nullable List<String> evaluateGroupedByTagKeys;
    /**
     * @return The granularity level for cost allocation. Valid values are `daily` or `monthly`.
     * 
     */
    private @Nullable String granularity;
    /**
     * @return The allocation method. Valid values are `even`, `proportional`, `proportionalTimeseries`, or `percent`.
     * 
     */
    private @Nullable String method;

    private CustomAllocationRuleStrategy() {}
    public List<CustomAllocationRuleStrategyAllocatedBy> allocatedBies() {
        return this.allocatedBies == null ? List.of() : this.allocatedBies;
    }
    public List<CustomAllocationRuleStrategyAllocatedByFilter> allocatedByFilters() {
        return this.allocatedByFilters == null ? List.of() : this.allocatedByFilters;
    }
    /**
     * @return List of tag keys used to allocate costs (e.g., `[&#34;team&#34;, &#34;project&#34;]`). Costs will be distributed across unique values of these tags.
     * 
     */
    public List<String> allocatedByTagKeys() {
        return this.allocatedByTagKeys == null ? List.of() : this.allocatedByTagKeys;
    }
    public List<CustomAllocationRuleStrategyBasedOnCost> basedOnCosts() {
        return this.basedOnCosts == null ? List.of() : this.basedOnCosts;
    }
    public Optional<CustomAllocationRuleStrategyBasedOnTimeseries> basedOnTimeseries() {
        return Optional.ofNullable(this.basedOnTimeseries);
    }
    public List<CustomAllocationRuleStrategyEvaluateGroupedByFilter> evaluateGroupedByFilters() {
        return this.evaluateGroupedByFilters == null ? List.of() : this.evaluateGroupedByFilters;
    }
    /**
     * @return List of tag keys used to group costs before allocation. Costs are grouped by these tag values before applying the allocation strategy.
     * 
     */
    public List<String> evaluateGroupedByTagKeys() {
        return this.evaluateGroupedByTagKeys == null ? List.of() : this.evaluateGroupedByTagKeys;
    }
    /**
     * @return The granularity level for cost allocation. Valid values are `daily` or `monthly`.
     * 
     */
    public Optional<String> granularity() {
        return Optional.ofNullable(this.granularity);
    }
    /**
     * @return The allocation method. Valid values are `even`, `proportional`, `proportionalTimeseries`, or `percent`.
     * 
     */
    public Optional<String> method() {
        return Optional.ofNullable(this.method);
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(CustomAllocationRuleStrategy defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable List<CustomAllocationRuleStrategyAllocatedBy> allocatedBies;
        private @Nullable List<CustomAllocationRuleStrategyAllocatedByFilter> allocatedByFilters;
        private @Nullable List<String> allocatedByTagKeys;
        private @Nullable List<CustomAllocationRuleStrategyBasedOnCost> basedOnCosts;
        private @Nullable CustomAllocationRuleStrategyBasedOnTimeseries basedOnTimeseries;
        private @Nullable List<CustomAllocationRuleStrategyEvaluateGroupedByFilter> evaluateGroupedByFilters;
        private @Nullable List<String> evaluateGroupedByTagKeys;
        private @Nullable String granularity;
        private @Nullable String method;
        public Builder() {}
        public Builder(CustomAllocationRuleStrategy defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.allocatedBies = defaults.allocatedBies;
    	      this.allocatedByFilters = defaults.allocatedByFilters;
    	      this.allocatedByTagKeys = defaults.allocatedByTagKeys;
    	      this.basedOnCosts = defaults.basedOnCosts;
    	      this.basedOnTimeseries = defaults.basedOnTimeseries;
    	      this.evaluateGroupedByFilters = defaults.evaluateGroupedByFilters;
    	      this.evaluateGroupedByTagKeys = defaults.evaluateGroupedByTagKeys;
    	      this.granularity = defaults.granularity;
    	      this.method = defaults.method;
        }

        @CustomType.Setter
        public Builder allocatedBies(@Nullable List<CustomAllocationRuleStrategyAllocatedBy> allocatedBies) {

            this.allocatedBies = allocatedBies;
            return this;
        }
        public Builder allocatedBies(CustomAllocationRuleStrategyAllocatedBy... allocatedBies) {
            return allocatedBies(List.of(allocatedBies));
        }
        @CustomType.Setter
        public Builder allocatedByFilters(@Nullable List<CustomAllocationRuleStrategyAllocatedByFilter> allocatedByFilters) {

            this.allocatedByFilters = allocatedByFilters;
            return this;
        }
        public Builder allocatedByFilters(CustomAllocationRuleStrategyAllocatedByFilter... allocatedByFilters) {
            return allocatedByFilters(List.of(allocatedByFilters));
        }
        @CustomType.Setter
        public Builder allocatedByTagKeys(@Nullable List<String> allocatedByTagKeys) {

            this.allocatedByTagKeys = allocatedByTagKeys;
            return this;
        }
        public Builder allocatedByTagKeys(String... allocatedByTagKeys) {
            return allocatedByTagKeys(List.of(allocatedByTagKeys));
        }
        @CustomType.Setter
        public Builder basedOnCosts(@Nullable List<CustomAllocationRuleStrategyBasedOnCost> basedOnCosts) {

            this.basedOnCosts = basedOnCosts;
            return this;
        }
        public Builder basedOnCosts(CustomAllocationRuleStrategyBasedOnCost... basedOnCosts) {
            return basedOnCosts(List.of(basedOnCosts));
        }
        @CustomType.Setter
        public Builder basedOnTimeseries(@Nullable CustomAllocationRuleStrategyBasedOnTimeseries basedOnTimeseries) {

            this.basedOnTimeseries = basedOnTimeseries;
            return this;
        }
        @CustomType.Setter
        public Builder evaluateGroupedByFilters(@Nullable List<CustomAllocationRuleStrategyEvaluateGroupedByFilter> evaluateGroupedByFilters) {

            this.evaluateGroupedByFilters = evaluateGroupedByFilters;
            return this;
        }
        public Builder evaluateGroupedByFilters(CustomAllocationRuleStrategyEvaluateGroupedByFilter... evaluateGroupedByFilters) {
            return evaluateGroupedByFilters(List.of(evaluateGroupedByFilters));
        }
        @CustomType.Setter
        public Builder evaluateGroupedByTagKeys(@Nullable List<String> evaluateGroupedByTagKeys) {

            this.evaluateGroupedByTagKeys = evaluateGroupedByTagKeys;
            return this;
        }
        public Builder evaluateGroupedByTagKeys(String... evaluateGroupedByTagKeys) {
            return evaluateGroupedByTagKeys(List.of(evaluateGroupedByTagKeys));
        }
        @CustomType.Setter
        public Builder granularity(@Nullable String granularity) {

            this.granularity = granularity;
            return this;
        }
        @CustomType.Setter
        public Builder method(@Nullable String method) {

            this.method = method;
            return this;
        }
        public CustomAllocationRuleStrategy build() {
            final var _resultValue = new CustomAllocationRuleStrategy();
            _resultValue.allocatedBies = allocatedBies;
            _resultValue.allocatedByFilters = allocatedByFilters;
            _resultValue.allocatedByTagKeys = allocatedByTagKeys;
            _resultValue.basedOnCosts = basedOnCosts;
            _resultValue.basedOnTimeseries = basedOnTimeseries;
            _resultValue.evaluateGroupedByFilters = evaluateGroupedByFilters;
            _resultValue.evaluateGroupedByTagKeys = evaluateGroupedByTagKeys;
            _resultValue.granularity = granularity;
            _resultValue.method = method;
            return _resultValue;
        }
    }
}

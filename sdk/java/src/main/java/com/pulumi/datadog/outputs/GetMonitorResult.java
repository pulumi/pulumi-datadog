// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.datadog.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.datadog.outputs.GetMonitorMonitorThreshold;
import com.pulumi.datadog.outputs.GetMonitorMonitorThresholdWindow;
import com.pulumi.datadog.outputs.GetMonitorSchedulingOption;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class GetMonitorResult {
    /**
     * @return Whether or not a list of log values which triggered the alert is included. This is only used by log monitors.
     * 
     */
    private Boolean enableLogsSample;
    /**
     * @return Whether or not a list of samples which triggered the alert is included. This is only used by CI Test and Pipeline monitors.
     * 
     */
    private Boolean enableSamples;
    /**
     * @return Message included with a re-notification for this monitor.
     * 
     */
    private String escalationMessage;
    /**
     * @return Time (in seconds) for which evaluation is delayed. This is only used by metric monitors.
     * 
     */
    private Integer evaluationDelay;
    /**
     * @return The time span after which groups with missing data are dropped from the monitor state. The minimum value is one hour, and the maximum value is 72 hours. Example values are: 60m, 1h, and 2d. This option is only available for APM Trace Analytics, Audit Trail, CI, Error Tracking, Event, Logs, and RUM monitors.
     * 
     */
    private String groupRetentionDuration;
    /**
     * @return Whether or not to trigger one alert if any source breaches a threshold.
     * 
     */
    private Boolean groupbySimpleMonitor;
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    private String id;
    /**
     * @return Whether or not notifications from the monitor automatically inserts its triggering tags into the title.
     * 
     */
    private Boolean includeTags;
    /**
     * @return Whether or not changes to the monitor are restricted to the creator or admins.
     * 
     */
    private Boolean locked;
    /**
     * @return Message included with notifications for this monitor
     * 
     */
    private String message;
    /**
     * @return A list of monitor tags to limit the search. This filters on the tags set on the monitor itself.
     * 
     */
    private @Nullable List<String> monitorTagsFilters;
    /**
     * @return Mapping containing `recovery_window` and `trigger_window` values, e.g. `last_15m`. This is only used by anomaly monitors.
     * 
     */
    private List<GetMonitorMonitorThresholdWindow> monitorThresholdWindows;
    /**
     * @return Alert thresholds of the monitor.
     * 
     */
    private List<GetMonitorMonitorThreshold> monitorThresholds;
    /**
     * @return Name of the monitor
     * 
     */
    private String name;
    /**
     * @return A monitor name to limit the search.
     * 
     */
    private @Nullable String nameFilter;
    /**
     * @return Time (in seconds) to skip evaluations for new groups.
     * 
     */
    private Integer newGroupDelay;
    /**
     * @return Time (in seconds) allowing a host to boot and applications to fully start before starting the evaluation of monitor results.
     * 
     */
    private Integer newHostDelay;
    /**
     * @return The number of minutes before the monitor notifies when data stops reporting.
     * 
     */
    private Integer noDataTimeframe;
    /**
     * @return Toggles the display of additional content sent in the monitor notification. Valid values are: `show_all`, `hide_query`, `hide_handles`, and `hide_all`.
     * 
     */
    private String notificationPresetName;
    /**
     * @return Whether or not tagged users are notified on changes to the monitor.
     * 
     */
    private Boolean notifyAudit;
    /**
     * @return Controls what granularity a monitor alerts on. Only available for monitors with groupings. For instance, a monitor grouped by `cluster`, `namespace`, and `pod` can be configured to only notify on each new `cluster` violating the alert conditions by setting `notify_by` to `[&#39;cluster&#39;]`. Tags mentioned in `notify_by` must be a subset of the grouping tags in the query. For example, a query grouped by `cluster` and `namespace` cannot notify on `region`. Setting `notify_by` to `[*]` configures the monitor to notify as a simple-alert.
     * 
     */
    private List<String> notifyBies;
    /**
     * @return Whether or not this monitor notifies when data stops reporting.
     * 
     */
    private Boolean notifyNoData;
    /**
     * @return Controls how groups or monitors are treated if an evaluation does not return any data points. The default option results in different behavior depending on the monitor query type. For monitors using `Count` queries, an empty monitor evaluation is treated as 0 and is compared to the threshold conditions. For monitors using any query type other than `Count`, for example `Gauge`, `Measure`, or `Rate`, the monitor shows the last known status. This option is only available for APM Trace Analytics, Audit Trail, CI, Error Tracking, Event, Logs, and RUM monitors. Valid values are: `show_no_data`, `show_and_notify_no_data`, `resolve`, and `default`.
     * 
     */
    private String onMissingData;
    /**
     * @return Query of the monitor.
     * 
     */
    private String query;
    /**
     * @return The number of minutes after the last notification before the monitor re-notifies on the current status.
     * 
     */
    private Integer renotifyInterval;
    /**
     * @return The number of re-notification messages that should be sent on the current status.
     * 
     */
    private Integer renotifyOccurrences;
    /**
     * @return The types of statuses for which re-notification messages should be sent. Valid values are `alert`, `warn`, `no data`.
     * 
     */
    private List<String> renotifyStatuses;
    /**
     * @return Whether or not the monitor needs a full window of data before it is evaluated.
     * 
     */
    private Boolean requireFullWindow;
    private List<String> restrictedRoles;
    /**
     * @return Configuration options for scheduling.
     * 
     */
    private List<GetMonitorSchedulingOption> schedulingOptions;
    /**
     * @return List of tags associated with the monitor.
     * 
     */
    private List<String> tags;
    /**
     * @return A list of tags to limit the search. This filters on the monitor scope.
     * 
     */
    private @Nullable List<String> tagsFilters;
    /**
     * @return Number of hours of the monitor not reporting data before it automatically resolves from a triggered state.
     * 
     */
    private Integer timeoutH;
    /**
     * @return Type of the monitor.
     * 
     */
    private String type;

    private GetMonitorResult() {}
    /**
     * @return Whether or not a list of log values which triggered the alert is included. This is only used by log monitors.
     * 
     */
    public Boolean enableLogsSample() {
        return this.enableLogsSample;
    }
    /**
     * @return Whether or not a list of samples which triggered the alert is included. This is only used by CI Test and Pipeline monitors.
     * 
     */
    public Boolean enableSamples() {
        return this.enableSamples;
    }
    /**
     * @return Message included with a re-notification for this monitor.
     * 
     */
    public String escalationMessage() {
        return this.escalationMessage;
    }
    /**
     * @return Time (in seconds) for which evaluation is delayed. This is only used by metric monitors.
     * 
     */
    public Integer evaluationDelay() {
        return this.evaluationDelay;
    }
    /**
     * @return The time span after which groups with missing data are dropped from the monitor state. The minimum value is one hour, and the maximum value is 72 hours. Example values are: 60m, 1h, and 2d. This option is only available for APM Trace Analytics, Audit Trail, CI, Error Tracking, Event, Logs, and RUM monitors.
     * 
     */
    public String groupRetentionDuration() {
        return this.groupRetentionDuration;
    }
    /**
     * @return Whether or not to trigger one alert if any source breaches a threshold.
     * 
     */
    public Boolean groupbySimpleMonitor() {
        return this.groupbySimpleMonitor;
    }
    /**
     * @return The provider-assigned unique ID for this managed resource.
     * 
     */
    public String id() {
        return this.id;
    }
    /**
     * @return Whether or not notifications from the monitor automatically inserts its triggering tags into the title.
     * 
     */
    public Boolean includeTags() {
        return this.includeTags;
    }
    /**
     * @return Whether or not changes to the monitor are restricted to the creator or admins.
     * 
     */
    public Boolean locked() {
        return this.locked;
    }
    /**
     * @return Message included with notifications for this monitor
     * 
     */
    public String message() {
        return this.message;
    }
    /**
     * @return A list of monitor tags to limit the search. This filters on the tags set on the monitor itself.
     * 
     */
    public List<String> monitorTagsFilters() {
        return this.monitorTagsFilters == null ? List.of() : this.monitorTagsFilters;
    }
    /**
     * @return Mapping containing `recovery_window` and `trigger_window` values, e.g. `last_15m`. This is only used by anomaly monitors.
     * 
     */
    public List<GetMonitorMonitorThresholdWindow> monitorThresholdWindows() {
        return this.monitorThresholdWindows;
    }
    /**
     * @return Alert thresholds of the monitor.
     * 
     */
    public List<GetMonitorMonitorThreshold> monitorThresholds() {
        return this.monitorThresholds;
    }
    /**
     * @return Name of the monitor
     * 
     */
    public String name() {
        return this.name;
    }
    /**
     * @return A monitor name to limit the search.
     * 
     */
    public Optional<String> nameFilter() {
        return Optional.ofNullable(this.nameFilter);
    }
    /**
     * @return Time (in seconds) to skip evaluations for new groups.
     * 
     */
    public Integer newGroupDelay() {
        return this.newGroupDelay;
    }
    /**
     * @return Time (in seconds) allowing a host to boot and applications to fully start before starting the evaluation of monitor results.
     * 
     */
    public Integer newHostDelay() {
        return this.newHostDelay;
    }
    /**
     * @return The number of minutes before the monitor notifies when data stops reporting.
     * 
     */
    public Integer noDataTimeframe() {
        return this.noDataTimeframe;
    }
    /**
     * @return Toggles the display of additional content sent in the monitor notification. Valid values are: `show_all`, `hide_query`, `hide_handles`, and `hide_all`.
     * 
     */
    public String notificationPresetName() {
        return this.notificationPresetName;
    }
    /**
     * @return Whether or not tagged users are notified on changes to the monitor.
     * 
     */
    public Boolean notifyAudit() {
        return this.notifyAudit;
    }
    /**
     * @return Controls what granularity a monitor alerts on. Only available for monitors with groupings. For instance, a monitor grouped by `cluster`, `namespace`, and `pod` can be configured to only notify on each new `cluster` violating the alert conditions by setting `notify_by` to `[&#39;cluster&#39;]`. Tags mentioned in `notify_by` must be a subset of the grouping tags in the query. For example, a query grouped by `cluster` and `namespace` cannot notify on `region`. Setting `notify_by` to `[*]` configures the monitor to notify as a simple-alert.
     * 
     */
    public List<String> notifyBies() {
        return this.notifyBies;
    }
    /**
     * @return Whether or not this monitor notifies when data stops reporting.
     * 
     */
    public Boolean notifyNoData() {
        return this.notifyNoData;
    }
    /**
     * @return Controls how groups or monitors are treated if an evaluation does not return any data points. The default option results in different behavior depending on the monitor query type. For monitors using `Count` queries, an empty monitor evaluation is treated as 0 and is compared to the threshold conditions. For monitors using any query type other than `Count`, for example `Gauge`, `Measure`, or `Rate`, the monitor shows the last known status. This option is only available for APM Trace Analytics, Audit Trail, CI, Error Tracking, Event, Logs, and RUM monitors. Valid values are: `show_no_data`, `show_and_notify_no_data`, `resolve`, and `default`.
     * 
     */
    public String onMissingData() {
        return this.onMissingData;
    }
    /**
     * @return Query of the monitor.
     * 
     */
    public String query() {
        return this.query;
    }
    /**
     * @return The number of minutes after the last notification before the monitor re-notifies on the current status.
     * 
     */
    public Integer renotifyInterval() {
        return this.renotifyInterval;
    }
    /**
     * @return The number of re-notification messages that should be sent on the current status.
     * 
     */
    public Integer renotifyOccurrences() {
        return this.renotifyOccurrences;
    }
    /**
     * @return The types of statuses for which re-notification messages should be sent. Valid values are `alert`, `warn`, `no data`.
     * 
     */
    public List<String> renotifyStatuses() {
        return this.renotifyStatuses;
    }
    /**
     * @return Whether or not the monitor needs a full window of data before it is evaluated.
     * 
     */
    public Boolean requireFullWindow() {
        return this.requireFullWindow;
    }
    public List<String> restrictedRoles() {
        return this.restrictedRoles;
    }
    /**
     * @return Configuration options for scheduling.
     * 
     */
    public List<GetMonitorSchedulingOption> schedulingOptions() {
        return this.schedulingOptions;
    }
    /**
     * @return List of tags associated with the monitor.
     * 
     */
    public List<String> tags() {
        return this.tags;
    }
    /**
     * @return A list of tags to limit the search. This filters on the monitor scope.
     * 
     */
    public List<String> tagsFilters() {
        return this.tagsFilters == null ? List.of() : this.tagsFilters;
    }
    /**
     * @return Number of hours of the monitor not reporting data before it automatically resolves from a triggered state.
     * 
     */
    public Integer timeoutH() {
        return this.timeoutH;
    }
    /**
     * @return Type of the monitor.
     * 
     */
    public String type() {
        return this.type;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetMonitorResult defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private Boolean enableLogsSample;
        private Boolean enableSamples;
        private String escalationMessage;
        private Integer evaluationDelay;
        private String groupRetentionDuration;
        private Boolean groupbySimpleMonitor;
        private String id;
        private Boolean includeTags;
        private Boolean locked;
        private String message;
        private @Nullable List<String> monitorTagsFilters;
        private List<GetMonitorMonitorThresholdWindow> monitorThresholdWindows;
        private List<GetMonitorMonitorThreshold> monitorThresholds;
        private String name;
        private @Nullable String nameFilter;
        private Integer newGroupDelay;
        private Integer newHostDelay;
        private Integer noDataTimeframe;
        private String notificationPresetName;
        private Boolean notifyAudit;
        private List<String> notifyBies;
        private Boolean notifyNoData;
        private String onMissingData;
        private String query;
        private Integer renotifyInterval;
        private Integer renotifyOccurrences;
        private List<String> renotifyStatuses;
        private Boolean requireFullWindow;
        private List<String> restrictedRoles;
        private List<GetMonitorSchedulingOption> schedulingOptions;
        private List<String> tags;
        private @Nullable List<String> tagsFilters;
        private Integer timeoutH;
        private String type;
        public Builder() {}
        public Builder(GetMonitorResult defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.enableLogsSample = defaults.enableLogsSample;
    	      this.enableSamples = defaults.enableSamples;
    	      this.escalationMessage = defaults.escalationMessage;
    	      this.evaluationDelay = defaults.evaluationDelay;
    	      this.groupRetentionDuration = defaults.groupRetentionDuration;
    	      this.groupbySimpleMonitor = defaults.groupbySimpleMonitor;
    	      this.id = defaults.id;
    	      this.includeTags = defaults.includeTags;
    	      this.locked = defaults.locked;
    	      this.message = defaults.message;
    	      this.monitorTagsFilters = defaults.monitorTagsFilters;
    	      this.monitorThresholdWindows = defaults.monitorThresholdWindows;
    	      this.monitorThresholds = defaults.monitorThresholds;
    	      this.name = defaults.name;
    	      this.nameFilter = defaults.nameFilter;
    	      this.newGroupDelay = defaults.newGroupDelay;
    	      this.newHostDelay = defaults.newHostDelay;
    	      this.noDataTimeframe = defaults.noDataTimeframe;
    	      this.notificationPresetName = defaults.notificationPresetName;
    	      this.notifyAudit = defaults.notifyAudit;
    	      this.notifyBies = defaults.notifyBies;
    	      this.notifyNoData = defaults.notifyNoData;
    	      this.onMissingData = defaults.onMissingData;
    	      this.query = defaults.query;
    	      this.renotifyInterval = defaults.renotifyInterval;
    	      this.renotifyOccurrences = defaults.renotifyOccurrences;
    	      this.renotifyStatuses = defaults.renotifyStatuses;
    	      this.requireFullWindow = defaults.requireFullWindow;
    	      this.restrictedRoles = defaults.restrictedRoles;
    	      this.schedulingOptions = defaults.schedulingOptions;
    	      this.tags = defaults.tags;
    	      this.tagsFilters = defaults.tagsFilters;
    	      this.timeoutH = defaults.timeoutH;
    	      this.type = defaults.type;
        }

        @CustomType.Setter
        public Builder enableLogsSample(Boolean enableLogsSample) {
            if (enableLogsSample == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "enableLogsSample");
            }
            this.enableLogsSample = enableLogsSample;
            return this;
        }
        @CustomType.Setter
        public Builder enableSamples(Boolean enableSamples) {
            if (enableSamples == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "enableSamples");
            }
            this.enableSamples = enableSamples;
            return this;
        }
        @CustomType.Setter
        public Builder escalationMessage(String escalationMessage) {
            if (escalationMessage == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "escalationMessage");
            }
            this.escalationMessage = escalationMessage;
            return this;
        }
        @CustomType.Setter
        public Builder evaluationDelay(Integer evaluationDelay) {
            if (evaluationDelay == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "evaluationDelay");
            }
            this.evaluationDelay = evaluationDelay;
            return this;
        }
        @CustomType.Setter
        public Builder groupRetentionDuration(String groupRetentionDuration) {
            if (groupRetentionDuration == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "groupRetentionDuration");
            }
            this.groupRetentionDuration = groupRetentionDuration;
            return this;
        }
        @CustomType.Setter
        public Builder groupbySimpleMonitor(Boolean groupbySimpleMonitor) {
            if (groupbySimpleMonitor == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "groupbySimpleMonitor");
            }
            this.groupbySimpleMonitor = groupbySimpleMonitor;
            return this;
        }
        @CustomType.Setter
        public Builder id(String id) {
            if (id == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "id");
            }
            this.id = id;
            return this;
        }
        @CustomType.Setter
        public Builder includeTags(Boolean includeTags) {
            if (includeTags == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "includeTags");
            }
            this.includeTags = includeTags;
            return this;
        }
        @CustomType.Setter
        public Builder locked(Boolean locked) {
            if (locked == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "locked");
            }
            this.locked = locked;
            return this;
        }
        @CustomType.Setter
        public Builder message(String message) {
            if (message == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "message");
            }
            this.message = message;
            return this;
        }
        @CustomType.Setter
        public Builder monitorTagsFilters(@Nullable List<String> monitorTagsFilters) {

            this.monitorTagsFilters = monitorTagsFilters;
            return this;
        }
        public Builder monitorTagsFilters(String... monitorTagsFilters) {
            return monitorTagsFilters(List.of(monitorTagsFilters));
        }
        @CustomType.Setter
        public Builder monitorThresholdWindows(List<GetMonitorMonitorThresholdWindow> monitorThresholdWindows) {
            if (monitorThresholdWindows == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "monitorThresholdWindows");
            }
            this.monitorThresholdWindows = monitorThresholdWindows;
            return this;
        }
        public Builder monitorThresholdWindows(GetMonitorMonitorThresholdWindow... monitorThresholdWindows) {
            return monitorThresholdWindows(List.of(monitorThresholdWindows));
        }
        @CustomType.Setter
        public Builder monitorThresholds(List<GetMonitorMonitorThreshold> monitorThresholds) {
            if (monitorThresholds == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "monitorThresholds");
            }
            this.monitorThresholds = monitorThresholds;
            return this;
        }
        public Builder monitorThresholds(GetMonitorMonitorThreshold... monitorThresholds) {
            return monitorThresholds(List.of(monitorThresholds));
        }
        @CustomType.Setter
        public Builder name(String name) {
            if (name == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "name");
            }
            this.name = name;
            return this;
        }
        @CustomType.Setter
        public Builder nameFilter(@Nullable String nameFilter) {

            this.nameFilter = nameFilter;
            return this;
        }
        @CustomType.Setter
        public Builder newGroupDelay(Integer newGroupDelay) {
            if (newGroupDelay == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "newGroupDelay");
            }
            this.newGroupDelay = newGroupDelay;
            return this;
        }
        @CustomType.Setter
        public Builder newHostDelay(Integer newHostDelay) {
            if (newHostDelay == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "newHostDelay");
            }
            this.newHostDelay = newHostDelay;
            return this;
        }
        @CustomType.Setter
        public Builder noDataTimeframe(Integer noDataTimeframe) {
            if (noDataTimeframe == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "noDataTimeframe");
            }
            this.noDataTimeframe = noDataTimeframe;
            return this;
        }
        @CustomType.Setter
        public Builder notificationPresetName(String notificationPresetName) {
            if (notificationPresetName == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "notificationPresetName");
            }
            this.notificationPresetName = notificationPresetName;
            return this;
        }
        @CustomType.Setter
        public Builder notifyAudit(Boolean notifyAudit) {
            if (notifyAudit == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "notifyAudit");
            }
            this.notifyAudit = notifyAudit;
            return this;
        }
        @CustomType.Setter
        public Builder notifyBies(List<String> notifyBies) {
            if (notifyBies == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "notifyBies");
            }
            this.notifyBies = notifyBies;
            return this;
        }
        public Builder notifyBies(String... notifyBies) {
            return notifyBies(List.of(notifyBies));
        }
        @CustomType.Setter
        public Builder notifyNoData(Boolean notifyNoData) {
            if (notifyNoData == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "notifyNoData");
            }
            this.notifyNoData = notifyNoData;
            return this;
        }
        @CustomType.Setter
        public Builder onMissingData(String onMissingData) {
            if (onMissingData == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "onMissingData");
            }
            this.onMissingData = onMissingData;
            return this;
        }
        @CustomType.Setter
        public Builder query(String query) {
            if (query == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "query");
            }
            this.query = query;
            return this;
        }
        @CustomType.Setter
        public Builder renotifyInterval(Integer renotifyInterval) {
            if (renotifyInterval == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "renotifyInterval");
            }
            this.renotifyInterval = renotifyInterval;
            return this;
        }
        @CustomType.Setter
        public Builder renotifyOccurrences(Integer renotifyOccurrences) {
            if (renotifyOccurrences == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "renotifyOccurrences");
            }
            this.renotifyOccurrences = renotifyOccurrences;
            return this;
        }
        @CustomType.Setter
        public Builder renotifyStatuses(List<String> renotifyStatuses) {
            if (renotifyStatuses == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "renotifyStatuses");
            }
            this.renotifyStatuses = renotifyStatuses;
            return this;
        }
        public Builder renotifyStatuses(String... renotifyStatuses) {
            return renotifyStatuses(List.of(renotifyStatuses));
        }
        @CustomType.Setter
        public Builder requireFullWindow(Boolean requireFullWindow) {
            if (requireFullWindow == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "requireFullWindow");
            }
            this.requireFullWindow = requireFullWindow;
            return this;
        }
        @CustomType.Setter
        public Builder restrictedRoles(List<String> restrictedRoles) {
            if (restrictedRoles == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "restrictedRoles");
            }
            this.restrictedRoles = restrictedRoles;
            return this;
        }
        public Builder restrictedRoles(String... restrictedRoles) {
            return restrictedRoles(List.of(restrictedRoles));
        }
        @CustomType.Setter
        public Builder schedulingOptions(List<GetMonitorSchedulingOption> schedulingOptions) {
            if (schedulingOptions == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "schedulingOptions");
            }
            this.schedulingOptions = schedulingOptions;
            return this;
        }
        public Builder schedulingOptions(GetMonitorSchedulingOption... schedulingOptions) {
            return schedulingOptions(List.of(schedulingOptions));
        }
        @CustomType.Setter
        public Builder tags(List<String> tags) {
            if (tags == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "tags");
            }
            this.tags = tags;
            return this;
        }
        public Builder tags(String... tags) {
            return tags(List.of(tags));
        }
        @CustomType.Setter
        public Builder tagsFilters(@Nullable List<String> tagsFilters) {

            this.tagsFilters = tagsFilters;
            return this;
        }
        public Builder tagsFilters(String... tagsFilters) {
            return tagsFilters(List.of(tagsFilters));
        }
        @CustomType.Setter
        public Builder timeoutH(Integer timeoutH) {
            if (timeoutH == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "timeoutH");
            }
            this.timeoutH = timeoutH;
            return this;
        }
        @CustomType.Setter
        public Builder type(String type) {
            if (type == null) {
              throw new MissingRequiredPropertyException("GetMonitorResult", "type");
            }
            this.type = type;
            return this;
        }
        public GetMonitorResult build() {
            final var _resultValue = new GetMonitorResult();
            _resultValue.enableLogsSample = enableLogsSample;
            _resultValue.enableSamples = enableSamples;
            _resultValue.escalationMessage = escalationMessage;
            _resultValue.evaluationDelay = evaluationDelay;
            _resultValue.groupRetentionDuration = groupRetentionDuration;
            _resultValue.groupbySimpleMonitor = groupbySimpleMonitor;
            _resultValue.id = id;
            _resultValue.includeTags = includeTags;
            _resultValue.locked = locked;
            _resultValue.message = message;
            _resultValue.monitorTagsFilters = monitorTagsFilters;
            _resultValue.monitorThresholdWindows = monitorThresholdWindows;
            _resultValue.monitorThresholds = monitorThresholds;
            _resultValue.name = name;
            _resultValue.nameFilter = nameFilter;
            _resultValue.newGroupDelay = newGroupDelay;
            _resultValue.newHostDelay = newHostDelay;
            _resultValue.noDataTimeframe = noDataTimeframe;
            _resultValue.notificationPresetName = notificationPresetName;
            _resultValue.notifyAudit = notifyAudit;
            _resultValue.notifyBies = notifyBies;
            _resultValue.notifyNoData = notifyNoData;
            _resultValue.onMissingData = onMissingData;
            _resultValue.query = query;
            _resultValue.renotifyInterval = renotifyInterval;
            _resultValue.renotifyOccurrences = renotifyOccurrences;
            _resultValue.renotifyStatuses = renotifyStatuses;
            _resultValue.requireFullWindow = requireFullWindow;
            _resultValue.restrictedRoles = restrictedRoles;
            _resultValue.schedulingOptions = schedulingOptions;
            _resultValue.tags = tags;
            _resultValue.tagsFilters = tagsFilters;
            _resultValue.timeoutH = timeoutH;
            _resultValue.type = type;
            return _resultValue;
        }
    }
}

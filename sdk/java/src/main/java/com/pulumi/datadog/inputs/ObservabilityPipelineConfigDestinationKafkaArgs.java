// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.datadog.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.datadog.inputs.ObservabilityPipelineConfigDestinationKafkaLibrdkafkaOptionArgs;
import com.pulumi.datadog.inputs.ObservabilityPipelineConfigDestinationKafkaSaslArgs;
import com.pulumi.datadog.inputs.ObservabilityPipelineConfigDestinationKafkaTlsArgs;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ObservabilityPipelineConfigDestinationKafkaArgs extends com.pulumi.resources.ResourceArgs {

    public static final ObservabilityPipelineConfigDestinationKafkaArgs Empty = new ObservabilityPipelineConfigDestinationKafkaArgs();

    /**
     * Compression codec for Kafka messages. Valid values are `none`, `gzip`, `snappy`, `lz4`, `zstd`.
     * 
     */
    @Import(name="compression")
    private @Nullable Output<String> compression;

    /**
     * @return Compression codec for Kafka messages. Valid values are `none`, `gzip`, `snappy`, `lz4`, `zstd`.
     * 
     */
    public Optional<Output<String>> compression() {
        return Optional.ofNullable(this.compression);
    }

    /**
     * Encoding format for log events. Valid values are `json`, `rawMessage`.
     * 
     */
    @Import(name="encoding", required=true)
    private Output<String> encoding;

    /**
     * @return Encoding format for log events. Valid values are `json`, `rawMessage`.
     * 
     */
    public Output<String> encoding() {
        return this.encoding;
    }

    /**
     * The field name to use for Kafka message headers.
     * 
     */
    @Import(name="headersKey")
    private @Nullable Output<String> headersKey;

    /**
     * @return The field name to use for Kafka message headers.
     * 
     */
    public Optional<Output<String>> headersKey() {
        return Optional.ofNullable(this.headersKey);
    }

    /**
     * The field name to use as the Kafka message key.
     * 
     */
    @Import(name="keyField")
    private @Nullable Output<String> keyField;

    /**
     * @return The field name to use as the Kafka message key.
     * 
     */
    public Optional<Output<String>> keyField() {
        return Optional.ofNullable(this.keyField);
    }

    /**
     * Optional list of advanced Kafka producer configuration options, defined as key-value pairs.
     * 
     */
    @Import(name="librdkafkaOptions")
    private @Nullable Output<List<ObservabilityPipelineConfigDestinationKafkaLibrdkafkaOptionArgs>> librdkafkaOptions;

    /**
     * @return Optional list of advanced Kafka producer configuration options, defined as key-value pairs.
     * 
     */
    public Optional<Output<List<ObservabilityPipelineConfigDestinationKafkaLibrdkafkaOptionArgs>>> librdkafkaOptions() {
        return Optional.ofNullable(this.librdkafkaOptions);
    }

    /**
     * Maximum time in milliseconds to wait for message delivery confirmation.
     * 
     */
    @Import(name="messageTimeoutMs")
    private @Nullable Output<Integer> messageTimeoutMs;

    /**
     * @return Maximum time in milliseconds to wait for message delivery confirmation.
     * 
     */
    public Optional<Output<Integer>> messageTimeoutMs() {
        return Optional.ofNullable(this.messageTimeoutMs);
    }

    /**
     * Duration in seconds for the rate limit window.
     * 
     */
    @Import(name="rateLimitDurationSecs")
    private @Nullable Output<Integer> rateLimitDurationSecs;

    /**
     * @return Duration in seconds for the rate limit window.
     * 
     */
    public Optional<Output<Integer>> rateLimitDurationSecs() {
        return Optional.ofNullable(this.rateLimitDurationSecs);
    }

    /**
     * Maximum number of messages allowed per rate limit duration.
     * 
     */
    @Import(name="rateLimitNum")
    private @Nullable Output<Integer> rateLimitNum;

    /**
     * @return Maximum number of messages allowed per rate limit duration.
     * 
     */
    public Optional<Output<Integer>> rateLimitNum() {
        return Optional.ofNullable(this.rateLimitNum);
    }

    /**
     * Specifies the SASL mechanism for authenticating with a Kafka cluster.
     * 
     */
    @Import(name="sasl")
    private @Nullable Output<ObservabilityPipelineConfigDestinationKafkaSaslArgs> sasl;

    /**
     * @return Specifies the SASL mechanism for authenticating with a Kafka cluster.
     * 
     */
    public Optional<Output<ObservabilityPipelineConfigDestinationKafkaSaslArgs>> sasl() {
        return Optional.ofNullable(this.sasl);
    }

    /**
     * Socket timeout in milliseconds for network requests.
     * 
     */
    @Import(name="socketTimeoutMs")
    private @Nullable Output<Integer> socketTimeoutMs;

    /**
     * @return Socket timeout in milliseconds for network requests.
     * 
     */
    public Optional<Output<Integer>> socketTimeoutMs() {
        return Optional.ofNullable(this.socketTimeoutMs);
    }

    /**
     * Configuration for enabling TLS encryption between the pipeline component and external services.
     * 
     */
    @Import(name="tls")
    private @Nullable Output<ObservabilityPipelineConfigDestinationKafkaTlsArgs> tls;

    /**
     * @return Configuration for enabling TLS encryption between the pipeline component and external services.
     * 
     */
    public Optional<Output<ObservabilityPipelineConfigDestinationKafkaTlsArgs>> tls() {
        return Optional.ofNullable(this.tls);
    }

    /**
     * The Kafka topic name to publish logs to.
     * 
     */
    @Import(name="topic", required=true)
    private Output<String> topic;

    /**
     * @return The Kafka topic name to publish logs to.
     * 
     */
    public Output<String> topic() {
        return this.topic;
    }

    private ObservabilityPipelineConfigDestinationKafkaArgs() {}

    private ObservabilityPipelineConfigDestinationKafkaArgs(ObservabilityPipelineConfigDestinationKafkaArgs $) {
        this.compression = $.compression;
        this.encoding = $.encoding;
        this.headersKey = $.headersKey;
        this.keyField = $.keyField;
        this.librdkafkaOptions = $.librdkafkaOptions;
        this.messageTimeoutMs = $.messageTimeoutMs;
        this.rateLimitDurationSecs = $.rateLimitDurationSecs;
        this.rateLimitNum = $.rateLimitNum;
        this.sasl = $.sasl;
        this.socketTimeoutMs = $.socketTimeoutMs;
        this.tls = $.tls;
        this.topic = $.topic;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ObservabilityPipelineConfigDestinationKafkaArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ObservabilityPipelineConfigDestinationKafkaArgs $;

        public Builder() {
            $ = new ObservabilityPipelineConfigDestinationKafkaArgs();
        }

        public Builder(ObservabilityPipelineConfigDestinationKafkaArgs defaults) {
            $ = new ObservabilityPipelineConfigDestinationKafkaArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param compression Compression codec for Kafka messages. Valid values are `none`, `gzip`, `snappy`, `lz4`, `zstd`.
         * 
         * @return builder
         * 
         */
        public Builder compression(@Nullable Output<String> compression) {
            $.compression = compression;
            return this;
        }

        /**
         * @param compression Compression codec for Kafka messages. Valid values are `none`, `gzip`, `snappy`, `lz4`, `zstd`.
         * 
         * @return builder
         * 
         */
        public Builder compression(String compression) {
            return compression(Output.of(compression));
        }

        /**
         * @param encoding Encoding format for log events. Valid values are `json`, `rawMessage`.
         * 
         * @return builder
         * 
         */
        public Builder encoding(Output<String> encoding) {
            $.encoding = encoding;
            return this;
        }

        /**
         * @param encoding Encoding format for log events. Valid values are `json`, `rawMessage`.
         * 
         * @return builder
         * 
         */
        public Builder encoding(String encoding) {
            return encoding(Output.of(encoding));
        }

        /**
         * @param headersKey The field name to use for Kafka message headers.
         * 
         * @return builder
         * 
         */
        public Builder headersKey(@Nullable Output<String> headersKey) {
            $.headersKey = headersKey;
            return this;
        }

        /**
         * @param headersKey The field name to use for Kafka message headers.
         * 
         * @return builder
         * 
         */
        public Builder headersKey(String headersKey) {
            return headersKey(Output.of(headersKey));
        }

        /**
         * @param keyField The field name to use as the Kafka message key.
         * 
         * @return builder
         * 
         */
        public Builder keyField(@Nullable Output<String> keyField) {
            $.keyField = keyField;
            return this;
        }

        /**
         * @param keyField The field name to use as the Kafka message key.
         * 
         * @return builder
         * 
         */
        public Builder keyField(String keyField) {
            return keyField(Output.of(keyField));
        }

        /**
         * @param librdkafkaOptions Optional list of advanced Kafka producer configuration options, defined as key-value pairs.
         * 
         * @return builder
         * 
         */
        public Builder librdkafkaOptions(@Nullable Output<List<ObservabilityPipelineConfigDestinationKafkaLibrdkafkaOptionArgs>> librdkafkaOptions) {
            $.librdkafkaOptions = librdkafkaOptions;
            return this;
        }

        /**
         * @param librdkafkaOptions Optional list of advanced Kafka producer configuration options, defined as key-value pairs.
         * 
         * @return builder
         * 
         */
        public Builder librdkafkaOptions(List<ObservabilityPipelineConfigDestinationKafkaLibrdkafkaOptionArgs> librdkafkaOptions) {
            return librdkafkaOptions(Output.of(librdkafkaOptions));
        }

        /**
         * @param librdkafkaOptions Optional list of advanced Kafka producer configuration options, defined as key-value pairs.
         * 
         * @return builder
         * 
         */
        public Builder librdkafkaOptions(ObservabilityPipelineConfigDestinationKafkaLibrdkafkaOptionArgs... librdkafkaOptions) {
            return librdkafkaOptions(List.of(librdkafkaOptions));
        }

        /**
         * @param messageTimeoutMs Maximum time in milliseconds to wait for message delivery confirmation.
         * 
         * @return builder
         * 
         */
        public Builder messageTimeoutMs(@Nullable Output<Integer> messageTimeoutMs) {
            $.messageTimeoutMs = messageTimeoutMs;
            return this;
        }

        /**
         * @param messageTimeoutMs Maximum time in milliseconds to wait for message delivery confirmation.
         * 
         * @return builder
         * 
         */
        public Builder messageTimeoutMs(Integer messageTimeoutMs) {
            return messageTimeoutMs(Output.of(messageTimeoutMs));
        }

        /**
         * @param rateLimitDurationSecs Duration in seconds for the rate limit window.
         * 
         * @return builder
         * 
         */
        public Builder rateLimitDurationSecs(@Nullable Output<Integer> rateLimitDurationSecs) {
            $.rateLimitDurationSecs = rateLimitDurationSecs;
            return this;
        }

        /**
         * @param rateLimitDurationSecs Duration in seconds for the rate limit window.
         * 
         * @return builder
         * 
         */
        public Builder rateLimitDurationSecs(Integer rateLimitDurationSecs) {
            return rateLimitDurationSecs(Output.of(rateLimitDurationSecs));
        }

        /**
         * @param rateLimitNum Maximum number of messages allowed per rate limit duration.
         * 
         * @return builder
         * 
         */
        public Builder rateLimitNum(@Nullable Output<Integer> rateLimitNum) {
            $.rateLimitNum = rateLimitNum;
            return this;
        }

        /**
         * @param rateLimitNum Maximum number of messages allowed per rate limit duration.
         * 
         * @return builder
         * 
         */
        public Builder rateLimitNum(Integer rateLimitNum) {
            return rateLimitNum(Output.of(rateLimitNum));
        }

        /**
         * @param sasl Specifies the SASL mechanism for authenticating with a Kafka cluster.
         * 
         * @return builder
         * 
         */
        public Builder sasl(@Nullable Output<ObservabilityPipelineConfigDestinationKafkaSaslArgs> sasl) {
            $.sasl = sasl;
            return this;
        }

        /**
         * @param sasl Specifies the SASL mechanism for authenticating with a Kafka cluster.
         * 
         * @return builder
         * 
         */
        public Builder sasl(ObservabilityPipelineConfigDestinationKafkaSaslArgs sasl) {
            return sasl(Output.of(sasl));
        }

        /**
         * @param socketTimeoutMs Socket timeout in milliseconds for network requests.
         * 
         * @return builder
         * 
         */
        public Builder socketTimeoutMs(@Nullable Output<Integer> socketTimeoutMs) {
            $.socketTimeoutMs = socketTimeoutMs;
            return this;
        }

        /**
         * @param socketTimeoutMs Socket timeout in milliseconds for network requests.
         * 
         * @return builder
         * 
         */
        public Builder socketTimeoutMs(Integer socketTimeoutMs) {
            return socketTimeoutMs(Output.of(socketTimeoutMs));
        }

        /**
         * @param tls Configuration for enabling TLS encryption between the pipeline component and external services.
         * 
         * @return builder
         * 
         */
        public Builder tls(@Nullable Output<ObservabilityPipelineConfigDestinationKafkaTlsArgs> tls) {
            $.tls = tls;
            return this;
        }

        /**
         * @param tls Configuration for enabling TLS encryption between the pipeline component and external services.
         * 
         * @return builder
         * 
         */
        public Builder tls(ObservabilityPipelineConfigDestinationKafkaTlsArgs tls) {
            return tls(Output.of(tls));
        }

        /**
         * @param topic The Kafka topic name to publish logs to.
         * 
         * @return builder
         * 
         */
        public Builder topic(Output<String> topic) {
            $.topic = topic;
            return this;
        }

        /**
         * @param topic The Kafka topic name to publish logs to.
         * 
         * @return builder
         * 
         */
        public Builder topic(String topic) {
            return topic(Output.of(topic));
        }

        public ObservabilityPipelineConfigDestinationKafkaArgs build() {
            if ($.encoding == null) {
                throw new MissingRequiredPropertyException("ObservabilityPipelineConfigDestinationKafkaArgs", "encoding");
            }
            if ($.topic == null) {
                throw new MissingRequiredPropertyException("ObservabilityPipelineConfigDestinationKafkaArgs", "topic");
            }
            return $;
        }
    }

}

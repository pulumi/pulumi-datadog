// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.datadog.outputs;

import com.pulumi.core.annotations.CustomType;
import com.pulumi.datadog.outputs.GetCustomAllocationRuleStrategyAllocatedBy;
import com.pulumi.datadog.outputs.GetCustomAllocationRuleStrategyAllocatedByFilter;
import com.pulumi.datadog.outputs.GetCustomAllocationRuleStrategyBasedOnCost;
import com.pulumi.datadog.outputs.GetCustomAllocationRuleStrategyBasedOnTimeseries;
import com.pulumi.datadog.outputs.GetCustomAllocationRuleStrategyEvaluateGroupedByFilter;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;

@CustomType
public final class GetCustomAllocationRuleStrategy {
    private @Nullable List<GetCustomAllocationRuleStrategyAllocatedBy> allocatedBies;
    private @Nullable List<GetCustomAllocationRuleStrategyAllocatedByFilter> allocatedByFilters;
    /**
     * @return List of tag keys used to allocate costs.
     * 
     */
    private List<String> allocatedByTagKeys;
    private @Nullable List<GetCustomAllocationRuleStrategyBasedOnCost> basedOnCosts;
    private @Nullable GetCustomAllocationRuleStrategyBasedOnTimeseries basedOnTimeseries;
    private @Nullable List<GetCustomAllocationRuleStrategyEvaluateGroupedByFilter> evaluateGroupedByFilters;
    /**
     * @return List of tag keys used to group costs before allocation.
     * 
     */
    private List<String> evaluateGroupedByTagKeys;
    /**
     * @return The granularity level for cost allocation (`daily` or `monthly`).
     * 
     */
    private String granularity;
    /**
     * @return The allocation method. Valid values are `even`, `proportional`, `proportionalTimeseries`, or `percent`.
     * 
     */
    private String method;

    private GetCustomAllocationRuleStrategy() {}
    public List<GetCustomAllocationRuleStrategyAllocatedBy> allocatedBies() {
        return this.allocatedBies == null ? List.of() : this.allocatedBies;
    }
    public List<GetCustomAllocationRuleStrategyAllocatedByFilter> allocatedByFilters() {
        return this.allocatedByFilters == null ? List.of() : this.allocatedByFilters;
    }
    /**
     * @return List of tag keys used to allocate costs.
     * 
     */
    public List<String> allocatedByTagKeys() {
        return this.allocatedByTagKeys;
    }
    public List<GetCustomAllocationRuleStrategyBasedOnCost> basedOnCosts() {
        return this.basedOnCosts == null ? List.of() : this.basedOnCosts;
    }
    public Optional<GetCustomAllocationRuleStrategyBasedOnTimeseries> basedOnTimeseries() {
        return Optional.ofNullable(this.basedOnTimeseries);
    }
    public List<GetCustomAllocationRuleStrategyEvaluateGroupedByFilter> evaluateGroupedByFilters() {
        return this.evaluateGroupedByFilters == null ? List.of() : this.evaluateGroupedByFilters;
    }
    /**
     * @return List of tag keys used to group costs before allocation.
     * 
     */
    public List<String> evaluateGroupedByTagKeys() {
        return this.evaluateGroupedByTagKeys;
    }
    /**
     * @return The granularity level for cost allocation (`daily` or `monthly`).
     * 
     */
    public String granularity() {
        return this.granularity;
    }
    /**
     * @return The allocation method. Valid values are `even`, `proportional`, `proportionalTimeseries`, or `percent`.
     * 
     */
    public String method() {
        return this.method;
    }

    public static Builder builder() {
        return new Builder();
    }

    public static Builder builder(GetCustomAllocationRuleStrategy defaults) {
        return new Builder(defaults);
    }
    @CustomType.Builder
    public static final class Builder {
        private @Nullable List<GetCustomAllocationRuleStrategyAllocatedBy> allocatedBies;
        private @Nullable List<GetCustomAllocationRuleStrategyAllocatedByFilter> allocatedByFilters;
        private List<String> allocatedByTagKeys;
        private @Nullable List<GetCustomAllocationRuleStrategyBasedOnCost> basedOnCosts;
        private @Nullable GetCustomAllocationRuleStrategyBasedOnTimeseries basedOnTimeseries;
        private @Nullable List<GetCustomAllocationRuleStrategyEvaluateGroupedByFilter> evaluateGroupedByFilters;
        private List<String> evaluateGroupedByTagKeys;
        private String granularity;
        private String method;
        public Builder() {}
        public Builder(GetCustomAllocationRuleStrategy defaults) {
    	      Objects.requireNonNull(defaults);
    	      this.allocatedBies = defaults.allocatedBies;
    	      this.allocatedByFilters = defaults.allocatedByFilters;
    	      this.allocatedByTagKeys = defaults.allocatedByTagKeys;
    	      this.basedOnCosts = defaults.basedOnCosts;
    	      this.basedOnTimeseries = defaults.basedOnTimeseries;
    	      this.evaluateGroupedByFilters = defaults.evaluateGroupedByFilters;
    	      this.evaluateGroupedByTagKeys = defaults.evaluateGroupedByTagKeys;
    	      this.granularity = defaults.granularity;
    	      this.method = defaults.method;
        }

        @CustomType.Setter
        public Builder allocatedBies(@Nullable List<GetCustomAllocationRuleStrategyAllocatedBy> allocatedBies) {

            this.allocatedBies = allocatedBies;
            return this;
        }
        public Builder allocatedBies(GetCustomAllocationRuleStrategyAllocatedBy... allocatedBies) {
            return allocatedBies(List.of(allocatedBies));
        }
        @CustomType.Setter
        public Builder allocatedByFilters(@Nullable List<GetCustomAllocationRuleStrategyAllocatedByFilter> allocatedByFilters) {

            this.allocatedByFilters = allocatedByFilters;
            return this;
        }
        public Builder allocatedByFilters(GetCustomAllocationRuleStrategyAllocatedByFilter... allocatedByFilters) {
            return allocatedByFilters(List.of(allocatedByFilters));
        }
        @CustomType.Setter
        public Builder allocatedByTagKeys(List<String> allocatedByTagKeys) {
            if (allocatedByTagKeys == null) {
              throw new MissingRequiredPropertyException("GetCustomAllocationRuleStrategy", "allocatedByTagKeys");
            }
            this.allocatedByTagKeys = allocatedByTagKeys;
            return this;
        }
        public Builder allocatedByTagKeys(String... allocatedByTagKeys) {
            return allocatedByTagKeys(List.of(allocatedByTagKeys));
        }
        @CustomType.Setter
        public Builder basedOnCosts(@Nullable List<GetCustomAllocationRuleStrategyBasedOnCost> basedOnCosts) {

            this.basedOnCosts = basedOnCosts;
            return this;
        }
        public Builder basedOnCosts(GetCustomAllocationRuleStrategyBasedOnCost... basedOnCosts) {
            return basedOnCosts(List.of(basedOnCosts));
        }
        @CustomType.Setter
        public Builder basedOnTimeseries(@Nullable GetCustomAllocationRuleStrategyBasedOnTimeseries basedOnTimeseries) {

            this.basedOnTimeseries = basedOnTimeseries;
            return this;
        }
        @CustomType.Setter
        public Builder evaluateGroupedByFilters(@Nullable List<GetCustomAllocationRuleStrategyEvaluateGroupedByFilter> evaluateGroupedByFilters) {

            this.evaluateGroupedByFilters = evaluateGroupedByFilters;
            return this;
        }
        public Builder evaluateGroupedByFilters(GetCustomAllocationRuleStrategyEvaluateGroupedByFilter... evaluateGroupedByFilters) {
            return evaluateGroupedByFilters(List.of(evaluateGroupedByFilters));
        }
        @CustomType.Setter
        public Builder evaluateGroupedByTagKeys(List<String> evaluateGroupedByTagKeys) {
            if (evaluateGroupedByTagKeys == null) {
              throw new MissingRequiredPropertyException("GetCustomAllocationRuleStrategy", "evaluateGroupedByTagKeys");
            }
            this.evaluateGroupedByTagKeys = evaluateGroupedByTagKeys;
            return this;
        }
        public Builder evaluateGroupedByTagKeys(String... evaluateGroupedByTagKeys) {
            return evaluateGroupedByTagKeys(List.of(evaluateGroupedByTagKeys));
        }
        @CustomType.Setter
        public Builder granularity(String granularity) {
            if (granularity == null) {
              throw new MissingRequiredPropertyException("GetCustomAllocationRuleStrategy", "granularity");
            }
            this.granularity = granularity;
            return this;
        }
        @CustomType.Setter
        public Builder method(String method) {
            if (method == null) {
              throw new MissingRequiredPropertyException("GetCustomAllocationRuleStrategy", "method");
            }
            this.method = method;
            return this;
        }
        public GetCustomAllocationRuleStrategy build() {
            final var _resultValue = new GetCustomAllocationRuleStrategy();
            _resultValue.allocatedBies = allocatedBies;
            _resultValue.allocatedByFilters = allocatedByFilters;
            _resultValue.allocatedByTagKeys = allocatedByTagKeys;
            _resultValue.basedOnCosts = basedOnCosts;
            _resultValue.basedOnTimeseries = basedOnTimeseries;
            _resultValue.evaluateGroupedByFilters = evaluateGroupedByFilters;
            _resultValue.evaluateGroupedByTagKeys = evaluateGroupedByTagKeys;
            _resultValue.granularity = granularity;
            _resultValue.method = method;
            return _resultValue;
        }
    }
}

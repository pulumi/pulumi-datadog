// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.datadog;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.datadog.inputs.LogsCustomDestinationElasticsearchDestinationArgs;
import com.pulumi.datadog.inputs.LogsCustomDestinationHttpDestinationArgs;
import com.pulumi.datadog.inputs.LogsCustomDestinationMicrosoftSentinelDestinationArgs;
import com.pulumi.datadog.inputs.LogsCustomDestinationSplunkDestinationArgs;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class LogsCustomDestinationArgs extends com.pulumi.resources.ResourceArgs {

    public static final LogsCustomDestinationArgs Empty = new LogsCustomDestinationArgs();

    /**
     * The Elasticsearch destination.
     * 
     */
    @Import(name="elasticsearchDestination")
    private @Nullable Output<LogsCustomDestinationElasticsearchDestinationArgs> elasticsearchDestination;

    /**
     * @return The Elasticsearch destination.
     * 
     */
    public Optional<Output<LogsCustomDestinationElasticsearchDestinationArgs>> elasticsearchDestination() {
        return Optional.ofNullable(this.elasticsearchDestination);
    }

    /**
     * Whether logs matching this custom destination should be forwarded or not.
     * 
     */
    @Import(name="enabled")
    private @Nullable Output<Boolean> enabled;

    /**
     * @return Whether logs matching this custom destination should be forwarded or not.
     * 
     */
    public Optional<Output<Boolean>> enabled() {
        return Optional.ofNullable(this.enabled);
    }

    /**
     * Whether tags from the forwarded logs should be forwarded or not.
     * 
     */
    @Import(name="forwardTags")
    private @Nullable Output<Boolean> forwardTags;

    /**
     * @return Whether tags from the forwarded logs should be forwarded or not.
     * 
     */
    public Optional<Output<Boolean>> forwardTags() {
        return Optional.ofNullable(this.forwardTags);
    }

    /**
     * How the `forward_tags_restriction_list` parameter should be interpreted.
     * 			If `ALLOW_LIST`, then only tags whose keys on the forwarded logs match the ones on the restriction list
     * 			are forwarded.
     * 			`BLOCK_LIST` works the opposite way. It does not forward the tags matching the ones on the list. Valid values are `ALLOW_LIST`, `BLOCK_LIST`.
     * 
     */
    @Import(name="forwardTagsRestrictionListType")
    private @Nullable Output<String> forwardTagsRestrictionListType;

    /**
     * @return How the `forward_tags_restriction_list` parameter should be interpreted.
     * 			If `ALLOW_LIST`, then only tags whose keys on the forwarded logs match the ones on the restriction list
     * 			are forwarded.
     * 			`BLOCK_LIST` works the opposite way. It does not forward the tags matching the ones on the list. Valid values are `ALLOW_LIST`, `BLOCK_LIST`.
     * 
     */
    public Optional<Output<String>> forwardTagsRestrictionListType() {
        return Optional.ofNullable(this.forwardTagsRestrictionListType);
    }

    /**
     * List of [tag keys](https://docs.datadoghq.com/getting_started/tagging/#define-tags) to be filtered.
     * 			An empty list represents no restriction is in place and either all or no tags will be
     * 			forwarded depending on `forward_tags_restriction_list_type` parameter.
     * 
     */
    @Import(name="forwardTagsRestrictionLists")
    private @Nullable Output<List<String>> forwardTagsRestrictionLists;

    /**
     * @return List of [tag keys](https://docs.datadoghq.com/getting_started/tagging/#define-tags) to be filtered.
     * 			An empty list represents no restriction is in place and either all or no tags will be
     * 			forwarded depending on `forward_tags_restriction_list_type` parameter.
     * 
     */
    public Optional<Output<List<String>>> forwardTagsRestrictionLists() {
        return Optional.ofNullable(this.forwardTagsRestrictionLists);
    }

    /**
     * The HTTP destination.
     * 
     */
    @Import(name="httpDestination")
    private @Nullable Output<LogsCustomDestinationHttpDestinationArgs> httpDestination;

    /**
     * @return The HTTP destination.
     * 
     */
    public Optional<Output<LogsCustomDestinationHttpDestinationArgs>> httpDestination() {
        return Optional.ofNullable(this.httpDestination);
    }

    /**
     * The Microsoft Sentinel destination.
     * 
     */
    @Import(name="microsoftSentinelDestination")
    private @Nullable Output<LogsCustomDestinationMicrosoftSentinelDestinationArgs> microsoftSentinelDestination;

    /**
     * @return The Microsoft Sentinel destination.
     * 
     */
    public Optional<Output<LogsCustomDestinationMicrosoftSentinelDestinationArgs>> microsoftSentinelDestination() {
        return Optional.ofNullable(this.microsoftSentinelDestination);
    }

    /**
     * The custom destination name.
     * 
     */
    @Import(name="name", required=true)
    private Output<String> name;

    /**
     * @return The custom destination name.
     * 
     */
    public Output<String> name() {
        return this.name;
    }

    /**
     * The custom destination query filter. Logs matching this query are forwarded to the destination.
     * 
     */
    @Import(name="query")
    private @Nullable Output<String> query;

    /**
     * @return The custom destination query filter. Logs matching this query are forwarded to the destination.
     * 
     */
    public Optional<Output<String>> query() {
        return Optional.ofNullable(this.query);
    }

    /**
     * The Splunk HTTP Event Collector (HEC) destination.
     * 
     */
    @Import(name="splunkDestination")
    private @Nullable Output<LogsCustomDestinationSplunkDestinationArgs> splunkDestination;

    /**
     * @return The Splunk HTTP Event Collector (HEC) destination.
     * 
     */
    public Optional<Output<LogsCustomDestinationSplunkDestinationArgs>> splunkDestination() {
        return Optional.ofNullable(this.splunkDestination);
    }

    private LogsCustomDestinationArgs() {}

    private LogsCustomDestinationArgs(LogsCustomDestinationArgs $) {
        this.elasticsearchDestination = $.elasticsearchDestination;
        this.enabled = $.enabled;
        this.forwardTags = $.forwardTags;
        this.forwardTagsRestrictionListType = $.forwardTagsRestrictionListType;
        this.forwardTagsRestrictionLists = $.forwardTagsRestrictionLists;
        this.httpDestination = $.httpDestination;
        this.microsoftSentinelDestination = $.microsoftSentinelDestination;
        this.name = $.name;
        this.query = $.query;
        this.splunkDestination = $.splunkDestination;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(LogsCustomDestinationArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private LogsCustomDestinationArgs $;

        public Builder() {
            $ = new LogsCustomDestinationArgs();
        }

        public Builder(LogsCustomDestinationArgs defaults) {
            $ = new LogsCustomDestinationArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param elasticsearchDestination The Elasticsearch destination.
         * 
         * @return builder
         * 
         */
        public Builder elasticsearchDestination(@Nullable Output<LogsCustomDestinationElasticsearchDestinationArgs> elasticsearchDestination) {
            $.elasticsearchDestination = elasticsearchDestination;
            return this;
        }

        /**
         * @param elasticsearchDestination The Elasticsearch destination.
         * 
         * @return builder
         * 
         */
        public Builder elasticsearchDestination(LogsCustomDestinationElasticsearchDestinationArgs elasticsearchDestination) {
            return elasticsearchDestination(Output.of(elasticsearchDestination));
        }

        /**
         * @param enabled Whether logs matching this custom destination should be forwarded or not.
         * 
         * @return builder
         * 
         */
        public Builder enabled(@Nullable Output<Boolean> enabled) {
            $.enabled = enabled;
            return this;
        }

        /**
         * @param enabled Whether logs matching this custom destination should be forwarded or not.
         * 
         * @return builder
         * 
         */
        public Builder enabled(Boolean enabled) {
            return enabled(Output.of(enabled));
        }

        /**
         * @param forwardTags Whether tags from the forwarded logs should be forwarded or not.
         * 
         * @return builder
         * 
         */
        public Builder forwardTags(@Nullable Output<Boolean> forwardTags) {
            $.forwardTags = forwardTags;
            return this;
        }

        /**
         * @param forwardTags Whether tags from the forwarded logs should be forwarded or not.
         * 
         * @return builder
         * 
         */
        public Builder forwardTags(Boolean forwardTags) {
            return forwardTags(Output.of(forwardTags));
        }

        /**
         * @param forwardTagsRestrictionListType How the `forward_tags_restriction_list` parameter should be interpreted.
         * 			If `ALLOW_LIST`, then only tags whose keys on the forwarded logs match the ones on the restriction list
         * 			are forwarded.
         * 			`BLOCK_LIST` works the opposite way. It does not forward the tags matching the ones on the list. Valid values are `ALLOW_LIST`, `BLOCK_LIST`.
         * 
         * @return builder
         * 
         */
        public Builder forwardTagsRestrictionListType(@Nullable Output<String> forwardTagsRestrictionListType) {
            $.forwardTagsRestrictionListType = forwardTagsRestrictionListType;
            return this;
        }

        /**
         * @param forwardTagsRestrictionListType How the `forward_tags_restriction_list` parameter should be interpreted.
         * 			If `ALLOW_LIST`, then only tags whose keys on the forwarded logs match the ones on the restriction list
         * 			are forwarded.
         * 			`BLOCK_LIST` works the opposite way. It does not forward the tags matching the ones on the list. Valid values are `ALLOW_LIST`, `BLOCK_LIST`.
         * 
         * @return builder
         * 
         */
        public Builder forwardTagsRestrictionListType(String forwardTagsRestrictionListType) {
            return forwardTagsRestrictionListType(Output.of(forwardTagsRestrictionListType));
        }

        /**
         * @param forwardTagsRestrictionLists List of [tag keys](https://docs.datadoghq.com/getting_started/tagging/#define-tags) to be filtered.
         * 			An empty list represents no restriction is in place and either all or no tags will be
         * 			forwarded depending on `forward_tags_restriction_list_type` parameter.
         * 
         * @return builder
         * 
         */
        public Builder forwardTagsRestrictionLists(@Nullable Output<List<String>> forwardTagsRestrictionLists) {
            $.forwardTagsRestrictionLists = forwardTagsRestrictionLists;
            return this;
        }

        /**
         * @param forwardTagsRestrictionLists List of [tag keys](https://docs.datadoghq.com/getting_started/tagging/#define-tags) to be filtered.
         * 			An empty list represents no restriction is in place and either all or no tags will be
         * 			forwarded depending on `forward_tags_restriction_list_type` parameter.
         * 
         * @return builder
         * 
         */
        public Builder forwardTagsRestrictionLists(List<String> forwardTagsRestrictionLists) {
            return forwardTagsRestrictionLists(Output.of(forwardTagsRestrictionLists));
        }

        /**
         * @param forwardTagsRestrictionLists List of [tag keys](https://docs.datadoghq.com/getting_started/tagging/#define-tags) to be filtered.
         * 			An empty list represents no restriction is in place and either all or no tags will be
         * 			forwarded depending on `forward_tags_restriction_list_type` parameter.
         * 
         * @return builder
         * 
         */
        public Builder forwardTagsRestrictionLists(String... forwardTagsRestrictionLists) {
            return forwardTagsRestrictionLists(List.of(forwardTagsRestrictionLists));
        }

        /**
         * @param httpDestination The HTTP destination.
         * 
         * @return builder
         * 
         */
        public Builder httpDestination(@Nullable Output<LogsCustomDestinationHttpDestinationArgs> httpDestination) {
            $.httpDestination = httpDestination;
            return this;
        }

        /**
         * @param httpDestination The HTTP destination.
         * 
         * @return builder
         * 
         */
        public Builder httpDestination(LogsCustomDestinationHttpDestinationArgs httpDestination) {
            return httpDestination(Output.of(httpDestination));
        }

        /**
         * @param microsoftSentinelDestination The Microsoft Sentinel destination.
         * 
         * @return builder
         * 
         */
        public Builder microsoftSentinelDestination(@Nullable Output<LogsCustomDestinationMicrosoftSentinelDestinationArgs> microsoftSentinelDestination) {
            $.microsoftSentinelDestination = microsoftSentinelDestination;
            return this;
        }

        /**
         * @param microsoftSentinelDestination The Microsoft Sentinel destination.
         * 
         * @return builder
         * 
         */
        public Builder microsoftSentinelDestination(LogsCustomDestinationMicrosoftSentinelDestinationArgs microsoftSentinelDestination) {
            return microsoftSentinelDestination(Output.of(microsoftSentinelDestination));
        }

        /**
         * @param name The custom destination name.
         * 
         * @return builder
         * 
         */
        public Builder name(Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The custom destination name.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param query The custom destination query filter. Logs matching this query are forwarded to the destination.
         * 
         * @return builder
         * 
         */
        public Builder query(@Nullable Output<String> query) {
            $.query = query;
            return this;
        }

        /**
         * @param query The custom destination query filter. Logs matching this query are forwarded to the destination.
         * 
         * @return builder
         * 
         */
        public Builder query(String query) {
            return query(Output.of(query));
        }

        /**
         * @param splunkDestination The Splunk HTTP Event Collector (HEC) destination.
         * 
         * @return builder
         * 
         */
        public Builder splunkDestination(@Nullable Output<LogsCustomDestinationSplunkDestinationArgs> splunkDestination) {
            $.splunkDestination = splunkDestination;
            return this;
        }

        /**
         * @param splunkDestination The Splunk HTTP Event Collector (HEC) destination.
         * 
         * @return builder
         * 
         */
        public Builder splunkDestination(LogsCustomDestinationSplunkDestinationArgs splunkDestination) {
            return splunkDestination(Output.of(splunkDestination));
        }

        public LogsCustomDestinationArgs build() {
            if ($.name == null) {
                throw new MissingRequiredPropertyException("LogsCustomDestinationArgs", "name");
            }
            return $;
        }
    }

}

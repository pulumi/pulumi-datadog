// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.datadog.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ObservabilityPipelineConfigProcessorGroupProcessorParseXmlArgs extends com.pulumi.resources.ResourceArgs {

    public static final ObservabilityPipelineConfigProcessorGroupProcessorParseXmlArgs Empty = new ObservabilityPipelineConfigProcessorGroupProcessorParseXmlArgs();

    /**
     * Whether to always store text inside an object using the text key even when no attributes exist.
     * 
     */
    @Import(name="alwaysUseTextKey")
    private @Nullable Output<Boolean> alwaysUseTextKey;

    /**
     * @return Whether to always store text inside an object using the text key even when no attributes exist.
     * 
     */
    public Optional<Output<Boolean>> alwaysUseTextKey() {
        return Optional.ofNullable(this.alwaysUseTextKey);
    }

    /**
     * The prefix to use for XML attributes in the parsed output. If the field is left empty, the original attribute key is used.
     * 
     */
    @Import(name="attrPrefix")
    private @Nullable Output<String> attrPrefix;

    /**
     * @return The prefix to use for XML attributes in the parsed output. If the field is left empty, the original attribute key is used.
     * 
     */
    public Optional<Output<String>> attrPrefix() {
        return Optional.ofNullable(this.attrPrefix);
    }

    /**
     * The path to the log field on which you want to parse XML.
     * 
     */
    @Import(name="field", required=true)
    private Output<String> field;

    /**
     * @return The path to the log field on which you want to parse XML.
     * 
     */
    public Output<String> field() {
        return this.field;
    }

    /**
     * Whether to include XML attributes in the parsed output.
     * 
     */
    @Import(name="includeAttr")
    private @Nullable Output<Boolean> includeAttr;

    /**
     * @return Whether to include XML attributes in the parsed output.
     * 
     */
    public Optional<Output<Boolean>> includeAttr() {
        return Optional.ofNullable(this.includeAttr);
    }

    /**
     * Whether to parse boolean values from strings.
     * 
     */
    @Import(name="parseBool")
    private @Nullable Output<Boolean> parseBool;

    /**
     * @return Whether to parse boolean values from strings.
     * 
     */
    public Optional<Output<Boolean>> parseBool() {
        return Optional.ofNullable(this.parseBool);
    }

    /**
     * Whether to parse null values.
     * 
     */
    @Import(name="parseNull")
    private @Nullable Output<Boolean> parseNull;

    /**
     * @return Whether to parse null values.
     * 
     */
    public Optional<Output<Boolean>> parseNull() {
        return Optional.ofNullable(this.parseNull);
    }

    /**
     * Whether to parse numeric values from strings.
     * 
     */
    @Import(name="parseNumber")
    private @Nullable Output<Boolean> parseNumber;

    /**
     * @return Whether to parse numeric values from strings.
     * 
     */
    public Optional<Output<Boolean>> parseNumber() {
        return Optional.ofNullable(this.parseNumber);
    }

    /**
     * The key name to use for the text node when XML attributes are appended.
     * 
     */
    @Import(name="textKey")
    private @Nullable Output<String> textKey;

    /**
     * @return The key name to use for the text node when XML attributes are appended.
     * 
     */
    public Optional<Output<String>> textKey() {
        return Optional.ofNullable(this.textKey);
    }

    private ObservabilityPipelineConfigProcessorGroupProcessorParseXmlArgs() {}

    private ObservabilityPipelineConfigProcessorGroupProcessorParseXmlArgs(ObservabilityPipelineConfigProcessorGroupProcessorParseXmlArgs $) {
        this.alwaysUseTextKey = $.alwaysUseTextKey;
        this.attrPrefix = $.attrPrefix;
        this.field = $.field;
        this.includeAttr = $.includeAttr;
        this.parseBool = $.parseBool;
        this.parseNull = $.parseNull;
        this.parseNumber = $.parseNumber;
        this.textKey = $.textKey;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ObservabilityPipelineConfigProcessorGroupProcessorParseXmlArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ObservabilityPipelineConfigProcessorGroupProcessorParseXmlArgs $;

        public Builder() {
            $ = new ObservabilityPipelineConfigProcessorGroupProcessorParseXmlArgs();
        }

        public Builder(ObservabilityPipelineConfigProcessorGroupProcessorParseXmlArgs defaults) {
            $ = new ObservabilityPipelineConfigProcessorGroupProcessorParseXmlArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param alwaysUseTextKey Whether to always store text inside an object using the text key even when no attributes exist.
         * 
         * @return builder
         * 
         */
        public Builder alwaysUseTextKey(@Nullable Output<Boolean> alwaysUseTextKey) {
            $.alwaysUseTextKey = alwaysUseTextKey;
            return this;
        }

        /**
         * @param alwaysUseTextKey Whether to always store text inside an object using the text key even when no attributes exist.
         * 
         * @return builder
         * 
         */
        public Builder alwaysUseTextKey(Boolean alwaysUseTextKey) {
            return alwaysUseTextKey(Output.of(alwaysUseTextKey));
        }

        /**
         * @param attrPrefix The prefix to use for XML attributes in the parsed output. If the field is left empty, the original attribute key is used.
         * 
         * @return builder
         * 
         */
        public Builder attrPrefix(@Nullable Output<String> attrPrefix) {
            $.attrPrefix = attrPrefix;
            return this;
        }

        /**
         * @param attrPrefix The prefix to use for XML attributes in the parsed output. If the field is left empty, the original attribute key is used.
         * 
         * @return builder
         * 
         */
        public Builder attrPrefix(String attrPrefix) {
            return attrPrefix(Output.of(attrPrefix));
        }

        /**
         * @param field The path to the log field on which you want to parse XML.
         * 
         * @return builder
         * 
         */
        public Builder field(Output<String> field) {
            $.field = field;
            return this;
        }

        /**
         * @param field The path to the log field on which you want to parse XML.
         * 
         * @return builder
         * 
         */
        public Builder field(String field) {
            return field(Output.of(field));
        }

        /**
         * @param includeAttr Whether to include XML attributes in the parsed output.
         * 
         * @return builder
         * 
         */
        public Builder includeAttr(@Nullable Output<Boolean> includeAttr) {
            $.includeAttr = includeAttr;
            return this;
        }

        /**
         * @param includeAttr Whether to include XML attributes in the parsed output.
         * 
         * @return builder
         * 
         */
        public Builder includeAttr(Boolean includeAttr) {
            return includeAttr(Output.of(includeAttr));
        }

        /**
         * @param parseBool Whether to parse boolean values from strings.
         * 
         * @return builder
         * 
         */
        public Builder parseBool(@Nullable Output<Boolean> parseBool) {
            $.parseBool = parseBool;
            return this;
        }

        /**
         * @param parseBool Whether to parse boolean values from strings.
         * 
         * @return builder
         * 
         */
        public Builder parseBool(Boolean parseBool) {
            return parseBool(Output.of(parseBool));
        }

        /**
         * @param parseNull Whether to parse null values.
         * 
         * @return builder
         * 
         */
        public Builder parseNull(@Nullable Output<Boolean> parseNull) {
            $.parseNull = parseNull;
            return this;
        }

        /**
         * @param parseNull Whether to parse null values.
         * 
         * @return builder
         * 
         */
        public Builder parseNull(Boolean parseNull) {
            return parseNull(Output.of(parseNull));
        }

        /**
         * @param parseNumber Whether to parse numeric values from strings.
         * 
         * @return builder
         * 
         */
        public Builder parseNumber(@Nullable Output<Boolean> parseNumber) {
            $.parseNumber = parseNumber;
            return this;
        }

        /**
         * @param parseNumber Whether to parse numeric values from strings.
         * 
         * @return builder
         * 
         */
        public Builder parseNumber(Boolean parseNumber) {
            return parseNumber(Output.of(parseNumber));
        }

        /**
         * @param textKey The key name to use for the text node when XML attributes are appended.
         * 
         * @return builder
         * 
         */
        public Builder textKey(@Nullable Output<String> textKey) {
            $.textKey = textKey;
            return this;
        }

        /**
         * @param textKey The key name to use for the text node when XML attributes are appended.
         * 
         * @return builder
         * 
         */
        public Builder textKey(String textKey) {
            return textKey(Output.of(textKey));
        }

        public ObservabilityPipelineConfigProcessorGroupProcessorParseXmlArgs build() {
            if ($.field == null) {
                throw new MissingRequiredPropertyException("ObservabilityPipelineConfigProcessorGroupProcessorParseXmlArgs", "field");
            }
            return $;
        }
    }

}

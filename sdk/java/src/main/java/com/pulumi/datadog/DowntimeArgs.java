// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.datadog;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.datadog.inputs.DowntimeRecurrenceArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class DowntimeArgs extends com.pulumi.resources.ResourceArgs {

    public static final DowntimeArgs Empty = new DowntimeArgs();

    /**
     * Optionally specify an end date when this downtime should expire
     * 
     */
    @Import(name="end")
    private @Nullable Output<Integer> end;

    /**
     * @return Optionally specify an end date when this downtime should expire
     * 
     */
    public Optional<Output<Integer>> end() {
        return Optional.ofNullable(this.end);
    }

    /**
     * String representing date and time to end the downtime in RFC3339 format.
     * 
     */
    @Import(name="endDate")
    private @Nullable Output<String> endDate;

    /**
     * @return String representing date and time to end the downtime in RFC3339 format.
     * 
     */
    public Optional<Output<String>> endDate() {
        return Optional.ofNullable(this.endDate);
    }

    /**
     * An optional message to provide when creating the downtime, can include notification handles
     * 
     */
    @Import(name="message")
    private @Nullable Output<String> message;

    /**
     * @return An optional message to provide when creating the downtime, can include notification handles
     * 
     */
    public Optional<Output<String>> message() {
        return Optional.ofNullable(this.message);
    }

    /**
     * When specified, this downtime will only apply to this monitor
     * 
     */
    @Import(name="monitorId")
    private @Nullable Output<Integer> monitorId;

    /**
     * @return When specified, this downtime will only apply to this monitor
     * 
     */
    public Optional<Output<Integer>> monitorId() {
        return Optional.ofNullable(this.monitorId);
    }

    /**
     * A list of monitor tags (up to 32) to base the scheduled downtime on. Only monitors that have all selected tags are
     * silenced
     * 
     */
    @Import(name="monitorTags")
    private @Nullable Output<List<String>> monitorTags;

    /**
     * @return A list of monitor tags (up to 32) to base the scheduled downtime on. Only monitors that have all selected tags are
     * silenced
     * 
     */
    public Optional<Output<List<String>>> monitorTags() {
        return Optional.ofNullable(this.monitorTags);
    }

    /**
     * When true the first recovery notification during the downtime will be muted
     * 
     */
    @Import(name="muteFirstRecoveryNotification")
    private @Nullable Output<Boolean> muteFirstRecoveryNotification;

    /**
     * @return When true the first recovery notification during the downtime will be muted
     * 
     */
    public Optional<Output<Boolean>> muteFirstRecoveryNotification() {
        return Optional.ofNullable(this.muteFirstRecoveryNotification);
    }

    /**
     * Optional recurring schedule for this downtime
     * 
     */
    @Import(name="recurrence")
    private @Nullable Output<DowntimeRecurrenceArgs> recurrence;

    /**
     * @return Optional recurring schedule for this downtime
     * 
     */
    public Optional<Output<DowntimeRecurrenceArgs>> recurrence() {
        return Optional.ofNullable(this.recurrence);
    }

    /**
     * specify the group scope to which this downtime applies. For everything use &#39;*&#39;
     * 
     */
    @Import(name="scopes", required=true)
    private Output<List<String>> scopes;

    /**
     * @return specify the group scope to which this downtime applies. For everything use &#39;*&#39;
     * 
     */
    public Output<List<String>> scopes() {
        return this.scopes;
    }

    /**
     * Specify when this downtime should start
     * 
     */
    @Import(name="start")
    private @Nullable Output<Integer> start;

    /**
     * @return Specify when this downtime should start
     * 
     */
    public Optional<Output<Integer>> start() {
        return Optional.ofNullable(this.start);
    }

    /**
     * String representing date and time to start the downtime in RFC3339 format.
     * 
     */
    @Import(name="startDate")
    private @Nullable Output<String> startDate;

    /**
     * @return String representing date and time to start the downtime in RFC3339 format.
     * 
     */
    public Optional<Output<String>> startDate() {
        return Optional.ofNullable(this.startDate);
    }

    /**
     * The timezone for the downtime, default UTC
     * 
     */
    @Import(name="timezone")
    private @Nullable Output<String> timezone;

    /**
     * @return The timezone for the downtime, default UTC
     * 
     */
    public Optional<Output<String>> timezone() {
        return Optional.ofNullable(this.timezone);
    }

    private DowntimeArgs() {}

    private DowntimeArgs(DowntimeArgs $) {
        this.end = $.end;
        this.endDate = $.endDate;
        this.message = $.message;
        this.monitorId = $.monitorId;
        this.monitorTags = $.monitorTags;
        this.muteFirstRecoveryNotification = $.muteFirstRecoveryNotification;
        this.recurrence = $.recurrence;
        this.scopes = $.scopes;
        this.start = $.start;
        this.startDate = $.startDate;
        this.timezone = $.timezone;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(DowntimeArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private DowntimeArgs $;

        public Builder() {
            $ = new DowntimeArgs();
        }

        public Builder(DowntimeArgs defaults) {
            $ = new DowntimeArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param end Optionally specify an end date when this downtime should expire
         * 
         * @return builder
         * 
         */
        public Builder end(@Nullable Output<Integer> end) {
            $.end = end;
            return this;
        }

        /**
         * @param end Optionally specify an end date when this downtime should expire
         * 
         * @return builder
         * 
         */
        public Builder end(Integer end) {
            return end(Output.of(end));
        }

        /**
         * @param endDate String representing date and time to end the downtime in RFC3339 format.
         * 
         * @return builder
         * 
         */
        public Builder endDate(@Nullable Output<String> endDate) {
            $.endDate = endDate;
            return this;
        }

        /**
         * @param endDate String representing date and time to end the downtime in RFC3339 format.
         * 
         * @return builder
         * 
         */
        public Builder endDate(String endDate) {
            return endDate(Output.of(endDate));
        }

        /**
         * @param message An optional message to provide when creating the downtime, can include notification handles
         * 
         * @return builder
         * 
         */
        public Builder message(@Nullable Output<String> message) {
            $.message = message;
            return this;
        }

        /**
         * @param message An optional message to provide when creating the downtime, can include notification handles
         * 
         * @return builder
         * 
         */
        public Builder message(String message) {
            return message(Output.of(message));
        }

        /**
         * @param monitorId When specified, this downtime will only apply to this monitor
         * 
         * @return builder
         * 
         */
        public Builder monitorId(@Nullable Output<Integer> monitorId) {
            $.monitorId = monitorId;
            return this;
        }

        /**
         * @param monitorId When specified, this downtime will only apply to this monitor
         * 
         * @return builder
         * 
         */
        public Builder monitorId(Integer monitorId) {
            return monitorId(Output.of(monitorId));
        }

        /**
         * @param monitorTags A list of monitor tags (up to 32) to base the scheduled downtime on. Only monitors that have all selected tags are
         * silenced
         * 
         * @return builder
         * 
         */
        public Builder monitorTags(@Nullable Output<List<String>> monitorTags) {
            $.monitorTags = monitorTags;
            return this;
        }

        /**
         * @param monitorTags A list of monitor tags (up to 32) to base the scheduled downtime on. Only monitors that have all selected tags are
         * silenced
         * 
         * @return builder
         * 
         */
        public Builder monitorTags(List<String> monitorTags) {
            return monitorTags(Output.of(monitorTags));
        }

        /**
         * @param monitorTags A list of monitor tags (up to 32) to base the scheduled downtime on. Only monitors that have all selected tags are
         * silenced
         * 
         * @return builder
         * 
         */
        public Builder monitorTags(String... monitorTags) {
            return monitorTags(List.of(monitorTags));
        }

        /**
         * @param muteFirstRecoveryNotification When true the first recovery notification during the downtime will be muted
         * 
         * @return builder
         * 
         */
        public Builder muteFirstRecoveryNotification(@Nullable Output<Boolean> muteFirstRecoveryNotification) {
            $.muteFirstRecoveryNotification = muteFirstRecoveryNotification;
            return this;
        }

        /**
         * @param muteFirstRecoveryNotification When true the first recovery notification during the downtime will be muted
         * 
         * @return builder
         * 
         */
        public Builder muteFirstRecoveryNotification(Boolean muteFirstRecoveryNotification) {
            return muteFirstRecoveryNotification(Output.of(muteFirstRecoveryNotification));
        }

        /**
         * @param recurrence Optional recurring schedule for this downtime
         * 
         * @return builder
         * 
         */
        public Builder recurrence(@Nullable Output<DowntimeRecurrenceArgs> recurrence) {
            $.recurrence = recurrence;
            return this;
        }

        /**
         * @param recurrence Optional recurring schedule for this downtime
         * 
         * @return builder
         * 
         */
        public Builder recurrence(DowntimeRecurrenceArgs recurrence) {
            return recurrence(Output.of(recurrence));
        }

        /**
         * @param scopes specify the group scope to which this downtime applies. For everything use &#39;*&#39;
         * 
         * @return builder
         * 
         */
        public Builder scopes(Output<List<String>> scopes) {
            $.scopes = scopes;
            return this;
        }

        /**
         * @param scopes specify the group scope to which this downtime applies. For everything use &#39;*&#39;
         * 
         * @return builder
         * 
         */
        public Builder scopes(List<String> scopes) {
            return scopes(Output.of(scopes));
        }

        /**
         * @param scopes specify the group scope to which this downtime applies. For everything use &#39;*&#39;
         * 
         * @return builder
         * 
         */
        public Builder scopes(String... scopes) {
            return scopes(List.of(scopes));
        }

        /**
         * @param start Specify when this downtime should start
         * 
         * @return builder
         * 
         */
        public Builder start(@Nullable Output<Integer> start) {
            $.start = start;
            return this;
        }

        /**
         * @param start Specify when this downtime should start
         * 
         * @return builder
         * 
         */
        public Builder start(Integer start) {
            return start(Output.of(start));
        }

        /**
         * @param startDate String representing date and time to start the downtime in RFC3339 format.
         * 
         * @return builder
         * 
         */
        public Builder startDate(@Nullable Output<String> startDate) {
            $.startDate = startDate;
            return this;
        }

        /**
         * @param startDate String representing date and time to start the downtime in RFC3339 format.
         * 
         * @return builder
         * 
         */
        public Builder startDate(String startDate) {
            return startDate(Output.of(startDate));
        }

        /**
         * @param timezone The timezone for the downtime, default UTC
         * 
         * @return builder
         * 
         */
        public Builder timezone(@Nullable Output<String> timezone) {
            $.timezone = timezone;
            return this;
        }

        /**
         * @param timezone The timezone for the downtime, default UTC
         * 
         * @return builder
         * 
         */
        public Builder timezone(String timezone) {
            return timezone(Output.of(timezone));
        }

        public DowntimeArgs build() {
            $.scopes = Objects.requireNonNull($.scopes, "expected parameter 'scopes' to be non-null");
            return $;
        }
    }

}

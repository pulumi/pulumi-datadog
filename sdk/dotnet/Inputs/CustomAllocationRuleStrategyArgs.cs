// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Datadog.Inputs
{

    public sealed class CustomAllocationRuleStrategyArgs : global::Pulumi.ResourceArgs
    {
        [Input("allocatedBies")]
        private InputList<Inputs.CustomAllocationRuleStrategyAllocatedByArgs>? _allocatedBies;
        public InputList<Inputs.CustomAllocationRuleStrategyAllocatedByArgs> AllocatedBies
        {
            get => _allocatedBies ?? (_allocatedBies = new InputList<Inputs.CustomAllocationRuleStrategyAllocatedByArgs>());
            set => _allocatedBies = value;
        }

        [Input("allocatedByFilters")]
        private InputList<Inputs.CustomAllocationRuleStrategyAllocatedByFilterArgs>? _allocatedByFilters;
        public InputList<Inputs.CustomAllocationRuleStrategyAllocatedByFilterArgs> AllocatedByFilters
        {
            get => _allocatedByFilters ?? (_allocatedByFilters = new InputList<Inputs.CustomAllocationRuleStrategyAllocatedByFilterArgs>());
            set => _allocatedByFilters = value;
        }

        [Input("allocatedByTagKeys")]
        private InputList<string>? _allocatedByTagKeys;

        /// <summary>
        /// List of tag keys used to allocate costs (e.g., `["team", "project"]`). Costs will be distributed across unique values of these tags.
        /// </summary>
        public InputList<string> AllocatedByTagKeys
        {
            get => _allocatedByTagKeys ?? (_allocatedByTagKeys = new InputList<string>());
            set => _allocatedByTagKeys = value;
        }

        [Input("basedOnCosts")]
        private InputList<Inputs.CustomAllocationRuleStrategyBasedOnCostArgs>? _basedOnCosts;
        public InputList<Inputs.CustomAllocationRuleStrategyBasedOnCostArgs> BasedOnCosts
        {
            get => _basedOnCosts ?? (_basedOnCosts = new InputList<Inputs.CustomAllocationRuleStrategyBasedOnCostArgs>());
            set => _basedOnCosts = value;
        }

        [Input("basedOnTimeseries")]
        public Input<Inputs.CustomAllocationRuleStrategyBasedOnTimeseriesArgs>? BasedOnTimeseries { get; set; }

        [Input("evaluateGroupedByFilters")]
        private InputList<Inputs.CustomAllocationRuleStrategyEvaluateGroupedByFilterArgs>? _evaluateGroupedByFilters;
        public InputList<Inputs.CustomAllocationRuleStrategyEvaluateGroupedByFilterArgs> EvaluateGroupedByFilters
        {
            get => _evaluateGroupedByFilters ?? (_evaluateGroupedByFilters = new InputList<Inputs.CustomAllocationRuleStrategyEvaluateGroupedByFilterArgs>());
            set => _evaluateGroupedByFilters = value;
        }

        [Input("evaluateGroupedByTagKeys")]
        private InputList<string>? _evaluateGroupedByTagKeys;

        /// <summary>
        /// List of tag keys used to group costs before allocation. Costs are grouped by these tag values before applying the allocation strategy.
        /// </summary>
        public InputList<string> EvaluateGroupedByTagKeys
        {
            get => _evaluateGroupedByTagKeys ?? (_evaluateGroupedByTagKeys = new InputList<string>());
            set => _evaluateGroupedByTagKeys = value;
        }

        /// <summary>
        /// The granularity level for cost allocation. Valid values are `Daily` or `Monthly`.
        /// </summary>
        [Input("granularity")]
        public Input<string>? Granularity { get; set; }

        /// <summary>
        /// The allocation method. Valid values are `Even`, `Proportional`, `ProportionalTimeseries`, or `Percent`.
        /// </summary>
        [Input("method")]
        public Input<string>? Method { get; set; }

        public CustomAllocationRuleStrategyArgs()
        {
        }
        public static new CustomAllocationRuleStrategyArgs Empty => new CustomAllocationRuleStrategyArgs();
    }
}

# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'DashboardListDashItem',
    'DashboardTemplateVariable',
    'DashboardTemplateVariablePreset',
    'DashboardTemplateVariablePresetTemplateVariable',
    'DashboardWidget',
    'DashboardWidgetAlertGraphDefinition',
    'DashboardWidgetAlertGraphDefinitionTime',
    'DashboardWidgetAlertValueDefinition',
    'DashboardWidgetChangeDefinition',
    'DashboardWidgetChangeDefinitionCustomLink',
    'DashboardWidgetChangeDefinitionRequest',
    'DashboardWidgetChangeDefinitionRequestApmQuery',
    'DashboardWidgetChangeDefinitionRequestApmQueryCompute',
    'DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetChangeDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetChangeDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetChangeDefinitionRequestApmQuerySearch',
    'DashboardWidgetChangeDefinitionRequestLogQuery',
    'DashboardWidgetChangeDefinitionRequestLogQueryCompute',
    'DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetChangeDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetChangeDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetChangeDefinitionRequestLogQuerySearch',
    'DashboardWidgetChangeDefinitionRequestProcessQuery',
    'DashboardWidgetChangeDefinitionRequestRumQuery',
    'DashboardWidgetChangeDefinitionRequestRumQueryCompute',
    'DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetChangeDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetChangeDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetChangeDefinitionRequestRumQuerySearch',
    'DashboardWidgetChangeDefinitionRequestSecurityQuery',
    'DashboardWidgetChangeDefinitionRequestSecurityQueryCompute',
    'DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySort',
    'DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetChangeDefinitionRequestSecurityQuerySearch',
    'DashboardWidgetChangeDefinitionTime',
    'DashboardWidgetCheckStatusDefinition',
    'DashboardWidgetCheckStatusDefinitionTime',
    'DashboardWidgetDistributionDefinition',
    'DashboardWidgetDistributionDefinitionRequest',
    'DashboardWidgetDistributionDefinitionRequestApmQuery',
    'DashboardWidgetDistributionDefinitionRequestApmQueryCompute',
    'DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetDistributionDefinitionRequestApmQuerySearch',
    'DashboardWidgetDistributionDefinitionRequestLogQuery',
    'DashboardWidgetDistributionDefinitionRequestLogQueryCompute',
    'DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetDistributionDefinitionRequestLogQuerySearch',
    'DashboardWidgetDistributionDefinitionRequestProcessQuery',
    'DashboardWidgetDistributionDefinitionRequestRumQuery',
    'DashboardWidgetDistributionDefinitionRequestRumQueryCompute',
    'DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetDistributionDefinitionRequestRumQuerySearch',
    'DashboardWidgetDistributionDefinitionRequestSecurityQuery',
    'DashboardWidgetDistributionDefinitionRequestSecurityQueryCompute',
    'DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySort',
    'DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetDistributionDefinitionRequestSecurityQuerySearch',
    'DashboardWidgetDistributionDefinitionRequestStyle',
    'DashboardWidgetDistributionDefinitionTime',
    'DashboardWidgetEventStreamDefinition',
    'DashboardWidgetEventStreamDefinitionTime',
    'DashboardWidgetEventTimelineDefinition',
    'DashboardWidgetEventTimelineDefinitionTime',
    'DashboardWidgetFreeTextDefinition',
    'DashboardWidgetGeomapDefinition',
    'DashboardWidgetGeomapDefinitionCustomLink',
    'DashboardWidgetGeomapDefinitionRequest',
    'DashboardWidgetGeomapDefinitionRequestFormula',
    'DashboardWidgetGeomapDefinitionRequestFormulaLimit',
    'DashboardWidgetGeomapDefinitionRequestLogQuery',
    'DashboardWidgetGeomapDefinitionRequestLogQueryCompute',
    'DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGeomapDefinitionRequestLogQuerySearch',
    'DashboardWidgetGeomapDefinitionRequestQuery',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQuery',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetGeomapDefinitionRequestQueryMetricQuery',
    'DashboardWidgetGeomapDefinitionRequestQueryProcessQuery',
    'DashboardWidgetGeomapDefinitionRequestRumQuery',
    'DashboardWidgetGeomapDefinitionRequestRumQueryCompute',
    'DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGeomapDefinitionRequestRumQuerySearch',
    'DashboardWidgetGeomapDefinitionStyle',
    'DashboardWidgetGeomapDefinitionView',
    'DashboardWidgetGroupDefinition',
    'DashboardWidgetGroupDefinitionWidget',
    'DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition',
    'DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetAlertValueDefinition',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinition',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition',
    'DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinition',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetEventStreamDefinition',
    'DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition',
    'DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetFreeTextDefinition',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinition',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinition',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinition',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle',
    'DashboardWidgetGroupDefinitionWidgetIframeDefinition',
    'DashboardWidgetGroupDefinitionWidgetImageDefinition',
    'DashboardWidgetGroupDefinitionWidgetLayout',
    'DashboardWidgetGroupDefinitionWidgetLogStreamDefinition',
    'DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort',
    'DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetManageStatusDefinition',
    'DashboardWidgetGroupDefinitionWidgetNoteDefinition',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinition',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinition',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinition',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis',
    'DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition',
    'DashboardWidgetGroupDefinitionWidgetServicemapDefinition',
    'DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinition',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition',
    'DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionTime',
    'DashboardWidgetGroupDefinitionWidgetWidgetLayout',
    'DashboardWidgetHeatmapDefinition',
    'DashboardWidgetHeatmapDefinitionCustomLink',
    'DashboardWidgetHeatmapDefinitionEvent',
    'DashboardWidgetHeatmapDefinitionRequest',
    'DashboardWidgetHeatmapDefinitionRequestApmQuery',
    'DashboardWidgetHeatmapDefinitionRequestApmQueryCompute',
    'DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetHeatmapDefinitionRequestApmQuerySearch',
    'DashboardWidgetHeatmapDefinitionRequestLogQuery',
    'DashboardWidgetHeatmapDefinitionRequestLogQueryCompute',
    'DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetHeatmapDefinitionRequestLogQuerySearch',
    'DashboardWidgetHeatmapDefinitionRequestProcessQuery',
    'DashboardWidgetHeatmapDefinitionRequestRumQuery',
    'DashboardWidgetHeatmapDefinitionRequestRumQueryCompute',
    'DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetHeatmapDefinitionRequestRumQuerySearch',
    'DashboardWidgetHeatmapDefinitionRequestSecurityQuery',
    'DashboardWidgetHeatmapDefinitionRequestSecurityQueryCompute',
    'DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySort',
    'DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetHeatmapDefinitionRequestSecurityQuerySearch',
    'DashboardWidgetHeatmapDefinitionRequestStyle',
    'DashboardWidgetHeatmapDefinitionTime',
    'DashboardWidgetHeatmapDefinitionYaxis',
    'DashboardWidgetHostmapDefinition',
    'DashboardWidgetHostmapDefinitionCustomLink',
    'DashboardWidgetHostmapDefinitionRequest',
    'DashboardWidgetHostmapDefinitionRequestFill',
    'DashboardWidgetHostmapDefinitionRequestFillApmQuery',
    'DashboardWidgetHostmapDefinitionRequestFillApmQueryCompute',
    'DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery',
    'DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySort',
    'DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery',
    'DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute',
    'DashboardWidgetHostmapDefinitionRequestFillApmQuerySearch',
    'DashboardWidgetHostmapDefinitionRequestFillLogQuery',
    'DashboardWidgetHostmapDefinitionRequestFillLogQueryCompute',
    'DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery',
    'DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySort',
    'DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery',
    'DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute',
    'DashboardWidgetHostmapDefinitionRequestFillLogQuerySearch',
    'DashboardWidgetHostmapDefinitionRequestFillProcessQuery',
    'DashboardWidgetHostmapDefinitionRequestFillRumQuery',
    'DashboardWidgetHostmapDefinitionRequestFillRumQueryCompute',
    'DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery',
    'DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySort',
    'DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery',
    'DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute',
    'DashboardWidgetHostmapDefinitionRequestFillRumQuerySearch',
    'DashboardWidgetHostmapDefinitionRequestFillSecurityQuery',
    'DashboardWidgetHostmapDefinitionRequestFillSecurityQueryCompute',
    'DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery',
    'DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySort',
    'DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery',
    'DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute',
    'DashboardWidgetHostmapDefinitionRequestFillSecurityQuerySearch',
    'DashboardWidgetHostmapDefinitionRequestSize',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQueryCompute',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySort',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQuerySearch',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQueryCompute',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySort',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQuerySearch',
    'DashboardWidgetHostmapDefinitionRequestSizeProcessQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeRumQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeRumQueryCompute',
    'DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySort',
    'DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute',
    'DashboardWidgetHostmapDefinitionRequestSizeRumQuerySearch',
    'DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryCompute',
    'DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySort',
    'DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute',
    'DashboardWidgetHostmapDefinitionRequestSizeSecurityQuerySearch',
    'DashboardWidgetHostmapDefinitionStyle',
    'DashboardWidgetIframeDefinition',
    'DashboardWidgetImageDefinition',
    'DashboardWidgetLayout',
    'DashboardWidgetLogStreamDefinition',
    'DashboardWidgetLogStreamDefinitionSort',
    'DashboardWidgetLogStreamDefinitionTime',
    'DashboardWidgetManageStatusDefinition',
    'DashboardWidgetNoteDefinition',
    'DashboardWidgetQueryTableDefinition',
    'DashboardWidgetQueryTableDefinitionCustomLink',
    'DashboardWidgetQueryTableDefinitionRequest',
    'DashboardWidgetQueryTableDefinitionRequestApmQuery',
    'DashboardWidgetQueryTableDefinitionRequestApmQueryCompute',
    'DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetQueryTableDefinitionRequestApmQuerySearch',
    'DashboardWidgetQueryTableDefinitionRequestApmStatsQuery',
    'DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn',
    'DashboardWidgetQueryTableDefinitionRequestConditionalFormat',
    'DashboardWidgetQueryTableDefinitionRequestLogQuery',
    'DashboardWidgetQueryTableDefinitionRequestLogQueryCompute',
    'DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetQueryTableDefinitionRequestLogQuerySearch',
    'DashboardWidgetQueryTableDefinitionRequestProcessQuery',
    'DashboardWidgetQueryTableDefinitionRequestRumQuery',
    'DashboardWidgetQueryTableDefinitionRequestRumQueryCompute',
    'DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetQueryTableDefinitionRequestRumQuerySearch',
    'DashboardWidgetQueryTableDefinitionRequestSecurityQuery',
    'DashboardWidgetQueryTableDefinitionRequestSecurityQueryCompute',
    'DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySort',
    'DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetQueryTableDefinitionRequestSecurityQuerySearch',
    'DashboardWidgetQueryTableDefinitionTime',
    'DashboardWidgetQueryValueDefinition',
    'DashboardWidgetQueryValueDefinitionCustomLink',
    'DashboardWidgetQueryValueDefinitionRequest',
    'DashboardWidgetQueryValueDefinitionRequestApmQuery',
    'DashboardWidgetQueryValueDefinitionRequestApmQueryCompute',
    'DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetQueryValueDefinitionRequestApmQuerySearch',
    'DashboardWidgetQueryValueDefinitionRequestConditionalFormat',
    'DashboardWidgetQueryValueDefinitionRequestFormula',
    'DashboardWidgetQueryValueDefinitionRequestFormulaLimit',
    'DashboardWidgetQueryValueDefinitionRequestLogQuery',
    'DashboardWidgetQueryValueDefinitionRequestLogQueryCompute',
    'DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetQueryValueDefinitionRequestLogQuerySearch',
    'DashboardWidgetQueryValueDefinitionRequestProcessQuery',
    'DashboardWidgetQueryValueDefinitionRequestQuery',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQuery',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery',
    'DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery',
    'DashboardWidgetQueryValueDefinitionRequestRumQuery',
    'DashboardWidgetQueryValueDefinitionRequestRumQueryCompute',
    'DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetQueryValueDefinitionRequestRumQuerySearch',
    'DashboardWidgetQueryValueDefinitionRequestSecurityQuery',
    'DashboardWidgetQueryValueDefinitionRequestSecurityQueryCompute',
    'DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySort',
    'DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetQueryValueDefinitionRequestSecurityQuerySearch',
    'DashboardWidgetQueryValueDefinitionTime',
    'DashboardWidgetScatterplotDefinition',
    'DashboardWidgetScatterplotDefinitionCustomLink',
    'DashboardWidgetScatterplotDefinitionRequest',
    'DashboardWidgetScatterplotDefinitionRequestX',
    'DashboardWidgetScatterplotDefinitionRequestXApmQuery',
    'DashboardWidgetScatterplotDefinitionRequestXApmQueryCompute',
    'DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery',
    'DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySort',
    'DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery',
    'DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute',
    'DashboardWidgetScatterplotDefinitionRequestXApmQuerySearch',
    'DashboardWidgetScatterplotDefinitionRequestXLogQuery',
    'DashboardWidgetScatterplotDefinitionRequestXLogQueryCompute',
    'DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery',
    'DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySort',
    'DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery',
    'DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute',
    'DashboardWidgetScatterplotDefinitionRequestXLogQuerySearch',
    'DashboardWidgetScatterplotDefinitionRequestXProcessQuery',
    'DashboardWidgetScatterplotDefinitionRequestXRumQuery',
    'DashboardWidgetScatterplotDefinitionRequestXRumQueryCompute',
    'DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery',
    'DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySort',
    'DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery',
    'DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute',
    'DashboardWidgetScatterplotDefinitionRequestXRumQuerySearch',
    'DashboardWidgetScatterplotDefinitionRequestXSecurityQuery',
    'DashboardWidgetScatterplotDefinitionRequestXSecurityQueryCompute',
    'DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery',
    'DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySort',
    'DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery',
    'DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute',
    'DashboardWidgetScatterplotDefinitionRequestXSecurityQuerySearch',
    'DashboardWidgetScatterplotDefinitionRequestY',
    'DashboardWidgetScatterplotDefinitionRequestYApmQuery',
    'DashboardWidgetScatterplotDefinitionRequestYApmQueryCompute',
    'DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery',
    'DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySort',
    'DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery',
    'DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute',
    'DashboardWidgetScatterplotDefinitionRequestYApmQuerySearch',
    'DashboardWidgetScatterplotDefinitionRequestYLogQuery',
    'DashboardWidgetScatterplotDefinitionRequestYLogQueryCompute',
    'DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery',
    'DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySort',
    'DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery',
    'DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute',
    'DashboardWidgetScatterplotDefinitionRequestYLogQuerySearch',
    'DashboardWidgetScatterplotDefinitionRequestYProcessQuery',
    'DashboardWidgetScatterplotDefinitionRequestYRumQuery',
    'DashboardWidgetScatterplotDefinitionRequestYRumQueryCompute',
    'DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery',
    'DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySort',
    'DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery',
    'DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute',
    'DashboardWidgetScatterplotDefinitionRequestYRumQuerySearch',
    'DashboardWidgetScatterplotDefinitionRequestYSecurityQuery',
    'DashboardWidgetScatterplotDefinitionRequestYSecurityQueryCompute',
    'DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery',
    'DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySort',
    'DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery',
    'DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute',
    'DashboardWidgetScatterplotDefinitionRequestYSecurityQuerySearch',
    'DashboardWidgetScatterplotDefinitionTime',
    'DashboardWidgetScatterplotDefinitionXaxis',
    'DashboardWidgetScatterplotDefinitionYaxis',
    'DashboardWidgetServiceLevelObjectiveDefinition',
    'DashboardWidgetServicemapDefinition',
    'DashboardWidgetServicemapDefinitionCustomLink',
    'DashboardWidgetTimeseriesDefinition',
    'DashboardWidgetTimeseriesDefinitionCustomLink',
    'DashboardWidgetTimeseriesDefinitionEvent',
    'DashboardWidgetTimeseriesDefinitionMarker',
    'DashboardWidgetTimeseriesDefinitionRequest',
    'DashboardWidgetTimeseriesDefinitionRequestApmQuery',
    'DashboardWidgetTimeseriesDefinitionRequestApmQueryCompute',
    'DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetTimeseriesDefinitionRequestApmQuerySearch',
    'DashboardWidgetTimeseriesDefinitionRequestFormula',
    'DashboardWidgetTimeseriesDefinitionRequestFormulaLimit',
    'DashboardWidgetTimeseriesDefinitionRequestLogQuery',
    'DashboardWidgetTimeseriesDefinitionRequestLogQueryCompute',
    'DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetTimeseriesDefinitionRequestLogQuerySearch',
    'DashboardWidgetTimeseriesDefinitionRequestMetadata',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQuery',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryCompute',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySort',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQuerySearch',
    'DashboardWidgetTimeseriesDefinitionRequestProcessQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery',
    'DashboardWidgetTimeseriesDefinitionRequestRumQuery',
    'DashboardWidgetTimeseriesDefinitionRequestRumQueryCompute',
    'DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetTimeseriesDefinitionRequestRumQuerySearch',
    'DashboardWidgetTimeseriesDefinitionRequestSecurityQuery',
    'DashboardWidgetTimeseriesDefinitionRequestSecurityQueryCompute',
    'DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySort',
    'DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetTimeseriesDefinitionRequestSecurityQuerySearch',
    'DashboardWidgetTimeseriesDefinitionRequestStyle',
    'DashboardWidgetTimeseriesDefinitionRightYaxis',
    'DashboardWidgetTimeseriesDefinitionTime',
    'DashboardWidgetTimeseriesDefinitionYaxis',
    'DashboardWidgetToplistDefinition',
    'DashboardWidgetToplistDefinitionCustomLink',
    'DashboardWidgetToplistDefinitionRequest',
    'DashboardWidgetToplistDefinitionRequestApmQuery',
    'DashboardWidgetToplistDefinitionRequestApmQueryCompute',
    'DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetToplistDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetToplistDefinitionRequestApmQueryGroupBySort',
    'DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetToplistDefinitionRequestApmQuerySearch',
    'DashboardWidgetToplistDefinitionRequestConditionalFormat',
    'DashboardWidgetToplistDefinitionRequestFormula',
    'DashboardWidgetToplistDefinitionRequestFormulaLimit',
    'DashboardWidgetToplistDefinitionRequestLogQuery',
    'DashboardWidgetToplistDefinitionRequestLogQueryCompute',
    'DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetToplistDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetToplistDefinitionRequestLogQueryGroupBySort',
    'DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetToplistDefinitionRequestLogQuerySearch',
    'DashboardWidgetToplistDefinitionRequestProcessQuery',
    'DashboardWidgetToplistDefinitionRequestQuery',
    'DashboardWidgetToplistDefinitionRequestQueryEventQuery',
    'DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetToplistDefinitionRequestQueryMetricQuery',
    'DashboardWidgetToplistDefinitionRequestQueryProcessQuery',
    'DashboardWidgetToplistDefinitionRequestRumQuery',
    'DashboardWidgetToplistDefinitionRequestRumQueryCompute',
    'DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetToplistDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetToplistDefinitionRequestRumQueryGroupBySort',
    'DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetToplistDefinitionRequestRumQuerySearch',
    'DashboardWidgetToplistDefinitionRequestSecurityQuery',
    'DashboardWidgetToplistDefinitionRequestSecurityQueryCompute',
    'DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySort',
    'DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetToplistDefinitionRequestSecurityQuerySearch',
    'DashboardWidgetToplistDefinitionRequestStyle',
    'DashboardWidgetToplistDefinitionTime',
    'DashboardWidgetTraceServiceDefinition',
    'DashboardWidgetTraceServiceDefinitionTime',
    'DashboardWidgetWidgetLayout',
    'DowntimeRecurrence',
    'LogsArchiveAzure',
    'LogsArchiveAzureArchive',
    'LogsArchiveGcs',
    'LogsArchiveGcsArchive',
    'LogsArchiveS3',
    'LogsArchiveS3Archive',
    'LogsCustomPipelineFilter',
    'LogsCustomPipelineProcessor',
    'LogsCustomPipelineProcessorArithmeticProcessor',
    'LogsCustomPipelineProcessorAttributeRemapper',
    'LogsCustomPipelineProcessorCategoryProcessor',
    'LogsCustomPipelineProcessorCategoryProcessorCategory',
    'LogsCustomPipelineProcessorCategoryProcessorCategoryFilter',
    'LogsCustomPipelineProcessorDateRemapper',
    'LogsCustomPipelineProcessorGeoIpParser',
    'LogsCustomPipelineProcessorGrokParser',
    'LogsCustomPipelineProcessorGrokParserGrok',
    'LogsCustomPipelineProcessorLookupProcessor',
    'LogsCustomPipelineProcessorMessageRemapper',
    'LogsCustomPipelineProcessorPipeline',
    'LogsCustomPipelineProcessorPipelineFilter',
    'LogsCustomPipelineProcessorPipelineProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter',
    'LogsCustomPipelineProcessorPipelineProcessorDateRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorGeoIpParser',
    'LogsCustomPipelineProcessorPipelineProcessorGrokParser',
    'LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok',
    'LogsCustomPipelineProcessorPipelineProcessorLookupProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorMessageRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorServiceRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorStatusRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorUrlParser',
    'LogsCustomPipelineProcessorPipelineProcessorUserAgentParser',
    'LogsCustomPipelineProcessorServiceRemapper',
    'LogsCustomPipelineProcessorStatusRemapper',
    'LogsCustomPipelineProcessorStringBuilderProcessor',
    'LogsCustomPipelineProcessorTraceIdRemapper',
    'LogsCustomPipelineProcessorUrlParser',
    'LogsCustomPipelineProcessorUserAgentParser',
    'LogsIndexExclusionFilter',
    'LogsIndexExclusionFilterFilter',
    'LogsIndexFilter',
    'LogsMetricCompute',
    'LogsMetricFilter',
    'LogsMetricGroupBy',
    'MonitorMonitorThresholdWindows',
    'MonitorMonitorThresholds',
    'MonitorThresholdWindows',
    'MonitorThresholds',
    'RolePermission',
    'ScreenBoardTemplateVariable',
    'ScreenBoardWidget',
    'ScreenBoardWidgetRule',
    'ScreenBoardWidgetTileDef',
    'ScreenBoardWidgetTileDefEvent',
    'ScreenBoardWidgetTileDefMarker',
    'ScreenBoardWidgetTileDefRequest',
    'ScreenBoardWidgetTileDefRequestApmQuery',
    'ScreenBoardWidgetTileDefRequestApmQueryCompute',
    'ScreenBoardWidgetTileDefRequestApmQueryGroupBy',
    'ScreenBoardWidgetTileDefRequestApmQueryGroupBySort',
    'ScreenBoardWidgetTileDefRequestApmQuerySearch',
    'ScreenBoardWidgetTileDefRequestConditionalFormat',
    'ScreenBoardWidgetTileDefRequestLogQuery',
    'ScreenBoardWidgetTileDefRequestLogQueryCompute',
    'ScreenBoardWidgetTileDefRequestLogQueryGroupBy',
    'ScreenBoardWidgetTileDefRequestLogQueryGroupBySort',
    'ScreenBoardWidgetTileDefRequestLogQuerySearch',
    'ScreenBoardWidgetTileDefRequestProcessQuery',
    'SecurityMonitoringRuleCase',
    'SecurityMonitoringRuleOptions',
    'SecurityMonitoringRuleQuery',
    'ServiceLevelObjectiveQuery',
    'ServiceLevelObjectiveThreshold',
    'SyntheticsGlobalVariableParseTestOptions',
    'SyntheticsGlobalVariableParseTestOptionsParser',
    'SyntheticsTestApiStep',
    'SyntheticsTestApiStepAssertion',
    'SyntheticsTestApiStepAssertionTargetjsonpath',
    'SyntheticsTestApiStepExtractedValue',
    'SyntheticsTestApiStepExtractedValueParser',
    'SyntheticsTestApiStepRequestBasicauth',
    'SyntheticsTestApiStepRequestClientCertificate',
    'SyntheticsTestApiStepRequestClientCertificateCert',
    'SyntheticsTestApiStepRequestClientCertificateKey',
    'SyntheticsTestApiStepRequestDefinition',
    'SyntheticsTestBrowserStep',
    'SyntheticsTestBrowserStepParams',
    'SyntheticsTestBrowserStepParamsVariable',
    'SyntheticsTestBrowserVariable',
    'SyntheticsTestConfigVariable',
    'SyntheticsTestOptions',
    'SyntheticsTestOptionsList',
    'SyntheticsTestOptionsListMonitorOptions',
    'SyntheticsTestOptionsListRetry',
    'SyntheticsTestRequest',
    'SyntheticsTestRequestBasicauth',
    'SyntheticsTestRequestClientCertificate',
    'SyntheticsTestRequestClientCertificateCert',
    'SyntheticsTestRequestClientCertificateKey',
    'SyntheticsTestRequestDefinition',
    'SyntheticsTestStep',
    'SyntheticsTestVariable',
    'TimeBoardGraph',
    'TimeBoardGraphMarker',
    'TimeBoardGraphRequest',
    'TimeBoardGraphRequestApmQuery',
    'TimeBoardGraphRequestApmQueryCompute',
    'TimeBoardGraphRequestApmQueryGroupBy',
    'TimeBoardGraphRequestApmQueryGroupBySort',
    'TimeBoardGraphRequestApmQuerySearch',
    'TimeBoardGraphRequestConditionalFormat',
    'TimeBoardGraphRequestLogQuery',
    'TimeBoardGraphRequestLogQueryCompute',
    'TimeBoardGraphRequestLogQueryGroupBy',
    'TimeBoardGraphRequestLogQueryGroupBySort',
    'TimeBoardGraphRequestLogQuerySearch',
    'TimeBoardGraphRequestProcessQuery',
    'TimeBoardTemplateVariable',
    'GetMonitorMonitorThresholdWindowsResult',
    'GetMonitorMonitorThresholdsResult',
    'GetMonitorThresholdWindowsResult',
    'GetMonitorThresholdsResult',
    'GetSecurityMonitoringRulesRuleResult',
    'GetSecurityMonitoringRulesRuleCaseResult',
    'GetSecurityMonitoringRulesRuleOptionsResult',
    'GetSecurityMonitoringRulesRuleQueryResult',
]

@pulumi.output_type
class DashboardListDashItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashId":
            suggest = "dash_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardListDashItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardListDashItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardListDashItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dash_id: str,
                 type: str):
        """
        :param str dash_id: The ID of the dashboard to add
        :param str type: The type of this dashboard. Available options are: custom_timeboard, custom_screenboard, integration_screenboard, integration_timeboard, and host_timeboard
        """
        pulumi.set(__self__, "dash_id", dash_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dashId")
    def dash_id(self) -> str:
        """
        The ID of the dashboard to add
        """
        return pulumi.get(self, "dash_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of this dashboard. Available options are: custom_timeboard, custom_screenboard, integration_screenboard, integration_timeboard, and host_timeboard
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DashboardTemplateVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 default: Optional[str] = None,
                 prefix: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str default: The default value for the template variable on dashboard load.
        :param str prefix: The tag prefix associated with the variable. Only tags with this prefix will appear in the variable dropdown.
        """
        pulumi.set(__self__, "name", name)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def default(self) -> Optional[str]:
        """
        The default value for the template variable on dashboard load.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        The tag prefix associated with the variable. Only tags with this prefix will appear in the variable dropdown.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class DashboardTemplateVariablePreset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateVariables":
            suggest = "template_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTemplateVariablePreset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTemplateVariablePreset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTemplateVariablePreset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 template_variables: Optional[Sequence['outputs.DashboardTemplateVariablePresetTemplateVariable']] = None):
        """
        :param str name: The name of the preset.
        :param Sequence['DashboardTemplateVariablePresetTemplateVariableArgs'] template_variables: The template variable names and assumed values under the given preset
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if template_variables is not None:
            pulumi.set(__self__, "template_variables", template_variables)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the preset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="templateVariables")
    def template_variables(self) -> Optional[Sequence['outputs.DashboardTemplateVariablePresetTemplateVariable']]:
        """
        The template variable names and assumed values under the given preset
        """
        return pulumi.get(self, "template_variables")


@pulumi.output_type
class DashboardTemplateVariablePresetTemplateVariable(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: The name of the variable.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardWidget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertGraphDefinition":
            suggest = "alert_graph_definition"
        elif key == "alertValueDefinition":
            suggest = "alert_value_definition"
        elif key == "changeDefinition":
            suggest = "change_definition"
        elif key == "checkStatusDefinition":
            suggest = "check_status_definition"
        elif key == "distributionDefinition":
            suggest = "distribution_definition"
        elif key == "eventStreamDefinition":
            suggest = "event_stream_definition"
        elif key == "eventTimelineDefinition":
            suggest = "event_timeline_definition"
        elif key == "freeTextDefinition":
            suggest = "free_text_definition"
        elif key == "geomapDefinition":
            suggest = "geomap_definition"
        elif key == "groupDefinition":
            suggest = "group_definition"
        elif key == "heatmapDefinition":
            suggest = "heatmap_definition"
        elif key == "hostmapDefinition":
            suggest = "hostmap_definition"
        elif key == "iframeDefinition":
            suggest = "iframe_definition"
        elif key == "imageDefinition":
            suggest = "image_definition"
        elif key == "logStreamDefinition":
            suggest = "log_stream_definition"
        elif key == "manageStatusDefinition":
            suggest = "manage_status_definition"
        elif key == "noteDefinition":
            suggest = "note_definition"
        elif key == "queryTableDefinition":
            suggest = "query_table_definition"
        elif key == "queryValueDefinition":
            suggest = "query_value_definition"
        elif key == "scatterplotDefinition":
            suggest = "scatterplot_definition"
        elif key == "serviceLevelObjectiveDefinition":
            suggest = "service_level_objective_definition"
        elif key == "servicemapDefinition":
            suggest = "servicemap_definition"
        elif key == "timeseriesDefinition":
            suggest = "timeseries_definition"
        elif key == "toplistDefinition":
            suggest = "toplist_definition"
        elif key == "traceServiceDefinition":
            suggest = "trace_service_definition"
        elif key == "widgetLayout":
            suggest = "widget_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_graph_definition: Optional['outputs.DashboardWidgetAlertGraphDefinition'] = None,
                 alert_value_definition: Optional['outputs.DashboardWidgetAlertValueDefinition'] = None,
                 change_definition: Optional['outputs.DashboardWidgetChangeDefinition'] = None,
                 check_status_definition: Optional['outputs.DashboardWidgetCheckStatusDefinition'] = None,
                 distribution_definition: Optional['outputs.DashboardWidgetDistributionDefinition'] = None,
                 event_stream_definition: Optional['outputs.DashboardWidgetEventStreamDefinition'] = None,
                 event_timeline_definition: Optional['outputs.DashboardWidgetEventTimelineDefinition'] = None,
                 free_text_definition: Optional['outputs.DashboardWidgetFreeTextDefinition'] = None,
                 geomap_definition: Optional['outputs.DashboardWidgetGeomapDefinition'] = None,
                 group_definition: Optional['outputs.DashboardWidgetGroupDefinition'] = None,
                 heatmap_definition: Optional['outputs.DashboardWidgetHeatmapDefinition'] = None,
                 hostmap_definition: Optional['outputs.DashboardWidgetHostmapDefinition'] = None,
                 id: Optional[int] = None,
                 iframe_definition: Optional['outputs.DashboardWidgetIframeDefinition'] = None,
                 image_definition: Optional['outputs.DashboardWidgetImageDefinition'] = None,
                 layout: Optional['outputs.DashboardWidgetLayout'] = None,
                 log_stream_definition: Optional['outputs.DashboardWidgetLogStreamDefinition'] = None,
                 manage_status_definition: Optional['outputs.DashboardWidgetManageStatusDefinition'] = None,
                 note_definition: Optional['outputs.DashboardWidgetNoteDefinition'] = None,
                 query_table_definition: Optional['outputs.DashboardWidgetQueryTableDefinition'] = None,
                 query_value_definition: Optional['outputs.DashboardWidgetQueryValueDefinition'] = None,
                 scatterplot_definition: Optional['outputs.DashboardWidgetScatterplotDefinition'] = None,
                 service_level_objective_definition: Optional['outputs.DashboardWidgetServiceLevelObjectiveDefinition'] = None,
                 servicemap_definition: Optional['outputs.DashboardWidgetServicemapDefinition'] = None,
                 timeseries_definition: Optional['outputs.DashboardWidgetTimeseriesDefinition'] = None,
                 toplist_definition: Optional['outputs.DashboardWidgetToplistDefinition'] = None,
                 trace_service_definition: Optional['outputs.DashboardWidgetTraceServiceDefinition'] = None,
                 widget_layout: Optional['outputs.DashboardWidgetWidgetLayout'] = None):
        """
        :param 'DashboardWidgetChangeDefinitionArgs' change_definition: The definition for a Change  widget.
        :param 'DashboardWidgetDistributionDefinitionArgs' distribution_definition: The definition for a Distribution widget.
        :param 'DashboardWidgetGeomapDefinitionArgs' geomap_definition: The definition for a Geomap widget.
        :param 'DashboardWidgetGroupDefinitionArgs' group_definition: The definition for a Group widget.
        :param 'DashboardWidgetHeatmapDefinitionArgs' heatmap_definition: The definition for a Heatmap widget.
        :param 'DashboardWidgetHostmapDefinitionArgs' hostmap_definition: The definition for a Hostmap widget.
        :param int id: The ID of the widget.
        :param 'DashboardWidgetIframeDefinitionArgs' iframe_definition: The definition for an Iframe widget.
        :param 'DashboardWidgetImageDefinitionArgs' image_definition: The definition for an Image widget
        :param 'DashboardWidgetLayoutArgs' layout: The layout of the widget on a 'free' dashboard.  Define widget_layout list with one element instead.
        :param 'DashboardWidgetNoteDefinitionArgs' note_definition: The definition for a Note widget.
        :param 'DashboardWidgetScatterplotDefinitionArgs' scatterplot_definition: The definition for a Scatterplot widget.
        :param 'DashboardWidgetServicemapDefinitionArgs' servicemap_definition: The definition for a Service Map widget.
        :param 'DashboardWidgetTimeseriesDefinitionArgs' timeseries_definition: The definition for a Timeseries widget.
        :param 'DashboardWidgetToplistDefinitionArgs' toplist_definition: The definition for a Toplist widget.
        :param 'DashboardWidgetWidgetLayoutArgs' widget_layout: The layout of the widget on a 'free' dashboard.
        """
        if alert_graph_definition is not None:
            pulumi.set(__self__, "alert_graph_definition", alert_graph_definition)
        if alert_value_definition is not None:
            pulumi.set(__self__, "alert_value_definition", alert_value_definition)
        if change_definition is not None:
            pulumi.set(__self__, "change_definition", change_definition)
        if check_status_definition is not None:
            pulumi.set(__self__, "check_status_definition", check_status_definition)
        if distribution_definition is not None:
            pulumi.set(__self__, "distribution_definition", distribution_definition)
        if event_stream_definition is not None:
            pulumi.set(__self__, "event_stream_definition", event_stream_definition)
        if event_timeline_definition is not None:
            pulumi.set(__self__, "event_timeline_definition", event_timeline_definition)
        if free_text_definition is not None:
            pulumi.set(__self__, "free_text_definition", free_text_definition)
        if geomap_definition is not None:
            pulumi.set(__self__, "geomap_definition", geomap_definition)
        if group_definition is not None:
            pulumi.set(__self__, "group_definition", group_definition)
        if heatmap_definition is not None:
            pulumi.set(__self__, "heatmap_definition", heatmap_definition)
        if hostmap_definition is not None:
            pulumi.set(__self__, "hostmap_definition", hostmap_definition)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if iframe_definition is not None:
            pulumi.set(__self__, "iframe_definition", iframe_definition)
        if image_definition is not None:
            pulumi.set(__self__, "image_definition", image_definition)
        if layout is not None:
            pulumi.set(__self__, "layout", layout)
        if log_stream_definition is not None:
            pulumi.set(__self__, "log_stream_definition", log_stream_definition)
        if manage_status_definition is not None:
            pulumi.set(__self__, "manage_status_definition", manage_status_definition)
        if note_definition is not None:
            pulumi.set(__self__, "note_definition", note_definition)
        if query_table_definition is not None:
            pulumi.set(__self__, "query_table_definition", query_table_definition)
        if query_value_definition is not None:
            pulumi.set(__self__, "query_value_definition", query_value_definition)
        if scatterplot_definition is not None:
            pulumi.set(__self__, "scatterplot_definition", scatterplot_definition)
        if service_level_objective_definition is not None:
            pulumi.set(__self__, "service_level_objective_definition", service_level_objective_definition)
        if servicemap_definition is not None:
            pulumi.set(__self__, "servicemap_definition", servicemap_definition)
        if timeseries_definition is not None:
            pulumi.set(__self__, "timeseries_definition", timeseries_definition)
        if toplist_definition is not None:
            pulumi.set(__self__, "toplist_definition", toplist_definition)
        if trace_service_definition is not None:
            pulumi.set(__self__, "trace_service_definition", trace_service_definition)
        if widget_layout is not None:
            pulumi.set(__self__, "widget_layout", widget_layout)

    @property
    @pulumi.getter(name="alertGraphDefinition")
    def alert_graph_definition(self) -> Optional['outputs.DashboardWidgetAlertGraphDefinition']:
        return pulumi.get(self, "alert_graph_definition")

    @property
    @pulumi.getter(name="alertValueDefinition")
    def alert_value_definition(self) -> Optional['outputs.DashboardWidgetAlertValueDefinition']:
        return pulumi.get(self, "alert_value_definition")

    @property
    @pulumi.getter(name="changeDefinition")
    def change_definition(self) -> Optional['outputs.DashboardWidgetChangeDefinition']:
        """
        The definition for a Change  widget.
        """
        return pulumi.get(self, "change_definition")

    @property
    @pulumi.getter(name="checkStatusDefinition")
    def check_status_definition(self) -> Optional['outputs.DashboardWidgetCheckStatusDefinition']:
        return pulumi.get(self, "check_status_definition")

    @property
    @pulumi.getter(name="distributionDefinition")
    def distribution_definition(self) -> Optional['outputs.DashboardWidgetDistributionDefinition']:
        """
        The definition for a Distribution widget.
        """
        return pulumi.get(self, "distribution_definition")

    @property
    @pulumi.getter(name="eventStreamDefinition")
    def event_stream_definition(self) -> Optional['outputs.DashboardWidgetEventStreamDefinition']:
        return pulumi.get(self, "event_stream_definition")

    @property
    @pulumi.getter(name="eventTimelineDefinition")
    def event_timeline_definition(self) -> Optional['outputs.DashboardWidgetEventTimelineDefinition']:
        return pulumi.get(self, "event_timeline_definition")

    @property
    @pulumi.getter(name="freeTextDefinition")
    def free_text_definition(self) -> Optional['outputs.DashboardWidgetFreeTextDefinition']:
        return pulumi.get(self, "free_text_definition")

    @property
    @pulumi.getter(name="geomapDefinition")
    def geomap_definition(self) -> Optional['outputs.DashboardWidgetGeomapDefinition']:
        """
        The definition for a Geomap widget.
        """
        return pulumi.get(self, "geomap_definition")

    @property
    @pulumi.getter(name="groupDefinition")
    def group_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinition']:
        """
        The definition for a Group widget.
        """
        return pulumi.get(self, "group_definition")

    @property
    @pulumi.getter(name="heatmapDefinition")
    def heatmap_definition(self) -> Optional['outputs.DashboardWidgetHeatmapDefinition']:
        """
        The definition for a Heatmap widget.
        """
        return pulumi.get(self, "heatmap_definition")

    @property
    @pulumi.getter(name="hostmapDefinition")
    def hostmap_definition(self) -> Optional['outputs.DashboardWidgetHostmapDefinition']:
        """
        The definition for a Hostmap widget.
        """
        return pulumi.get(self, "hostmap_definition")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        The ID of the widget.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="iframeDefinition")
    def iframe_definition(self) -> Optional['outputs.DashboardWidgetIframeDefinition']:
        """
        The definition for an Iframe widget.
        """
        return pulumi.get(self, "iframe_definition")

    @property
    @pulumi.getter(name="imageDefinition")
    def image_definition(self) -> Optional['outputs.DashboardWidgetImageDefinition']:
        """
        The definition for an Image widget
        """
        return pulumi.get(self, "image_definition")

    @property
    @pulumi.getter
    def layout(self) -> Optional['outputs.DashboardWidgetLayout']:
        """
        The layout of the widget on a 'free' dashboard.  Define widget_layout list with one element instead.
        """
        return pulumi.get(self, "layout")

    @property
    @pulumi.getter(name="logStreamDefinition")
    def log_stream_definition(self) -> Optional['outputs.DashboardWidgetLogStreamDefinition']:
        return pulumi.get(self, "log_stream_definition")

    @property
    @pulumi.getter(name="manageStatusDefinition")
    def manage_status_definition(self) -> Optional['outputs.DashboardWidgetManageStatusDefinition']:
        return pulumi.get(self, "manage_status_definition")

    @property
    @pulumi.getter(name="noteDefinition")
    def note_definition(self) -> Optional['outputs.DashboardWidgetNoteDefinition']:
        """
        The definition for a Note widget.
        """
        return pulumi.get(self, "note_definition")

    @property
    @pulumi.getter(name="queryTableDefinition")
    def query_table_definition(self) -> Optional['outputs.DashboardWidgetQueryTableDefinition']:
        return pulumi.get(self, "query_table_definition")

    @property
    @pulumi.getter(name="queryValueDefinition")
    def query_value_definition(self) -> Optional['outputs.DashboardWidgetQueryValueDefinition']:
        return pulumi.get(self, "query_value_definition")

    @property
    @pulumi.getter(name="scatterplotDefinition")
    def scatterplot_definition(self) -> Optional['outputs.DashboardWidgetScatterplotDefinition']:
        """
        The definition for a Scatterplot widget.
        """
        return pulumi.get(self, "scatterplot_definition")

    @property
    @pulumi.getter(name="serviceLevelObjectiveDefinition")
    def service_level_objective_definition(self) -> Optional['outputs.DashboardWidgetServiceLevelObjectiveDefinition']:
        return pulumi.get(self, "service_level_objective_definition")

    @property
    @pulumi.getter(name="servicemapDefinition")
    def servicemap_definition(self) -> Optional['outputs.DashboardWidgetServicemapDefinition']:
        """
        The definition for a Service Map widget.
        """
        return pulumi.get(self, "servicemap_definition")

    @property
    @pulumi.getter(name="timeseriesDefinition")
    def timeseries_definition(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinition']:
        """
        The definition for a Timeseries widget.
        """
        return pulumi.get(self, "timeseries_definition")

    @property
    @pulumi.getter(name="toplistDefinition")
    def toplist_definition(self) -> Optional['outputs.DashboardWidgetToplistDefinition']:
        """
        The definition for a Toplist widget.
        """
        return pulumi.get(self, "toplist_definition")

    @property
    @pulumi.getter(name="traceServiceDefinition")
    def trace_service_definition(self) -> Optional['outputs.DashboardWidgetTraceServiceDefinition']:
        return pulumi.get(self, "trace_service_definition")

    @property
    @pulumi.getter(name="widgetLayout")
    def widget_layout(self) -> Optional['outputs.DashboardWidgetWidgetLayout']:
        """
        The layout of the widget on a 'free' dashboard.
        """
        return pulumi.get(self, "widget_layout")


@pulumi.output_type
class DashboardWidgetAlertGraphDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertId":
            suggest = "alert_id"
        elif key == "vizType":
            suggest = "viz_type"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetAlertGraphDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetAlertGraphDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetAlertGraphDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_id: str,
                 viz_type: str,
                 live_span: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetAlertGraphDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "alert_id", alert_id)
        pulumi.set(__self__, "viz_type", viz_type)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter(name="vizType")
    def viz_type(self) -> str:
        return pulumi.get(self, "viz_type")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetAlertGraphDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetAlertGraphDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetAlertGraphDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetAlertGraphDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetAlertGraphDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetAlertValueDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertId":
            suggest = "alert_id"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetAlertValueDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetAlertValueDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetAlertValueDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_id: str,
                 precision: Optional[int] = None,
                 text_align: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 unit: Optional[str] = None):
        pulumi.set(__self__, "alert_id", alert_id)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter
    def precision(self) -> Optional[int]:
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class DashboardWidgetChangeDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequest']] = None,
                 time: Optional['outputs.DashboardWidgetChangeDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetChangeDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetChangeDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "changeType":
            suggest = "change_type"
        elif key == "compareTo":
            suggest = "compare_to"
        elif key == "increaseGood":
            suggest = "increase_good"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "orderBy":
            suggest = "order_by"
        elif key == "orderDir":
            suggest = "order_dir"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"
        elif key == "showPresent":
            suggest = "show_present"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQuery'] = None,
                 change_type: Optional[str] = None,
                 compare_to: Optional[str] = None,
                 increase_good: Optional[bool] = None,
                 log_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQuery'] = None,
                 order_by: Optional[str] = None,
                 order_dir: Optional[str] = None,
                 process_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQuery'] = None,
                 show_present: Optional[bool] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if compare_to is not None:
            pulumi.set(__self__, "compare_to", compare_to)
        if increase_good is not None:
            pulumi.set(__self__, "increase_good", increase_good)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)
        if order_dir is not None:
            pulumi.set(__self__, "order_dir", order_dir)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if show_present is not None:
            pulumi.set(__self__, "show_present", show_present)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[str]:
        return pulumi.get(self, "change_type")

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[str]:
        return pulumi.get(self, "compare_to")

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[bool]:
        return pulumi.get(self, "increase_good")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[str]:
        return pulumi.get(self, "order_by")

    @property
    @pulumi.getter(name="orderDir")
    def order_dir(self) -> Optional[str]:
        return pulumi.get(self, "order_dir")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQuery']:
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter(name="showPresent")
    def show_present(self) -> Optional[bool]:
        return pulumi.get(self, "show_present")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetCheckStatusDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBies":
            suggest = "group_bies"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetCheckStatusDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetCheckStatusDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetCheckStatusDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check: str,
                 grouping: str,
                 group: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 live_span: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 time: Optional['outputs.DashboardWidgetCheckStatusDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "check", check)
        pulumi.set(__self__, "grouping", grouping)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def check(self) -> str:
        return pulumi.get(self, "check")

    @property
    @pulumi.getter
    def grouping(self) -> str:
        return pulumi.get(self, "grouping")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetCheckStatusDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetCheckStatusDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetCheckStatusDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetCheckStatusDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetCheckStatusDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetDistributionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 time: Optional['outputs.DashboardWidgetDistributionDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetDistributionDefinitionRequestStyle'] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQuery']:
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestStyle']:
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetEventStreamDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventSize":
            suggest = "event_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "tagsExecution":
            suggest = "tags_execution"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetEventStreamDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetEventStreamDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetEventStreamDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 event_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 tags_execution: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetEventStreamDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "query", query)
        if event_size is not None:
            pulumi.set(__self__, "event_size", event_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[str]:
        return pulumi.get(self, "event_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        return pulumi.get(self, "tags_execution")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetEventStreamDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetEventStreamDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetEventStreamDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetEventStreamDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetEventStreamDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetEventTimelineDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"
        elif key == "tagsExecution":
            suggest = "tags_execution"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetEventTimelineDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetEventTimelineDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetEventTimelineDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 live_span: Optional[str] = None,
                 tags_execution: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetEventTimelineDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "query", query)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        return pulumi.get(self, "tags_execution")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetEventTimelineDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetEventTimelineDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetEventTimelineDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetEventTimelineDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetEventTimelineDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetFreeTextDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontSize":
            suggest = "font_size"
        elif key == "textAlign":
            suggest = "text_align"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetFreeTextDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetFreeTextDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetFreeTextDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text: str,
                 color: Optional[str] = None,
                 font_size: Optional[str] = None,
                 text_align: Optional[str] = None):
        pulumi.set(__self__, "text", text)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)

    @property
    @pulumi.getter
    def text(self) -> str:
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        return pulumi.get(self, "text_align")


@pulumi.output_type
class DashboardWidgetGeomapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 view: 'outputs.DashboardWidgetGeomapDefinitionView',
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequest']] = None,
                 style: Optional['outputs.DashboardWidgetGeomapDefinitionStyle'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "view", view)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def view(self) -> 'outputs.DashboardWidgetGeomapDefinitionView':
        return pulumi.get(self, "view")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionStyle']:
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logQuery":
            suggest = "log_query"
        elif key == "rumQuery":
            suggest = "rum_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formulas: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQuery'] = None):
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 limit: Optional['outputs.DashboardWidgetGeomapDefinitionRequestFormulaLimit'] = None):
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestFormulaLimit']:
        return pulumi.get(self, "limit")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryProcessQuery'] = None):
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuery']:
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryMetricQuery']:
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryProcessQuery']:
        return pulumi.get(self, "process_query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch'] = None):
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute']:
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch']:
        return pulumi.get(self, "search")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort'] = None):
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort']:
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteFlip":
            suggest = "palette_flip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: str,
                 palette_flip: bool):
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "palette_flip", palette_flip)

    @property
    @pulumi.getter
    def palette(self) -> str:
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> bool:
        return pulumi.get(self, "palette_flip")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionView(dict):
    def __init__(__self__, *,
                 focus: str):
        pulumi.set(__self__, "focus", focus)

    @property
    @pulumi.getter
    def focus(self) -> str:
        return pulumi.get(self, "focus")


@pulumi.output_type
class DashboardWidgetGroupDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layoutType":
            suggest = "layout_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layout_type: str,
                 widgets: Sequence['outputs.DashboardWidgetGroupDefinitionWidget'],
                 title: Optional[str] = None):
        pulumi.set(__self__, "layout_type", layout_type)
        pulumi.set(__self__, "widgets", widgets)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="layoutType")
    def layout_type(self) -> str:
        return pulumi.get(self, "layout_type")

    @property
    @pulumi.getter
    def widgets(self) -> Sequence['outputs.DashboardWidgetGroupDefinitionWidget']:
        return pulumi.get(self, "widgets")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertGraphDefinition":
            suggest = "alert_graph_definition"
        elif key == "alertValueDefinition":
            suggest = "alert_value_definition"
        elif key == "changeDefinition":
            suggest = "change_definition"
        elif key == "checkStatusDefinition":
            suggest = "check_status_definition"
        elif key == "distributionDefinition":
            suggest = "distribution_definition"
        elif key == "eventStreamDefinition":
            suggest = "event_stream_definition"
        elif key == "eventTimelineDefinition":
            suggest = "event_timeline_definition"
        elif key == "freeTextDefinition":
            suggest = "free_text_definition"
        elif key == "geomapDefinition":
            suggest = "geomap_definition"
        elif key == "heatmapDefinition":
            suggest = "heatmap_definition"
        elif key == "hostmapDefinition":
            suggest = "hostmap_definition"
        elif key == "iframeDefinition":
            suggest = "iframe_definition"
        elif key == "imageDefinition":
            suggest = "image_definition"
        elif key == "logStreamDefinition":
            suggest = "log_stream_definition"
        elif key == "manageStatusDefinition":
            suggest = "manage_status_definition"
        elif key == "noteDefinition":
            suggest = "note_definition"
        elif key == "queryTableDefinition":
            suggest = "query_table_definition"
        elif key == "queryValueDefinition":
            suggest = "query_value_definition"
        elif key == "scatterplotDefinition":
            suggest = "scatterplot_definition"
        elif key == "serviceLevelObjectiveDefinition":
            suggest = "service_level_objective_definition"
        elif key == "servicemapDefinition":
            suggest = "servicemap_definition"
        elif key == "timeseriesDefinition":
            suggest = "timeseries_definition"
        elif key == "toplistDefinition":
            suggest = "toplist_definition"
        elif key == "traceServiceDefinition":
            suggest = "trace_service_definition"
        elif key == "widgetLayout":
            suggest = "widget_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_graph_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition'] = None,
                 alert_value_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertValueDefinition'] = None,
                 change_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinition'] = None,
                 check_status_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition'] = None,
                 distribution_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinition'] = None,
                 event_stream_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventStreamDefinition'] = None,
                 event_timeline_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition'] = None,
                 free_text_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetFreeTextDefinition'] = None,
                 geomap_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinition'] = None,
                 heatmap_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinition'] = None,
                 hostmap_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinition'] = None,
                 id: Optional[int] = None,
                 iframe_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetIframeDefinition'] = None,
                 image_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetImageDefinition'] = None,
                 layout: Optional['outputs.DashboardWidgetGroupDefinitionWidgetLayout'] = None,
                 log_stream_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinition'] = None,
                 manage_status_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetManageStatusDefinition'] = None,
                 note_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetNoteDefinition'] = None,
                 query_table_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinition'] = None,
                 query_value_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinition'] = None,
                 scatterplot_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinition'] = None,
                 service_level_objective_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition'] = None,
                 servicemap_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetServicemapDefinition'] = None,
                 timeseries_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition'] = None,
                 toplist_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinition'] = None,
                 trace_service_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition'] = None,
                 widget_layout: Optional['outputs.DashboardWidgetGroupDefinitionWidgetWidgetLayout'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionArgs' change_definition: The definition for a Change  widget.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionArgs' distribution_definition: The definition for a Distribution widget.
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionArgs' geomap_definition: The definition for a Geomap widget.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionArgs' heatmap_definition: The definition for a Heatmap widget.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionArgs' hostmap_definition: The definition for a Hostmap widget.
        :param int id: The ID of the widget.
        :param 'DashboardWidgetGroupDefinitionWidgetIframeDefinitionArgs' iframe_definition: The definition for an Iframe widget.
        :param 'DashboardWidgetGroupDefinitionWidgetImageDefinitionArgs' image_definition: The definition for an Image widget
        :param 'DashboardWidgetGroupDefinitionWidgetLayoutArgs' layout: The layout of the widget on a 'free' dashboard.  Define widget_layout list with one element instead.
        :param 'DashboardWidgetGroupDefinitionWidgetNoteDefinitionArgs' note_definition: The definition for a Note widget.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionArgs' scatterplot_definition: The definition for a Scatterplot widget.
        :param 'DashboardWidgetGroupDefinitionWidgetServicemapDefinitionArgs' servicemap_definition: The definition for a Service Map widget.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionArgs' timeseries_definition: The definition for a Timeseries widget.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionArgs' toplist_definition: The definition for a Toplist widget.
        :param 'DashboardWidgetGroupDefinitionWidgetWidgetLayoutArgs' widget_layout: The layout of the widget on a 'free' dashboard.
        """
        if alert_graph_definition is not None:
            pulumi.set(__self__, "alert_graph_definition", alert_graph_definition)
        if alert_value_definition is not None:
            pulumi.set(__self__, "alert_value_definition", alert_value_definition)
        if change_definition is not None:
            pulumi.set(__self__, "change_definition", change_definition)
        if check_status_definition is not None:
            pulumi.set(__self__, "check_status_definition", check_status_definition)
        if distribution_definition is not None:
            pulumi.set(__self__, "distribution_definition", distribution_definition)
        if event_stream_definition is not None:
            pulumi.set(__self__, "event_stream_definition", event_stream_definition)
        if event_timeline_definition is not None:
            pulumi.set(__self__, "event_timeline_definition", event_timeline_definition)
        if free_text_definition is not None:
            pulumi.set(__self__, "free_text_definition", free_text_definition)
        if geomap_definition is not None:
            pulumi.set(__self__, "geomap_definition", geomap_definition)
        if heatmap_definition is not None:
            pulumi.set(__self__, "heatmap_definition", heatmap_definition)
        if hostmap_definition is not None:
            pulumi.set(__self__, "hostmap_definition", hostmap_definition)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if iframe_definition is not None:
            pulumi.set(__self__, "iframe_definition", iframe_definition)
        if image_definition is not None:
            pulumi.set(__self__, "image_definition", image_definition)
        if layout is not None:
            pulumi.set(__self__, "layout", layout)
        if log_stream_definition is not None:
            pulumi.set(__self__, "log_stream_definition", log_stream_definition)
        if manage_status_definition is not None:
            pulumi.set(__self__, "manage_status_definition", manage_status_definition)
        if note_definition is not None:
            pulumi.set(__self__, "note_definition", note_definition)
        if query_table_definition is not None:
            pulumi.set(__self__, "query_table_definition", query_table_definition)
        if query_value_definition is not None:
            pulumi.set(__self__, "query_value_definition", query_value_definition)
        if scatterplot_definition is not None:
            pulumi.set(__self__, "scatterplot_definition", scatterplot_definition)
        if service_level_objective_definition is not None:
            pulumi.set(__self__, "service_level_objective_definition", service_level_objective_definition)
        if servicemap_definition is not None:
            pulumi.set(__self__, "servicemap_definition", servicemap_definition)
        if timeseries_definition is not None:
            pulumi.set(__self__, "timeseries_definition", timeseries_definition)
        if toplist_definition is not None:
            pulumi.set(__self__, "toplist_definition", toplist_definition)
        if trace_service_definition is not None:
            pulumi.set(__self__, "trace_service_definition", trace_service_definition)
        if widget_layout is not None:
            pulumi.set(__self__, "widget_layout", widget_layout)

    @property
    @pulumi.getter(name="alertGraphDefinition")
    def alert_graph_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition']:
        return pulumi.get(self, "alert_graph_definition")

    @property
    @pulumi.getter(name="alertValueDefinition")
    def alert_value_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertValueDefinition']:
        return pulumi.get(self, "alert_value_definition")

    @property
    @pulumi.getter(name="changeDefinition")
    def change_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinition']:
        """
        The definition for a Change  widget.
        """
        return pulumi.get(self, "change_definition")

    @property
    @pulumi.getter(name="checkStatusDefinition")
    def check_status_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition']:
        return pulumi.get(self, "check_status_definition")

    @property
    @pulumi.getter(name="distributionDefinition")
    def distribution_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinition']:
        """
        The definition for a Distribution widget.
        """
        return pulumi.get(self, "distribution_definition")

    @property
    @pulumi.getter(name="eventStreamDefinition")
    def event_stream_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventStreamDefinition']:
        return pulumi.get(self, "event_stream_definition")

    @property
    @pulumi.getter(name="eventTimelineDefinition")
    def event_timeline_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition']:
        return pulumi.get(self, "event_timeline_definition")

    @property
    @pulumi.getter(name="freeTextDefinition")
    def free_text_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetFreeTextDefinition']:
        return pulumi.get(self, "free_text_definition")

    @property
    @pulumi.getter(name="geomapDefinition")
    def geomap_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinition']:
        """
        The definition for a Geomap widget.
        """
        return pulumi.get(self, "geomap_definition")

    @property
    @pulumi.getter(name="heatmapDefinition")
    def heatmap_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinition']:
        """
        The definition for a Heatmap widget.
        """
        return pulumi.get(self, "heatmap_definition")

    @property
    @pulumi.getter(name="hostmapDefinition")
    def hostmap_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinition']:
        """
        The definition for a Hostmap widget.
        """
        return pulumi.get(self, "hostmap_definition")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        The ID of the widget.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="iframeDefinition")
    def iframe_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetIframeDefinition']:
        """
        The definition for an Iframe widget.
        """
        return pulumi.get(self, "iframe_definition")

    @property
    @pulumi.getter(name="imageDefinition")
    def image_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetImageDefinition']:
        """
        The definition for an Image widget
        """
        return pulumi.get(self, "image_definition")

    @property
    @pulumi.getter
    def layout(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetLayout']:
        """
        The layout of the widget on a 'free' dashboard.  Define widget_layout list with one element instead.
        """
        return pulumi.get(self, "layout")

    @property
    @pulumi.getter(name="logStreamDefinition")
    def log_stream_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinition']:
        return pulumi.get(self, "log_stream_definition")

    @property
    @pulumi.getter(name="manageStatusDefinition")
    def manage_status_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetManageStatusDefinition']:
        return pulumi.get(self, "manage_status_definition")

    @property
    @pulumi.getter(name="noteDefinition")
    def note_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetNoteDefinition']:
        """
        The definition for a Note widget.
        """
        return pulumi.get(self, "note_definition")

    @property
    @pulumi.getter(name="queryTableDefinition")
    def query_table_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinition']:
        return pulumi.get(self, "query_table_definition")

    @property
    @pulumi.getter(name="queryValueDefinition")
    def query_value_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinition']:
        return pulumi.get(self, "query_value_definition")

    @property
    @pulumi.getter(name="scatterplotDefinition")
    def scatterplot_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinition']:
        """
        The definition for a Scatterplot widget.
        """
        return pulumi.get(self, "scatterplot_definition")

    @property
    @pulumi.getter(name="serviceLevelObjectiveDefinition")
    def service_level_objective_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition']:
        return pulumi.get(self, "service_level_objective_definition")

    @property
    @pulumi.getter(name="servicemapDefinition")
    def servicemap_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetServicemapDefinition']:
        """
        The definition for a Service Map widget.
        """
        return pulumi.get(self, "servicemap_definition")

    @property
    @pulumi.getter(name="timeseriesDefinition")
    def timeseries_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition']:
        """
        The definition for a Timeseries widget.
        """
        return pulumi.get(self, "timeseries_definition")

    @property
    @pulumi.getter(name="toplistDefinition")
    def toplist_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinition']:
        """
        The definition for a Toplist widget.
        """
        return pulumi.get(self, "toplist_definition")

    @property
    @pulumi.getter(name="traceServiceDefinition")
    def trace_service_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition']:
        return pulumi.get(self, "trace_service_definition")

    @property
    @pulumi.getter(name="widgetLayout")
    def widget_layout(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetWidgetLayout']:
        """
        The layout of the widget on a 'free' dashboard.
        """
        return pulumi.get(self, "widget_layout")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertId":
            suggest = "alert_id"
        elif key == "vizType":
            suggest = "viz_type"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_id: str,
                 viz_type: str,
                 live_span: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "alert_id", alert_id)
        pulumi.set(__self__, "viz_type", viz_type)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter(name="vizType")
    def viz_type(self) -> str:
        return pulumi.get(self, "viz_type")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetAlertValueDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertId":
            suggest = "alert_id"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetAlertValueDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetAlertValueDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetAlertValueDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_id: str,
                 precision: Optional[int] = None,
                 text_align: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 unit: Optional[str] = None):
        pulumi.set(__self__, "alert_id", alert_id)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter
    def precision(self) -> Optional[int]:
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        return pulumi.get(self, "unit")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest']] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "changeType":
            suggest = "change_type"
        elif key == "compareTo":
            suggest = "compare_to"
        elif key == "increaseGood":
            suggest = "increase_good"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "orderBy":
            suggest = "order_by"
        elif key == "orderDir":
            suggest = "order_dir"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"
        elif key == "showPresent":
            suggest = "show_present"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery'] = None,
                 change_type: Optional[str] = None,
                 compare_to: Optional[str] = None,
                 increase_good: Optional[bool] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery'] = None,
                 order_by: Optional[str] = None,
                 order_dir: Optional[str] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery'] = None,
                 show_present: Optional[bool] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if compare_to is not None:
            pulumi.set(__self__, "compare_to", compare_to)
        if increase_good is not None:
            pulumi.set(__self__, "increase_good", increase_good)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)
        if order_dir is not None:
            pulumi.set(__self__, "order_dir", order_dir)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if show_present is not None:
            pulumi.set(__self__, "show_present", show_present)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[str]:
        return pulumi.get(self, "change_type")

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[str]:
        return pulumi.get(self, "compare_to")

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[bool]:
        return pulumi.get(self, "increase_good")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[str]:
        return pulumi.get(self, "order_by")

    @property
    @pulumi.getter(name="orderDir")
    def order_dir(self) -> Optional[str]:
        return pulumi.get(self, "order_dir")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery']:
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter(name="showPresent")
    def show_present(self) -> Optional[bool]:
        return pulumi.get(self, "show_present")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBies":
            suggest = "group_bies"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check: str,
                 grouping: str,
                 group: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 live_span: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "check", check)
        pulumi.set(__self__, "grouping", grouping)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def check(self) -> str:
        return pulumi.get(self, "check")

    @property
    @pulumi.getter
    def grouping(self) -> str:
        return pulumi.get(self, "grouping")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle'] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery']:
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle']:
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetEventStreamDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventSize":
            suggest = "event_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "tagsExecution":
            suggest = "tags_execution"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetEventStreamDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetEventStreamDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetEventStreamDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 event_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 tags_execution: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "query", query)
        if event_size is not None:
            pulumi.set(__self__, "event_size", event_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[str]:
        return pulumi.get(self, "event_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        return pulumi.get(self, "tags_execution")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"
        elif key == "tagsExecution":
            suggest = "tags_execution"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 live_span: Optional[str] = None,
                 tags_execution: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "query", query)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        return pulumi.get(self, "tags_execution")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetFreeTextDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontSize":
            suggest = "font_size"
        elif key == "textAlign":
            suggest = "text_align"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetFreeTextDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetFreeTextDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetFreeTextDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text: str,
                 color: Optional[str] = None,
                 font_size: Optional[str] = None,
                 text_align: Optional[str] = None):
        pulumi.set(__self__, "text", text)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)

    @property
    @pulumi.getter
    def text(self) -> str:
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        return pulumi.get(self, "text_align")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 view: 'outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView',
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest']] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "view", view)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def view(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView':
        return pulumi.get(self, "view")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle']:
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logQuery":
            suggest = "log_query"
        elif key == "rumQuery":
            suggest = "rum_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery'] = None):
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit'] = None):
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit']:
        return pulumi.get(self, "limit")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery'] = None):
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery']:
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery']:
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery']:
        return pulumi.get(self, "process_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch'] = None):
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute']:
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch']:
        return pulumi.get(self, "search")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort'] = None):
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort']:
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteFlip":
            suggest = "palette_flip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: str,
                 palette_flip: bool):
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "palette_flip", palette_flip)

    @property
    @pulumi.getter
    def palette(self) -> str:
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> bool:
        return pulumi.get(self, "palette_flip")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView(dict):
    def __init__(__self__, *,
                 focus: str):
        pulumi.set(__self__, "focus", focus)

    @property
    @pulumi.getter
    def focus(self) -> str:
        return pulumi.get(self, "focus")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink']] = None,
                 events: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent']] = None,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 yaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis'] = None):
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent']]:
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis']:
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagsExecution":
            suggest = "tags_execution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 q: str,
                 tags_execution: Optional[str] = None):
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> str:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        return pulumi.get(self, "tags_execution")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle'] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery']:
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle']:
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "noGroupHosts":
            suggest = "no_group_hosts"
        elif key == "noMetricHosts":
            suggest = "no_metric_hosts"
        elif key == "nodeType":
            suggest = "node_type"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink']] = None,
                 groups: Optional[Sequence[str]] = None,
                 no_group_hosts: Optional[bool] = None,
                 no_metric_hosts: Optional[bool] = None,
                 node_type: Optional[str] = None,
                 request: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest'] = None,
                 scopes: Optional[Sequence[str]] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if no_group_hosts is not None:
            pulumi.set(__self__, "no_group_hosts", no_group_hosts)
        if no_metric_hosts is not None:
            pulumi.set(__self__, "no_metric_hosts", no_metric_hosts)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="noGroupHosts")
    def no_group_hosts(self) -> Optional[bool]:
        return pulumi.get(self, "no_group_hosts")

    @property
    @pulumi.getter(name="noMetricHosts")
    def no_metric_hosts(self) -> Optional[bool]:
        return pulumi.get(self, "no_metric_hosts")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[str]:
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest']:
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle']:
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest(dict):
    def __init__(__self__, *,
                 fills: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill']] = None,
                 sizes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize']] = None):
        if fills is not None:
            pulumi.set(__self__, "fills", fills)
        if sizes is not None:
            pulumi.set(__self__, "sizes", sizes)

    @property
    @pulumi.getter
    def fills(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill']]:
        return pulumi.get(self, "fills")

    @property
    @pulumi.getter
    def sizes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize']]:
        return pulumi.get(self, "sizes")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery'] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery']:
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery'] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery']:
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fillMax":
            suggest = "fill_max"
        elif key == "fillMin":
            suggest = "fill_min"
        elif key == "paletteFlip":
            suggest = "palette_flip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fill_max: Optional[str] = None,
                 fill_min: Optional[str] = None,
                 palette: Optional[str] = None,
                 palette_flip: Optional[bool] = None):
        if fill_max is not None:
            pulumi.set(__self__, "fill_max", fill_max)
        if fill_min is not None:
            pulumi.set(__self__, "fill_min", fill_min)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_flip is not None:
            pulumi.set(__self__, "palette_flip", palette_flip)

    @property
    @pulumi.getter(name="fillMax")
    def fill_max(self) -> Optional[str]:
        return pulumi.get(self, "fill_max")

    @property
    @pulumi.getter(name="fillMin")
    def fill_min(self) -> Optional[str]:
        return pulumi.get(self, "fill_min")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> Optional[bool]:
        return pulumi.get(self, "palette_flip")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetIframeDefinition(dict):
    def __init__(__self__, *,
                 url: str):
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetImageDefinition(dict):
    def __init__(__self__, *,
                 url: str,
                 margin: Optional[str] = None,
                 sizing: Optional[str] = None):
        pulumi.set(__self__, "url", url)
        if margin is not None:
            pulumi.set(__self__, "margin", margin)
        if sizing is not None:
            pulumi.set(__self__, "sizing", sizing)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def margin(self) -> Optional[str]:
        return pulumi.get(self, "margin")

    @property
    @pulumi.getter
    def sizing(self) -> Optional[str]:
        return pulumi.get(self, "sizing")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetLayout(dict):
    def __init__(__self__, *,
                 height: int,
                 width: int,
                 x: int,
                 y: int):
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "width", width)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def height(self) -> int:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> int:
        return pulumi.get(self, "width")

    @property
    @pulumi.getter
    def x(self) -> int:
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> int:
        return pulumi.get(self, "y")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetLogStreamDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"
        elif key == "messageDisplay":
            suggest = "message_display"
        elif key == "showDateColumn":
            suggest = "show_date_column"
        elif key == "showMessageColumn":
            suggest = "show_message_column"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetLogStreamDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetLogStreamDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetLogStreamDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Optional[Sequence[str]] = None,
                 indexes: Optional[Sequence[str]] = None,
                 live_span: Optional[str] = None,
                 logset: Optional[str] = None,
                 message_display: Optional[str] = None,
                 query: Optional[str] = None,
                 show_date_column: Optional[bool] = None,
                 show_message_column: Optional[bool] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort'] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if logset is not None:
            pulumi.set(__self__, "logset", logset)
        if message_display is not None:
            pulumi.set(__self__, "message_display", message_display)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if show_date_column is not None:
            pulumi.set(__self__, "show_date_column", show_date_column)
        if show_message_column is not None:
            pulumi.set(__self__, "show_message_column", show_message_column)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def logset(self) -> Optional[str]:
        return pulumi.get(self, "logset")

    @property
    @pulumi.getter(name="messageDisplay")
    def message_display(self) -> Optional[str]:
        return pulumi.get(self, "message_display")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="showDateColumn")
    def show_date_column(self) -> Optional[bool]:
        return pulumi.get(self, "show_date_column")

    @property
    @pulumi.getter(name="showMessageColumn")
    def show_message_column(self) -> Optional[bool]:
        return pulumi.get(self, "show_message_column")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort(dict):
    def __init__(__self__, *,
                 column: str,
                 order: str):
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> str:
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetManageStatusDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorPreference":
            suggest = "color_preference"
        elif key == "displayFormat":
            suggest = "display_format"
        elif key == "hideZeroCounts":
            suggest = "hide_zero_counts"
        elif key == "showLastTriggered":
            suggest = "show_last_triggered"
        elif key == "summaryType":
            suggest = "summary_type"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetManageStatusDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetManageStatusDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetManageStatusDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 color_preference: Optional[str] = None,
                 count: Optional[int] = None,
                 display_format: Optional[str] = None,
                 hide_zero_counts: Optional[bool] = None,
                 show_last_triggered: Optional[bool] = None,
                 sort: Optional[str] = None,
                 start: Optional[int] = None,
                 summary_type: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "query", query)
        if color_preference is not None:
            pulumi.set(__self__, "color_preference", color_preference)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if hide_zero_counts is not None:
            pulumi.set(__self__, "hide_zero_counts", hide_zero_counts)
        if show_last_triggered is not None:
            pulumi.set(__self__, "show_last_triggered", show_last_triggered)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if start is not None:
            pulumi.set(__self__, "start", start)
        if summary_type is not None:
            pulumi.set(__self__, "summary_type", summary_type)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="colorPreference")
    def color_preference(self) -> Optional[str]:
        return pulumi.get(self, "color_preference")

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter(name="hideZeroCounts")
    def hide_zero_counts(self) -> Optional[bool]:
        return pulumi.get(self, "hide_zero_counts")

    @property
    @pulumi.getter(name="showLastTriggered")
    def show_last_triggered(self) -> Optional[bool]:
        return pulumi.get(self, "show_last_triggered")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter
    def start(self) -> Optional[int]:
        return pulumi.get(self, "start")

    @property
    @pulumi.getter(name="summaryType")
    def summary_type(self) -> Optional[str]:
        return pulumi.get(self, "summary_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetNoteDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "showTick":
            suggest = "show_tick"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "tickEdge":
            suggest = "tick_edge"
        elif key == "tickPos":
            suggest = "tick_pos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetNoteDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetNoteDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetNoteDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: str,
                 background_color: Optional[str] = None,
                 font_size: Optional[str] = None,
                 show_tick: Optional[bool] = None,
                 text_align: Optional[str] = None,
                 tick_edge: Optional[str] = None,
                 tick_pos: Optional[str] = None):
        pulumi.set(__self__, "content", content)
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if show_tick is not None:
            pulumi.set(__self__, "show_tick", show_tick)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if tick_edge is not None:
            pulumi.set(__self__, "tick_edge", tick_edge)
        if tick_pos is not None:
            pulumi.set(__self__, "tick_pos", tick_pos)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="showTick")
    def show_tick(self) -> Optional[bool]:
        return pulumi.get(self, "show_tick")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter(name="tickEdge")
    def tick_edge(self) -> Optional[str]:
        return pulumi.get(self, "tick_edge")

    @property
    @pulumi.getter(name="tickPos")
    def tick_pos(self) -> Optional[str]:
        return pulumi.get(self, "tick_pos")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "hasSearchBar":
            suggest = "has_search_bar"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink']] = None,
                 has_search_bar: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest']] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if has_search_bar is not None:
            pulumi.set(__self__, "has_search_bar", has_search_bar)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="hasSearchBar")
    def has_search_bar(self) -> Optional[str]:
        return pulumi.get(self, "has_search_bar")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "apmStatsQuery":
            suggest = "apm_stats_query"
        elif key == "cellDisplayModes":
            suggest = "cell_display_modes"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 alias: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery'] = None,
                 apm_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery'] = None,
                 cell_display_modes: Optional[Sequence[str]] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat']] = None,
                 limit: Optional[int] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery'] = None,
                 order: Optional[str] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery'] = None):
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if apm_stats_query is not None:
            pulumi.set(__self__, "apm_stats_query", apm_stats_query)
        if cell_display_modes is not None:
            pulumi.set(__self__, "cell_display_modes", cell_display_modes)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="apmStatsQuery")
    def apm_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery']:
        return pulumi.get(self, "apm_stats_query")

    @property
    @pulumi.getter(name="cellDisplayModes")
    def cell_display_modes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cell_display_modes")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat']]:
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery']:
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryTag":
            suggest = "primary_tag"
        elif key == "rowType":
            suggest = "row_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env: str,
                 name: str,
                 primary_tag: str,
                 row_type: str,
                 service: str,
                 columns: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn']] = None,
                 resource: Optional[str] = None):
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary_tag", primary_tag)
        pulumi.set(__self__, "row_type", row_type)
        pulumi.set(__self__, "service", service)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter
    def env(self) -> str:
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryTag")
    def primary_tag(self) -> str:
        return pulumi.get(self, "primary_tag")

    @property
    @pulumi.getter(name="rowType")
    def row_type(self) -> str:
        return pulumi.get(self, "row_type")

    @property
    @pulumi.getter
    def service(self) -> str:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn']]:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        return pulumi.get(self, "resource")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellDisplayMode":
            suggest = "cell_display_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 order: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "customUnit":
            suggest = "custom_unit"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscale: Optional[bool] = None,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink']] = None,
                 custom_unit: Optional[str] = None,
                 live_span: Optional[str] = None,
                 precision: Optional[int] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest']] = None,
                 text_align: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if custom_unit is not None:
            pulumi.set(__self__, "custom_unit", custom_unit)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[bool]:
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[str]:
        return pulumi.get(self, "custom_unit")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def precision(self) -> Optional[int]:
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery'] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat']] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery'] = None):
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat']]:
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery']:
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit'] = None):
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit']:
        return pulumi.get(self, "limit")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery'] = None):
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery']:
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery']:
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery']:
        return pulumi.get(self, "process_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch'] = None):
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute']:
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch']:
        return pulumi.get(self, "search")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort'] = None):
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort']:
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorByGroups":
            suggest = "color_by_groups"
        elif key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_by_groups: Optional[Sequence[str]] = None,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 request: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest'] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 xaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis'] = None,
                 yaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis'] = None):
        if color_by_groups is not None:
            pulumi.set(__self__, "color_by_groups", color_by_groups)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if xaxis is not None:
            pulumi.set(__self__, "xaxis", xaxis)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="colorByGroups")
    def color_by_groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "color_by_groups")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest']:
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def xaxis(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis']:
        return pulumi.get(self, "xaxis")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis']:
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest(dict):
    def __init__(__self__, *,
                 xes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX']] = None,
                 ys: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY']] = None):
        if xes is not None:
            pulumi.set(__self__, "xes", xes)
        if ys is not None:
            pulumi.set(__self__, "ys", ys)

    @property
    @pulumi.getter
    def xes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX']]:
        return pulumi.get(self, "xes")

    @property
    @pulumi.getter
    def ys(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY']]:
        return pulumi.get(self, "ys")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery'] = None):
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery']:
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery'] = None):
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery']:
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sloId":
            suggest = "slo_id"
        elif key == "timeWindows":
            suggest = "time_windows"
        elif key == "viewMode":
            suggest = "view_mode"
        elif key == "viewType":
            suggest = "view_type"
        elif key == "globalTimeTarget":
            suggest = "global_time_target"
        elif key == "showErrorBudget":
            suggest = "show_error_budget"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slo_id: str,
                 time_windows: Sequence[str],
                 view_mode: str,
                 view_type: str,
                 global_time_target: Optional[str] = None,
                 show_error_budget: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "slo_id", slo_id)
        pulumi.set(__self__, "time_windows", time_windows)
        pulumi.set(__self__, "view_mode", view_mode)
        pulumi.set(__self__, "view_type", view_type)
        if global_time_target is not None:
            pulumi.set(__self__, "global_time_target", global_time_target)
        if show_error_budget is not None:
            pulumi.set(__self__, "show_error_budget", show_error_budget)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Sequence[str]:
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter(name="viewMode")
    def view_mode(self) -> str:
        return pulumi.get(self, "view_mode")

    @property
    @pulumi.getter(name="viewType")
    def view_type(self) -> str:
        return pulumi.get(self, "view_type")

    @property
    @pulumi.getter(name="globalTimeTarget")
    def global_time_target(self) -> Optional[str]:
        return pulumi.get(self, "global_time_target")

    @property
    @pulumi.getter(name="showErrorBudget")
    def show_error_budget(self) -> Optional[bool]:
        return pulumi.get(self, "show_error_budget")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetServicemapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetServicemapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetServicemapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetServicemapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Sequence[str],
                 service: str,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "service", service)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def filters(self) -> Sequence[str]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def service(self) -> str:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "legendColumns":
            suggest = "legend_columns"
        elif key == "legendLayout":
            suggest = "legend_layout"
        elif key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "rightYaxis":
            suggest = "right_yaxis"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink']] = None,
                 events: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent']] = None,
                 legend_columns: Optional[Sequence[str]] = None,
                 legend_layout: Optional[str] = None,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 markers: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker']] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest']] = None,
                 right_yaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis'] = None,
                 show_legend: Optional[bool] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 yaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis'] = None):
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_columns is not None:
            pulumi.set(__self__, "legend_columns", legend_columns)
        if legend_layout is not None:
            pulumi.set(__self__, "legend_layout", legend_layout)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if markers is not None:
            pulumi.set(__self__, "markers", markers)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if right_yaxis is not None:
            pulumi.set(__self__, "right_yaxis", right_yaxis)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent']]:
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="legendColumns")
    def legend_columns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "legend_columns")

    @property
    @pulumi.getter(name="legendLayout")
    def legend_layout(self) -> Optional[str]:
        return pulumi.get(self, "legend_layout")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def markers(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker']]:
        return pulumi.get(self, "markers")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="rightYaxis")
    def right_yaxis(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis']:
        return pulumi.get(self, "right_yaxis")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis']:
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagsExecution":
            suggest = "tags_execution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 q: str,
                 tags_execution: Optional[str] = None):
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> str:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        return pulumi.get(self, "tags_execution")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayType":
            suggest = "display_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: str,
                 display_type: Optional[str] = None,
                 label: Optional[str] = None):
        pulumi.set(__self__, "value", value)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[str]:
        return pulumi.get(self, "display_type")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "displayType":
            suggest = "display_type"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "networkQuery":
            suggest = "network_query"
        elif key == "onRightYaxis":
            suggest = "on_right_yaxis"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery'] = None,
                 display_type: Optional[str] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery'] = None,
                 metadatas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata']] = None,
                 network_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery'] = None,
                 on_right_yaxis: Optional[bool] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle'] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if network_query is not None:
            pulumi.set(__self__, "network_query", network_query)
        if on_right_yaxis is not None:
            pulumi.set(__self__, "on_right_yaxis", on_right_yaxis)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[str]:
        return pulumi.get(self, "display_type")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata']]:
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery']:
        return pulumi.get(self, "network_query")

    @property
    @pulumi.getter(name="onRightYaxis")
    def on_right_yaxis(self) -> Optional[bool]:
        return pulumi.get(self, "on_right_yaxis")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery']:
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle']:
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit'] = None):
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit']:
        return pulumi.get(self, "limit")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasName":
            suggest = "alias_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 alias_name: Optional[str] = None):
        pulumi.set(__self__, "expression", expression)
        if alias_name is not None:
            pulumi.set(__self__, "alias_name", alias_name)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="aliasName")
    def alias_name(self) -> Optional[str]:
        return pulumi.get(self, "alias_name")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery'] = None):
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery']:
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery']:
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery']:
        return pulumi.get(self, "process_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch'] = None):
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute']:
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch']:
        return pulumi.get(self, "search")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort'] = None):
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort']:
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineType":
            suggest = "line_type"
        elif key == "lineWidth":
            suggest = "line_width"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 line_type: Optional[str] = None,
                 line_width: Optional[str] = None,
                 palette: Optional[str] = None):
        if line_type is not None:
            pulumi.set(__self__, "line_type", line_type)
        if line_width is not None:
            pulumi.set(__self__, "line_width", line_width)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter(name="lineType")
    def line_type(self) -> Optional[str]:
        return pulumi.get(self, "line_type")

    @property
    @pulumi.getter(name="lineWidth")
    def line_width(self) -> Optional[str]:
        return pulumi.get(self, "line_width")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest']] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery'] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat']] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle'] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat']]:
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery']:
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle']:
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit'] = None):
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit']:
        return pulumi.get(self, "limit")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery'] = None):
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery']:
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery']:
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery']:
        return pulumi.get(self, "process_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch'] = None):
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute']:
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch']:
        return pulumi.get(self, "search")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort'] = None):
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort']:
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spanName":
            suggest = "span_name"
        elif key == "displayFormat":
            suggest = "display_format"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showBreakdown":
            suggest = "show_breakdown"
        elif key == "showDistribution":
            suggest = "show_distribution"
        elif key == "showErrors":
            suggest = "show_errors"
        elif key == "showHits":
            suggest = "show_hits"
        elif key == "showLatency":
            suggest = "show_latency"
        elif key == "showResourceList":
            suggest = "show_resource_list"
        elif key == "sizeFormat":
            suggest = "size_format"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env: str,
                 service: str,
                 span_name: str,
                 display_format: Optional[str] = None,
                 live_span: Optional[str] = None,
                 show_breakdown: Optional[bool] = None,
                 show_distribution: Optional[bool] = None,
                 show_errors: Optional[bool] = None,
                 show_hits: Optional[bool] = None,
                 show_latency: Optional[bool] = None,
                 show_resource_list: Optional[bool] = None,
                 size_format: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "span_name", span_name)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if show_breakdown is not None:
            pulumi.set(__self__, "show_breakdown", show_breakdown)
        if show_distribution is not None:
            pulumi.set(__self__, "show_distribution", show_distribution)
        if show_errors is not None:
            pulumi.set(__self__, "show_errors", show_errors)
        if show_hits is not None:
            pulumi.set(__self__, "show_hits", show_hits)
        if show_latency is not None:
            pulumi.set(__self__, "show_latency", show_latency)
        if show_resource_list is not None:
            pulumi.set(__self__, "show_resource_list", show_resource_list)
        if size_format is not None:
            pulumi.set(__self__, "size_format", size_format)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def env(self) -> str:
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def service(self) -> str:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="spanName")
    def span_name(self) -> str:
        return pulumi.get(self, "span_name")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="showBreakdown")
    def show_breakdown(self) -> Optional[bool]:
        return pulumi.get(self, "show_breakdown")

    @property
    @pulumi.getter(name="showDistribution")
    def show_distribution(self) -> Optional[bool]:
        return pulumi.get(self, "show_distribution")

    @property
    @pulumi.getter(name="showErrors")
    def show_errors(self) -> Optional[bool]:
        return pulumi.get(self, "show_errors")

    @property
    @pulumi.getter(name="showHits")
    def show_hits(self) -> Optional[bool]:
        return pulumi.get(self, "show_hits")

    @property
    @pulumi.getter(name="showLatency")
    def show_latency(self) -> Optional[bool]:
        return pulumi.get(self, "show_latency")

    @property
    @pulumi.getter(name="showResourceList")
    def show_resource_list(self) -> Optional[bool]:
        return pulumi.get(self, "show_resource_list")

    @property
    @pulumi.getter(name="sizeFormat")
    def size_format(self) -> Optional[str]:
        return pulumi.get(self, "size_format")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetWidgetLayout(dict):
    def __init__(__self__, *,
                 height: int,
                 width: int,
                 x: int,
                 y: int):
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "width", width)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def height(self) -> int:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> int:
        return pulumi.get(self, "width")

    @property
    @pulumi.getter
    def x(self) -> int:
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> int:
        return pulumi.get(self, "y")


@pulumi.output_type
class DashboardWidgetHeatmapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionCustomLink']] = None,
                 events: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionEvent']] = None,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 time: Optional['outputs.DashboardWidgetHeatmapDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 yaxis: Optional['outputs.DashboardWidgetHeatmapDefinitionYaxis'] = None):
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionEvent']]:
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionYaxis']:
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagsExecution":
            suggest = "tags_execution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 q: str,
                 tags_execution: Optional[str] = None):
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> str:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        return pulumi.get(self, "tags_execution")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestStyle'] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQuery']:
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestStyle']:
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetHostmapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "noGroupHosts":
            suggest = "no_group_hosts"
        elif key == "noMetricHosts":
            suggest = "no_metric_hosts"
        elif key == "nodeType":
            suggest = "node_type"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionCustomLink']] = None,
                 groups: Optional[Sequence[str]] = None,
                 no_group_hosts: Optional[bool] = None,
                 no_metric_hosts: Optional[bool] = None,
                 node_type: Optional[str] = None,
                 request: Optional['outputs.DashboardWidgetHostmapDefinitionRequest'] = None,
                 scopes: Optional[Sequence[str]] = None,
                 style: Optional['outputs.DashboardWidgetHostmapDefinitionStyle'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if no_group_hosts is not None:
            pulumi.set(__self__, "no_group_hosts", no_group_hosts)
        if no_metric_hosts is not None:
            pulumi.set(__self__, "no_metric_hosts", no_metric_hosts)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="noGroupHosts")
    def no_group_hosts(self) -> Optional[bool]:
        return pulumi.get(self, "no_group_hosts")

    @property
    @pulumi.getter(name="noMetricHosts")
    def no_metric_hosts(self) -> Optional[bool]:
        return pulumi.get(self, "no_metric_hosts")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[str]:
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequest']:
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionStyle']:
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequest(dict):
    def __init__(__self__, *,
                 fills: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFill']] = None,
                 sizes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSize']] = None):
        if fills is not None:
            pulumi.set(__self__, "fills", fills)
        if sizes is not None:
            pulumi.set(__self__, "sizes", sizes)

    @property
    @pulumi.getter
    def fills(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFill']]:
        return pulumi.get(self, "fills")

    @property
    @pulumi.getter
    def sizes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSize']]:
        return pulumi.get(self, "sizes")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFill(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFill. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFill.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFill.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQuery'] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQuery']:
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSize(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSize. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSize.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSize.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery'] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery']:
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fillMax":
            suggest = "fill_max"
        elif key == "fillMin":
            suggest = "fill_min"
        elif key == "paletteFlip":
            suggest = "palette_flip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fill_max: Optional[str] = None,
                 fill_min: Optional[str] = None,
                 palette: Optional[str] = None,
                 palette_flip: Optional[bool] = None):
        if fill_max is not None:
            pulumi.set(__self__, "fill_max", fill_max)
        if fill_min is not None:
            pulumi.set(__self__, "fill_min", fill_min)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_flip is not None:
            pulumi.set(__self__, "palette_flip", palette_flip)

    @property
    @pulumi.getter(name="fillMax")
    def fill_max(self) -> Optional[str]:
        return pulumi.get(self, "fill_max")

    @property
    @pulumi.getter(name="fillMin")
    def fill_min(self) -> Optional[str]:
        return pulumi.get(self, "fill_min")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> Optional[bool]:
        return pulumi.get(self, "palette_flip")


@pulumi.output_type
class DashboardWidgetIframeDefinition(dict):
    def __init__(__self__, *,
                 url: str):
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")


@pulumi.output_type
class DashboardWidgetImageDefinition(dict):
    def __init__(__self__, *,
                 url: str,
                 margin: Optional[str] = None,
                 sizing: Optional[str] = None):
        pulumi.set(__self__, "url", url)
        if margin is not None:
            pulumi.set(__self__, "margin", margin)
        if sizing is not None:
            pulumi.set(__self__, "sizing", sizing)

    @property
    @pulumi.getter
    def url(self) -> str:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def margin(self) -> Optional[str]:
        return pulumi.get(self, "margin")

    @property
    @pulumi.getter
    def sizing(self) -> Optional[str]:
        return pulumi.get(self, "sizing")


@pulumi.output_type
class DashboardWidgetLayout(dict):
    def __init__(__self__, *,
                 height: int,
                 width: int,
                 x: int,
                 y: int):
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "width", width)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def height(self) -> int:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> int:
        return pulumi.get(self, "width")

    @property
    @pulumi.getter
    def x(self) -> int:
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> int:
        return pulumi.get(self, "y")


@pulumi.output_type
class DashboardWidgetLogStreamDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"
        elif key == "messageDisplay":
            suggest = "message_display"
        elif key == "showDateColumn":
            suggest = "show_date_column"
        elif key == "showMessageColumn":
            suggest = "show_message_column"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetLogStreamDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetLogStreamDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetLogStreamDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Optional[Sequence[str]] = None,
                 indexes: Optional[Sequence[str]] = None,
                 live_span: Optional[str] = None,
                 logset: Optional[str] = None,
                 message_display: Optional[str] = None,
                 query: Optional[str] = None,
                 show_date_column: Optional[bool] = None,
                 show_message_column: Optional[bool] = None,
                 sort: Optional['outputs.DashboardWidgetLogStreamDefinitionSort'] = None,
                 time: Optional['outputs.DashboardWidgetLogStreamDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if logset is not None:
            pulumi.set(__self__, "logset", logset)
        if message_display is not None:
            pulumi.set(__self__, "message_display", message_display)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if show_date_column is not None:
            pulumi.set(__self__, "show_date_column", show_date_column)
        if show_message_column is not None:
            pulumi.set(__self__, "show_message_column", show_message_column)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def logset(self) -> Optional[str]:
        return pulumi.get(self, "logset")

    @property
    @pulumi.getter(name="messageDisplay")
    def message_display(self) -> Optional[str]:
        return pulumi.get(self, "message_display")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="showDateColumn")
    def show_date_column(self) -> Optional[bool]:
        return pulumi.get(self, "show_date_column")

    @property
    @pulumi.getter(name="showMessageColumn")
    def show_message_column(self) -> Optional[bool]:
        return pulumi.get(self, "show_message_column")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetLogStreamDefinitionSort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetLogStreamDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetLogStreamDefinitionSort(dict):
    def __init__(__self__, *,
                 column: str,
                 order: str):
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> str:
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetLogStreamDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetLogStreamDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetLogStreamDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetLogStreamDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetManageStatusDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorPreference":
            suggest = "color_preference"
        elif key == "displayFormat":
            suggest = "display_format"
        elif key == "hideZeroCounts":
            suggest = "hide_zero_counts"
        elif key == "showLastTriggered":
            suggest = "show_last_triggered"
        elif key == "summaryType":
            suggest = "summary_type"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetManageStatusDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetManageStatusDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetManageStatusDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 color_preference: Optional[str] = None,
                 count: Optional[int] = None,
                 display_format: Optional[str] = None,
                 hide_zero_counts: Optional[bool] = None,
                 show_last_triggered: Optional[bool] = None,
                 sort: Optional[str] = None,
                 start: Optional[int] = None,
                 summary_type: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "query", query)
        if color_preference is not None:
            pulumi.set(__self__, "color_preference", color_preference)
        if count is not None:
            pulumi.set(__self__, "count", count)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if hide_zero_counts is not None:
            pulumi.set(__self__, "hide_zero_counts", hide_zero_counts)
        if show_last_triggered is not None:
            pulumi.set(__self__, "show_last_triggered", show_last_triggered)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if start is not None:
            pulumi.set(__self__, "start", start)
        if summary_type is not None:
            pulumi.set(__self__, "summary_type", summary_type)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="colorPreference")
    def color_preference(self) -> Optional[str]:
        return pulumi.get(self, "color_preference")

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter(name="hideZeroCounts")
    def hide_zero_counts(self) -> Optional[bool]:
        return pulumi.get(self, "hide_zero_counts")

    @property
    @pulumi.getter(name="showLastTriggered")
    def show_last_triggered(self) -> Optional[bool]:
        return pulumi.get(self, "show_last_triggered")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter
    def start(self) -> Optional[int]:
        return pulumi.get(self, "start")

    @property
    @pulumi.getter(name="summaryType")
    def summary_type(self) -> Optional[str]:
        return pulumi.get(self, "summary_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetNoteDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "showTick":
            suggest = "show_tick"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "tickEdge":
            suggest = "tick_edge"
        elif key == "tickPos":
            suggest = "tick_pos"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetNoteDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetNoteDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetNoteDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: str,
                 background_color: Optional[str] = None,
                 font_size: Optional[str] = None,
                 show_tick: Optional[bool] = None,
                 text_align: Optional[str] = None,
                 tick_edge: Optional[str] = None,
                 tick_pos: Optional[str] = None):
        pulumi.set(__self__, "content", content)
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if show_tick is not None:
            pulumi.set(__self__, "show_tick", show_tick)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if tick_edge is not None:
            pulumi.set(__self__, "tick_edge", tick_edge)
        if tick_pos is not None:
            pulumi.set(__self__, "tick_pos", tick_pos)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="showTick")
    def show_tick(self) -> Optional[bool]:
        return pulumi.get(self, "show_tick")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter(name="tickEdge")
    def tick_edge(self) -> Optional[str]:
        return pulumi.get(self, "tick_edge")

    @property
    @pulumi.getter(name="tickPos")
    def tick_pos(self) -> Optional[str]:
        return pulumi.get(self, "tick_pos")


@pulumi.output_type
class DashboardWidgetQueryTableDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "hasSearchBar":
            suggest = "has_search_bar"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionCustomLink']] = None,
                 has_search_bar: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequest']] = None,
                 time: Optional['outputs.DashboardWidgetQueryTableDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if has_search_bar is not None:
            pulumi.set(__self__, "has_search_bar", has_search_bar)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="hasSearchBar")
    def has_search_bar(self) -> Optional[str]:
        return pulumi.get(self, "has_search_bar")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "apmStatsQuery":
            suggest = "apm_stats_query"
        elif key == "cellDisplayModes":
            suggest = "cell_display_modes"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 alias: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQuery'] = None,
                 apm_stats_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQuery'] = None,
                 cell_display_modes: Optional[Sequence[str]] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestConditionalFormat']] = None,
                 limit: Optional[int] = None,
                 log_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQuery'] = None,
                 order: Optional[str] = None,
                 process_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQuery'] = None):
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if apm_stats_query is not None:
            pulumi.set(__self__, "apm_stats_query", apm_stats_query)
        if cell_display_modes is not None:
            pulumi.set(__self__, "cell_display_modes", cell_display_modes)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="apmStatsQuery")
    def apm_stats_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQuery']:
        return pulumi.get(self, "apm_stats_query")

    @property
    @pulumi.getter(name="cellDisplayModes")
    def cell_display_modes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "cell_display_modes")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestConditionalFormat']]:
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQuery']:
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryTag":
            suggest = "primary_tag"
        elif key == "rowType":
            suggest = "row_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestApmStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env: str,
                 name: str,
                 primary_tag: str,
                 row_type: str,
                 service: str,
                 columns: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn']] = None,
                 resource: Optional[str] = None):
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary_tag", primary_tag)
        pulumi.set(__self__, "row_type", row_type)
        pulumi.set(__self__, "service", service)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter
    def env(self) -> str:
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryTag")
    def primary_tag(self) -> str:
        return pulumi.get(self, "primary_tag")

    @property
    @pulumi.getter(name="rowType")
    def row_type(self) -> str:
        return pulumi.get(self, "row_type")

    @property
    @pulumi.getter
    def service(self) -> str:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn']]:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        return pulumi.get(self, "resource")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellDisplayMode":
            suggest = "cell_display_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 order: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetQueryValueDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "customUnit":
            suggest = "custom_unit"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscale: Optional[bool] = None,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionCustomLink']] = None,
                 custom_unit: Optional[str] = None,
                 live_span: Optional[str] = None,
                 precision: Optional[int] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequest']] = None,
                 text_align: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetQueryValueDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if custom_unit is not None:
            pulumi.set(__self__, "custom_unit", custom_unit)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[bool]:
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[str]:
        return pulumi.get(self, "custom_unit")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def precision(self) -> Optional[int]:
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQuery'] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestConditionalFormat']] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQuery'] = None):
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestConditionalFormat']]:
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQuery']:
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 limit: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestFormulaLimit'] = None):
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestFormulaLimit']:
        return pulumi.get(self, "limit")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery'] = None):
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuery']:
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery']:
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery']:
        return pulumi.get(self, "process_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch'] = None):
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute']:
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch']:
        return pulumi.get(self, "search")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort'] = None):
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort']:
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetScatterplotDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorByGroups":
            suggest = "color_by_groups"
        elif key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_by_groups: Optional[Sequence[str]] = None,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 request: Optional['outputs.DashboardWidgetScatterplotDefinitionRequest'] = None,
                 time: Optional['outputs.DashboardWidgetScatterplotDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 xaxis: Optional['outputs.DashboardWidgetScatterplotDefinitionXaxis'] = None,
                 yaxis: Optional['outputs.DashboardWidgetScatterplotDefinitionYaxis'] = None):
        if color_by_groups is not None:
            pulumi.set(__self__, "color_by_groups", color_by_groups)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if xaxis is not None:
            pulumi.set(__self__, "xaxis", xaxis)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="colorByGroups")
    def color_by_groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "color_by_groups")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequest']:
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def xaxis(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionXaxis']:
        return pulumi.get(self, "xaxis")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionYaxis']:
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequest(dict):
    def __init__(__self__, *,
                 xes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestX']] = None,
                 ys: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestY']] = None):
        if xes is not None:
            pulumi.set(__self__, "xes", xes)
        if ys is not None:
            pulumi.set(__self__, "ys", ys)

    @property
    @pulumi.getter
    def xes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestX']]:
        return pulumi.get(self, "xes")

    @property
    @pulumi.getter
    def ys(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestY']]:
        return pulumi.get(self, "ys")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestX(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestX. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestX.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestX.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQuery'] = None):
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQuery']:
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestY(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestY. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestY.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestY.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQuery'] = None):
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQuery']:
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionXaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionXaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionXaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionXaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetServiceLevelObjectiveDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sloId":
            suggest = "slo_id"
        elif key == "timeWindows":
            suggest = "time_windows"
        elif key == "viewMode":
            suggest = "view_mode"
        elif key == "viewType":
            suggest = "view_type"
        elif key == "globalTimeTarget":
            suggest = "global_time_target"
        elif key == "showErrorBudget":
            suggest = "show_error_budget"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetServiceLevelObjectiveDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetServiceLevelObjectiveDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetServiceLevelObjectiveDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slo_id: str,
                 time_windows: Sequence[str],
                 view_mode: str,
                 view_type: str,
                 global_time_target: Optional[str] = None,
                 show_error_budget: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "slo_id", slo_id)
        pulumi.set(__self__, "time_windows", time_windows)
        pulumi.set(__self__, "view_mode", view_mode)
        pulumi.set(__self__, "view_type", view_type)
        if global_time_target is not None:
            pulumi.set(__self__, "global_time_target", global_time_target)
        if show_error_budget is not None:
            pulumi.set(__self__, "show_error_budget", show_error_budget)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Sequence[str]:
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter(name="viewMode")
    def view_mode(self) -> str:
        return pulumi.get(self, "view_mode")

    @property
    @pulumi.getter(name="viewType")
    def view_type(self) -> str:
        return pulumi.get(self, "view_type")

    @property
    @pulumi.getter(name="globalTimeTarget")
    def global_time_target(self) -> Optional[str]:
        return pulumi.get(self, "global_time_target")

    @property
    @pulumi.getter(name="showErrorBudget")
    def show_error_budget(self) -> Optional[bool]:
        return pulumi.get(self, "show_error_budget")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetServicemapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetServicemapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetServicemapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetServicemapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Sequence[str],
                 service: str,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetServicemapDefinitionCustomLink']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "service", service)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def filters(self) -> Sequence[str]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def service(self) -> str:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetServicemapDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetServicemapDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "legendColumns":
            suggest = "legend_columns"
        elif key == "legendLayout":
            suggest = "legend_layout"
        elif key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "rightYaxis":
            suggest = "right_yaxis"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionCustomLink']] = None,
                 events: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionEvent']] = None,
                 legend_columns: Optional[Sequence[str]] = None,
                 legend_layout: Optional[str] = None,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 markers: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionMarker']] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequest']] = None,
                 right_yaxis: Optional['outputs.DashboardWidgetTimeseriesDefinitionRightYaxis'] = None,
                 show_legend: Optional[bool] = None,
                 time: Optional['outputs.DashboardWidgetTimeseriesDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 yaxis: Optional['outputs.DashboardWidgetTimeseriesDefinitionYaxis'] = None):
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_columns is not None:
            pulumi.set(__self__, "legend_columns", legend_columns)
        if legend_layout is not None:
            pulumi.set(__self__, "legend_layout", legend_layout)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if markers is not None:
            pulumi.set(__self__, "markers", markers)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if right_yaxis is not None:
            pulumi.set(__self__, "right_yaxis", right_yaxis)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionEvent']]:
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="legendColumns")
    def legend_columns(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "legend_columns")

    @property
    @pulumi.getter(name="legendLayout")
    def legend_layout(self) -> Optional[str]:
        return pulumi.get(self, "legend_layout")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def markers(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionMarker']]:
        return pulumi.get(self, "markers")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="rightYaxis")
    def right_yaxis(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRightYaxis']:
        return pulumi.get(self, "right_yaxis")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionYaxis']:
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagsExecution":
            suggest = "tags_execution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 q: str,
                 tags_execution: Optional[str] = None):
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> str:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        return pulumi.get(self, "tags_execution")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionMarker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayType":
            suggest = "display_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionMarker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionMarker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionMarker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: str,
                 display_type: Optional[str] = None,
                 label: Optional[str] = None):
        pulumi.set(__self__, "value", value)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[str]:
        return pulumi.get(self, "display_type")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "displayType":
            suggest = "display_type"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "networkQuery":
            suggest = "network_query"
        elif key == "onRightYaxis":
            suggest = "on_right_yaxis"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQuery'] = None,
                 display_type: Optional[str] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQuery'] = None,
                 metadatas: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestMetadata']] = None,
                 network_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQuery'] = None,
                 on_right_yaxis: Optional[bool] = None,
                 process_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestStyle'] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if network_query is not None:
            pulumi.set(__self__, "network_query", network_query)
        if on_right_yaxis is not None:
            pulumi.set(__self__, "on_right_yaxis", on_right_yaxis)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[str]:
        return pulumi.get(self, "display_type")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestMetadata']]:
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQuery']:
        return pulumi.get(self, "network_query")

    @property
    @pulumi.getter(name="onRightYaxis")
    def on_right_yaxis(self) -> Optional[bool]:
        return pulumi.get(self, "on_right_yaxis")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQuery']:
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestStyle']:
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 limit: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaLimit'] = None):
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaLimit']:
        return pulumi.get(self, "limit")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasName":
            suggest = "alias_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 alias_name: Optional[str] = None):
        pulumi.set(__self__, "expression", expression)
        if alias_name is not None:
            pulumi.set(__self__, "alias_name", alias_name)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="aliasName")
    def alias_name(self) -> Optional[str]:
        return pulumi.get(self, "alias_name")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestNetworkQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestNetworkQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestNetworkQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery'] = None):
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery']:
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery']:
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery']:
        return pulumi.get(self, "process_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch'] = None):
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute']:
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch']:
        return pulumi.get(self, "search")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort'] = None):
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort']:
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineType":
            suggest = "line_type"
        elif key == "lineWidth":
            suggest = "line_width"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 line_type: Optional[str] = None,
                 line_width: Optional[str] = None,
                 palette: Optional[str] = None):
        if line_type is not None:
            pulumi.set(__self__, "line_type", line_type)
        if line_width is not None:
            pulumi.set(__self__, "line_width", line_width)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter(name="lineType")
    def line_type(self) -> Optional[str]:
        return pulumi.get(self, "line_type")

    @property
    @pulumi.getter(name="lineWidth")
    def line_width(self) -> Optional[str]:
        return pulumi.get(self, "line_width")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRightYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRightYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRightYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRightYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetToplistDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequest']] = None,
                 time: Optional['outputs.DashboardWidgetToplistDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionCustomLink']]:
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequest']]:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetToplistDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetToplistDefinitionCustomLink(dict):
    def __init__(__self__, *,
                 label: str,
                 link: str):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> str:
        return pulumi.get(self, "link")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQuery'] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestConditionalFormat']] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetToplistDefinitionRequestStyle'] = None):
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestConditionalFormat']]:
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQuery']:
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQuery']:
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestStyle']:
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 limit: Optional['outputs.DashboardWidgetToplistDefinitionRequestFormulaLimit'] = None):
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestFormulaLimit']:
        return pulumi.get(self, "limit")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryProcessQuery'] = None):
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuery']:
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryMetricQuery']:
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryProcessQuery']:
        return pulumi.get(self, "process_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch'] = None):
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute']:
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch']:
        return pulumi.get(self, "search")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort'] = None):
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort']:
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestRumQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestRumQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestRumQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestRumQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute: Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryCompute'] = None,
                 compute_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search: Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQuerySearch'] = None,
                 search_query: Optional[str] = None):
        pulumi.set(__self__, "index", index)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryCompute']:
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery']:
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute']]:
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQuerySearch']:
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestSecurityQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySort'] = None,
                 sort_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySort']:
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery']:
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestSecurityQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetToplistDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetTraceServiceDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spanName":
            suggest = "span_name"
        elif key == "displayFormat":
            suggest = "display_format"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showBreakdown":
            suggest = "show_breakdown"
        elif key == "showDistribution":
            suggest = "show_distribution"
        elif key == "showErrors":
            suggest = "show_errors"
        elif key == "showHits":
            suggest = "show_hits"
        elif key == "showLatency":
            suggest = "show_latency"
        elif key == "showResourceList":
            suggest = "show_resource_list"
        elif key == "sizeFormat":
            suggest = "size_format"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTraceServiceDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTraceServiceDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTraceServiceDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env: str,
                 service: str,
                 span_name: str,
                 display_format: Optional[str] = None,
                 live_span: Optional[str] = None,
                 show_breakdown: Optional[bool] = None,
                 show_distribution: Optional[bool] = None,
                 show_errors: Optional[bool] = None,
                 show_hits: Optional[bool] = None,
                 show_latency: Optional[bool] = None,
                 show_resource_list: Optional[bool] = None,
                 size_format: Optional[str] = None,
                 time: Optional['outputs.DashboardWidgetTraceServiceDefinitionTime'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "span_name", span_name)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if show_breakdown is not None:
            pulumi.set(__self__, "show_breakdown", show_breakdown)
        if show_distribution is not None:
            pulumi.set(__self__, "show_distribution", show_distribution)
        if show_errors is not None:
            pulumi.set(__self__, "show_errors", show_errors)
        if show_hits is not None:
            pulumi.set(__self__, "show_hits", show_hits)
        if show_latency is not None:
            pulumi.set(__self__, "show_latency", show_latency)
        if show_resource_list is not None:
            pulumi.set(__self__, "show_resource_list", show_resource_list)
        if size_format is not None:
            pulumi.set(__self__, "size_format", size_format)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def env(self) -> str:
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def service(self) -> str:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="spanName")
    def span_name(self) -> str:
        return pulumi.get(self, "span_name")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="showBreakdown")
    def show_breakdown(self) -> Optional[bool]:
        return pulumi.get(self, "show_breakdown")

    @property
    @pulumi.getter(name="showDistribution")
    def show_distribution(self) -> Optional[bool]:
        return pulumi.get(self, "show_distribution")

    @property
    @pulumi.getter(name="showErrors")
    def show_errors(self) -> Optional[bool]:
        return pulumi.get(self, "show_errors")

    @property
    @pulumi.getter(name="showHits")
    def show_hits(self) -> Optional[bool]:
        return pulumi.get(self, "show_hits")

    @property
    @pulumi.getter(name="showLatency")
    def show_latency(self) -> Optional[bool]:
        return pulumi.get(self, "show_latency")

    @property
    @pulumi.getter(name="showResourceList")
    def show_resource_list(self) -> Optional[bool]:
        return pulumi.get(self, "show_resource_list")

    @property
    @pulumi.getter(name="sizeFormat")
    def size_format(self) -> Optional[str]:
        return pulumi.get(self, "size_format")

    @property
    @pulumi.getter
    def time(self) -> Optional['outputs.DashboardWidgetTraceServiceDefinitionTime']:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetTraceServiceDefinitionTime(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTraceServiceDefinitionTime. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTraceServiceDefinitionTime.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTraceServiceDefinitionTime.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 live_span: Optional[str] = None):
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        return pulumi.get(self, "live_span")


@pulumi.output_type
class DashboardWidgetWidgetLayout(dict):
    def __init__(__self__, *,
                 height: int,
                 width: int,
                 x: int,
                 y: int):
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "width", width)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def height(self) -> int:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> int:
        return pulumi.get(self, "width")

    @property
    @pulumi.getter
    def x(self) -> int:
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> int:
        return pulumi.get(self, "y")


@pulumi.output_type
class DowntimeRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "untilDate":
            suggest = "until_date"
        elif key == "untilOccurrences":
            suggest = "until_occurrences"
        elif key == "weekDays":
            suggest = "week_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DowntimeRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DowntimeRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DowntimeRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 period: Optional[int] = None,
                 rrule: Optional[str] = None,
                 until_date: Optional[int] = None,
                 until_occurrences: Optional[int] = None,
                 week_days: Optional[Sequence[str]] = None):
        """
        :param str type: One of days, weeks, months, or years
        :param int period: How often to repeat as an integer. For example to repeat every 3 days, select a type of days and a period of 3.
        :param str rrule: The RRULE standard for defining recurring events. For example, to have a recurring event on the first day of each month, use FREQ=MONTHLY;INTERVAL=1. Most common rrule options from the iCalendar Spec are supported. Attributes specifying the duration in RRULE are not supported (for example, DTSTART, DTEND, DURATION).
        :param int until_date: The date at which the recurrence should end as a POSIX timestamp. until_occurrences and until_date are mutually exclusive.
        :param int until_occurrences: How many times the downtime will be rescheduled. until_occurrences and until_date are mutually exclusive.
        :param Sequence[str] week_days: A list of week days to repeat on. Choose from: Mon, Tue, Wed, Thu, Fri, Sat or Sun. Only applicable when type is weeks. First letter must be capitalized.
        """
        pulumi.set(__self__, "type", type)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if rrule is not None:
            pulumi.set(__self__, "rrule", rrule)
        if until_date is not None:
            pulumi.set(__self__, "until_date", until_date)
        if until_occurrences is not None:
            pulumi.set(__self__, "until_occurrences", until_occurrences)
        if week_days is not None:
            pulumi.set(__self__, "week_days", week_days)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        One of days, weeks, months, or years
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        """
        How often to repeat as an integer. For example to repeat every 3 days, select a type of days and a period of 3.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def rrule(self) -> Optional[str]:
        """
        The RRULE standard for defining recurring events. For example, to have a recurring event on the first day of each month, use FREQ=MONTHLY;INTERVAL=1. Most common rrule options from the iCalendar Spec are supported. Attributes specifying the duration in RRULE are not supported (for example, DTSTART, DTEND, DURATION).
        """
        return pulumi.get(self, "rrule")

    @property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[int]:
        """
        The date at which the recurrence should end as a POSIX timestamp. until_occurrences and until_date are mutually exclusive.
        """
        return pulumi.get(self, "until_date")

    @property
    @pulumi.getter(name="untilOccurrences")
    def until_occurrences(self) -> Optional[int]:
        """
        How many times the downtime will be rescheduled. until_occurrences and until_date are mutually exclusive.
        """
        return pulumi.get(self, "until_occurrences")

    @property
    @pulumi.getter(name="weekDays")
    def week_days(self) -> Optional[Sequence[str]]:
        """
        A list of week days to repeat on. Choose from: Mon, Tue, Wed, Thu, Fri, Sat or Sun. Only applicable when type is weeks. First letter must be capitalized.
        """
        return pulumi.get(self, "week_days")


@pulumi.output_type
class LogsArchiveAzure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "storageAccount":
            suggest = "storage_account"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsArchiveAzure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsArchiveAzure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsArchiveAzure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 container: str,
                 storage_account: str,
                 tenant_id: str,
                 path: Optional[str] = None):
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "storage_account", storage_account)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def container(self) -> str:
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="storageAccount")
    def storage_account(self) -> str:
        return pulumi.get(self, "storage_account")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")


@pulumi.output_type
class LogsArchiveAzureArchive(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "storageAccount":
            suggest = "storage_account"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsArchiveAzureArchive. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsArchiveAzureArchive.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsArchiveAzureArchive.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 container: str,
                 storage_account: str,
                 tenant_id: str,
                 path: Optional[str] = None):
        """
        :param str client_id: Your client id.
        :param str container: The container where the archive will be stored.
        :param str storage_account: The associated storage account.
        :param str tenant_id: Your tenant id.
        :param str path: The path where the archive will be stored.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "storage_account", storage_account)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Your client id.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def container(self) -> str:
        """
        The container where the archive will be stored.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="storageAccount")
    def storage_account(self) -> str:
        """
        The associated storage account.
        """
        return pulumi.get(self, "storage_account")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Your tenant id.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path where the archive will be stored.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class LogsArchiveGcs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientEmail":
            suggest = "client_email"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsArchiveGcs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsArchiveGcs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsArchiveGcs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 client_email: str,
                 path: str,
                 project_id: str):
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "client_email", client_email)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> str:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        return pulumi.get(self, "project_id")


@pulumi.output_type
class LogsArchiveGcsArchive(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientEmail":
            suggest = "client_email"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsArchiveGcsArchive. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsArchiveGcsArchive.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsArchiveGcsArchive.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 client_email: str,
                 path: str,
                 project_id: str):
        """
        :param str bucket: Name of your GCS bucket.
        :param str client_email: Your client email.
        :param str path: Path where the archive will be stored.
        :param str project_id: Your project id.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "client_email", client_email)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of your GCS bucket.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> str:
        """
        Your client email.
        """
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path where the archive will be stored.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Your project id.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class LogsArchiveS3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "roleName":
            suggest = "role_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsArchiveS3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsArchiveS3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsArchiveS3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str,
                 bucket: str,
                 path: str,
                 role_name: str):
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def path(self) -> str:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        return pulumi.get(self, "role_name")


@pulumi.output_type
class LogsArchiveS3Archive(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "roleName":
            suggest = "role_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsArchiveS3Archive. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsArchiveS3Archive.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsArchiveS3Archive.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str,
                 bucket: str,
                 path: str,
                 role_name: str):
        """
        :param str account_id: Your AWS account id.
        :param str bucket: Name of your s3 bucket.
        :param str path: Path where the archive will be stored.
        :param str role_name: Your AWS role name
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "role_name", role_name)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        Your AWS account id.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of your s3 bucket.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path where the archive will be stored.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Your AWS role name
        """
        return pulumi.get(self, "role_name")


@pulumi.output_type
class LogsCustomPipelineFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Filter criteria of the category.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Filter criteria of the category.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsCustomPipelineProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arithmeticProcessor":
            suggest = "arithmetic_processor"
        elif key == "attributeRemapper":
            suggest = "attribute_remapper"
        elif key == "categoryProcessor":
            suggest = "category_processor"
        elif key == "dateRemapper":
            suggest = "date_remapper"
        elif key == "geoIpParser":
            suggest = "geo_ip_parser"
        elif key == "grokParser":
            suggest = "grok_parser"
        elif key == "lookupProcessor":
            suggest = "lookup_processor"
        elif key == "messageRemapper":
            suggest = "message_remapper"
        elif key == "serviceRemapper":
            suggest = "service_remapper"
        elif key == "statusRemapper":
            suggest = "status_remapper"
        elif key == "stringBuilderProcessor":
            suggest = "string_builder_processor"
        elif key == "traceIdRemapper":
            suggest = "trace_id_remapper"
        elif key == "urlParser":
            suggest = "url_parser"
        elif key == "userAgentParser":
            suggest = "user_agent_parser"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arithmetic_processor: Optional['outputs.LogsCustomPipelineProcessorArithmeticProcessor'] = None,
                 attribute_remapper: Optional['outputs.LogsCustomPipelineProcessorAttributeRemapper'] = None,
                 category_processor: Optional['outputs.LogsCustomPipelineProcessorCategoryProcessor'] = None,
                 date_remapper: Optional['outputs.LogsCustomPipelineProcessorDateRemapper'] = None,
                 geo_ip_parser: Optional['outputs.LogsCustomPipelineProcessorGeoIpParser'] = None,
                 grok_parser: Optional['outputs.LogsCustomPipelineProcessorGrokParser'] = None,
                 lookup_processor: Optional['outputs.LogsCustomPipelineProcessorLookupProcessor'] = None,
                 message_remapper: Optional['outputs.LogsCustomPipelineProcessorMessageRemapper'] = None,
                 pipeline: Optional['outputs.LogsCustomPipelineProcessorPipeline'] = None,
                 service_remapper: Optional['outputs.LogsCustomPipelineProcessorServiceRemapper'] = None,
                 status_remapper: Optional['outputs.LogsCustomPipelineProcessorStatusRemapper'] = None,
                 string_builder_processor: Optional['outputs.LogsCustomPipelineProcessorStringBuilderProcessor'] = None,
                 trace_id_remapper: Optional['outputs.LogsCustomPipelineProcessorTraceIdRemapper'] = None,
                 url_parser: Optional['outputs.LogsCustomPipelineProcessorUrlParser'] = None,
                 user_agent_parser: Optional['outputs.LogsCustomPipelineProcessorUserAgentParser'] = None):
        """
        :param 'LogsCustomPipelineProcessorArithmeticProcessorArgs' arithmetic_processor: Arithmetic Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorAttributeRemapperArgs' attribute_remapper: Attribute Remapper Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorCategoryProcessorArgs' category_processor: Category Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorDateRemapperArgs' date_remapper: Date Remapper Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorGrokParserArgs' grok_parser: Grok Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorLookupProcessorArgs' lookup_processor: Lookup Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorMessageRemapperArgs' message_remapper: Message Remapper Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorServiceRemapperArgs' service_remapper: Service Remapper Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorStatusRemapperArgs' status_remapper: Status Remapper Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorUrlParserArgs' url_parser: URL Parser Processor. More information can be found in the
        """
        if arithmetic_processor is not None:
            pulumi.set(__self__, "arithmetic_processor", arithmetic_processor)
        if attribute_remapper is not None:
            pulumi.set(__self__, "attribute_remapper", attribute_remapper)
        if category_processor is not None:
            pulumi.set(__self__, "category_processor", category_processor)
        if date_remapper is not None:
            pulumi.set(__self__, "date_remapper", date_remapper)
        if geo_ip_parser is not None:
            pulumi.set(__self__, "geo_ip_parser", geo_ip_parser)
        if grok_parser is not None:
            pulumi.set(__self__, "grok_parser", grok_parser)
        if lookup_processor is not None:
            pulumi.set(__self__, "lookup_processor", lookup_processor)
        if message_remapper is not None:
            pulumi.set(__self__, "message_remapper", message_remapper)
        if pipeline is not None:
            pulumi.set(__self__, "pipeline", pipeline)
        if service_remapper is not None:
            pulumi.set(__self__, "service_remapper", service_remapper)
        if status_remapper is not None:
            pulumi.set(__self__, "status_remapper", status_remapper)
        if string_builder_processor is not None:
            pulumi.set(__self__, "string_builder_processor", string_builder_processor)
        if trace_id_remapper is not None:
            pulumi.set(__self__, "trace_id_remapper", trace_id_remapper)
        if url_parser is not None:
            pulumi.set(__self__, "url_parser", url_parser)
        if user_agent_parser is not None:
            pulumi.set(__self__, "user_agent_parser", user_agent_parser)

    @property
    @pulumi.getter(name="arithmeticProcessor")
    def arithmetic_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorArithmeticProcessor']:
        """
        Arithmetic Processor. More information can be found in the
        """
        return pulumi.get(self, "arithmetic_processor")

    @property
    @pulumi.getter(name="attributeRemapper")
    def attribute_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorAttributeRemapper']:
        """
        Attribute Remapper Processor. More information can be found in the
        """
        return pulumi.get(self, "attribute_remapper")

    @property
    @pulumi.getter(name="categoryProcessor")
    def category_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorCategoryProcessor']:
        """
        Category Processor. More information can be found in the
        """
        return pulumi.get(self, "category_processor")

    @property
    @pulumi.getter(name="dateRemapper")
    def date_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorDateRemapper']:
        """
        Date Remapper Processor. More information can be found in the
        """
        return pulumi.get(self, "date_remapper")

    @property
    @pulumi.getter(name="geoIpParser")
    def geo_ip_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorGeoIpParser']:
        return pulumi.get(self, "geo_ip_parser")

    @property
    @pulumi.getter(name="grokParser")
    def grok_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorGrokParser']:
        """
        Grok Processor. More information can be found in the
        """
        return pulumi.get(self, "grok_parser")

    @property
    @pulumi.getter(name="lookupProcessor")
    def lookup_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorLookupProcessor']:
        """
        Lookup Processor. More information can be found in the
        """
        return pulumi.get(self, "lookup_processor")

    @property
    @pulumi.getter(name="messageRemapper")
    def message_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorMessageRemapper']:
        """
        Message Remapper Processor. More information can be found in the
        """
        return pulumi.get(self, "message_remapper")

    @property
    @pulumi.getter
    def pipeline(self) -> Optional['outputs.LogsCustomPipelineProcessorPipeline']:
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter(name="serviceRemapper")
    def service_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorServiceRemapper']:
        """
        Service Remapper Processor. More information can be found in the
        """
        return pulumi.get(self, "service_remapper")

    @property
    @pulumi.getter(name="statusRemapper")
    def status_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorStatusRemapper']:
        """
        Status Remapper Processor. More information can be found in the
        """
        return pulumi.get(self, "status_remapper")

    @property
    @pulumi.getter(name="stringBuilderProcessor")
    def string_builder_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorStringBuilderProcessor']:
        return pulumi.get(self, "string_builder_processor")

    @property
    @pulumi.getter(name="traceIdRemapper")
    def trace_id_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorTraceIdRemapper']:
        return pulumi.get(self, "trace_id_remapper")

    @property
    @pulumi.getter(name="urlParser")
    def url_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorUrlParser']:
        """
        URL Parser Processor. More information can be found in the
        """
        return pulumi.get(self, "url_parser")

    @property
    @pulumi.getter(name="userAgentParser")
    def user_agent_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorUserAgentParser']:
        return pulumi.get(self, "user_agent_parser")


@pulumi.output_type
class LogsCustomPipelineProcessorArithmeticProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isReplaceMissing":
            suggest = "is_replace_missing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorArithmeticProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorArithmeticProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorArithmeticProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 target: str,
                 is_enabled: Optional[bool] = None,
                 is_replace_missing: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[bool]:
        return pulumi.get(self, "is_replace_missing")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorAttributeRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"
        elif key == "targetType":
            suggest = "target_type"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "overrideOnConflict":
            suggest = "override_on_conflict"
        elif key == "preserveSource":
            suggest = "preserve_source"
        elif key == "targetFormat":
            suggest = "target_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorAttributeRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorAttributeRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorAttributeRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 sources: Sequence[str],
                 target: str,
                 target_type: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 override_on_conflict: Optional[bool] = None,
                 preserve_source: Optional[bool] = None,
                 target_format: Optional[str] = None):
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "target_type", target_type)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_on_conflict is not None:
            pulumi.set(__self__, "override_on_conflict", override_on_conflict)
        if preserve_source is not None:
            pulumi.set(__self__, "preserve_source", preserve_source)
        if target_format is not None:
            pulumi.set(__self__, "target_format", target_format)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> str:
        return pulumi.get(self, "target_type")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideOnConflict")
    def override_on_conflict(self) -> Optional[bool]:
        return pulumi.get(self, "override_on_conflict")

    @property
    @pulumi.getter(name="preserveSource")
    def preserve_source(self) -> Optional[bool]:
        return pulumi.get(self, "preserve_source")

    @property
    @pulumi.getter(name="targetFormat")
    def target_format(self) -> Optional[str]:
        return pulumi.get(self, "target_format")


@pulumi.output_type
class LogsCustomPipelineProcessorCategoryProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorCategoryProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorCategoryProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorCategoryProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 categories: Sequence['outputs.LogsCustomPipelineProcessorCategoryProcessorCategory'],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def categories(self) -> Sequence['outputs.LogsCustomPipelineProcessorCategoryProcessorCategory']:
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorCategoryProcessorCategory(dict):
    def __init__(__self__, *,
                 filter: 'outputs.LogsCustomPipelineProcessorCategoryProcessorCategoryFilter',
                 name: str):
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.LogsCustomPipelineProcessorCategoryProcessorCategoryFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorCategoryProcessorCategoryFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Filter criteria of the category.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Filter criteria of the category.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsCustomPipelineProcessorDateRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorDateRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorDateRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorDateRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorGeoIpParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorGeoIpParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorGeoIpParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorGeoIpParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorGrokParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorGrokParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorGrokParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorGrokParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grok: 'outputs.LogsCustomPipelineProcessorGrokParserGrok',
                 source: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 samples: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "grok", grok)
        pulumi.set(__self__, "source", source)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if samples is not None:
            pulumi.set(__self__, "samples", samples)

    @property
    @pulumi.getter
    def grok(self) -> 'outputs.LogsCustomPipelineProcessorGrokParserGrok':
        return pulumi.get(self, "grok")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def samples(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "samples")


@pulumi.output_type
class LogsCustomPipelineProcessorGrokParserGrok(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchRules":
            suggest = "match_rules"
        elif key == "supportRules":
            suggest = "support_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorGrokParserGrok. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorGrokParserGrok.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorGrokParserGrok.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_rules: str,
                 support_rules: str):
        pulumi.set(__self__, "match_rules", match_rules)
        pulumi.set(__self__, "support_rules", support_rules)

    @property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> str:
        return pulumi.get(self, "match_rules")

    @property
    @pulumi.getter(name="supportRules")
    def support_rules(self) -> str:
        return pulumi.get(self, "support_rules")


@pulumi.output_type
class LogsCustomPipelineProcessorLookupProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lookupTables":
            suggest = "lookup_tables"
        elif key == "defaultLookup":
            suggest = "default_lookup"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorLookupProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorLookupProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorLookupProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lookup_tables: Sequence[str],
                 source: str,
                 target: str,
                 default_lookup: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "lookup_tables", lookup_tables)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if default_lookup is not None:
            pulumi.set(__self__, "default_lookup", default_lookup)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lookupTables")
    def lookup_tables(self) -> Sequence[str]:
        return pulumi.get(self, "lookup_tables")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="defaultLookup")
    def default_lookup(self) -> Optional[str]:
        return pulumi.get(self, "default_lookup")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorMessageRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorMessageRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorMessageRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorMessageRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipeline(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipeline. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipeline.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipeline.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Sequence['outputs.LogsCustomPipelineProcessorPipelineFilter'],
                 name: str,
                 is_enabled: Optional[bool] = None,
                 processors: Optional[Sequence['outputs.LogsCustomPipelineProcessorPipelineProcessor']] = None):
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "name", name)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if processors is not None:
            pulumi.set(__self__, "processors", processors)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.LogsCustomPipelineProcessorPipelineFilter']:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def processors(self) -> Optional[Sequence['outputs.LogsCustomPipelineProcessorPipelineProcessor']]:
        return pulumi.get(self, "processors")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Filter criteria of the category.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Filter criteria of the category.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arithmeticProcessor":
            suggest = "arithmetic_processor"
        elif key == "attributeRemapper":
            suggest = "attribute_remapper"
        elif key == "categoryProcessor":
            suggest = "category_processor"
        elif key == "dateRemapper":
            suggest = "date_remapper"
        elif key == "geoIpParser":
            suggest = "geo_ip_parser"
        elif key == "grokParser":
            suggest = "grok_parser"
        elif key == "lookupProcessor":
            suggest = "lookup_processor"
        elif key == "messageRemapper":
            suggest = "message_remapper"
        elif key == "serviceRemapper":
            suggest = "service_remapper"
        elif key == "statusRemapper":
            suggest = "status_remapper"
        elif key == "stringBuilderProcessor":
            suggest = "string_builder_processor"
        elif key == "traceIdRemapper":
            suggest = "trace_id_remapper"
        elif key == "urlParser":
            suggest = "url_parser"
        elif key == "userAgentParser":
            suggest = "user_agent_parser"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arithmetic_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor'] = None,
                 attribute_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper'] = None,
                 category_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor'] = None,
                 date_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorDateRemapper'] = None,
                 geo_ip_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGeoIpParser'] = None,
                 grok_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParser'] = None,
                 lookup_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorLookupProcessor'] = None,
                 message_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorMessageRemapper'] = None,
                 service_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorServiceRemapper'] = None,
                 status_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStatusRemapper'] = None,
                 string_builder_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor'] = None,
                 trace_id_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper'] = None,
                 url_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUrlParser'] = None,
                 user_agent_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUserAgentParser'] = None):
        """
        :param 'LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessorArgs' arithmetic_processor: Arithmetic Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorPipelineProcessorAttributeRemapperArgs' attribute_remapper: Attribute Remapper Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorArgs' category_processor: Category Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorPipelineProcessorDateRemapperArgs' date_remapper: Date Remapper Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorPipelineProcessorGrokParserArgs' grok_parser: Grok Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorPipelineProcessorLookupProcessorArgs' lookup_processor: Lookup Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorPipelineProcessorMessageRemapperArgs' message_remapper: Message Remapper Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorPipelineProcessorServiceRemapperArgs' service_remapper: Service Remapper Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorPipelineProcessorStatusRemapperArgs' status_remapper: Status Remapper Processor. More information can be found in the
        :param 'LogsCustomPipelineProcessorPipelineProcessorUrlParserArgs' url_parser: URL Parser Processor. More information can be found in the
        """
        if arithmetic_processor is not None:
            pulumi.set(__self__, "arithmetic_processor", arithmetic_processor)
        if attribute_remapper is not None:
            pulumi.set(__self__, "attribute_remapper", attribute_remapper)
        if category_processor is not None:
            pulumi.set(__self__, "category_processor", category_processor)
        if date_remapper is not None:
            pulumi.set(__self__, "date_remapper", date_remapper)
        if geo_ip_parser is not None:
            pulumi.set(__self__, "geo_ip_parser", geo_ip_parser)
        if grok_parser is not None:
            pulumi.set(__self__, "grok_parser", grok_parser)
        if lookup_processor is not None:
            pulumi.set(__self__, "lookup_processor", lookup_processor)
        if message_remapper is not None:
            pulumi.set(__self__, "message_remapper", message_remapper)
        if service_remapper is not None:
            pulumi.set(__self__, "service_remapper", service_remapper)
        if status_remapper is not None:
            pulumi.set(__self__, "status_remapper", status_remapper)
        if string_builder_processor is not None:
            pulumi.set(__self__, "string_builder_processor", string_builder_processor)
        if trace_id_remapper is not None:
            pulumi.set(__self__, "trace_id_remapper", trace_id_remapper)
        if url_parser is not None:
            pulumi.set(__self__, "url_parser", url_parser)
        if user_agent_parser is not None:
            pulumi.set(__self__, "user_agent_parser", user_agent_parser)

    @property
    @pulumi.getter(name="arithmeticProcessor")
    def arithmetic_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor']:
        """
        Arithmetic Processor. More information can be found in the
        """
        return pulumi.get(self, "arithmetic_processor")

    @property
    @pulumi.getter(name="attributeRemapper")
    def attribute_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper']:
        """
        Attribute Remapper Processor. More information can be found in the
        """
        return pulumi.get(self, "attribute_remapper")

    @property
    @pulumi.getter(name="categoryProcessor")
    def category_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor']:
        """
        Category Processor. More information can be found in the
        """
        return pulumi.get(self, "category_processor")

    @property
    @pulumi.getter(name="dateRemapper")
    def date_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorDateRemapper']:
        """
        Date Remapper Processor. More information can be found in the
        """
        return pulumi.get(self, "date_remapper")

    @property
    @pulumi.getter(name="geoIpParser")
    def geo_ip_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGeoIpParser']:
        return pulumi.get(self, "geo_ip_parser")

    @property
    @pulumi.getter(name="grokParser")
    def grok_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParser']:
        """
        Grok Processor. More information can be found in the
        """
        return pulumi.get(self, "grok_parser")

    @property
    @pulumi.getter(name="lookupProcessor")
    def lookup_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorLookupProcessor']:
        """
        Lookup Processor. More information can be found in the
        """
        return pulumi.get(self, "lookup_processor")

    @property
    @pulumi.getter(name="messageRemapper")
    def message_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorMessageRemapper']:
        """
        Message Remapper Processor. More information can be found in the
        """
        return pulumi.get(self, "message_remapper")

    @property
    @pulumi.getter(name="serviceRemapper")
    def service_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorServiceRemapper']:
        """
        Service Remapper Processor. More information can be found in the
        """
        return pulumi.get(self, "service_remapper")

    @property
    @pulumi.getter(name="statusRemapper")
    def status_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStatusRemapper']:
        """
        Status Remapper Processor. More information can be found in the
        """
        return pulumi.get(self, "status_remapper")

    @property
    @pulumi.getter(name="stringBuilderProcessor")
    def string_builder_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor']:
        return pulumi.get(self, "string_builder_processor")

    @property
    @pulumi.getter(name="traceIdRemapper")
    def trace_id_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper']:
        return pulumi.get(self, "trace_id_remapper")

    @property
    @pulumi.getter(name="urlParser")
    def url_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUrlParser']:
        """
        URL Parser Processor. More information can be found in the
        """
        return pulumi.get(self, "url_parser")

    @property
    @pulumi.getter(name="userAgentParser")
    def user_agent_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUserAgentParser']:
        return pulumi.get(self, "user_agent_parser")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isReplaceMissing":
            suggest = "is_replace_missing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 target: str,
                 is_enabled: Optional[bool] = None,
                 is_replace_missing: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[bool]:
        return pulumi.get(self, "is_replace_missing")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"
        elif key == "targetType":
            suggest = "target_type"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "overrideOnConflict":
            suggest = "override_on_conflict"
        elif key == "preserveSource":
            suggest = "preserve_source"
        elif key == "targetFormat":
            suggest = "target_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 sources: Sequence[str],
                 target: str,
                 target_type: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 override_on_conflict: Optional[bool] = None,
                 preserve_source: Optional[bool] = None,
                 target_format: Optional[str] = None):
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "target_type", target_type)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_on_conflict is not None:
            pulumi.set(__self__, "override_on_conflict", override_on_conflict)
        if preserve_source is not None:
            pulumi.set(__self__, "preserve_source", preserve_source)
        if target_format is not None:
            pulumi.set(__self__, "target_format", target_format)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> str:
        return pulumi.get(self, "target_type")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideOnConflict")
    def override_on_conflict(self) -> Optional[bool]:
        return pulumi.get(self, "override_on_conflict")

    @property
    @pulumi.getter(name="preserveSource")
    def preserve_source(self) -> Optional[bool]:
        return pulumi.get(self, "preserve_source")

    @property
    @pulumi.getter(name="targetFormat")
    def target_format(self) -> Optional[str]:
        return pulumi.get(self, "target_format")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 categories: Sequence['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory'],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def categories(self) -> Sequence['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory']:
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory(dict):
    def __init__(__self__, *,
                 filter: 'outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter',
                 name: str):
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Filter criteria of the category.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Filter criteria of the category.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorDateRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorDateRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorDateRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorDateRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorGeoIpParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorGeoIpParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGeoIpParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGeoIpParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorGrokParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorGrokParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGrokParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGrokParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grok: 'outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok',
                 source: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 samples: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "grok", grok)
        pulumi.set(__self__, "source", source)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if samples is not None:
            pulumi.set(__self__, "samples", samples)

    @property
    @pulumi.getter
    def grok(self) -> 'outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok':
        return pulumi.get(self, "grok")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def samples(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "samples")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchRules":
            suggest = "match_rules"
        elif key == "supportRules":
            suggest = "support_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_rules: str,
                 support_rules: str):
        pulumi.set(__self__, "match_rules", match_rules)
        pulumi.set(__self__, "support_rules", support_rules)

    @property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> str:
        return pulumi.get(self, "match_rules")

    @property
    @pulumi.getter(name="supportRules")
    def support_rules(self) -> str:
        return pulumi.get(self, "support_rules")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorLookupProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lookupTables":
            suggest = "lookup_tables"
        elif key == "defaultLookup":
            suggest = "default_lookup"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorLookupProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorLookupProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorLookupProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lookup_tables: Sequence[str],
                 source: str,
                 target: str,
                 default_lookup: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "lookup_tables", lookup_tables)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if default_lookup is not None:
            pulumi.set(__self__, "default_lookup", default_lookup)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lookupTables")
    def lookup_tables(self) -> Sequence[str]:
        return pulumi.get(self, "lookup_tables")

    @property
    @pulumi.getter
    def source(self) -> str:
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="defaultLookup")
    def default_lookup(self) -> Optional[str]:
        return pulumi.get(self, "default_lookup")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorMessageRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorMessageRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorMessageRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorMessageRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorServiceRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorServiceRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorServiceRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorServiceRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorStatusRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorStatusRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorStatusRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorStatusRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isReplaceMissing":
            suggest = "is_replace_missing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: str,
                 template: str,
                 is_enabled: Optional[bool] = None,
                 is_replace_missing: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "template", template)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def template(self) -> str:
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[bool]:
        return pulumi.get(self, "is_replace_missing")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorUrlParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "normalizeEndingSlashes":
            suggest = "normalize_ending_slashes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorUrlParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorUrlParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorUrlParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 normalize_ending_slashes: Optional[bool] = None):
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if normalize_ending_slashes is not None:
            pulumi.set(__self__, "normalize_ending_slashes", normalize_ending_slashes)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="normalizeEndingSlashes")
    def normalize_ending_slashes(self) -> Optional[bool]:
        return pulumi.get(self, "normalize_ending_slashes")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorUserAgentParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isEncoded":
            suggest = "is_encoded"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorUserAgentParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorUserAgentParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorUserAgentParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 is_encoded: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_encoded is not None:
            pulumi.set(__self__, "is_encoded", is_encoded)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isEncoded")
    def is_encoded(self) -> Optional[bool]:
        return pulumi.get(self, "is_encoded")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorServiceRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorServiceRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorServiceRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorServiceRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorStatusRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorStatusRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorStatusRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorStatusRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorStringBuilderProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isReplaceMissing":
            suggest = "is_replace_missing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorStringBuilderProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorStringBuilderProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorStringBuilderProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: str,
                 template: str,
                 is_enabled: Optional[bool] = None,
                 is_replace_missing: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "template", template)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def template(self) -> str:
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[bool]:
        return pulumi.get(self, "is_replace_missing")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorTraceIdRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorTraceIdRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorTraceIdRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorTraceIdRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorUrlParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "normalizeEndingSlashes":
            suggest = "normalize_ending_slashes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorUrlParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorUrlParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorUrlParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 normalize_ending_slashes: Optional[bool] = None):
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if normalize_ending_slashes is not None:
            pulumi.set(__self__, "normalize_ending_slashes", normalize_ending_slashes)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="normalizeEndingSlashes")
    def normalize_ending_slashes(self) -> Optional[bool]:
        return pulumi.get(self, "normalize_ending_slashes")


@pulumi.output_type
class LogsCustomPipelineProcessorUserAgentParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isEncoded":
            suggest = "is_encoded"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorUserAgentParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorUserAgentParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorUserAgentParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 is_encoded: Optional[bool] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_encoded is not None:
            pulumi.set(__self__, "is_encoded", is_encoded)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isEncoded")
    def is_encoded(self) -> Optional[bool]:
        return pulumi.get(self, "is_encoded")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsIndexExclusionFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsIndexExclusionFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsIndexExclusionFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsIndexExclusionFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.LogsIndexExclusionFilterFilter']] = None,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param bool is_enabled: A boolean stating if the exclusion is active or not.
        :param str name: The name of the exclusion filter.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.LogsIndexExclusionFilterFilter']]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        A boolean stating if the exclusion is active or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the exclusion filter.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsIndexExclusionFilterFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sampleRate":
            suggest = "sample_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsIndexExclusionFilterFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsIndexExclusionFilterFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsIndexExclusionFilterFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: Optional[str] = None,
                 sample_rate: Optional[float] = None):
        """
        :param str query: Logs filter criteria. Only logs matching this filter criteria are considered for this index.
        """
        if query is not None:
            pulumi.set(__self__, "query", query)
        if sample_rate is not None:
            pulumi.set(__self__, "sample_rate", sample_rate)

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        Logs filter criteria. Only logs matching this filter criteria are considered for this index.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[float]:
        return pulumi.get(self, "sample_rate")


@pulumi.output_type
class LogsIndexFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Logs filter criteria. Only logs matching this filter criteria are considered for this index.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Logs filter criteria. Only logs matching this filter criteria are considered for this index.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsMetricCompute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsMetricCompute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsMetricCompute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsMetricCompute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_type: str,
                 path: Optional[str] = None):
        """
        :param str aggregation_type: The type of aggregation to use. This field can't be updated after creation.
        :param str path: The path to the value the log-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
        """
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> str:
        """
        The type of aggregation to use. This field can't be updated after creation.
        """
        return pulumi.get(self, "aggregation_type")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to the value the log-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class LogsMetricFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The search query - following the log search syntax.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The search query - following the log search syntax.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsMetricGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagName":
            suggest = "tag_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsMetricGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsMetricGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsMetricGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 tag_name: str):
        """
        :param str path: The path to the value the log-based metric will be aggregated over.
        :param str tag_name: Name of the tag that gets created.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "tag_name", tag_name)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path to the value the log-based metric will be aggregated over.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> str:
        """
        Name of the tag that gets created.
        """
        return pulumi.get(self, "tag_name")


@pulumi.output_type
class MonitorMonitorThresholdWindows(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recoveryWindow":
            suggest = "recovery_window"
        elif key == "triggerWindow":
            suggest = "trigger_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorMonitorThresholdWindows. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorMonitorThresholdWindows.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorMonitorThresholdWindows.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recovery_window: Optional[str] = None,
                 trigger_window: Optional[str] = None):
        """
        :param str recovery_window: Describes how long an anomalous metric must be normal before the alert recovers.
        :param str trigger_window: Describes how long a metric must be anomalous before an alert triggers.
        """
        if recovery_window is not None:
            pulumi.set(__self__, "recovery_window", recovery_window)
        if trigger_window is not None:
            pulumi.set(__self__, "trigger_window", trigger_window)

    @property
    @pulumi.getter(name="recoveryWindow")
    def recovery_window(self) -> Optional[str]:
        """
        Describes how long an anomalous metric must be normal before the alert recovers.
        """
        return pulumi.get(self, "recovery_window")

    @property
    @pulumi.getter(name="triggerWindow")
    def trigger_window(self) -> Optional[str]:
        """
        Describes how long a metric must be anomalous before an alert triggers.
        """
        return pulumi.get(self, "trigger_window")


@pulumi.output_type
class MonitorMonitorThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "criticalRecovery":
            suggest = "critical_recovery"
        elif key == "warningRecovery":
            suggest = "warning_recovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorMonitorThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorMonitorThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorMonitorThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 critical: Optional[str] = None,
                 critical_recovery: Optional[str] = None,
                 ok: Optional[str] = None,
                 unknown: Optional[str] = None,
                 warning: Optional[str] = None,
                 warning_recovery: Optional[str] = None):
        """
        :param str critical: The monitor CRITICAL recovery threshold. Must be a number.
        :param str critical_recovery: The monitor CRITICAL recovery threshold. Must be a number.
        :param str ok: The monitor OK threshold. Must be a number.
        :param str unknown: The monitor UNKNOWN threshold. Must be a number.
        :param str warning: The monitor WARNING threshold. Must be a number.
        :param str warning_recovery: The monitor WARNING recovery threshold. Must be a number.
        """
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if critical_recovery is not None:
            pulumi.set(__self__, "critical_recovery", critical_recovery)
        if ok is not None:
            pulumi.set(__self__, "ok", ok)
        if unknown is not None:
            pulumi.set(__self__, "unknown", unknown)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)
        if warning_recovery is not None:
            pulumi.set(__self__, "warning_recovery", warning_recovery)

    @property
    @pulumi.getter
    def critical(self) -> Optional[str]:
        """
        The monitor CRITICAL recovery threshold. Must be a number.
        """
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter(name="criticalRecovery")
    def critical_recovery(self) -> Optional[str]:
        """
        The monitor CRITICAL recovery threshold. Must be a number.
        """
        return pulumi.get(self, "critical_recovery")

    @property
    @pulumi.getter
    def ok(self) -> Optional[str]:
        """
        The monitor OK threshold. Must be a number.
        """
        return pulumi.get(self, "ok")

    @property
    @pulumi.getter
    def unknown(self) -> Optional[str]:
        """
        The monitor UNKNOWN threshold. Must be a number.
        """
        return pulumi.get(self, "unknown")

    @property
    @pulumi.getter
    def warning(self) -> Optional[str]:
        """
        The monitor WARNING threshold. Must be a number.
        """
        return pulumi.get(self, "warning")

    @property
    @pulumi.getter(name="warningRecovery")
    def warning_recovery(self) -> Optional[str]:
        """
        The monitor WARNING recovery threshold. Must be a number.
        """
        return pulumi.get(self, "warning_recovery")


@pulumi.output_type
class MonitorThresholdWindows(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recoveryWindow":
            suggest = "recovery_window"
        elif key == "triggerWindow":
            suggest = "trigger_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorThresholdWindows. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorThresholdWindows.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorThresholdWindows.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recovery_window: Optional[str] = None,
                 trigger_window: Optional[str] = None):
        if recovery_window is not None:
            pulumi.set(__self__, "recovery_window", recovery_window)
        if trigger_window is not None:
            pulumi.set(__self__, "trigger_window", trigger_window)

    @property
    @pulumi.getter(name="recoveryWindow")
    def recovery_window(self) -> Optional[str]:
        return pulumi.get(self, "recovery_window")

    @property
    @pulumi.getter(name="triggerWindow")
    def trigger_window(self) -> Optional[str]:
        return pulumi.get(self, "trigger_window")


@pulumi.output_type
class MonitorThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "criticalRecovery":
            suggest = "critical_recovery"
        elif key == "warningRecovery":
            suggest = "warning_recovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 critical: Optional[float] = None,
                 critical_recovery: Optional[float] = None,
                 ok: Optional[float] = None,
                 unknown: Optional[float] = None,
                 warning: Optional[float] = None,
                 warning_recovery: Optional[float] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if critical_recovery is not None:
            pulumi.set(__self__, "critical_recovery", critical_recovery)
        if ok is not None:
            pulumi.set(__self__, "ok", ok)
        if unknown is not None:
            pulumi.set(__self__, "unknown", unknown)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)
        if warning_recovery is not None:
            pulumi.set(__self__, "warning_recovery", warning_recovery)

    @property
    @pulumi.getter
    def critical(self) -> Optional[float]:
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter(name="criticalRecovery")
    def critical_recovery(self) -> Optional[float]:
        return pulumi.get(self, "critical_recovery")

    @property
    @pulumi.getter
    def ok(self) -> Optional[float]:
        return pulumi.get(self, "ok")

    @property
    @pulumi.getter
    def unknown(self) -> Optional[float]:
        return pulumi.get(self, "unknown")

    @property
    @pulumi.getter
    def warning(self) -> Optional[float]:
        return pulumi.get(self, "warning")

    @property
    @pulumi.getter(name="warningRecovery")
    def warning_recovery(self) -> Optional[float]:
        return pulumi.get(self, "warning_recovery")


@pulumi.output_type
class RolePermission(dict):
    def __init__(__self__, *,
                 id: str,
                 name: Optional[str] = None):
        """
        :param str id: ID of the permission to assign.
        :param str name: Name of the permission.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the permission to assign.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the permission.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ScreenBoardTemplateVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 default: Optional[str] = None,
                 prefix: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def default(self) -> Optional[str]:
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")


@pulumi.output_type
class ScreenBoardWidget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertId":
            suggest = "alert_id"
        elif key == "autoRefresh":
            suggest = "auto_refresh"
        elif key == "colorPreference":
            suggest = "color_preference"
        elif key == "displayFormat":
            suggest = "display_format"
        elif key == "eventSize":
            suggest = "event_size"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "hideZeroCounts":
            suggest = "hide_zero_counts"
        elif key == "layoutVersion":
            suggest = "layout_version"
        elif key == "legendSize":
            suggest = "legend_size"
        elif key == "manageStatusShowTitle":
            suggest = "manage_status_show_title"
        elif key == "manageStatusTitleAlign":
            suggest = "manage_status_title_align"
        elif key == "manageStatusTitleSize":
            suggest = "manage_status_title_size"
        elif key == "manageStatusTitleText":
            suggest = "manage_status_title_text"
        elif key == "mustShowBreakdown":
            suggest = "must_show_breakdown"
        elif key == "mustShowDistribution":
            suggest = "must_show_distribution"
        elif key == "mustShowErrors":
            suggest = "must_show_errors"
        elif key == "mustShowHits":
            suggest = "must_show_hits"
        elif key == "mustShowLatency":
            suggest = "must_show_latency"
        elif key == "mustShowResourceList":
            suggest = "must_show_resource_list"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "serviceService":
            suggest = "service_service"
        elif key == "showLastTriggered":
            suggest = "show_last_triggered"
        elif key == "sizeVersion":
            suggest = "size_version"
        elif key == "summaryType":
            suggest = "summary_type"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "textSize":
            suggest = "text_size"
        elif key == "tickEdge":
            suggest = "tick_edge"
        elif key == "tickPos":
            suggest = "tick_pos"
        elif key == "tileDeves":
            suggest = "tile_deves"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"
        elif key == "vizType":
            suggest = "viz_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScreenBoardWidget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScreenBoardWidget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScreenBoardWidget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 x: int,
                 y: int,
                 alert_id: Optional[int] = None,
                 auto_refresh: Optional[bool] = None,
                 bgcolor: Optional[str] = None,
                 check: Optional[str] = None,
                 color: Optional[str] = None,
                 color_preference: Optional[str] = None,
                 columns: Optional[str] = None,
                 display_format: Optional[str] = None,
                 env: Optional[str] = None,
                 event_size: Optional[str] = None,
                 font_size: Optional[str] = None,
                 group: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 grouping: Optional[str] = None,
                 height: Optional[int] = None,
                 hide_zero_counts: Optional[bool] = None,
                 html: Optional[str] = None,
                 layout_version: Optional[str] = None,
                 legend: Optional[bool] = None,
                 legend_size: Optional[str] = None,
                 logset: Optional[str] = None,
                 manage_status_show_title: Optional[bool] = None,
                 manage_status_title_align: Optional[str] = None,
                 manage_status_title_size: Optional[str] = None,
                 manage_status_title_text: Optional[str] = None,
                 margin: Optional[str] = None,
                 monitor: Optional[Mapping[str, str]] = None,
                 must_show_breakdown: Optional[bool] = None,
                 must_show_distribution: Optional[bool] = None,
                 must_show_errors: Optional[bool] = None,
                 must_show_hits: Optional[bool] = None,
                 must_show_latency: Optional[bool] = None,
                 must_show_resource_list: Optional[bool] = None,
                 params: Optional[Mapping[str, str]] = None,
                 precision: Optional[str] = None,
                 query: Optional[str] = None,
                 rules: Optional[Sequence['outputs.ScreenBoardWidgetRule']] = None,
                 service_name: Optional[str] = None,
                 service_service: Optional[str] = None,
                 show_last_triggered: Optional[bool] = None,
                 size_version: Optional[str] = None,
                 sizing: Optional[str] = None,
                 summary_type: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 text: Optional[str] = None,
                 text_align: Optional[str] = None,
                 text_size: Optional[str] = None,
                 tick: Optional[bool] = None,
                 tick_edge: Optional[str] = None,
                 tick_pos: Optional[str] = None,
                 tile_deves: Optional[Sequence['outputs.ScreenBoardWidgetTileDef']] = None,
                 time: Optional[Mapping[str, str]] = None,
                 timeframes: Optional[Sequence[str]] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[int] = None,
                 unit: Optional[str] = None,
                 url: Optional[str] = None,
                 viz_type: Optional[str] = None,
                 width: Optional[int] = None):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)
        if alert_id is not None:
            pulumi.set(__self__, "alert_id", alert_id)
        if auto_refresh is not None:
            pulumi.set(__self__, "auto_refresh", auto_refresh)
        if bgcolor is not None:
            pulumi.set(__self__, "bgcolor", bgcolor)
        if check is not None:
            pulumi.set(__self__, "check", check)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if color_preference is not None:
            pulumi.set(__self__, "color_preference", color_preference)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if env is not None:
            pulumi.set(__self__, "env", env)
        if event_size is not None:
            pulumi.set(__self__, "event_size", event_size)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if grouping is not None:
            pulumi.set(__self__, "grouping", grouping)
        if height is not None:
            pulumi.set(__self__, "height", height)
        if hide_zero_counts is not None:
            pulumi.set(__self__, "hide_zero_counts", hide_zero_counts)
        if html is not None:
            pulumi.set(__self__, "html", html)
        if layout_version is not None:
            pulumi.set(__self__, "layout_version", layout_version)
        if legend is not None:
            pulumi.set(__self__, "legend", legend)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if logset is not None:
            pulumi.set(__self__, "logset", logset)
        if manage_status_show_title is not None:
            pulumi.set(__self__, "manage_status_show_title", manage_status_show_title)
        if manage_status_title_align is not None:
            pulumi.set(__self__, "manage_status_title_align", manage_status_title_align)
        if manage_status_title_size is not None:
            pulumi.set(__self__, "manage_status_title_size", manage_status_title_size)
        if manage_status_title_text is not None:
            pulumi.set(__self__, "manage_status_title_text", manage_status_title_text)
        if margin is not None:
            pulumi.set(__self__, "margin", margin)
        if monitor is not None:
            pulumi.set(__self__, "monitor", monitor)
        if must_show_breakdown is not None:
            pulumi.set(__self__, "must_show_breakdown", must_show_breakdown)
        if must_show_distribution is not None:
            pulumi.set(__self__, "must_show_distribution", must_show_distribution)
        if must_show_errors is not None:
            pulumi.set(__self__, "must_show_errors", must_show_errors)
        if must_show_hits is not None:
            pulumi.set(__self__, "must_show_hits", must_show_hits)
        if must_show_latency is not None:
            pulumi.set(__self__, "must_show_latency", must_show_latency)
        if must_show_resource_list is not None:
            pulumi.set(__self__, "must_show_resource_list", must_show_resource_list)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if service_service is not None:
            pulumi.set(__self__, "service_service", service_service)
        if show_last_triggered is not None:
            pulumi.set(__self__, "show_last_triggered", show_last_triggered)
        if size_version is not None:
            pulumi.set(__self__, "size_version", size_version)
        if sizing is not None:
            pulumi.set(__self__, "sizing", sizing)
        if summary_type is not None:
            pulumi.set(__self__, "summary_type", summary_type)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if text_size is not None:
            pulumi.set(__self__, "text_size", text_size)
        if tick is not None:
            pulumi.set(__self__, "tick", tick)
        if tick_edge is not None:
            pulumi.set(__self__, "tick_edge", tick_edge)
        if tick_pos is not None:
            pulumi.set(__self__, "tick_pos", tick_pos)
        if tile_deves is not None:
            pulumi.set(__self__, "tile_deves", tile_deves)
        if time is not None:
            pulumi.set(__self__, "time", time)
        if timeframes is not None:
            pulumi.set(__self__, "timeframes", timeframes)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if viz_type is not None:
            pulumi.set(__self__, "viz_type", viz_type)
        if width is not None:
            pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def x(self) -> int:
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> int:
        return pulumi.get(self, "y")

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> Optional[int]:
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter(name="autoRefresh")
    def auto_refresh(self) -> Optional[bool]:
        return pulumi.get(self, "auto_refresh")

    @property
    @pulumi.getter
    def bgcolor(self) -> Optional[str]:
        return pulumi.get(self, "bgcolor")

    @property
    @pulumi.getter
    def check(self) -> Optional[str]:
        return pulumi.get(self, "check")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="colorPreference")
    def color_preference(self) -> Optional[str]:
        return pulumi.get(self, "color_preference")

    @property
    @pulumi.getter
    def columns(self) -> Optional[str]:
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter
    def env(self) -> Optional[str]:
        return pulumi.get(self, "env")

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[str]:
        return pulumi.get(self, "event_size")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def grouping(self) -> Optional[str]:
        return pulumi.get(self, "grouping")

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        return pulumi.get(self, "height")

    @property
    @pulumi.getter(name="hideZeroCounts")
    def hide_zero_counts(self) -> Optional[bool]:
        return pulumi.get(self, "hide_zero_counts")

    @property
    @pulumi.getter
    def html(self) -> Optional[str]:
        return pulumi.get(self, "html")

    @property
    @pulumi.getter(name="layoutVersion")
    def layout_version(self) -> Optional[str]:
        return pulumi.get(self, "layout_version")

    @property
    @pulumi.getter
    def legend(self) -> Optional[bool]:
        return pulumi.get(self, "legend")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter
    def logset(self) -> Optional[str]:
        return pulumi.get(self, "logset")

    @property
    @pulumi.getter(name="manageStatusShowTitle")
    def manage_status_show_title(self) -> Optional[bool]:
        return pulumi.get(self, "manage_status_show_title")

    @property
    @pulumi.getter(name="manageStatusTitleAlign")
    def manage_status_title_align(self) -> Optional[str]:
        return pulumi.get(self, "manage_status_title_align")

    @property
    @pulumi.getter(name="manageStatusTitleSize")
    def manage_status_title_size(self) -> Optional[str]:
        return pulumi.get(self, "manage_status_title_size")

    @property
    @pulumi.getter(name="manageStatusTitleText")
    def manage_status_title_text(self) -> Optional[str]:
        return pulumi.get(self, "manage_status_title_text")

    @property
    @pulumi.getter
    def margin(self) -> Optional[str]:
        return pulumi.get(self, "margin")

    @property
    @pulumi.getter
    def monitor(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "monitor")

    @property
    @pulumi.getter(name="mustShowBreakdown")
    def must_show_breakdown(self) -> Optional[bool]:
        return pulumi.get(self, "must_show_breakdown")

    @property
    @pulumi.getter(name="mustShowDistribution")
    def must_show_distribution(self) -> Optional[bool]:
        return pulumi.get(self, "must_show_distribution")

    @property
    @pulumi.getter(name="mustShowErrors")
    def must_show_errors(self) -> Optional[bool]:
        return pulumi.get(self, "must_show_errors")

    @property
    @pulumi.getter(name="mustShowHits")
    def must_show_hits(self) -> Optional[bool]:
        return pulumi.get(self, "must_show_hits")

    @property
    @pulumi.getter(name="mustShowLatency")
    def must_show_latency(self) -> Optional[bool]:
        return pulumi.get(self, "must_show_latency")

    @property
    @pulumi.getter(name="mustShowResourceList")
    def must_show_resource_list(self) -> Optional[bool]:
        return pulumi.get(self, "must_show_resource_list")

    @property
    @pulumi.getter
    def params(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "params")

    @property
    @pulumi.getter
    def precision(self) -> Optional[str]:
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.ScreenBoardWidgetRule']]:
        return pulumi.get(self, "rules")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="serviceService")
    def service_service(self) -> Optional[str]:
        return pulumi.get(self, "service_service")

    @property
    @pulumi.getter(name="showLastTriggered")
    def show_last_triggered(self) -> Optional[bool]:
        return pulumi.get(self, "show_last_triggered")

    @property
    @pulumi.getter(name="sizeVersion")
    def size_version(self) -> Optional[str]:
        return pulumi.get(self, "size_version")

    @property
    @pulumi.getter
    def sizing(self) -> Optional[str]:
        return pulumi.get(self, "sizing")

    @property
    @pulumi.getter(name="summaryType")
    def summary_type(self) -> Optional[str]:
        return pulumi.get(self, "summary_type")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        return pulumi.get(self, "text")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter(name="textSize")
    def text_size(self) -> Optional[str]:
        return pulumi.get(self, "text_size")

    @property
    @pulumi.getter
    def tick(self) -> Optional[bool]:
        return pulumi.get(self, "tick")

    @property
    @pulumi.getter(name="tickEdge")
    def tick_edge(self) -> Optional[str]:
        return pulumi.get(self, "tick_edge")

    @property
    @pulumi.getter(name="tickPos")
    def tick_pos(self) -> Optional[str]:
        return pulumi.get(self, "tick_pos")

    @property
    @pulumi.getter(name="tileDeves")
    def tile_deves(self) -> Optional[Sequence['outputs.ScreenBoardWidgetTileDef']]:
        return pulumi.get(self, "tile_deves")

    @property
    @pulumi.getter
    def time(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "time")

    @property
    @pulumi.getter
    def timeframes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "timeframes")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[int]:
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="vizType")
    def viz_type(self) -> Optional[str]:
        return pulumi.get(self, "viz_type")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        return pulumi.get(self, "width")


@pulumi.output_type
class ScreenBoardWidgetRule(dict):
    def __init__(__self__, *,
                 color: Optional[str] = None,
                 threshold: Optional[float] = None,
                 timeframe: Optional[str] = None):
        if color is not None:
            pulumi.set(__self__, "color", color)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class ScreenBoardWidgetTileDef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customUnit":
            suggest = "custom_unit"
        elif key == "noGroupHosts":
            suggest = "no_group_hosts"
        elif key == "noMetricHosts":
            suggest = "no_metric_hosts"
        elif key == "nodeType":
            suggest = "node_type"
        elif key == "textAlign":
            suggest = "text_align"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScreenBoardWidgetTileDef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScreenBoardWidgetTileDef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScreenBoardWidgetTileDef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 requests: Sequence['outputs.ScreenBoardWidgetTileDefRequest'],
                 viz: str,
                 autoscale: Optional[bool] = None,
                 custom_unit: Optional[str] = None,
                 events: Optional[Sequence['outputs.ScreenBoardWidgetTileDefEvent']] = None,
                 groups: Optional[Sequence[str]] = None,
                 markers: Optional[Sequence['outputs.ScreenBoardWidgetTileDefMarker']] = None,
                 no_group_hosts: Optional[bool] = None,
                 no_metric_hosts: Optional[bool] = None,
                 node_type: Optional[str] = None,
                 precision: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 style: Optional[Mapping[str, Any]] = None,
                 text_align: Optional[str] = None):
        pulumi.set(__self__, "requests", requests)
        pulumi.set(__self__, "viz", viz)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if custom_unit is not None:
            pulumi.set(__self__, "custom_unit", custom_unit)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if markers is not None:
            pulumi.set(__self__, "markers", markers)
        if no_group_hosts is not None:
            pulumi.set(__self__, "no_group_hosts", no_group_hosts)
        if no_metric_hosts is not None:
            pulumi.set(__self__, "no_metric_hosts", no_metric_hosts)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)

    @property
    @pulumi.getter
    def requests(self) -> Sequence['outputs.ScreenBoardWidgetTileDefRequest']:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def viz(self) -> str:
        return pulumi.get(self, "viz")

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[bool]:
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[str]:
        return pulumi.get(self, "custom_unit")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.ScreenBoardWidgetTileDefEvent']]:
        return pulumi.get(self, "events")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def markers(self) -> Optional[Sequence['outputs.ScreenBoardWidgetTileDefMarker']]:
        return pulumi.get(self, "markers")

    @property
    @pulumi.getter(name="noGroupHosts")
    def no_group_hosts(self) -> Optional[bool]:
        return pulumi.get(self, "no_group_hosts")

    @property
    @pulumi.getter(name="noMetricHosts")
    def no_metric_hosts(self) -> Optional[bool]:
        return pulumi.get(self, "no_metric_hosts")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[str]:
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter
    def precision(self) -> Optional[str]:
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def style(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "style")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        return pulumi.get(self, "text_align")


@pulumi.output_type
class ScreenBoardWidgetTileDefEvent(dict):
    def __init__(__self__, *,
                 q: str):
        pulumi.set(__self__, "q", q)

    @property
    @pulumi.getter
    def q(self) -> str:
        return pulumi.get(self, "q")


@pulumi.output_type
class ScreenBoardWidgetTileDefMarker(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str,
                 label: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")


@pulumi.output_type
class ScreenBoardWidgetTileDefRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "changeType":
            suggest = "change_type"
        elif key == "compareTo":
            suggest = "compare_to"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "extraCol":
            suggest = "extra_col"
        elif key == "increaseGood":
            suggest = "increase_good"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "metadataJson":
            suggest = "metadata_json"
        elif key == "orderBy":
            suggest = "order_by"
        elif key == "orderDir":
            suggest = "order_dir"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "queryType":
            suggest = "query_type"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScreenBoardWidgetTileDefRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScreenBoardWidgetTileDefRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScreenBoardWidgetTileDefRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.ScreenBoardWidgetTileDefRequestApmQuery'] = None,
                 change_type: Optional[str] = None,
                 compare_to: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.ScreenBoardWidgetTileDefRequestConditionalFormat']] = None,
                 extra_col: Optional[str] = None,
                 increase_good: Optional[bool] = None,
                 limit: Optional[int] = None,
                 log_query: Optional['outputs.ScreenBoardWidgetTileDefRequestLogQuery'] = None,
                 metadata_json: Optional[str] = None,
                 metric: Optional[str] = None,
                 order_by: Optional[str] = None,
                 order_dir: Optional[str] = None,
                 process_query: Optional['outputs.ScreenBoardWidgetTileDefRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 query_type: Optional[str] = None,
                 style: Optional[Mapping[str, Any]] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None,
                 type: Optional[str] = None):
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if compare_to is not None:
            pulumi.set(__self__, "compare_to", compare_to)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if extra_col is not None:
            pulumi.set(__self__, "extra_col", extra_col)
        if increase_good is not None:
            pulumi.set(__self__, "increase_good", increase_good)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if metadata_json is not None:
            pulumi.set(__self__, "metadata_json", metadata_json)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)
        if order_dir is not None:
            pulumi.set(__self__, "order_dir", order_dir)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if query_type is not None:
            pulumi.set(__self__, "query_type", query_type)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.ScreenBoardWidgetTileDefRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[str]:
        return pulumi.get(self, "change_type")

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[str]:
        return pulumi.get(self, "compare_to")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.ScreenBoardWidgetTileDefRequestConditionalFormat']]:
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter(name="extraCol")
    def extra_col(self) -> Optional[str]:
        return pulumi.get(self, "extra_col")

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[bool]:
        return pulumi.get(self, "increase_good")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.ScreenBoardWidgetTileDefRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="metadataJson")
    def metadata_json(self) -> Optional[str]:
        return pulumi.get(self, "metadata_json")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[str]:
        return pulumi.get(self, "order_by")

    @property
    @pulumi.getter(name="orderDir")
    def order_dir(self) -> Optional[str]:
        return pulumi.get(self, "order_dir")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.ScreenBoardWidgetTileDefRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> Optional[str]:
        return pulumi.get(self, "query_type")

    @property
    @pulumi.getter
    def style(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "style")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        return pulumi.get(self, "text_filter")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScreenBoardWidgetTileDefRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScreenBoardWidgetTileDefRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScreenBoardWidgetTileDefRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute: 'outputs.ScreenBoardWidgetTileDefRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[Sequence['outputs.ScreenBoardWidgetTileDefRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.ScreenBoardWidgetTileDefRequestApmQuerySearch'] = None):
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.ScreenBoardWidgetTileDefRequestApmQueryCompute':
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.ScreenBoardWidgetTileDefRequestApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.ScreenBoardWidgetTileDefRequestApmQuerySearch']:
        return pulumi.get(self, "search")


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.ScreenBoardWidgetTileDefRequestApmQueryGroupBySort'] = None):
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.ScreenBoardWidgetTileDefRequestApmQueryGroupBySort']:
        return pulumi.get(self, "sort")


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScreenBoardWidgetTileDefRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScreenBoardWidgetTileDefRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScreenBoardWidgetTileDefRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 color: Optional[str] = None,
                 custom_bg_color: Optional[str] = None,
                 invert: Optional[bool] = None,
                 palette: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "comparator", comparator)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if invert is not None:
            pulumi.set(__self__, "invert", invert)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter
    def invert(self) -> Optional[bool]:
        return pulumi.get(self, "invert")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScreenBoardWidgetTileDefRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScreenBoardWidgetTileDefRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScreenBoardWidgetTileDefRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute: 'outputs.ScreenBoardWidgetTileDefRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[Sequence['outputs.ScreenBoardWidgetTileDefRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.ScreenBoardWidgetTileDefRequestLogQuerySearch'] = None):
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.ScreenBoardWidgetTileDefRequestLogQueryCompute':
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.ScreenBoardWidgetTileDefRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.ScreenBoardWidgetTileDefRequestLogQuerySearch']:
        return pulumi.get(self, "search")


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.ScreenBoardWidgetTileDefRequestLogQueryGroupBySort'] = None):
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.ScreenBoardWidgetTileDefRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class ScreenBoardWidgetTileDefRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScreenBoardWidgetTileDefRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScreenBoardWidgetTileDefRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScreenBoardWidgetTileDefRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class SecurityMonitoringRuleCase(dict):
    def __init__(__self__, *,
                 status: str,
                 condition: Optional[str] = None,
                 name: Optional[str] = None,
                 notifications: Optional[Sequence[str]] = None):
        """
        :param str status: Severity of the Security Signal.
        :param str condition: A rule case contains logical operations (>,>=, &&, ||) to determine if a signal should be generated based on the event counts in the previously defined queries.
        :param str name: Name of the case.
        :param Sequence[str] notifications: Notification targets for each rule case.
        """
        pulumi.set(__self__, "status", status)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Severity of the Security Signal.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        A rule case contains logical operations (>,>=, &&, ||) to determine if a signal should be generated based on the event counts in the previously defined queries.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the case.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def notifications(self) -> Optional[Sequence[str]]:
        """
        Notification targets for each rule case.
        """
        return pulumi.get(self, "notifications")


@pulumi.output_type
class SecurityMonitoringRuleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluationWindow":
            suggest = "evaluation_window"
        elif key == "keepAlive":
            suggest = "keep_alive"
        elif key == "maxSignalDuration":
            suggest = "max_signal_duration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringRuleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringRuleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringRuleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluation_window: int,
                 keep_alive: int,
                 max_signal_duration: int):
        """
        :param int evaluation_window: A time window is specified to match when at least one of the cases matches true. This is a sliding window and evaluates in real time.
        :param int keep_alive: Once a signal is generated, the signal will remain “open” if a case is matched at least once within this keep alive window.
        """
        pulumi.set(__self__, "evaluation_window", evaluation_window)
        pulumi.set(__self__, "keep_alive", keep_alive)
        pulumi.set(__self__, "max_signal_duration", max_signal_duration)

    @property
    @pulumi.getter(name="evaluationWindow")
    def evaluation_window(self) -> int:
        """
        A time window is specified to match when at least one of the cases matches true. This is a sliding window and evaluates in real time.
        """
        return pulumi.get(self, "evaluation_window")

    @property
    @pulumi.getter(name="keepAlive")
    def keep_alive(self) -> int:
        """
        Once a signal is generated, the signal will remain “open” if a case is matched at least once within this keep alive window.
        """
        return pulumi.get(self, "keep_alive")

    @property
    @pulumi.getter(name="maxSignalDuration")
    def max_signal_duration(self) -> int:
        return pulumi.get(self, "max_signal_duration")


@pulumi.output_type
class SecurityMonitoringRuleQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "distinctFields":
            suggest = "distinct_fields"
        elif key == "groupByFields":
            suggest = "group_by_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringRuleQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringRuleQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringRuleQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 aggregation: Optional[str] = None,
                 distinct_fields: Optional[Sequence[str]] = None,
                 group_by_fields: Optional[Sequence[str]] = None,
                 metric: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str query: Query to run on logs.
        :param str aggregation: The aggregation type.
        :param Sequence[str] distinct_fields: Field for which the cardinality is measured. Sent as an array.
        :param str metric: The target field to aggregate over when using the sum or max aggregations.
        :param str name: Name of the query.
        """
        pulumi.set(__self__, "query", query)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if distinct_fields is not None:
            pulumi.set(__self__, "distinct_fields", distinct_fields)
        if group_by_fields is not None:
            pulumi.set(__self__, "group_by_fields", group_by_fields)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query to run on logs.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        The aggregation type.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="distinctFields")
    def distinct_fields(self) -> Optional[Sequence[str]]:
        """
        Field for which the cardinality is measured. Sent as an array.
        """
        return pulumi.get(self, "distinct_fields")

    @property
    @pulumi.getter(name="groupByFields")
    def group_by_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "group_by_fields")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The target field to aggregate over when using the sum or max aggregations.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the query.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ServiceLevelObjectiveQuery(dict):
    def __init__(__self__, *,
                 denominator: str,
                 numerator: str):
        """
        :param str denominator: The sum of the total events.
        :param str numerator: The sum of all the good events.
        """
        pulumi.set(__self__, "denominator", denominator)
        pulumi.set(__self__, "numerator", numerator)

    @property
    @pulumi.getter
    def denominator(self) -> str:
        """
        The sum of the total events.
        """
        return pulumi.get(self, "denominator")

    @property
    @pulumi.getter
    def numerator(self) -> str:
        """
        The sum of all the good events.
        """
        return pulumi.get(self, "numerator")


@pulumi.output_type
class ServiceLevelObjectiveThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetDisplay":
            suggest = "target_display"
        elif key == "warningDisplay":
            suggest = "warning_display"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceLevelObjectiveThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceLevelObjectiveThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceLevelObjectiveThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: float,
                 timeframe: str,
                 target_display: Optional[str] = None,
                 warning: Optional[float] = None,
                 warning_display: Optional[str] = None):
        """
        :param float target: The objective's target in[0,100].
        :param str timeframe: The time frame for the objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API documentation page. Available options to choose from are: 7d, 30d, 90d.
        :param str target_display: A string representation of the target that indicates its precision. It uses trailing zeros to show significant decimal places (e.g. 98.00).
        :param float warning: The objective's warning value in [0,100]. This must be greater than the target value.
        :param str warning_display: A string representation of the warning target (see the description of the target_display field for details).
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "timeframe", timeframe)
        if target_display is not None:
            pulumi.set(__self__, "target_display", target_display)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)
        if warning_display is not None:
            pulumi.set(__self__, "warning_display", warning_display)

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        The objective's target in[0,100].
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def timeframe(self) -> str:
        """
        The time frame for the objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API documentation page. Available options to choose from are: 7d, 30d, 90d.
        """
        return pulumi.get(self, "timeframe")

    @property
    @pulumi.getter(name="targetDisplay")
    def target_display(self) -> Optional[str]:
        """
        A string representation of the target that indicates its precision. It uses trailing zeros to show significant decimal places (e.g. 98.00).
        """
        return pulumi.get(self, "target_display")

    @property
    @pulumi.getter
    def warning(self) -> Optional[float]:
        """
        The objective's warning value in [0,100]. This must be greater than the target value.
        """
        return pulumi.get(self, "warning")

    @property
    @pulumi.getter(name="warningDisplay")
    def warning_display(self) -> Optional[str]:
        """
        A string representation of the warning target (see the description of the target_display field for details).
        """
        return pulumi.get(self, "warning_display")


@pulumi.output_type
class SyntheticsGlobalVariableParseTestOptions(dict):
    def __init__(__self__, *,
                 parser: 'outputs.SyntheticsGlobalVariableParseTestOptionsParser',
                 type: str,
                 field: Optional[str] = None):
        """
        :param str type: Defines the source to use to extract the value. Allowed enum values: http_body, http_header.
        :param str field: Required when type = http_header. Defines the header to use to extract the value
        """
        pulumi.set(__self__, "parser", parser)
        pulumi.set(__self__, "type", type)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @property
    @pulumi.getter
    def parser(self) -> 'outputs.SyntheticsGlobalVariableParseTestOptionsParser':
        return pulumi.get(self, "parser")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines the source to use to extract the value. Allowed enum values: http_body, http_header.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        """
        Required when type = http_header. Defines the header to use to extract the value
        """
        return pulumi.get(self, "field")


@pulumi.output_type
class SyntheticsGlobalVariableParseTestOptionsParser(dict):
    def __init__(__self__, *,
                 type: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class SyntheticsTestApiStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "extractedValues":
            suggest = "extracted_values"
        elif key == "requestBasicauth":
            suggest = "request_basicauth"
        elif key == "requestClientCertificate":
            suggest = "request_client_certificate"
        elif key == "requestDefinition":
            suggest = "request_definition"
        elif key == "requestHeaders":
            suggest = "request_headers"
        elif key == "requestQuery":
            suggest = "request_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestApiStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestApiStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestApiStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 assertions: Optional[Sequence['outputs.SyntheticsTestApiStepAssertion']] = None,
                 extracted_values: Optional[Sequence['outputs.SyntheticsTestApiStepExtractedValue']] = None,
                 request_basicauth: Optional['outputs.SyntheticsTestApiStepRequestBasicauth'] = None,
                 request_client_certificate: Optional['outputs.SyntheticsTestApiStepRequestClientCertificate'] = None,
                 request_definition: Optional['outputs.SyntheticsTestApiStepRequestDefinition'] = None,
                 request_headers: Optional[Mapping[str, Any]] = None,
                 request_query: Optional[Mapping[str, Any]] = None,
                 subtype: Optional[str] = None):
        """
        :param str name: The name of the step.
        :param Sequence['SyntheticsTestApiStepAssertionArgs'] assertions: Assertions used for the test. Multiple assertion blocks are allowed with the structure below.
        :param Sequence['SyntheticsTestApiStepExtractedValueArgs'] extracted_values: Values to parse and save as variables from the response.
        :param 'SyntheticsTestApiStepRequestBasicauthArgs' request_basicauth: The HTTP basic authentication credentials. Exactly one nested block is allowed with the structure below.
        :param 'SyntheticsTestApiStepRequestDefinitionArgs' request_definition: The request for the api step.
        :param Mapping[str, Any] request_headers: Header name and value map.
        :param Mapping[str, Any] request_query: Query arguments name and value map.
        :param str subtype: The subtype of the Synthetic multistep API test step, currently only supporting http.
        """
        pulumi.set(__self__, "name", name)
        if assertions is not None:
            pulumi.set(__self__, "assertions", assertions)
        if extracted_values is not None:
            pulumi.set(__self__, "extracted_values", extracted_values)
        if request_basicauth is not None:
            pulumi.set(__self__, "request_basicauth", request_basicauth)
        if request_client_certificate is not None:
            pulumi.set(__self__, "request_client_certificate", request_client_certificate)
        if request_definition is not None:
            pulumi.set(__self__, "request_definition", request_definition)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if request_query is not None:
            pulumi.set(__self__, "request_query", request_query)
        if subtype is not None:
            pulumi.set(__self__, "subtype", subtype)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the step.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def assertions(self) -> Optional[Sequence['outputs.SyntheticsTestApiStepAssertion']]:
        """
        Assertions used for the test. Multiple assertion blocks are allowed with the structure below.
        """
        return pulumi.get(self, "assertions")

    @property
    @pulumi.getter(name="extractedValues")
    def extracted_values(self) -> Optional[Sequence['outputs.SyntheticsTestApiStepExtractedValue']]:
        """
        Values to parse and save as variables from the response.
        """
        return pulumi.get(self, "extracted_values")

    @property
    @pulumi.getter(name="requestBasicauth")
    def request_basicauth(self) -> Optional['outputs.SyntheticsTestApiStepRequestBasicauth']:
        """
        The HTTP basic authentication credentials. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "request_basicauth")

    @property
    @pulumi.getter(name="requestClientCertificate")
    def request_client_certificate(self) -> Optional['outputs.SyntheticsTestApiStepRequestClientCertificate']:
        return pulumi.get(self, "request_client_certificate")

    @property
    @pulumi.getter(name="requestDefinition")
    def request_definition(self) -> Optional['outputs.SyntheticsTestApiStepRequestDefinition']:
        """
        The request for the api step.
        """
        return pulumi.get(self, "request_definition")

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[Mapping[str, Any]]:
        """
        Header name and value map.
        """
        return pulumi.get(self, "request_headers")

    @property
    @pulumi.getter(name="requestQuery")
    def request_query(self) -> Optional[Mapping[str, Any]]:
        """
        Query arguments name and value map.
        """
        return pulumi.get(self, "request_query")

    @property
    @pulumi.getter
    def subtype(self) -> Optional[str]:
        """
        The subtype of the Synthetic multistep API test step, currently only supporting http.
        """
        return pulumi.get(self, "subtype")


@pulumi.output_type
class SyntheticsTestApiStepAssertion(dict):
    def __init__(__self__, *,
                 operator: str,
                 type: str,
                 property: Optional[str] = None,
                 target: Optional[str] = None,
                 targetjsonpath: Optional['outputs.SyntheticsTestApiStepAssertionTargetjsonpath'] = None):
        """
        :param str operator: Assertion operator.  Only some combinations of type and operator are valid (please refer to ).
        :param str type: Type of assertion. Choose from body, header, responseTime, statusCode.  Only some combinations of type and operator are valid (please refer to ).
        :param str property: If assertion type is header, this is the header name.
        :param str target: Expected value. Depends on the assertion type, refer to  for details.
        :param 'SyntheticsTestApiStepAssertionTargetjsonpathArgs' targetjsonpath: Expected structure if operator is validatesJSONPath. Exactly one nested block is allowed with the structure below.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "type", type)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if targetjsonpath is not None:
            pulumi.set(__self__, "targetjsonpath", targetjsonpath)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Assertion operator.  Only some combinations of type and operator are valid (please refer to ).
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of assertion. Choose from body, header, responseTime, statusCode.  Only some combinations of type and operator are valid (please refer to ).
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Expected value. Depends on the assertion type, refer to  for details.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def targetjsonpath(self) -> Optional['outputs.SyntheticsTestApiStepAssertionTargetjsonpath']:
        """
        Expected structure if operator is validatesJSONPath. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "targetjsonpath")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        """
        If assertion type is header, this is the header name.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class SyntheticsTestApiStepAssertionTargetjsonpath(dict):
    def __init__(__self__, *,
                 jsonpath: str,
                 operator: str,
                 targetvalue: str):
        pulumi.set(__self__, "jsonpath", jsonpath)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "targetvalue", targetvalue)

    @property
    @pulumi.getter
    def jsonpath(self) -> str:
        return pulumi.get(self, "jsonpath")

    @property
    @pulumi.getter
    def operator(self) -> str:
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def targetvalue(self) -> str:
        return pulumi.get(self, "targetvalue")


@pulumi.output_type
class SyntheticsTestApiStepExtractedValue(dict):
    def __init__(__self__, *,
                 name: str,
                 parser: 'outputs.SyntheticsTestApiStepExtractedValueParser',
                 type: str,
                 field: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parser", parser)
        pulumi.set(__self__, "type", type)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parser(self) -> 'outputs.SyntheticsTestApiStepExtractedValueParser':
        return pulumi.get(self, "parser")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        return pulumi.get(self, "field")


@pulumi.output_type
class SyntheticsTestApiStepExtractedValueParser(dict):
    def __init__(__self__, *,
                 type: str,
                 value: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class SyntheticsTestApiStepRequestBasicauth(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: Password for authentication.
        :param str username: Username for authentication.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username for authentication.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SyntheticsTestApiStepRequestClientCertificate(dict):
    def __init__(__self__, *,
                 cert: 'outputs.SyntheticsTestApiStepRequestClientCertificateCert',
                 key: 'outputs.SyntheticsTestApiStepRequestClientCertificateKey'):
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def cert(self) -> 'outputs.SyntheticsTestApiStepRequestClientCertificateCert':
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def key(self) -> 'outputs.SyntheticsTestApiStepRequestClientCertificateKey':
        return pulumi.get(self, "key")


@pulumi.output_type
class SyntheticsTestApiStepRequestClientCertificateCert(dict):
    def __init__(__self__, *,
                 content: str,
                 filename: Optional[str] = None):
        pulumi.set(__self__, "content", content)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        return pulumi.get(self, "filename")


@pulumi.output_type
class SyntheticsTestApiStepRequestClientCertificateKey(dict):
    def __init__(__self__, *,
                 content: str,
                 filename: Optional[str] = None):
        pulumi.set(__self__, "content", content)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        return pulumi.get(self, "filename")


@pulumi.output_type
class SyntheticsTestApiStepRequestDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServer":
            suggest = "dns_server"
        elif key == "noSavingResponseBody":
            suggest = "no_saving_response_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestApiStepRequestDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestApiStepRequestDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestApiStepRequestDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: Optional[str] = None,
                 dns_server: Optional[str] = None,
                 host: Optional[str] = None,
                 method: Optional[str] = None,
                 no_saving_response_body: Optional[bool] = None,
                 port: Optional[int] = None,
                 timeout: Optional[int] = None,
                 url: Optional[str] = None):
        """
        :param str body: The request body.
        :param str dns_server: DNS server to use for DNS tests (subtype = "dns").
        :param str host: Host name to perform the test with.
        :param str method: The HTTP method. One of DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT.
        :param int port: Port to use when performing the test.
        :param int timeout: Timeout in seconds for the test. Defaults to 60.
        :param str url: The URL to send the request to.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if dns_server is not None:
            pulumi.set(__self__, "dns_server", dns_server)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if no_saving_response_body is not None:
            pulumi.set(__self__, "no_saving_response_body", no_saving_response_body)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        The request body.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> Optional[str]:
        """
        DNS server to use for DNS tests (subtype = "dns").
        """
        return pulumi.get(self, "dns_server")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to perform the test with.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The HTTP method. One of DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="noSavingResponseBody")
    def no_saving_response_body(self) -> Optional[bool]:
        return pulumi.get(self, "no_saving_response_body")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port to use when performing the test.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        Timeout in seconds for the test. Defaults to 60.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL to send the request to.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class SyntheticsTestBrowserStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowFailure":
            suggest = "allow_failure"
        elif key == "forceElementUpdate":
            suggest = "force_element_update"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestBrowserStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestBrowserStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestBrowserStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 params: 'outputs.SyntheticsTestBrowserStepParams',
                 type: str,
                 allow_failure: Optional[bool] = None,
                 force_element_update: Optional[bool] = None,
                 timeout: Optional[int] = None):
        """
        :param str name: Name of the step.
        :param 'SyntheticsTestBrowserStepParamsArgs' params: Parameters for the step.
        :param str type: Type of the step. Refer to  for the complete list of available types.
        :param bool allow_failure: Determines if the step should be allowed to fail.
        :param int timeout: Used to override the default timeout of a step.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "params", params)
        pulumi.set(__self__, "type", type)
        if allow_failure is not None:
            pulumi.set(__self__, "allow_failure", allow_failure)
        if force_element_update is not None:
            pulumi.set(__self__, "force_element_update", force_element_update)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the step.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def params(self) -> 'outputs.SyntheticsTestBrowserStepParams':
        """
        Parameters for the step.
        """
        return pulumi.get(self, "params")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the step. Refer to  for the complete list of available types.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="allowFailure")
    def allow_failure(self) -> Optional[bool]:
        """
        Determines if the step should be allowed to fail.
        """
        return pulumi.get(self, "allow_failure")

    @property
    @pulumi.getter(name="forceElementUpdate")
    def force_element_update(self) -> Optional[bool]:
        return pulumi.get(self, "force_element_update")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        Used to override the default timeout of a step.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class SyntheticsTestBrowserStepParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clickType":
            suggest = "click_type"
        elif key == "playingTabId":
            suggest = "playing_tab_id"
        elif key == "subtestPublicId":
            suggest = "subtest_public_id"
        elif key == "withClick":
            suggest = "with_click"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestBrowserStepParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestBrowserStepParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestBrowserStepParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: Optional[str] = None,
                 check: Optional[str] = None,
                 click_type: Optional[str] = None,
                 code: Optional[str] = None,
                 delay: Optional[int] = None,
                 element: Optional[str] = None,
                 email: Optional[str] = None,
                 file: Optional[str] = None,
                 files: Optional[str] = None,
                 modifiers: Optional[Sequence[str]] = None,
                 playing_tab_id: Optional[str] = None,
                 request: Optional[str] = None,
                 subtest_public_id: Optional[str] = None,
                 value: Optional[str] = None,
                 variable: Optional['outputs.SyntheticsTestBrowserStepParamsVariable'] = None,
                 with_click: Optional[bool] = None,
                 x: Optional[int] = None,
                 y: Optional[int] = None):
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)
        if check is not None:
            pulumi.set(__self__, "check", check)
        if click_type is not None:
            pulumi.set(__self__, "click_type", click_type)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if element is not None:
            pulumi.set(__self__, "element", element)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if files is not None:
            pulumi.set(__self__, "files", files)
        if modifiers is not None:
            pulumi.set(__self__, "modifiers", modifiers)
        if playing_tab_id is not None:
            pulumi.set(__self__, "playing_tab_id", playing_tab_id)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if subtest_public_id is not None:
            pulumi.set(__self__, "subtest_public_id", subtest_public_id)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if variable is not None:
            pulumi.set(__self__, "variable", variable)
        if with_click is not None:
            pulumi.set(__self__, "with_click", with_click)
        if x is not None:
            pulumi.set(__self__, "x", x)
        if y is not None:
            pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def attribute(self) -> Optional[str]:
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def check(self) -> Optional[str]:
        return pulumi.get(self, "check")

    @property
    @pulumi.getter(name="clickType")
    def click_type(self) -> Optional[str]:
        return pulumi.get(self, "click_type")

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def delay(self) -> Optional[int]:
        return pulumi.get(self, "delay")

    @property
    @pulumi.getter
    def element(self) -> Optional[str]:
        return pulumi.get(self, "element")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def file(self) -> Optional[str]:
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def files(self) -> Optional[str]:
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def modifiers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "modifiers")

    @property
    @pulumi.getter(name="playingTabId")
    def playing_tab_id(self) -> Optional[str]:
        return pulumi.get(self, "playing_tab_id")

    @property
    @pulumi.getter
    def request(self) -> Optional[str]:
        return pulumi.get(self, "request")

    @property
    @pulumi.getter(name="subtestPublicId")
    def subtest_public_id(self) -> Optional[str]:
        return pulumi.get(self, "subtest_public_id")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def variable(self) -> Optional['outputs.SyntheticsTestBrowserStepParamsVariable']:
        return pulumi.get(self, "variable")

    @property
    @pulumi.getter(name="withClick")
    def with_click(self) -> Optional[bool]:
        return pulumi.get(self, "with_click")

    @property
    @pulumi.getter
    def x(self) -> Optional[int]:
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> Optional[int]:
        return pulumi.get(self, "y")


@pulumi.output_type
class SyntheticsTestBrowserStepParamsVariable(dict):
    def __init__(__self__, *,
                 example: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str example: Example for the variable.
        :param str name: Name of the variable.
        """
        if example is not None:
            pulumi.set(__self__, "example", example)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def example(self) -> Optional[str]:
        """
        Example for the variable.
        """
        return pulumi.get(self, "example")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the variable.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SyntheticsTestBrowserVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 example: Optional[str] = None,
                 id: Optional[str] = None,
                 pattern: Optional[str] = None):
        """
        :param str name: Name of the variable.
        :param str type: Type of browser test variable. Allowed enum values: element, email, global, javascript, text.
        :param str example: Example for the variable.
        :param str id: ID of the global variable to use. This is actually only used (and required) in the case of using a variable of type global.
        :param str pattern: Pattern of the variable.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if example is not None:
            pulumi.set(__self__, "example", example)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of browser test variable. Allowed enum values: element, email, global, javascript, text.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def example(self) -> Optional[str]:
        """
        Example for the variable.
        """
        return pulumi.get(self, "example")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the global variable to use. This is actually only used (and required) in the case of using a variable of type global.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        """
        Pattern of the variable.
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class SyntheticsTestConfigVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 example: Optional[str] = None,
                 pattern: Optional[str] = None):
        """
        :param str name: Name of the variable.
        :param str type: Type of test configuration variable. Allowed enum values: text.
        :param str example: Example for the variable.
        :param str pattern: Pattern of the variable.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if example is not None:
            pulumi.set(__self__, "example", example)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of test configuration variable. Allowed enum values: text.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def example(self) -> Optional[str]:
        """
        Example for the variable.
        """
        return pulumi.get(self, "example")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        """
        Pattern of the variable.
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class SyntheticsTestOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tickEvery":
            suggest = "tick_every"
        elif key == "acceptSelfSigned":
            suggest = "accept_self_signed"
        elif key == "allowInsecure":
            suggest = "allow_insecure"
        elif key == "followRedirects":
            suggest = "follow_redirects"
        elif key == "minFailureDuration":
            suggest = "min_failure_duration"
        elif key == "minLocationFailed":
            suggest = "min_location_failed"
        elif key == "retryCount":
            suggest = "retry_count"
        elif key == "retryInterval":
            suggest = "retry_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tick_every: int,
                 accept_self_signed: Optional[bool] = None,
                 allow_insecure: Optional[bool] = None,
                 follow_redirects: Optional[bool] = None,
                 min_failure_duration: Optional[int] = None,
                 min_location_failed: Optional[int] = None,
                 retry_count: Optional[int] = None,
                 retry_interval: Optional[int] = None):
        pulumi.set(__self__, "tick_every", tick_every)
        if accept_self_signed is not None:
            pulumi.set(__self__, "accept_self_signed", accept_self_signed)
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if min_failure_duration is not None:
            pulumi.set(__self__, "min_failure_duration", min_failure_duration)
        if min_location_failed is not None:
            pulumi.set(__self__, "min_location_failed", min_location_failed)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)
        if retry_interval is not None:
            pulumi.set(__self__, "retry_interval", retry_interval)

    @property
    @pulumi.getter(name="tickEvery")
    def tick_every(self) -> int:
        return pulumi.get(self, "tick_every")

    @property
    @pulumi.getter(name="acceptSelfSigned")
    def accept_self_signed(self) -> Optional[bool]:
        return pulumi.get(self, "accept_self_signed")

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[bool]:
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[bool]:
        return pulumi.get(self, "follow_redirects")

    @property
    @pulumi.getter(name="minFailureDuration")
    def min_failure_duration(self) -> Optional[int]:
        return pulumi.get(self, "min_failure_duration")

    @property
    @pulumi.getter(name="minLocationFailed")
    def min_location_failed(self) -> Optional[int]:
        return pulumi.get(self, "min_location_failed")

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[int]:
        return pulumi.get(self, "retry_count")

    @property
    @pulumi.getter(name="retryInterval")
    def retry_interval(self) -> Optional[int]:
        return pulumi.get(self, "retry_interval")


@pulumi.output_type
class SyntheticsTestOptionsList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tickEvery":
            suggest = "tick_every"
        elif key == "acceptSelfSigned":
            suggest = "accept_self_signed"
        elif key == "allowInsecure":
            suggest = "allow_insecure"
        elif key == "followRedirects":
            suggest = "follow_redirects"
        elif key == "minFailureDuration":
            suggest = "min_failure_duration"
        elif key == "minLocationFailed":
            suggest = "min_location_failed"
        elif key == "monitorOptions":
            suggest = "monitor_options"
        elif key == "noScreenshot":
            suggest = "no_screenshot"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestOptionsList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestOptionsList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestOptionsList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tick_every: int,
                 accept_self_signed: Optional[bool] = None,
                 allow_insecure: Optional[bool] = None,
                 follow_redirects: Optional[bool] = None,
                 min_failure_duration: Optional[int] = None,
                 min_location_failed: Optional[int] = None,
                 monitor_options: Optional['outputs.SyntheticsTestOptionsListMonitorOptions'] = None,
                 no_screenshot: Optional[bool] = None,
                 retry: Optional['outputs.SyntheticsTestOptionsListRetry'] = None):
        """
        :param int tick_every: How often the test should run (in seconds). Current possible values are 900, 1800, 3600, 21600, 43200, 86400, 604800 plus 60 for API tests or 300 for browser tests.
        :param bool allow_insecure: Allows loading insecure content for an HTTP test.
        :param bool follow_redirects: For API HTTP test, whether or not the test should follow redirects.
        :param bool no_screenshot: Prevents saving screenshots of the steps.
        """
        pulumi.set(__self__, "tick_every", tick_every)
        if accept_self_signed is not None:
            pulumi.set(__self__, "accept_self_signed", accept_self_signed)
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if min_failure_duration is not None:
            pulumi.set(__self__, "min_failure_duration", min_failure_duration)
        if min_location_failed is not None:
            pulumi.set(__self__, "min_location_failed", min_location_failed)
        if monitor_options is not None:
            pulumi.set(__self__, "monitor_options", monitor_options)
        if no_screenshot is not None:
            pulumi.set(__self__, "no_screenshot", no_screenshot)
        if retry is not None:
            pulumi.set(__self__, "retry", retry)

    @property
    @pulumi.getter(name="tickEvery")
    def tick_every(self) -> int:
        """
        How often the test should run (in seconds). Current possible values are 900, 1800, 3600, 21600, 43200, 86400, 604800 plus 60 for API tests or 300 for browser tests.
        """
        return pulumi.get(self, "tick_every")

    @property
    @pulumi.getter(name="acceptSelfSigned")
    def accept_self_signed(self) -> Optional[bool]:
        return pulumi.get(self, "accept_self_signed")

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[bool]:
        """
        Allows loading insecure content for an HTTP test.
        """
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[bool]:
        """
        For API HTTP test, whether or not the test should follow redirects.
        """
        return pulumi.get(self, "follow_redirects")

    @property
    @pulumi.getter(name="minFailureDuration")
    def min_failure_duration(self) -> Optional[int]:
        return pulumi.get(self, "min_failure_duration")

    @property
    @pulumi.getter(name="minLocationFailed")
    def min_location_failed(self) -> Optional[int]:
        return pulumi.get(self, "min_location_failed")

    @property
    @pulumi.getter(name="monitorOptions")
    def monitor_options(self) -> Optional['outputs.SyntheticsTestOptionsListMonitorOptions']:
        return pulumi.get(self, "monitor_options")

    @property
    @pulumi.getter(name="noScreenshot")
    def no_screenshot(self) -> Optional[bool]:
        """
        Prevents saving screenshots of the steps.
        """
        return pulumi.get(self, "no_screenshot")

    @property
    @pulumi.getter
    def retry(self) -> Optional['outputs.SyntheticsTestOptionsListRetry']:
        return pulumi.get(self, "retry")


@pulumi.output_type
class SyntheticsTestOptionsListMonitorOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renotifyInterval":
            suggest = "renotify_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestOptionsListMonitorOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestOptionsListMonitorOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestOptionsListMonitorOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 renotify_interval: Optional[int] = None):
        if renotify_interval is not None:
            pulumi.set(__self__, "renotify_interval", renotify_interval)

    @property
    @pulumi.getter(name="renotifyInterval")
    def renotify_interval(self) -> Optional[int]:
        return pulumi.get(self, "renotify_interval")


@pulumi.output_type
class SyntheticsTestOptionsListRetry(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 interval: Optional[int] = None):
        if count is not None:
            pulumi.set(__self__, "count", count)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class SyntheticsTestRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServer":
            suggest = "dns_server"
        elif key == "noSavingResponseBody":
            suggest = "no_saving_response_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: Optional[str] = None,
                 dns_server: Optional[str] = None,
                 host: Optional[str] = None,
                 method: Optional[str] = None,
                 no_saving_response_body: Optional[bool] = None,
                 port: Optional[int] = None,
                 timeout: Optional[int] = None,
                 url: Optional[str] = None):
        if body is not None:
            pulumi.set(__self__, "body", body)
        if dns_server is not None:
            pulumi.set(__self__, "dns_server", dns_server)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if no_saving_response_body is not None:
            pulumi.set(__self__, "no_saving_response_body", no_saving_response_body)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> Optional[str]:
        return pulumi.get(self, "dns_server")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="noSavingResponseBody")
    def no_saving_response_body(self) -> Optional[bool]:
        return pulumi.get(self, "no_saving_response_body")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        return pulumi.get(self, "url")


@pulumi.output_type
class SyntheticsTestRequestBasicauth(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: Password for authentication.
        :param str username: Username for authentication.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        Username for authentication.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class SyntheticsTestRequestClientCertificate(dict):
    def __init__(__self__, *,
                 cert: 'outputs.SyntheticsTestRequestClientCertificateCert',
                 key: 'outputs.SyntheticsTestRequestClientCertificateKey'):
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def cert(self) -> 'outputs.SyntheticsTestRequestClientCertificateCert':
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def key(self) -> 'outputs.SyntheticsTestRequestClientCertificateKey':
        return pulumi.get(self, "key")


@pulumi.output_type
class SyntheticsTestRequestClientCertificateCert(dict):
    def __init__(__self__, *,
                 content: str,
                 filename: Optional[str] = None):
        pulumi.set(__self__, "content", content)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        return pulumi.get(self, "filename")


@pulumi.output_type
class SyntheticsTestRequestClientCertificateKey(dict):
    def __init__(__self__, *,
                 content: str,
                 filename: Optional[str] = None):
        pulumi.set(__self__, "content", content)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def content(self) -> str:
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        return pulumi.get(self, "filename")


@pulumi.output_type
class SyntheticsTestRequestDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsServer":
            suggest = "dns_server"
        elif key == "noSavingResponseBody":
            suggest = "no_saving_response_body"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestRequestDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestRequestDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestRequestDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: Optional[str] = None,
                 dns_server: Optional[str] = None,
                 host: Optional[str] = None,
                 method: Optional[str] = None,
                 no_saving_response_body: Optional[bool] = None,
                 port: Optional[int] = None,
                 timeout: Optional[int] = None,
                 url: Optional[str] = None):
        """
        :param str body: The request body.
        :param str dns_server: DNS server to use for DNS tests (subtype = "dns").
        :param str host: Host name to perform the test with.
        :param str method: The HTTP method. One of DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT.
        :param int port: Port to use when performing the test.
        :param int timeout: Timeout in seconds for the test. Defaults to 60.
        :param str url: The URL to send the request to.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if dns_server is not None:
            pulumi.set(__self__, "dns_server", dns_server)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if no_saving_response_body is not None:
            pulumi.set(__self__, "no_saving_response_body", no_saving_response_body)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        The request body.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> Optional[str]:
        """
        DNS server to use for DNS tests (subtype = "dns").
        """
        return pulumi.get(self, "dns_server")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to perform the test with.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        The HTTP method. One of DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="noSavingResponseBody")
    def no_saving_response_body(self) -> Optional[bool]:
        return pulumi.get(self, "no_saving_response_body")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port to use when performing the test.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        Timeout in seconds for the test. Defaults to 60.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL to send the request to.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class SyntheticsTestStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowFailure":
            suggest = "allow_failure"
        elif key == "forceElementUpdate":
            suggest = "force_element_update"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 params: str,
                 type: str,
                 allow_failure: Optional[bool] = None,
                 force_element_update: Optional[bool] = None,
                 timeout: Optional[int] = None):
        """
        :param str name: Name of the step.
        :param str params: Parameters for the step as JSON string.
        :param str type: Type of the step. Refer to  for the complete list of available types.
        :param bool allow_failure: Determines if the step should be allowed to fail.
        :param int timeout: Used to override the default timeout of a step.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "params", params)
        pulumi.set(__self__, "type", type)
        if allow_failure is not None:
            pulumi.set(__self__, "allow_failure", allow_failure)
        if force_element_update is not None:
            pulumi.set(__self__, "force_element_update", force_element_update)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the step.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def params(self) -> str:
        """
        Parameters for the step as JSON string.
        """
        return pulumi.get(self, "params")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the step. Refer to  for the complete list of available types.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="allowFailure")
    def allow_failure(self) -> Optional[bool]:
        """
        Determines if the step should be allowed to fail.
        """
        return pulumi.get(self, "allow_failure")

    @property
    @pulumi.getter(name="forceElementUpdate")
    def force_element_update(self) -> Optional[bool]:
        return pulumi.get(self, "force_element_update")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        Used to override the default timeout of a step.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class SyntheticsTestVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 example: Optional[str] = None,
                 id: Optional[str] = None,
                 pattern: Optional[str] = None):
        """
        :param str name: Name of the variable.
        :param str type: Type of browser test variable. Allowed enum values: element, email, global, javascript, text.
        :param str example: Example for the variable.
        :param str id: ID of the global variable to use. This is actually only used (and required) in the case of using a variable of type global.
        :param str pattern: Pattern of the variable.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if example is not None:
            pulumi.set(__self__, "example", example)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of browser test variable. Allowed enum values: element, email, global, javascript, text.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def example(self) -> Optional[str]:
        """
        Example for the variable.
        """
        return pulumi.get(self, "example")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the global variable to use. This is actually only used (and required) in the case of using a variable of type global.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        """
        Pattern of the variable.
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class TimeBoardGraph(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customUnit":
            suggest = "custom_unit"
        elif key == "includeNoMetricHosts":
            suggest = "include_no_metric_hosts"
        elif key == "includeUngroupedHosts":
            suggest = "include_ungrouped_hosts"
        elif key == "nodeType":
            suggest = "node_type"
        elif key == "textAlign":
            suggest = "text_align"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeBoardGraph. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeBoardGraph.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeBoardGraph.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 requests: Sequence['outputs.TimeBoardGraphRequest'],
                 title: str,
                 viz: str,
                 autoscale: Optional[bool] = None,
                 custom_unit: Optional[str] = None,
                 events: Optional[Sequence[str]] = None,
                 groups: Optional[Sequence[str]] = None,
                 include_no_metric_hosts: Optional[bool] = None,
                 include_ungrouped_hosts: Optional[bool] = None,
                 markers: Optional[Sequence['outputs.TimeBoardGraphMarker']] = None,
                 node_type: Optional[str] = None,
                 precision: Optional[str] = None,
                 scopes: Optional[Sequence[str]] = None,
                 style: Optional[Mapping[str, Any]] = None,
                 text_align: Optional[str] = None,
                 yaxis: Optional[Mapping[str, Any]] = None):
        pulumi.set(__self__, "requests", requests)
        pulumi.set(__self__, "title", title)
        pulumi.set(__self__, "viz", viz)
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if custom_unit is not None:
            pulumi.set(__self__, "custom_unit", custom_unit)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if include_no_metric_hosts is not None:
            pulumi.set(__self__, "include_no_metric_hosts", include_no_metric_hosts)
        if include_ungrouped_hosts is not None:
            pulumi.set(__self__, "include_ungrouped_hosts", include_ungrouped_hosts)
        if markers is not None:
            pulumi.set(__self__, "markers", markers)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter
    def requests(self) -> Sequence['outputs.TimeBoardGraphRequest']:
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> str:
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def viz(self) -> str:
        return pulumi.get(self, "viz")

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[bool]:
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[str]:
        return pulumi.get(self, "custom_unit")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "events")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="includeNoMetricHosts")
    def include_no_metric_hosts(self) -> Optional[bool]:
        return pulumi.get(self, "include_no_metric_hosts")

    @property
    @pulumi.getter(name="includeUngroupedHosts")
    def include_ungrouped_hosts(self) -> Optional[bool]:
        return pulumi.get(self, "include_ungrouped_hosts")

    @property
    @pulumi.getter
    def markers(self) -> Optional[Sequence['outputs.TimeBoardGraphMarker']]:
        return pulumi.get(self, "markers")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[str]:
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter
    def precision(self) -> Optional[str]:
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def style(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "style")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class TimeBoardGraphMarker(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str,
                 label: Optional[str] = None):
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        return pulumi.get(self, "label")


@pulumi.output_type
class TimeBoardGraphRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "changeType":
            suggest = "change_type"
        elif key == "compareTo":
            suggest = "compare_to"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "extraCol":
            suggest = "extra_col"
        elif key == "increaseGood":
            suggest = "increase_good"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "metadataJson":
            suggest = "metadata_json"
        elif key == "orderBy":
            suggest = "order_by"
        elif key == "orderDirection":
            suggest = "order_direction"
        elif key == "processQuery":
            suggest = "process_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeBoardGraphRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeBoardGraphRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeBoardGraphRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.TimeBoardGraphRequestApmQuery'] = None,
                 change_type: Optional[str] = None,
                 compare_to: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.TimeBoardGraphRequestConditionalFormat']] = None,
                 extra_col: Optional[str] = None,
                 increase_good: Optional[bool] = None,
                 log_query: Optional['outputs.TimeBoardGraphRequestLogQuery'] = None,
                 metadata_json: Optional[str] = None,
                 order_by: Optional[str] = None,
                 order_direction: Optional[str] = None,
                 process_query: Optional['outputs.TimeBoardGraphRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 stacked: Optional[bool] = None,
                 style: Optional[Mapping[str, Any]] = None,
                 type: Optional[str] = None):
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if compare_to is not None:
            pulumi.set(__self__, "compare_to", compare_to)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if extra_col is not None:
            pulumi.set(__self__, "extra_col", extra_col)
        if increase_good is not None:
            pulumi.set(__self__, "increase_good", increase_good)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if metadata_json is not None:
            pulumi.set(__self__, "metadata_json", metadata_json)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)
        if order_direction is not None:
            pulumi.set(__self__, "order_direction", order_direction)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if stacked is not None:
            pulumi.set(__self__, "stacked", stacked)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.TimeBoardGraphRequestApmQuery']:
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[str]:
        return pulumi.get(self, "change_type")

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[str]:
        return pulumi.get(self, "compare_to")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.TimeBoardGraphRequestConditionalFormat']]:
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter(name="extraCol")
    def extra_col(self) -> Optional[str]:
        return pulumi.get(self, "extra_col")

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[bool]:
        return pulumi.get(self, "increase_good")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.TimeBoardGraphRequestLogQuery']:
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="metadataJson")
    def metadata_json(self) -> Optional[str]:
        return pulumi.get(self, "metadata_json")

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[str]:
        return pulumi.get(self, "order_by")

    @property
    @pulumi.getter(name="orderDirection")
    def order_direction(self) -> Optional[str]:
        return pulumi.get(self, "order_direction")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.TimeBoardGraphRequestProcessQuery']:
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def stacked(self) -> Optional[bool]:
        return pulumi.get(self, "stacked")

    @property
    @pulumi.getter
    def style(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class TimeBoardGraphRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeBoardGraphRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeBoardGraphRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeBoardGraphRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute: 'outputs.TimeBoardGraphRequestApmQueryCompute',
                 index: str,
                 group_bies: Optional[Sequence['outputs.TimeBoardGraphRequestApmQueryGroupBy']] = None,
                 search: Optional['outputs.TimeBoardGraphRequestApmQuerySearch'] = None):
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.TimeBoardGraphRequestApmQueryCompute':
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.TimeBoardGraphRequestApmQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.TimeBoardGraphRequestApmQuerySearch']:
        return pulumi.get(self, "search")


@pulumi.output_type
class TimeBoardGraphRequestApmQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class TimeBoardGraphRequestApmQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.TimeBoardGraphRequestApmQueryGroupBySort'] = None):
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.TimeBoardGraphRequestApmQueryGroupBySort']:
        return pulumi.get(self, "sort")


@pulumi.output_type
class TimeBoardGraphRequestApmQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class TimeBoardGraphRequestApmQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class TimeBoardGraphRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeBoardGraphRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeBoardGraphRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeBoardGraphRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 palette: Optional[str] = None,
                 value: Optional[str] = None):
        pulumi.set(__self__, "comparator", comparator)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class TimeBoardGraphRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeBoardGraphRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeBoardGraphRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeBoardGraphRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compute: 'outputs.TimeBoardGraphRequestLogQueryCompute',
                 index: str,
                 group_bies: Optional[Sequence['outputs.TimeBoardGraphRequestLogQueryGroupBy']] = None,
                 search: Optional['outputs.TimeBoardGraphRequestLogQuerySearch'] = None):
        pulumi.set(__self__, "compute", compute)
        pulumi.set(__self__, "index", index)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if search is not None:
            pulumi.set(__self__, "search", search)

    @property
    @pulumi.getter
    def compute(self) -> 'outputs.TimeBoardGraphRequestLogQueryCompute':
        return pulumi.get(self, "compute")

    @property
    @pulumi.getter
    def index(self) -> str:
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.TimeBoardGraphRequestLogQueryGroupBy']]:
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.TimeBoardGraphRequestLogQuerySearch']:
        return pulumi.get(self, "search")


@pulumi.output_type
class TimeBoardGraphRequestLogQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        return pulumi.get(self, "interval")


@pulumi.output_type
class TimeBoardGraphRequestLogQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.TimeBoardGraphRequestLogQueryGroupBySort'] = None):
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.TimeBoardGraphRequestLogQueryGroupBySort']:
        return pulumi.get(self, "sort")


@pulumi.output_type
class TimeBoardGraphRequestLogQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        return pulumi.get(self, "facet")


@pulumi.output_type
class TimeBoardGraphRequestLogQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class TimeBoardGraphRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TimeBoardGraphRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TimeBoardGraphRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TimeBoardGraphRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        return pulumi.get(self, "search_by")


@pulumi.output_type
class TimeBoardTemplateVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 default: Optional[str] = None,
                 prefix: Optional[str] = None):
        pulumi.set(__self__, "name", name)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def default(self) -> Optional[str]:
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetMonitorMonitorThresholdWindowsResult(dict):
    def __init__(__self__, *,
                 recovery_window: str,
                 trigger_window: str):
        pulumi.set(__self__, "recovery_window", recovery_window)
        pulumi.set(__self__, "trigger_window", trigger_window)

    @property
    @pulumi.getter(name="recoveryWindow")
    def recovery_window(self) -> str:
        return pulumi.get(self, "recovery_window")

    @property
    @pulumi.getter(name="triggerWindow")
    def trigger_window(self) -> str:
        return pulumi.get(self, "trigger_window")


@pulumi.output_type
class GetMonitorMonitorThresholdsResult(dict):
    def __init__(__self__, *,
                 critical: str,
                 critical_recovery: str,
                 ok: str,
                 unknown: str,
                 warning: str,
                 warning_recovery: str):
        pulumi.set(__self__, "critical", critical)
        pulumi.set(__self__, "critical_recovery", critical_recovery)
        pulumi.set(__self__, "ok", ok)
        pulumi.set(__self__, "unknown", unknown)
        pulumi.set(__self__, "warning", warning)
        pulumi.set(__self__, "warning_recovery", warning_recovery)

    @property
    @pulumi.getter
    def critical(self) -> str:
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter(name="criticalRecovery")
    def critical_recovery(self) -> str:
        return pulumi.get(self, "critical_recovery")

    @property
    @pulumi.getter
    def ok(self) -> str:
        return pulumi.get(self, "ok")

    @property
    @pulumi.getter
    def unknown(self) -> str:
        return pulumi.get(self, "unknown")

    @property
    @pulumi.getter
    def warning(self) -> str:
        return pulumi.get(self, "warning")

    @property
    @pulumi.getter(name="warningRecovery")
    def warning_recovery(self) -> str:
        return pulumi.get(self, "warning_recovery")


@pulumi.output_type
class GetMonitorThresholdWindowsResult(dict):
    def __init__(__self__, *,
                 recovery_window: str,
                 trigger_window: str):
        pulumi.set(__self__, "recovery_window", recovery_window)
        pulumi.set(__self__, "trigger_window", trigger_window)

    @property
    @pulumi.getter(name="recoveryWindow")
    def recovery_window(self) -> str:
        return pulumi.get(self, "recovery_window")

    @property
    @pulumi.getter(name="triggerWindow")
    def trigger_window(self) -> str:
        return pulumi.get(self, "trigger_window")


@pulumi.output_type
class GetMonitorThresholdsResult(dict):
    def __init__(__self__, *,
                 critical: float,
                 critical_recovery: float,
                 ok: float,
                 unknown: float,
                 warning: float,
                 warning_recovery: float):
        pulumi.set(__self__, "critical", critical)
        pulumi.set(__self__, "critical_recovery", critical_recovery)
        pulumi.set(__self__, "ok", ok)
        pulumi.set(__self__, "unknown", unknown)
        pulumi.set(__self__, "warning", warning)
        pulumi.set(__self__, "warning_recovery", warning_recovery)

    @property
    @pulumi.getter
    def critical(self) -> float:
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter(name="criticalRecovery")
    def critical_recovery(self) -> float:
        return pulumi.get(self, "critical_recovery")

    @property
    @pulumi.getter
    def ok(self) -> float:
        return pulumi.get(self, "ok")

    @property
    @pulumi.getter
    def unknown(self) -> float:
        return pulumi.get(self, "unknown")

    @property
    @pulumi.getter
    def warning(self) -> float:
        return pulumi.get(self, "warning")

    @property
    @pulumi.getter(name="warningRecovery")
    def warning_recovery(self) -> float:
        return pulumi.get(self, "warning_recovery")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleResult(dict):
    def __init__(__self__, *,
                 cases: Sequence['outputs.GetSecurityMonitoringRulesRuleCaseResult'],
                 message: str,
                 name: str,
                 queries: Sequence['outputs.GetSecurityMonitoringRulesRuleQueryResult'],
                 enabled: Optional[bool] = None,
                 options: Optional['outputs.GetSecurityMonitoringRulesRuleOptionsResult'] = None,
                 tags: Optional[Sequence[str]] = None):
        """
        :param Sequence['GetSecurityMonitoringRulesRuleCaseArgs'] cases: Cases for generating signals.
        :param str message: Message for generated signals.
        :param str name: The name of the rule.
        :param Sequence['GetSecurityMonitoringRulesRuleQueryArgs'] queries: Queries for selecting logs which are part of the rule.
        :param bool enabled: Whether the rule is enabled.
        :param 'GetSecurityMonitoringRulesRuleOptionsArgs' options: Options on rules.
        :param Sequence[str] tags: Tags for generated signals.
        """
        pulumi.set(__self__, "cases", cases)
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "queries", queries)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def cases(self) -> Sequence['outputs.GetSecurityMonitoringRulesRuleCaseResult']:
        """
        Cases for generating signals.
        """
        return pulumi.get(self, "cases")

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Message for generated signals.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.GetSecurityMonitoringRulesRuleQueryResult']:
        """
        Queries for selecting logs which are part of the rule.
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether the rule is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def options(self) -> Optional['outputs.GetSecurityMonitoringRulesRuleOptionsResult']:
        """
        Options on rules.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        Tags for generated signals.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleCaseResult(dict):
    def __init__(__self__, *,
                 status: str,
                 condition: Optional[str] = None,
                 name: Optional[str] = None,
                 notifications: Optional[Sequence[str]] = None):
        pulumi.set(__self__, "status", status)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def notifications(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "notifications")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleOptionsResult(dict):
    def __init__(__self__, *,
                 evaluation_window: int,
                 keep_alive: int,
                 max_signal_duration: int):
        pulumi.set(__self__, "evaluation_window", evaluation_window)
        pulumi.set(__self__, "keep_alive", keep_alive)
        pulumi.set(__self__, "max_signal_duration", max_signal_duration)

    @property
    @pulumi.getter(name="evaluationWindow")
    def evaluation_window(self) -> int:
        return pulumi.get(self, "evaluation_window")

    @property
    @pulumi.getter(name="keepAlive")
    def keep_alive(self) -> int:
        return pulumi.get(self, "keep_alive")

    @property
    @pulumi.getter(name="maxSignalDuration")
    def max_signal_duration(self) -> int:
        return pulumi.get(self, "max_signal_duration")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleQueryResult(dict):
    def __init__(__self__, *,
                 query: str,
                 aggregation: Optional[str] = None,
                 distinct_fields: Optional[Sequence[str]] = None,
                 group_by_fields: Optional[Sequence[str]] = None,
                 metric: Optional[str] = None,
                 name: Optional[str] = None):
        pulumi.set(__self__, "query", query)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if distinct_fields is not None:
            pulumi.set(__self__, "distinct_fields", distinct_fields)
        if group_by_fields is not None:
            pulumi.set(__self__, "group_by_fields", group_by_fields)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="distinctFields")
    def distinct_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "distinct_fields")

    @property
    @pulumi.getter(name="groupByFields")
    def group_by_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "group_by_fields")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")



# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'ChildOrganizationApiKey',
    'ChildOrganizationApplicationKey',
    'ChildOrganizationSetting',
    'ChildOrganizationSettingSaml',
    'ChildOrganizationSettingSamlAutocreateUsersDomain',
    'ChildOrganizationSettingSamlIdpInitiatedLogin',
    'ChildOrganizationSettingSamlStrictMode',
    'ChildOrganizationUser',
    'CloudConfigurationRuleFilter',
    'DashboardListDashItem',
    'DashboardTemplateVariable',
    'DashboardTemplateVariablePreset',
    'DashboardTemplateVariablePresetTemplateVariable',
    'DashboardWidget',
    'DashboardWidgetAlertGraphDefinition',
    'DashboardWidgetAlertValueDefinition',
    'DashboardWidgetChangeDefinition',
    'DashboardWidgetChangeDefinitionCustomLink',
    'DashboardWidgetChangeDefinitionRequest',
    'DashboardWidgetChangeDefinitionRequestApmQuery',
    'DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetChangeDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetChangeDefinitionRequestFormula',
    'DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetChangeDefinitionRequestFormulaLimit',
    'DashboardWidgetChangeDefinitionRequestFormulaStyle',
    'DashboardWidgetChangeDefinitionRequestLogQuery',
    'DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetChangeDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetChangeDefinitionRequestProcessQuery',
    'DashboardWidgetChangeDefinitionRequestQuery',
    'DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetChangeDefinitionRequestQueryEventQuery',
    'DashboardWidgetChangeDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetChangeDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetChangeDefinitionRequestQueryMetricQuery',
    'DashboardWidgetChangeDefinitionRequestQueryProcessQuery',
    'DashboardWidgetChangeDefinitionRequestQuerySloQuery',
    'DashboardWidgetChangeDefinitionRequestRumQuery',
    'DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetChangeDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetChangeDefinitionRequestSecurityQuery',
    'DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetCheckStatusDefinition',
    'DashboardWidgetDistributionDefinition',
    'DashboardWidgetDistributionDefinitionRequest',
    'DashboardWidgetDistributionDefinitionRequestApmQuery',
    'DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetDistributionDefinitionRequestApmStatsQuery',
    'DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn',
    'DashboardWidgetDistributionDefinitionRequestLogQuery',
    'DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetDistributionDefinitionRequestProcessQuery',
    'DashboardWidgetDistributionDefinitionRequestRumQuery',
    'DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetDistributionDefinitionRequestSecurityQuery',
    'DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetDistributionDefinitionRequestStyle',
    'DashboardWidgetEventStreamDefinition',
    'DashboardWidgetEventTimelineDefinition',
    'DashboardWidgetFreeTextDefinition',
    'DashboardWidgetGeomapDefinition',
    'DashboardWidgetGeomapDefinitionCustomLink',
    'DashboardWidgetGeomapDefinitionRequest',
    'DashboardWidgetGeomapDefinitionRequestFormula',
    'DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetGeomapDefinitionRequestFormulaLimit',
    'DashboardWidgetGeomapDefinitionRequestFormulaStyle',
    'DashboardWidgetGeomapDefinitionRequestLogQuery',
    'DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGeomapDefinitionRequestQuery',
    'DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQuery',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetGeomapDefinitionRequestQueryMetricQuery',
    'DashboardWidgetGeomapDefinitionRequestQueryProcessQuery',
    'DashboardWidgetGeomapDefinitionRequestQuerySloQuery',
    'DashboardWidgetGeomapDefinitionRequestRumQuery',
    'DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGeomapDefinitionStyle',
    'DashboardWidgetGeomapDefinitionView',
    'DashboardWidgetGroupDefinition',
    'DashboardWidgetGroupDefinitionWidget',
    'DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition',
    'DashboardWidgetGroupDefinitionWidgetAlertValueDefinition',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinition',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormula',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaLimit',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaStyle',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryMetricQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuerySloQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinition',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQueryColumn',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle',
    'DashboardWidgetGroupDefinitionWidgetEventStreamDefinition',
    'DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition',
    'DashboardWidgetGroupDefinitionWidgetFreeTextDefinition',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinition',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaStyle',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuerySloQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle',
    'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinition',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle',
    'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinition',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle',
    'DashboardWidgetGroupDefinitionWidgetIframeDefinition',
    'DashboardWidgetGroupDefinitionWidgetImageDefinition',
    'DashboardWidgetGroupDefinitionWidgetListStreamDefinition',
    'DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestColumn',
    'DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuery',
    'DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuerySort',
    'DashboardWidgetGroupDefinitionWidgetLogStreamDefinition',
    'DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort',
    'DashboardWidgetGroupDefinitionWidgetManageStatusDefinition',
    'DashboardWidgetGroupDefinitionWidgetNoteDefinition',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinition',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormula',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaLimit',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaStyle',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryMetricQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuerySloQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinition',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaStyle',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuerySloQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackground',
    'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackgroundYaxis',
    'DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinition',
    'DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionInput',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinition',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTable',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableFormula',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis',
    'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis',
    'DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition',
    'DashboardWidgetGroupDefinitionWidgetServicemapDefinition',
    'DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetSloListDefinition',
    'DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuery',
    'DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuerySort',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinition',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendInline',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendTable',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormula',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaLimit',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaStyle',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryMetricQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuerySloQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestStyle',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaStyle',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuerySloQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis',
    'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinition',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaStyle',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuerySloQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle',
    'DashboardWidgetGroupDefinitionWidgetTopologyMapDefinition',
    'DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionCustomLink',
    'DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequestQuery',
    'DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition',
    'DashboardWidgetGroupDefinitionWidgetTreemapDefinition',
    'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequest',
    'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormula',
    'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaLimit',
    'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaStyle',
    'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuery',
    'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuery',
    'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryMetricQuery',
    'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryProcessQuery',
    'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuerySloQuery',
    'DashboardWidgetGroupDefinitionWidgetWidgetLayout',
    'DashboardWidgetHeatmapDefinition',
    'DashboardWidgetHeatmapDefinitionCustomLink',
    'DashboardWidgetHeatmapDefinitionEvent',
    'DashboardWidgetHeatmapDefinitionRequest',
    'DashboardWidgetHeatmapDefinitionRequestApmQuery',
    'DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetHeatmapDefinitionRequestLogQuery',
    'DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetHeatmapDefinitionRequestProcessQuery',
    'DashboardWidgetHeatmapDefinitionRequestRumQuery',
    'DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetHeatmapDefinitionRequestSecurityQuery',
    'DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetHeatmapDefinitionRequestStyle',
    'DashboardWidgetHeatmapDefinitionYaxis',
    'DashboardWidgetHostmapDefinition',
    'DashboardWidgetHostmapDefinitionCustomLink',
    'DashboardWidgetHostmapDefinitionRequest',
    'DashboardWidgetHostmapDefinitionRequestFill',
    'DashboardWidgetHostmapDefinitionRequestFillApmQuery',
    'DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery',
    'DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery',
    'DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute',
    'DashboardWidgetHostmapDefinitionRequestFillLogQuery',
    'DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery',
    'DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery',
    'DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute',
    'DashboardWidgetHostmapDefinitionRequestFillProcessQuery',
    'DashboardWidgetHostmapDefinitionRequestFillRumQuery',
    'DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery',
    'DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery',
    'DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute',
    'DashboardWidgetHostmapDefinitionRequestFillSecurityQuery',
    'DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery',
    'DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery',
    'DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute',
    'DashboardWidgetHostmapDefinitionRequestSize',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute',
    'DashboardWidgetHostmapDefinitionRequestSizeProcessQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeRumQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute',
    'DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy',
    'DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery',
    'DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute',
    'DashboardWidgetHostmapDefinitionStyle',
    'DashboardWidgetIframeDefinition',
    'DashboardWidgetImageDefinition',
    'DashboardWidgetListStreamDefinition',
    'DashboardWidgetListStreamDefinitionRequest',
    'DashboardWidgetListStreamDefinitionRequestColumn',
    'DashboardWidgetListStreamDefinitionRequestQuery',
    'DashboardWidgetListStreamDefinitionRequestQuerySort',
    'DashboardWidgetLogStreamDefinition',
    'DashboardWidgetLogStreamDefinitionSort',
    'DashboardWidgetManageStatusDefinition',
    'DashboardWidgetNoteDefinition',
    'DashboardWidgetQueryTableDefinition',
    'DashboardWidgetQueryTableDefinitionCustomLink',
    'DashboardWidgetQueryTableDefinitionRequest',
    'DashboardWidgetQueryTableDefinitionRequestApmQuery',
    'DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetQueryTableDefinitionRequestApmStatsQuery',
    'DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn',
    'DashboardWidgetQueryTableDefinitionRequestConditionalFormat',
    'DashboardWidgetQueryTableDefinitionRequestFormula',
    'DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetQueryTableDefinitionRequestFormulaLimit',
    'DashboardWidgetQueryTableDefinitionRequestFormulaStyle',
    'DashboardWidgetQueryTableDefinitionRequestLogQuery',
    'DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetQueryTableDefinitionRequestProcessQuery',
    'DashboardWidgetQueryTableDefinitionRequestQuery',
    'DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetQueryTableDefinitionRequestQueryEventQuery',
    'DashboardWidgetQueryTableDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery',
    'DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery',
    'DashboardWidgetQueryTableDefinitionRequestQuerySloQuery',
    'DashboardWidgetQueryTableDefinitionRequestRumQuery',
    'DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetQueryTableDefinitionRequestSecurityQuery',
    'DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetQueryValueDefinition',
    'DashboardWidgetQueryValueDefinitionCustomLink',
    'DashboardWidgetQueryValueDefinitionRequest',
    'DashboardWidgetQueryValueDefinitionRequestApmQuery',
    'DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetQueryValueDefinitionRequestAuditQuery',
    'DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQuery',
    'DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy',
    'DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery',
    'DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiCompute',
    'DashboardWidgetQueryValueDefinitionRequestConditionalFormat',
    'DashboardWidgetQueryValueDefinitionRequestFormula',
    'DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetQueryValueDefinitionRequestFormulaLimit',
    'DashboardWidgetQueryValueDefinitionRequestFormulaStyle',
    'DashboardWidgetQueryValueDefinitionRequestLogQuery',
    'DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetQueryValueDefinitionRequestProcessQuery',
    'DashboardWidgetQueryValueDefinitionRequestQuery',
    'DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQuery',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery',
    'DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery',
    'DashboardWidgetQueryValueDefinitionRequestQuerySloQuery',
    'DashboardWidgetQueryValueDefinitionRequestRumQuery',
    'DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetQueryValueDefinitionRequestSecurityQuery',
    'DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetQueryValueDefinitionTimeseriesBackground',
    'DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis',
    'DashboardWidgetRunWorkflowDefinition',
    'DashboardWidgetRunWorkflowDefinitionCustomLink',
    'DashboardWidgetRunWorkflowDefinitionInput',
    'DashboardWidgetScatterplotDefinition',
    'DashboardWidgetScatterplotDefinitionCustomLink',
    'DashboardWidgetScatterplotDefinitionRequest',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTable',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery',
    'DashboardWidgetScatterplotDefinitionRequestX',
    'DashboardWidgetScatterplotDefinitionRequestXApmQuery',
    'DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery',
    'DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery',
    'DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute',
    'DashboardWidgetScatterplotDefinitionRequestXLogQuery',
    'DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery',
    'DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery',
    'DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute',
    'DashboardWidgetScatterplotDefinitionRequestXProcessQuery',
    'DashboardWidgetScatterplotDefinitionRequestXRumQuery',
    'DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery',
    'DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery',
    'DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute',
    'DashboardWidgetScatterplotDefinitionRequestXSecurityQuery',
    'DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery',
    'DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery',
    'DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute',
    'DashboardWidgetScatterplotDefinitionRequestY',
    'DashboardWidgetScatterplotDefinitionRequestYApmQuery',
    'DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery',
    'DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery',
    'DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute',
    'DashboardWidgetScatterplotDefinitionRequestYLogQuery',
    'DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery',
    'DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery',
    'DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute',
    'DashboardWidgetScatterplotDefinitionRequestYProcessQuery',
    'DashboardWidgetScatterplotDefinitionRequestYRumQuery',
    'DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery',
    'DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery',
    'DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute',
    'DashboardWidgetScatterplotDefinitionRequestYSecurityQuery',
    'DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery',
    'DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery',
    'DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute',
    'DashboardWidgetScatterplotDefinitionXaxis',
    'DashboardWidgetScatterplotDefinitionYaxis',
    'DashboardWidgetServiceLevelObjectiveDefinition',
    'DashboardWidgetServicemapDefinition',
    'DashboardWidgetServicemapDefinitionCustomLink',
    'DashboardWidgetSloListDefinition',
    'DashboardWidgetSloListDefinitionRequest',
    'DashboardWidgetSloListDefinitionRequestQuery',
    'DashboardWidgetSloListDefinitionRequestQuerySort',
    'DashboardWidgetSunburstDefinition',
    'DashboardWidgetSunburstDefinitionCustomLink',
    'DashboardWidgetSunburstDefinitionLegendInline',
    'DashboardWidgetSunburstDefinitionLegendTable',
    'DashboardWidgetSunburstDefinitionRequest',
    'DashboardWidgetSunburstDefinitionRequestApmQuery',
    'DashboardWidgetSunburstDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetSunburstDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetSunburstDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetSunburstDefinitionRequestAuditQuery',
    'DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQuery',
    'DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy',
    'DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery',
    'DashboardWidgetSunburstDefinitionRequestAuditQueryMultiCompute',
    'DashboardWidgetSunburstDefinitionRequestFormula',
    'DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetSunburstDefinitionRequestFormulaLimit',
    'DashboardWidgetSunburstDefinitionRequestFormulaStyle',
    'DashboardWidgetSunburstDefinitionRequestLogQuery',
    'DashboardWidgetSunburstDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetSunburstDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetSunburstDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetSunburstDefinitionRequestNetworkQuery',
    'DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQuery',
    'DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy',
    'DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery',
    'DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiCompute',
    'DashboardWidgetSunburstDefinitionRequestProcessQuery',
    'DashboardWidgetSunburstDefinitionRequestQuery',
    'DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetSunburstDefinitionRequestQueryEventQuery',
    'DashboardWidgetSunburstDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetSunburstDefinitionRequestQueryMetricQuery',
    'DashboardWidgetSunburstDefinitionRequestQueryProcessQuery',
    'DashboardWidgetSunburstDefinitionRequestQuerySloQuery',
    'DashboardWidgetSunburstDefinitionRequestRumQuery',
    'DashboardWidgetSunburstDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetSunburstDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetSunburstDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetSunburstDefinitionRequestSecurityQuery',
    'DashboardWidgetSunburstDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetSunburstDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetSunburstDefinitionRequestStyle',
    'DashboardWidgetTimeseriesDefinition',
    'DashboardWidgetTimeseriesDefinitionCustomLink',
    'DashboardWidgetTimeseriesDefinitionEvent',
    'DashboardWidgetTimeseriesDefinitionMarker',
    'DashboardWidgetTimeseriesDefinitionRequest',
    'DashboardWidgetTimeseriesDefinitionRequestApmQuery',
    'DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetTimeseriesDefinitionRequestAuditQuery',
    'DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery',
    'DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery',
    'DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute',
    'DashboardWidgetTimeseriesDefinitionRequestFormula',
    'DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetTimeseriesDefinitionRequestFormulaLimit',
    'DashboardWidgetTimeseriesDefinitionRequestFormulaStyle',
    'DashboardWidgetTimeseriesDefinitionRequestLogQuery',
    'DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetTimeseriesDefinitionRequestMetadata',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQuery',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute',
    'DashboardWidgetTimeseriesDefinitionRequestProcessQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery',
    'DashboardWidgetTimeseriesDefinitionRequestRumQuery',
    'DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetTimeseriesDefinitionRequestSecurityQuery',
    'DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetTimeseriesDefinitionRequestStyle',
    'DashboardWidgetTimeseriesDefinitionRightYaxis',
    'DashboardWidgetTimeseriesDefinitionYaxis',
    'DashboardWidgetToplistDefinition',
    'DashboardWidgetToplistDefinitionCustomLink',
    'DashboardWidgetToplistDefinitionRequest',
    'DashboardWidgetToplistDefinitionRequestApmQuery',
    'DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery',
    'DashboardWidgetToplistDefinitionRequestApmQueryGroupBy',
    'DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery',
    'DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute',
    'DashboardWidgetToplistDefinitionRequestAuditQuery',
    'DashboardWidgetToplistDefinitionRequestAuditQueryComputeQuery',
    'DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy',
    'DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery',
    'DashboardWidgetToplistDefinitionRequestAuditQueryMultiCompute',
    'DashboardWidgetToplistDefinitionRequestConditionalFormat',
    'DashboardWidgetToplistDefinitionRequestFormula',
    'DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetToplistDefinitionRequestFormulaLimit',
    'DashboardWidgetToplistDefinitionRequestFormulaStyle',
    'DashboardWidgetToplistDefinitionRequestLogQuery',
    'DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery',
    'DashboardWidgetToplistDefinitionRequestLogQueryGroupBy',
    'DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery',
    'DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute',
    'DashboardWidgetToplistDefinitionRequestProcessQuery',
    'DashboardWidgetToplistDefinitionRequestQuery',
    'DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetToplistDefinitionRequestQueryEventQuery',
    'DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetToplistDefinitionRequestQueryMetricQuery',
    'DashboardWidgetToplistDefinitionRequestQueryProcessQuery',
    'DashboardWidgetToplistDefinitionRequestQuerySloQuery',
    'DashboardWidgetToplistDefinitionRequestRumQuery',
    'DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery',
    'DashboardWidgetToplistDefinitionRequestRumQueryGroupBy',
    'DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery',
    'DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute',
    'DashboardWidgetToplistDefinitionRequestSecurityQuery',
    'DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery',
    'DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy',
    'DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery',
    'DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute',
    'DashboardWidgetToplistDefinitionRequestStyle',
    'DashboardWidgetTopologyMapDefinition',
    'DashboardWidgetTopologyMapDefinitionCustomLink',
    'DashboardWidgetTopologyMapDefinitionRequest',
    'DashboardWidgetTopologyMapDefinitionRequestQuery',
    'DashboardWidgetTraceServiceDefinition',
    'DashboardWidgetTreemapDefinition',
    'DashboardWidgetTreemapDefinitionRequest',
    'DashboardWidgetTreemapDefinitionRequestFormula',
    'DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetTreemapDefinitionRequestFormulaLimit',
    'DashboardWidgetTreemapDefinitionRequestFormulaStyle',
    'DashboardWidgetTreemapDefinitionRequestQuery',
    'DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetTreemapDefinitionRequestQueryEventQuery',
    'DashboardWidgetTreemapDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetTreemapDefinitionRequestQueryMetricQuery',
    'DashboardWidgetTreemapDefinitionRequestQueryProcessQuery',
    'DashboardWidgetTreemapDefinitionRequestQuerySloQuery',
    'DashboardWidgetWidgetLayout',
    'DowntimeRecurrence',
    'DowntimeScheduleMonitorIdentifier',
    'DowntimeScheduleOneTimeSchedule',
    'DowntimeScheduleRecurringSchedule',
    'DowntimeScheduleRecurringScheduleRecurrence',
    'IpAllowlistEntry',
    'LogsArchiveAzureArchive',
    'LogsArchiveGcsArchive',
    'LogsArchiveS3Archive',
    'LogsCustomPipelineFilter',
    'LogsCustomPipelineProcessor',
    'LogsCustomPipelineProcessorArithmeticProcessor',
    'LogsCustomPipelineProcessorAttributeRemapper',
    'LogsCustomPipelineProcessorCategoryProcessor',
    'LogsCustomPipelineProcessorCategoryProcessorCategory',
    'LogsCustomPipelineProcessorCategoryProcessorCategoryFilter',
    'LogsCustomPipelineProcessorDateRemapper',
    'LogsCustomPipelineProcessorGeoIpParser',
    'LogsCustomPipelineProcessorGrokParser',
    'LogsCustomPipelineProcessorGrokParserGrok',
    'LogsCustomPipelineProcessorLookupProcessor',
    'LogsCustomPipelineProcessorMessageRemapper',
    'LogsCustomPipelineProcessorPipeline',
    'LogsCustomPipelineProcessorPipelineFilter',
    'LogsCustomPipelineProcessorPipelineProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter',
    'LogsCustomPipelineProcessorPipelineProcessorDateRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorGeoIpParser',
    'LogsCustomPipelineProcessorPipelineProcessorGrokParser',
    'LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok',
    'LogsCustomPipelineProcessorPipelineProcessorLookupProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorMessageRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorServiceRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorStatusRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorUrlParser',
    'LogsCustomPipelineProcessorPipelineProcessorUserAgentParser',
    'LogsCustomPipelineProcessorReferenceTableLookupProcessor',
    'LogsCustomPipelineProcessorServiceRemapper',
    'LogsCustomPipelineProcessorStatusRemapper',
    'LogsCustomPipelineProcessorStringBuilderProcessor',
    'LogsCustomPipelineProcessorTraceIdRemapper',
    'LogsCustomPipelineProcessorUrlParser',
    'LogsCustomPipelineProcessorUserAgentParser',
    'LogsIndexExclusionFilter',
    'LogsIndexExclusionFilterFilter',
    'LogsIndexFilter',
    'LogsMetricCompute',
    'LogsMetricFilter',
    'LogsMetricGroupBy',
    'MetricTagConfigurationAggregation',
    'MonitorConfigPolicyTagPolicy',
    'MonitorMonitorThresholdWindows',
    'MonitorMonitorThresholds',
    'MonitorSchedulingOption',
    'MonitorSchedulingOptionEvaluationWindow',
    'MonitorVariables',
    'MonitorVariablesEventQuery',
    'MonitorVariablesEventQueryCompute',
    'MonitorVariablesEventQueryGroupBy',
    'MonitorVariablesEventQueryGroupBySort',
    'MonitorVariablesEventQuerySearch',
    'OrganizationSettingsSettings',
    'OrganizationSettingsSettingsSaml',
    'OrganizationSettingsSettingsSamlAutocreateUsersDomains',
    'OrganizationSettingsSettingsSamlIdpInitiatedLogin',
    'OrganizationSettingsSettingsSamlStrictMode',
    'RestrictionPolicyBinding',
    'RolePermission',
    'SecurityMonitoringDefaultRuleCase',
    'SecurityMonitoringDefaultRuleFilter',
    'SecurityMonitoringDefaultRuleOptions',
    'SecurityMonitoringFilterExclusionFilter',
    'SecurityMonitoringRuleCase',
    'SecurityMonitoringRuleFilter',
    'SecurityMonitoringRuleOptions',
    'SecurityMonitoringRuleOptionsImpossibleTravelOptions',
    'SecurityMonitoringRuleOptionsNewValueOptions',
    'SecurityMonitoringRuleQuery',
    'SecurityMonitoringRuleQueryAgentRule',
    'SecurityMonitoringRuleSignalQuery',
    'SensitiveDataScannerGroupFilter',
    'SensitiveDataScannerRuleTextReplacement',
    'ServiceLevelObjectiveQuery',
    'ServiceLevelObjectiveThreshold',
    'SpansMetricCompute',
    'SpansMetricFilter',
    'SpansMetricGroupBy',
    'SyntheticsGlobalVariableOptions',
    'SyntheticsGlobalVariableOptionsTotpParameters',
    'SyntheticsGlobalVariableParseTestOptions',
    'SyntheticsGlobalVariableParseTestOptionsParser',
    'SyntheticsPrivateLocationMetadata',
    'SyntheticsTestApiStep',
    'SyntheticsTestApiStepAssertion',
    'SyntheticsTestApiStepAssertionTargetjsonpath',
    'SyntheticsTestApiStepAssertionTargetxpath',
    'SyntheticsTestApiStepExtractedValue',
    'SyntheticsTestApiStepExtractedValueParser',
    'SyntheticsTestApiStepRequestBasicauth',
    'SyntheticsTestApiStepRequestClientCertificate',
    'SyntheticsTestApiStepRequestClientCertificateCert',
    'SyntheticsTestApiStepRequestClientCertificateKey',
    'SyntheticsTestApiStepRequestDefinition',
    'SyntheticsTestApiStepRequestProxy',
    'SyntheticsTestApiStepRetry',
    'SyntheticsTestAssertion',
    'SyntheticsTestAssertionTargetjsonpath',
    'SyntheticsTestAssertionTargetxpath',
    'SyntheticsTestBrowserStep',
    'SyntheticsTestBrowserStepParams',
    'SyntheticsTestBrowserStepParamsElementUserLocator',
    'SyntheticsTestBrowserStepParamsElementUserLocatorValue',
    'SyntheticsTestBrowserStepParamsVariable',
    'SyntheticsTestBrowserVariable',
    'SyntheticsTestConfigVariable',
    'SyntheticsTestOptionsList',
    'SyntheticsTestOptionsListCi',
    'SyntheticsTestOptionsListMonitorOptions',
    'SyntheticsTestOptionsListRetry',
    'SyntheticsTestOptionsListRumSettings',
    'SyntheticsTestOptionsListScheduling',
    'SyntheticsTestOptionsListSchedulingTimeframe',
    'SyntheticsTestRequestBasicauth',
    'SyntheticsTestRequestClientCertificate',
    'SyntheticsTestRequestClientCertificateCert',
    'SyntheticsTestRequestClientCertificateKey',
    'SyntheticsTestRequestDefinition',
    'SyntheticsTestRequestProxy',
    'GetCloudWorkloadSecurityAgentRulesAgentRuleResult',
    'GetHostsHostListResult',
    'GetHostsHostListMetaResult',
    'GetHostsHostListMetricsResult',
    'GetLogsIndexesLogsIndexResult',
    'GetLogsIndexesLogsIndexExclusionFilterResult',
    'GetLogsIndexesLogsIndexExclusionFilterFilterResult',
    'GetLogsIndexesLogsIndexFilterResult',
    'GetLogsPipelinesLogsPipelineResult',
    'GetLogsPipelinesLogsPipelineFilterResult',
    'GetMonitorConfigPoliciesMonitorConfigPolicyResult',
    'GetMonitorConfigPoliciesMonitorConfigPolicyTagPolicyResult',
    'GetMonitorMonitorThresholdResult',
    'GetMonitorMonitorThresholdWindowResult',
    'GetMonitorSchedulingOptionResult',
    'GetMonitorSchedulingOptionEvaluationWindowResult',
    'GetMonitorsMonitorResult',
    'GetRolesRoleResult',
    'GetSecurityMonitoringFiltersFilterResult',
    'GetSecurityMonitoringFiltersFilterExclusionFilterResult',
    'GetSecurityMonitoringRulesRuleResult',
    'GetSecurityMonitoringRulesRuleCaseResult',
    'GetSecurityMonitoringRulesRuleFilterResult',
    'GetSecurityMonitoringRulesRuleOptionsResult',
    'GetSecurityMonitoringRulesRuleOptionsImpossibleTravelOptionsResult',
    'GetSecurityMonitoringRulesRuleOptionsNewValueOptionsResult',
    'GetSecurityMonitoringRulesRuleQueryResult',
    'GetSecurityMonitoringRulesRuleQueryAgentRuleResult',
    'GetSecurityMonitoringRulesRuleSignalQueryResult',
    'GetServiceLevelObjectiveQueryResult',
    'GetServiceLevelObjectivesSloResult',
    'GetTeamMembershipsTeamMembershipResult',
]

@pulumi.output_type
class ChildOrganizationApiKey(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None):
        ChildOrganizationApiKey._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if key is not None:
            _setter("key", key)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class ChildOrganizationApplicationKey(dict):
    def __init__(__self__, *,
                 hash: Optional[str] = None,
                 name: Optional[str] = None,
                 owner: Optional[str] = None):
        ChildOrganizationApplicationKey._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hash=hash,
            name=name,
            owner=owner,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hash: Optional[str] = None,
             name: Optional[str] = None,
             owner: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if hash is not None:
            _setter("hash", hash)
        if name is not None:
            _setter("name", name)
        if owner is not None:
            _setter("owner", owner)

    @property
    @pulumi.getter
    def hash(self) -> Optional[str]:
        return pulumi.get(self, "hash")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        return pulumi.get(self, "owner")


@pulumi.output_type
class ChildOrganizationSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateWidgetShare":
            suggest = "private_widget_share"
        elif key == "samlAutocreateAccessRole":
            suggest = "saml_autocreate_access_role"
        elif key == "samlAutocreateUsersDomains":
            suggest = "saml_autocreate_users_domains"
        elif key == "samlCanBeEnabled":
            suggest = "saml_can_be_enabled"
        elif key == "samlIdpEndpoint":
            suggest = "saml_idp_endpoint"
        elif key == "samlIdpInitiatedLogins":
            suggest = "saml_idp_initiated_logins"
        elif key == "samlIdpMetadataUploaded":
            suggest = "saml_idp_metadata_uploaded"
        elif key == "samlLoginUrl":
            suggest = "saml_login_url"
        elif key == "samlStrictModes":
            suggest = "saml_strict_modes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChildOrganizationSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChildOrganizationSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChildOrganizationSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_widget_share: Optional[bool] = None,
                 saml_autocreate_access_role: Optional[str] = None,
                 saml_autocreate_users_domains: Optional[Sequence['outputs.ChildOrganizationSettingSamlAutocreateUsersDomain']] = None,
                 saml_can_be_enabled: Optional[bool] = None,
                 saml_idp_endpoint: Optional[str] = None,
                 saml_idp_initiated_logins: Optional[Sequence['outputs.ChildOrganizationSettingSamlIdpInitiatedLogin']] = None,
                 saml_idp_metadata_uploaded: Optional[bool] = None,
                 saml_login_url: Optional[str] = None,
                 saml_strict_modes: Optional[Sequence['outputs.ChildOrganizationSettingSamlStrictMode']] = None,
                 samls: Optional[Sequence['outputs.ChildOrganizationSettingSaml']] = None):
        ChildOrganizationSetting._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            private_widget_share=private_widget_share,
            saml_autocreate_access_role=saml_autocreate_access_role,
            saml_autocreate_users_domains=saml_autocreate_users_domains,
            saml_can_be_enabled=saml_can_be_enabled,
            saml_idp_endpoint=saml_idp_endpoint,
            saml_idp_initiated_logins=saml_idp_initiated_logins,
            saml_idp_metadata_uploaded=saml_idp_metadata_uploaded,
            saml_login_url=saml_login_url,
            saml_strict_modes=saml_strict_modes,
            samls=samls,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             private_widget_share: Optional[bool] = None,
             saml_autocreate_access_role: Optional[str] = None,
             saml_autocreate_users_domains: Optional[Sequence['outputs.ChildOrganizationSettingSamlAutocreateUsersDomain']] = None,
             saml_can_be_enabled: Optional[bool] = None,
             saml_idp_endpoint: Optional[str] = None,
             saml_idp_initiated_logins: Optional[Sequence['outputs.ChildOrganizationSettingSamlIdpInitiatedLogin']] = None,
             saml_idp_metadata_uploaded: Optional[bool] = None,
             saml_login_url: Optional[str] = None,
             saml_strict_modes: Optional[Sequence['outputs.ChildOrganizationSettingSamlStrictMode']] = None,
             samls: Optional[Sequence['outputs.ChildOrganizationSettingSaml']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if private_widget_share is not None:
            _setter("private_widget_share", private_widget_share)
        if saml_autocreate_access_role is not None:
            _setter("saml_autocreate_access_role", saml_autocreate_access_role)
        if saml_autocreate_users_domains is not None:
            _setter("saml_autocreate_users_domains", saml_autocreate_users_domains)
        if saml_can_be_enabled is not None:
            _setter("saml_can_be_enabled", saml_can_be_enabled)
        if saml_idp_endpoint is not None:
            _setter("saml_idp_endpoint", saml_idp_endpoint)
        if saml_idp_initiated_logins is not None:
            _setter("saml_idp_initiated_logins", saml_idp_initiated_logins)
        if saml_idp_metadata_uploaded is not None:
            _setter("saml_idp_metadata_uploaded", saml_idp_metadata_uploaded)
        if saml_login_url is not None:
            _setter("saml_login_url", saml_login_url)
        if saml_strict_modes is not None:
            _setter("saml_strict_modes", saml_strict_modes)
        if samls is not None:
            _setter("samls", samls)

    @property
    @pulumi.getter(name="privateWidgetShare")
    def private_widget_share(self) -> Optional[bool]:
        return pulumi.get(self, "private_widget_share")

    @property
    @pulumi.getter(name="samlAutocreateAccessRole")
    def saml_autocreate_access_role(self) -> Optional[str]:
        return pulumi.get(self, "saml_autocreate_access_role")

    @property
    @pulumi.getter(name="samlAutocreateUsersDomains")
    def saml_autocreate_users_domains(self) -> Optional[Sequence['outputs.ChildOrganizationSettingSamlAutocreateUsersDomain']]:
        return pulumi.get(self, "saml_autocreate_users_domains")

    @property
    @pulumi.getter(name="samlCanBeEnabled")
    def saml_can_be_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "saml_can_be_enabled")

    @property
    @pulumi.getter(name="samlIdpEndpoint")
    def saml_idp_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "saml_idp_endpoint")

    @property
    @pulumi.getter(name="samlIdpInitiatedLogins")
    def saml_idp_initiated_logins(self) -> Optional[Sequence['outputs.ChildOrganizationSettingSamlIdpInitiatedLogin']]:
        return pulumi.get(self, "saml_idp_initiated_logins")

    @property
    @pulumi.getter(name="samlIdpMetadataUploaded")
    def saml_idp_metadata_uploaded(self) -> Optional[bool]:
        return pulumi.get(self, "saml_idp_metadata_uploaded")

    @property
    @pulumi.getter(name="samlLoginUrl")
    def saml_login_url(self) -> Optional[str]:
        return pulumi.get(self, "saml_login_url")

    @property
    @pulumi.getter(name="samlStrictModes")
    def saml_strict_modes(self) -> Optional[Sequence['outputs.ChildOrganizationSettingSamlStrictMode']]:
        return pulumi.get(self, "saml_strict_modes")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.ChildOrganizationSettingSaml']]:
        return pulumi.get(self, "samls")


@pulumi.output_type
class ChildOrganizationSettingSaml(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        ChildOrganizationSettingSaml._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ChildOrganizationSettingSamlAutocreateUsersDomain(dict):
    def __init__(__self__, *,
                 domains: Optional[Sequence[str]] = None,
                 enabled: Optional[bool] = None):
        ChildOrganizationSettingSamlAutocreateUsersDomain._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domains=domains,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domains: Optional[Sequence[str]] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if domains is not None:
            _setter("domains", domains)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def domains(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ChildOrganizationSettingSamlIdpInitiatedLogin(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        ChildOrganizationSettingSamlIdpInitiatedLogin._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ChildOrganizationSettingSamlStrictMode(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        ChildOrganizationSettingSamlStrictMode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ChildOrganizationUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessRole":
            suggest = "access_role"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChildOrganizationUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChildOrganizationUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChildOrganizationUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_role: Optional[str] = None,
                 email: Optional[str] = None,
                 name: Optional[str] = None):
        ChildOrganizationUser._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_role=access_role,
            email=email,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_role: Optional[str] = None,
             email: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if access_role is not None:
            _setter("access_role", access_role)
        if email is not None:
            _setter("email", email)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="accessRole")
    def access_role(self) -> Optional[str]:
        return pulumi.get(self, "access_role")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class CloudConfigurationRuleFilter(dict):
    def __init__(__self__, *,
                 action: str,
                 query: str):
        """
        :param str action: The type of filtering action. Valid values are `require`, `suppress`.
        :param str query: Query for selecting logs to apply the filtering action.
        """
        CloudConfigurationRuleFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("query", query)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The type of filtering action. Valid values are `require`, `suppress`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for selecting logs to apply the filtering action.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardListDashItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashId":
            suggest = "dash_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardListDashItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardListDashItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardListDashItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dash_id: str,
                 type: str):
        """
        :param str dash_id: The ID of the dashboard to add
        :param str type: The type of this dashboard. Valid values are `custom_timeboard`, `custom_screenboard`, `integration_screenboard`, `integration_timeboard`, `host_timeboard`.
        """
        DashboardListDashItem._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dash_id=dash_id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dash_id: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dash_id", dash_id)
        _setter("type", type)

    @property
    @pulumi.getter(name="dashId")
    def dash_id(self) -> str:
        """
        The ID of the dashboard to add
        """
        return pulumi.get(self, "dash_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of this dashboard. Valid values are `custom_timeboard`, `custom_screenboard`, `integration_screenboard`, `integration_timeboard`, `host_timeboard`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DashboardTemplateVariable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availableValues":
            suggest = "available_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTemplateVariable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTemplateVariable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTemplateVariable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 available_values: Optional[Sequence[str]] = None,
                 default: Optional[str] = None,
                 defaults: Optional[Sequence[str]] = None,
                 prefix: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param Sequence[str] available_values: The list of values that the template variable drop-down is be limited to
        :param str default: The default value for the template variable on dashboard load. Cannot be used in conjunction with `defaults`. **Deprecated.** Use `defaults` instead.
        :param Sequence[str] defaults: One or many default values for template variables on load. If more than one default is specified, they will be unioned together with `OR`. Cannot be used in conjunction with `default`.
        :param str prefix: The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
        """
        DashboardTemplateVariable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            available_values=available_values,
            default=default,
            defaults=defaults,
            prefix=prefix,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             available_values: Optional[Sequence[str]] = None,
             default: Optional[str] = None,
             defaults: Optional[Sequence[str]] = None,
             prefix: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if available_values is not None:
            _setter("available_values", available_values)
        if default is not None:
            _setter("default", default)
        if defaults is not None:
            _setter("defaults", defaults)
        if prefix is not None:
            _setter("prefix", prefix)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="availableValues")
    def available_values(self) -> Optional[Sequence[str]]:
        """
        The list of values that the template variable drop-down is be limited to
        """
        return pulumi.get(self, "available_values")

    @property
    @pulumi.getter
    def default(self) -> Optional[str]:
        """
        The default value for the template variable on dashboard load. Cannot be used in conjunction with `defaults`. **Deprecated.** Use `defaults` instead.
        """
        warnings.warn("""Use `defaults` instead.""", DeprecationWarning)
        pulumi.log.warn("""default is deprecated: Use `defaults` instead.""")

        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def defaults(self) -> Optional[Sequence[str]]:
        """
        One or many default values for template variables on load. If more than one default is specified, they will be unioned together with `OR`. Cannot be used in conjunction with `default`.
        """
        return pulumi.get(self, "defaults")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class DashboardTemplateVariablePreset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateVariables":
            suggest = "template_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTemplateVariablePreset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTemplateVariablePreset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTemplateVariablePreset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 template_variables: Optional[Sequence['outputs.DashboardTemplateVariablePresetTemplateVariable']] = None):
        """
        :param str name: The name of the preset.
        :param Sequence['DashboardTemplateVariablePresetTemplateVariableArgs'] template_variables: The template variable names and assumed values under the given preset
        """
        DashboardTemplateVariablePreset._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            template_variables=template_variables,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             template_variables: Optional[Sequence['outputs.DashboardTemplateVariablePresetTemplateVariable']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if template_variables is not None:
            _setter("template_variables", template_variables)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the preset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="templateVariables")
    def template_variables(self) -> Optional[Sequence['outputs.DashboardTemplateVariablePresetTemplateVariable']]:
        """
        The template variable names and assumed values under the given preset
        """
        return pulumi.get(self, "template_variables")


@pulumi.output_type
class DashboardTemplateVariablePresetTemplateVariable(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str name: The name of the variable.
        :param str value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param Sequence[str] values: One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified. Cannot be used in conjunction with `value`.
        """
        DashboardTemplateVariablePresetTemplateVariable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
            values=values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[str] = None,
             value: Optional[str] = None,
             values: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if value is not None:
            _setter("value", value)
        if values is not None:
            _setter("values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        warnings.warn("""Use `values` instead.""", DeprecationWarning)
        pulumi.log.warn("""value is deprecated: Use `values` instead.""")

        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified. Cannot be used in conjunction with `value`.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardWidget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertGraphDefinition":
            suggest = "alert_graph_definition"
        elif key == "alertValueDefinition":
            suggest = "alert_value_definition"
        elif key == "changeDefinition":
            suggest = "change_definition"
        elif key == "checkStatusDefinition":
            suggest = "check_status_definition"
        elif key == "distributionDefinition":
            suggest = "distribution_definition"
        elif key == "eventStreamDefinition":
            suggest = "event_stream_definition"
        elif key == "eventTimelineDefinition":
            suggest = "event_timeline_definition"
        elif key == "freeTextDefinition":
            suggest = "free_text_definition"
        elif key == "geomapDefinition":
            suggest = "geomap_definition"
        elif key == "groupDefinition":
            suggest = "group_definition"
        elif key == "heatmapDefinition":
            suggest = "heatmap_definition"
        elif key == "hostmapDefinition":
            suggest = "hostmap_definition"
        elif key == "iframeDefinition":
            suggest = "iframe_definition"
        elif key == "imageDefinition":
            suggest = "image_definition"
        elif key == "listStreamDefinition":
            suggest = "list_stream_definition"
        elif key == "logStreamDefinition":
            suggest = "log_stream_definition"
        elif key == "manageStatusDefinition":
            suggest = "manage_status_definition"
        elif key == "noteDefinition":
            suggest = "note_definition"
        elif key == "queryTableDefinition":
            suggest = "query_table_definition"
        elif key == "queryValueDefinition":
            suggest = "query_value_definition"
        elif key == "runWorkflowDefinition":
            suggest = "run_workflow_definition"
        elif key == "scatterplotDefinition":
            suggest = "scatterplot_definition"
        elif key == "serviceLevelObjectiveDefinition":
            suggest = "service_level_objective_definition"
        elif key == "servicemapDefinition":
            suggest = "servicemap_definition"
        elif key == "sloListDefinition":
            suggest = "slo_list_definition"
        elif key == "sunburstDefinition":
            suggest = "sunburst_definition"
        elif key == "timeseriesDefinition":
            suggest = "timeseries_definition"
        elif key == "toplistDefinition":
            suggest = "toplist_definition"
        elif key == "topologyMapDefinition":
            suggest = "topology_map_definition"
        elif key == "traceServiceDefinition":
            suggest = "trace_service_definition"
        elif key == "treemapDefinition":
            suggest = "treemap_definition"
        elif key == "widgetLayout":
            suggest = "widget_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_graph_definition: Optional['outputs.DashboardWidgetAlertGraphDefinition'] = None,
                 alert_value_definition: Optional['outputs.DashboardWidgetAlertValueDefinition'] = None,
                 change_definition: Optional['outputs.DashboardWidgetChangeDefinition'] = None,
                 check_status_definition: Optional['outputs.DashboardWidgetCheckStatusDefinition'] = None,
                 distribution_definition: Optional['outputs.DashboardWidgetDistributionDefinition'] = None,
                 event_stream_definition: Optional['outputs.DashboardWidgetEventStreamDefinition'] = None,
                 event_timeline_definition: Optional['outputs.DashboardWidgetEventTimelineDefinition'] = None,
                 free_text_definition: Optional['outputs.DashboardWidgetFreeTextDefinition'] = None,
                 geomap_definition: Optional['outputs.DashboardWidgetGeomapDefinition'] = None,
                 group_definition: Optional['outputs.DashboardWidgetGroupDefinition'] = None,
                 heatmap_definition: Optional['outputs.DashboardWidgetHeatmapDefinition'] = None,
                 hostmap_definition: Optional['outputs.DashboardWidgetHostmapDefinition'] = None,
                 id: Optional[int] = None,
                 iframe_definition: Optional['outputs.DashboardWidgetIframeDefinition'] = None,
                 image_definition: Optional['outputs.DashboardWidgetImageDefinition'] = None,
                 list_stream_definition: Optional['outputs.DashboardWidgetListStreamDefinition'] = None,
                 log_stream_definition: Optional['outputs.DashboardWidgetLogStreamDefinition'] = None,
                 manage_status_definition: Optional['outputs.DashboardWidgetManageStatusDefinition'] = None,
                 note_definition: Optional['outputs.DashboardWidgetNoteDefinition'] = None,
                 query_table_definition: Optional['outputs.DashboardWidgetQueryTableDefinition'] = None,
                 query_value_definition: Optional['outputs.DashboardWidgetQueryValueDefinition'] = None,
                 run_workflow_definition: Optional['outputs.DashboardWidgetRunWorkflowDefinition'] = None,
                 scatterplot_definition: Optional['outputs.DashboardWidgetScatterplotDefinition'] = None,
                 service_level_objective_definition: Optional['outputs.DashboardWidgetServiceLevelObjectiveDefinition'] = None,
                 servicemap_definition: Optional['outputs.DashboardWidgetServicemapDefinition'] = None,
                 slo_list_definition: Optional['outputs.DashboardWidgetSloListDefinition'] = None,
                 sunburst_definition: Optional['outputs.DashboardWidgetSunburstDefinition'] = None,
                 timeseries_definition: Optional['outputs.DashboardWidgetTimeseriesDefinition'] = None,
                 toplist_definition: Optional['outputs.DashboardWidgetToplistDefinition'] = None,
                 topology_map_definition: Optional['outputs.DashboardWidgetTopologyMapDefinition'] = None,
                 trace_service_definition: Optional['outputs.DashboardWidgetTraceServiceDefinition'] = None,
                 treemap_definition: Optional['outputs.DashboardWidgetTreemapDefinition'] = None,
                 widget_layout: Optional['outputs.DashboardWidgetWidgetLayout'] = None):
        """
        :param 'DashboardWidgetAlertGraphDefinitionArgs' alert_graph_definition: The definition for a Alert Graph widget.
        :param 'DashboardWidgetAlertValueDefinitionArgs' alert_value_definition: The definition for a Alert Value widget.
        :param 'DashboardWidgetChangeDefinitionArgs' change_definition: The definition for a Change widget.
        :param 'DashboardWidgetCheckStatusDefinitionArgs' check_status_definition: The definition for a Check Status widget.
        :param 'DashboardWidgetDistributionDefinitionArgs' distribution_definition: The definition for a Distribution widget.
        :param 'DashboardWidgetEventStreamDefinitionArgs' event_stream_definition: The definition for a Event Stream widget.
        :param 'DashboardWidgetEventTimelineDefinitionArgs' event_timeline_definition: The definition for a Event Timeline widget.
        :param 'DashboardWidgetFreeTextDefinitionArgs' free_text_definition: The definition for a Free Text widget.
        :param 'DashboardWidgetGeomapDefinitionArgs' geomap_definition: The definition for a Geomap widget.
        :param 'DashboardWidgetGroupDefinitionArgs' group_definition: The definition for a Group widget.
        :param 'DashboardWidgetHeatmapDefinitionArgs' heatmap_definition: The definition for a Heatmap widget.
        :param 'DashboardWidgetHostmapDefinitionArgs' hostmap_definition: The definition for a Hostmap widget.
        :param int id: The ID of the widget.
        :param 'DashboardWidgetIframeDefinitionArgs' iframe_definition: The definition for an Iframe widget.
        :param 'DashboardWidgetImageDefinitionArgs' image_definition: The definition for an Image widget
        :param 'DashboardWidgetListStreamDefinitionArgs' list_stream_definition: The definition for a List Stream widget.
        :param 'DashboardWidgetLogStreamDefinitionArgs' log_stream_definition: The definition for an Log Stream widget.
        :param 'DashboardWidgetManageStatusDefinitionArgs' manage_status_definition: The definition for an Manage Status widget.
        :param 'DashboardWidgetNoteDefinitionArgs' note_definition: The definition for a Note widget.
        :param 'DashboardWidgetQueryTableDefinitionArgs' query_table_definition: The definition for a Query Table widget.
        :param 'DashboardWidgetQueryValueDefinitionArgs' query_value_definition: The definition for a Query Value widget.
        :param 'DashboardWidgetRunWorkflowDefinitionArgs' run_workflow_definition: The definition for a Run Workflow widget.
        :param 'DashboardWidgetScatterplotDefinitionArgs' scatterplot_definition: The definition for a Scatterplot widget.
        :param 'DashboardWidgetServiceLevelObjectiveDefinitionArgs' service_level_objective_definition: The definition for a Service Level Objective widget.
        :param 'DashboardWidgetServicemapDefinitionArgs' servicemap_definition: The definition for a Service Map widget.
        :param 'DashboardWidgetSloListDefinitionArgs' slo_list_definition: The definition for an SLO (Service Level Objective) List widget.
        :param 'DashboardWidgetSunburstDefinitionArgs' sunburst_definition: The definition for a Sunburst widget.
        :param 'DashboardWidgetTimeseriesDefinitionArgs' timeseries_definition: The definition for a Timeseries widget.
        :param 'DashboardWidgetToplistDefinitionArgs' toplist_definition: The definition for a Toplist widget.
        :param 'DashboardWidgetTopologyMapDefinitionArgs' topology_map_definition: The definition for a Topology Map widget.
        :param 'DashboardWidgetTraceServiceDefinitionArgs' trace_service_definition: The definition for a Trace Service widget.
        :param 'DashboardWidgetTreemapDefinitionArgs' treemap_definition: The definition for a Treemap widget.
        :param 'DashboardWidgetWidgetLayoutArgs' widget_layout: The layout of the widget on a 'free' dashboard.
        """
        DashboardWidget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_graph_definition=alert_graph_definition,
            alert_value_definition=alert_value_definition,
            change_definition=change_definition,
            check_status_definition=check_status_definition,
            distribution_definition=distribution_definition,
            event_stream_definition=event_stream_definition,
            event_timeline_definition=event_timeline_definition,
            free_text_definition=free_text_definition,
            geomap_definition=geomap_definition,
            group_definition=group_definition,
            heatmap_definition=heatmap_definition,
            hostmap_definition=hostmap_definition,
            id=id,
            iframe_definition=iframe_definition,
            image_definition=image_definition,
            list_stream_definition=list_stream_definition,
            log_stream_definition=log_stream_definition,
            manage_status_definition=manage_status_definition,
            note_definition=note_definition,
            query_table_definition=query_table_definition,
            query_value_definition=query_value_definition,
            run_workflow_definition=run_workflow_definition,
            scatterplot_definition=scatterplot_definition,
            service_level_objective_definition=service_level_objective_definition,
            servicemap_definition=servicemap_definition,
            slo_list_definition=slo_list_definition,
            sunburst_definition=sunburst_definition,
            timeseries_definition=timeseries_definition,
            toplist_definition=toplist_definition,
            topology_map_definition=topology_map_definition,
            trace_service_definition=trace_service_definition,
            treemap_definition=treemap_definition,
            widget_layout=widget_layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_graph_definition: Optional['outputs.DashboardWidgetAlertGraphDefinition'] = None,
             alert_value_definition: Optional['outputs.DashboardWidgetAlertValueDefinition'] = None,
             change_definition: Optional['outputs.DashboardWidgetChangeDefinition'] = None,
             check_status_definition: Optional['outputs.DashboardWidgetCheckStatusDefinition'] = None,
             distribution_definition: Optional['outputs.DashboardWidgetDistributionDefinition'] = None,
             event_stream_definition: Optional['outputs.DashboardWidgetEventStreamDefinition'] = None,
             event_timeline_definition: Optional['outputs.DashboardWidgetEventTimelineDefinition'] = None,
             free_text_definition: Optional['outputs.DashboardWidgetFreeTextDefinition'] = None,
             geomap_definition: Optional['outputs.DashboardWidgetGeomapDefinition'] = None,
             group_definition: Optional['outputs.DashboardWidgetGroupDefinition'] = None,
             heatmap_definition: Optional['outputs.DashboardWidgetHeatmapDefinition'] = None,
             hostmap_definition: Optional['outputs.DashboardWidgetHostmapDefinition'] = None,
             id: Optional[int] = None,
             iframe_definition: Optional['outputs.DashboardWidgetIframeDefinition'] = None,
             image_definition: Optional['outputs.DashboardWidgetImageDefinition'] = None,
             list_stream_definition: Optional['outputs.DashboardWidgetListStreamDefinition'] = None,
             log_stream_definition: Optional['outputs.DashboardWidgetLogStreamDefinition'] = None,
             manage_status_definition: Optional['outputs.DashboardWidgetManageStatusDefinition'] = None,
             note_definition: Optional['outputs.DashboardWidgetNoteDefinition'] = None,
             query_table_definition: Optional['outputs.DashboardWidgetQueryTableDefinition'] = None,
             query_value_definition: Optional['outputs.DashboardWidgetQueryValueDefinition'] = None,
             run_workflow_definition: Optional['outputs.DashboardWidgetRunWorkflowDefinition'] = None,
             scatterplot_definition: Optional['outputs.DashboardWidgetScatterplotDefinition'] = None,
             service_level_objective_definition: Optional['outputs.DashboardWidgetServiceLevelObjectiveDefinition'] = None,
             servicemap_definition: Optional['outputs.DashboardWidgetServicemapDefinition'] = None,
             slo_list_definition: Optional['outputs.DashboardWidgetSloListDefinition'] = None,
             sunburst_definition: Optional['outputs.DashboardWidgetSunburstDefinition'] = None,
             timeseries_definition: Optional['outputs.DashboardWidgetTimeseriesDefinition'] = None,
             toplist_definition: Optional['outputs.DashboardWidgetToplistDefinition'] = None,
             topology_map_definition: Optional['outputs.DashboardWidgetTopologyMapDefinition'] = None,
             trace_service_definition: Optional['outputs.DashboardWidgetTraceServiceDefinition'] = None,
             treemap_definition: Optional['outputs.DashboardWidgetTreemapDefinition'] = None,
             widget_layout: Optional['outputs.DashboardWidgetWidgetLayout'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if alert_graph_definition is not None:
            _setter("alert_graph_definition", alert_graph_definition)
        if alert_value_definition is not None:
            _setter("alert_value_definition", alert_value_definition)
        if change_definition is not None:
            _setter("change_definition", change_definition)
        if check_status_definition is not None:
            _setter("check_status_definition", check_status_definition)
        if distribution_definition is not None:
            _setter("distribution_definition", distribution_definition)
        if event_stream_definition is not None:
            _setter("event_stream_definition", event_stream_definition)
        if event_timeline_definition is not None:
            _setter("event_timeline_definition", event_timeline_definition)
        if free_text_definition is not None:
            _setter("free_text_definition", free_text_definition)
        if geomap_definition is not None:
            _setter("geomap_definition", geomap_definition)
        if group_definition is not None:
            _setter("group_definition", group_definition)
        if heatmap_definition is not None:
            _setter("heatmap_definition", heatmap_definition)
        if hostmap_definition is not None:
            _setter("hostmap_definition", hostmap_definition)
        if id is not None:
            _setter("id", id)
        if iframe_definition is not None:
            _setter("iframe_definition", iframe_definition)
        if image_definition is not None:
            _setter("image_definition", image_definition)
        if list_stream_definition is not None:
            _setter("list_stream_definition", list_stream_definition)
        if log_stream_definition is not None:
            _setter("log_stream_definition", log_stream_definition)
        if manage_status_definition is not None:
            _setter("manage_status_definition", manage_status_definition)
        if note_definition is not None:
            _setter("note_definition", note_definition)
        if query_table_definition is not None:
            _setter("query_table_definition", query_table_definition)
        if query_value_definition is not None:
            _setter("query_value_definition", query_value_definition)
        if run_workflow_definition is not None:
            _setter("run_workflow_definition", run_workflow_definition)
        if scatterplot_definition is not None:
            _setter("scatterplot_definition", scatterplot_definition)
        if service_level_objective_definition is not None:
            _setter("service_level_objective_definition", service_level_objective_definition)
        if servicemap_definition is not None:
            _setter("servicemap_definition", servicemap_definition)
        if slo_list_definition is not None:
            _setter("slo_list_definition", slo_list_definition)
        if sunburst_definition is not None:
            _setter("sunburst_definition", sunburst_definition)
        if timeseries_definition is not None:
            _setter("timeseries_definition", timeseries_definition)
        if toplist_definition is not None:
            _setter("toplist_definition", toplist_definition)
        if topology_map_definition is not None:
            _setter("topology_map_definition", topology_map_definition)
        if trace_service_definition is not None:
            _setter("trace_service_definition", trace_service_definition)
        if treemap_definition is not None:
            _setter("treemap_definition", treemap_definition)
        if widget_layout is not None:
            _setter("widget_layout", widget_layout)

    @property
    @pulumi.getter(name="alertGraphDefinition")
    def alert_graph_definition(self) -> Optional['outputs.DashboardWidgetAlertGraphDefinition']:
        """
        The definition for a Alert Graph widget.
        """
        return pulumi.get(self, "alert_graph_definition")

    @property
    @pulumi.getter(name="alertValueDefinition")
    def alert_value_definition(self) -> Optional['outputs.DashboardWidgetAlertValueDefinition']:
        """
        The definition for a Alert Value widget.
        """
        return pulumi.get(self, "alert_value_definition")

    @property
    @pulumi.getter(name="changeDefinition")
    def change_definition(self) -> Optional['outputs.DashboardWidgetChangeDefinition']:
        """
        The definition for a Change widget.
        """
        return pulumi.get(self, "change_definition")

    @property
    @pulumi.getter(name="checkStatusDefinition")
    def check_status_definition(self) -> Optional['outputs.DashboardWidgetCheckStatusDefinition']:
        """
        The definition for a Check Status widget.
        """
        return pulumi.get(self, "check_status_definition")

    @property
    @pulumi.getter(name="distributionDefinition")
    def distribution_definition(self) -> Optional['outputs.DashboardWidgetDistributionDefinition']:
        """
        The definition for a Distribution widget.
        """
        return pulumi.get(self, "distribution_definition")

    @property
    @pulumi.getter(name="eventStreamDefinition")
    def event_stream_definition(self) -> Optional['outputs.DashboardWidgetEventStreamDefinition']:
        """
        The definition for a Event Stream widget.
        """
        return pulumi.get(self, "event_stream_definition")

    @property
    @pulumi.getter(name="eventTimelineDefinition")
    def event_timeline_definition(self) -> Optional['outputs.DashboardWidgetEventTimelineDefinition']:
        """
        The definition for a Event Timeline widget.
        """
        return pulumi.get(self, "event_timeline_definition")

    @property
    @pulumi.getter(name="freeTextDefinition")
    def free_text_definition(self) -> Optional['outputs.DashboardWidgetFreeTextDefinition']:
        """
        The definition for a Free Text widget.
        """
        return pulumi.get(self, "free_text_definition")

    @property
    @pulumi.getter(name="geomapDefinition")
    def geomap_definition(self) -> Optional['outputs.DashboardWidgetGeomapDefinition']:
        """
        The definition for a Geomap widget.
        """
        return pulumi.get(self, "geomap_definition")

    @property
    @pulumi.getter(name="groupDefinition")
    def group_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinition']:
        """
        The definition for a Group widget.
        """
        return pulumi.get(self, "group_definition")

    @property
    @pulumi.getter(name="heatmapDefinition")
    def heatmap_definition(self) -> Optional['outputs.DashboardWidgetHeatmapDefinition']:
        """
        The definition for a Heatmap widget.
        """
        return pulumi.get(self, "heatmap_definition")

    @property
    @pulumi.getter(name="hostmapDefinition")
    def hostmap_definition(self) -> Optional['outputs.DashboardWidgetHostmapDefinition']:
        """
        The definition for a Hostmap widget.
        """
        return pulumi.get(self, "hostmap_definition")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        The ID of the widget.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="iframeDefinition")
    def iframe_definition(self) -> Optional['outputs.DashboardWidgetIframeDefinition']:
        """
        The definition for an Iframe widget.
        """
        return pulumi.get(self, "iframe_definition")

    @property
    @pulumi.getter(name="imageDefinition")
    def image_definition(self) -> Optional['outputs.DashboardWidgetImageDefinition']:
        """
        The definition for an Image widget
        """
        return pulumi.get(self, "image_definition")

    @property
    @pulumi.getter(name="listStreamDefinition")
    def list_stream_definition(self) -> Optional['outputs.DashboardWidgetListStreamDefinition']:
        """
        The definition for a List Stream widget.
        """
        return pulumi.get(self, "list_stream_definition")

    @property
    @pulumi.getter(name="logStreamDefinition")
    def log_stream_definition(self) -> Optional['outputs.DashboardWidgetLogStreamDefinition']:
        """
        The definition for an Log Stream widget.
        """
        return pulumi.get(self, "log_stream_definition")

    @property
    @pulumi.getter(name="manageStatusDefinition")
    def manage_status_definition(self) -> Optional['outputs.DashboardWidgetManageStatusDefinition']:
        """
        The definition for an Manage Status widget.
        """
        return pulumi.get(self, "manage_status_definition")

    @property
    @pulumi.getter(name="noteDefinition")
    def note_definition(self) -> Optional['outputs.DashboardWidgetNoteDefinition']:
        """
        The definition for a Note widget.
        """
        return pulumi.get(self, "note_definition")

    @property
    @pulumi.getter(name="queryTableDefinition")
    def query_table_definition(self) -> Optional['outputs.DashboardWidgetQueryTableDefinition']:
        """
        The definition for a Query Table widget.
        """
        return pulumi.get(self, "query_table_definition")

    @property
    @pulumi.getter(name="queryValueDefinition")
    def query_value_definition(self) -> Optional['outputs.DashboardWidgetQueryValueDefinition']:
        """
        The definition for a Query Value widget.
        """
        return pulumi.get(self, "query_value_definition")

    @property
    @pulumi.getter(name="runWorkflowDefinition")
    def run_workflow_definition(self) -> Optional['outputs.DashboardWidgetRunWorkflowDefinition']:
        """
        The definition for a Run Workflow widget.
        """
        return pulumi.get(self, "run_workflow_definition")

    @property
    @pulumi.getter(name="scatterplotDefinition")
    def scatterplot_definition(self) -> Optional['outputs.DashboardWidgetScatterplotDefinition']:
        """
        The definition for a Scatterplot widget.
        """
        return pulumi.get(self, "scatterplot_definition")

    @property
    @pulumi.getter(name="serviceLevelObjectiveDefinition")
    def service_level_objective_definition(self) -> Optional['outputs.DashboardWidgetServiceLevelObjectiveDefinition']:
        """
        The definition for a Service Level Objective widget.
        """
        return pulumi.get(self, "service_level_objective_definition")

    @property
    @pulumi.getter(name="servicemapDefinition")
    def servicemap_definition(self) -> Optional['outputs.DashboardWidgetServicemapDefinition']:
        """
        The definition for a Service Map widget.
        """
        return pulumi.get(self, "servicemap_definition")

    @property
    @pulumi.getter(name="sloListDefinition")
    def slo_list_definition(self) -> Optional['outputs.DashboardWidgetSloListDefinition']:
        """
        The definition for an SLO (Service Level Objective) List widget.
        """
        return pulumi.get(self, "slo_list_definition")

    @property
    @pulumi.getter(name="sunburstDefinition")
    def sunburst_definition(self) -> Optional['outputs.DashboardWidgetSunburstDefinition']:
        """
        The definition for a Sunburst widget.
        """
        return pulumi.get(self, "sunburst_definition")

    @property
    @pulumi.getter(name="timeseriesDefinition")
    def timeseries_definition(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinition']:
        """
        The definition for a Timeseries widget.
        """
        return pulumi.get(self, "timeseries_definition")

    @property
    @pulumi.getter(name="toplistDefinition")
    def toplist_definition(self) -> Optional['outputs.DashboardWidgetToplistDefinition']:
        """
        The definition for a Toplist widget.
        """
        return pulumi.get(self, "toplist_definition")

    @property
    @pulumi.getter(name="topologyMapDefinition")
    def topology_map_definition(self) -> Optional['outputs.DashboardWidgetTopologyMapDefinition']:
        """
        The definition for a Topology Map widget.
        """
        return pulumi.get(self, "topology_map_definition")

    @property
    @pulumi.getter(name="traceServiceDefinition")
    def trace_service_definition(self) -> Optional['outputs.DashboardWidgetTraceServiceDefinition']:
        """
        The definition for a Trace Service widget.
        """
        return pulumi.get(self, "trace_service_definition")

    @property
    @pulumi.getter(name="treemapDefinition")
    def treemap_definition(self) -> Optional['outputs.DashboardWidgetTreemapDefinition']:
        """
        The definition for a Treemap widget.
        """
        return pulumi.get(self, "treemap_definition")

    @property
    @pulumi.getter(name="widgetLayout")
    def widget_layout(self) -> Optional['outputs.DashboardWidgetWidgetLayout']:
        """
        The layout of the widget on a 'free' dashboard.
        """
        return pulumi.get(self, "widget_layout")


@pulumi.output_type
class DashboardWidgetAlertGraphDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertId":
            suggest = "alert_id"
        elif key == "vizType":
            suggest = "viz_type"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetAlertGraphDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetAlertGraphDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetAlertGraphDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_id: str,
                 viz_type: str,
                 live_span: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str alert_id: The ID of the monitor used by the widget.
        :param str viz_type: Type of visualization to use when displaying the widget. Valid values are `timeseries`, `toplist`.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetAlertGraphDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_id=alert_id,
            viz_type=viz_type,
            live_span=live_span,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_id: str,
             viz_type: str,
             live_span: Optional[str] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("alert_id", alert_id)
        _setter("viz_type", viz_type)
        if live_span is not None:
            _setter("live_span", live_span)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        """
        The ID of the monitor used by the widget.
        """
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter(name="vizType")
    def viz_type(self) -> str:
        """
        Type of visualization to use when displaying the widget. Valid values are `timeseries`, `toplist`.
        """
        return pulumi.get(self, "viz_type")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetAlertValueDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertId":
            suggest = "alert_id"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetAlertValueDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetAlertValueDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetAlertValueDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_id: str,
                 precision: Optional[int] = None,
                 text_align: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 unit: Optional[str] = None):
        """
        :param str alert_id: The ID of the monitor used by the widget.
        :param int precision: The precision to use when displaying the value. Use `*` for maximum precision.
        :param str text_align: The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param str unit: The unit for the value displayed in the widget.
        """
        DashboardWidgetAlertValueDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_id=alert_id,
            precision=precision,
            text_align=text_align,
            title=title,
            title_align=title_align,
            title_size=title_size,
            unit=unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_id: str,
             precision: Optional[int] = None,
             text_align: Optional[str] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("alert_id", alert_id)
        if precision is not None:
            _setter("precision", precision)
        if text_align is not None:
            _setter("text_align", text_align)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)
        if unit is not None:
            _setter("unit", unit)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        """
        The ID of the monitor used by the widget.
        """
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter
    def precision(self) -> Optional[int]:
        """
        The precision to use when displaying the value. Use `*` for maximum precision.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class DashboardWidgetChangeDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetChangeDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence['DashboardWidgetChangeDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetChangeDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_links=custom_links,
            live_span=live_span,
            requests=requests,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_links: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionCustomLink']] = None,
             live_span: Optional[str] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequest']] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if live_span is not None:
            _setter("live_span", live_span)
        if requests is not None:
            _setter("requests", requests)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetChangeDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetChangeDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "changeType":
            suggest = "change_type"
        elif key == "compareTo":
            suggest = "compare_to"
        elif key == "increaseGood":
            suggest = "increase_good"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "orderBy":
            suggest = "order_by"
        elif key == "orderDir":
            suggest = "order_dir"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"
        elif key == "showPresent":
            suggest = "show_present"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQuery'] = None,
                 change_type: Optional[str] = None,
                 compare_to: Optional[str] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestFormula']] = None,
                 increase_good: Optional[bool] = None,
                 log_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQuery'] = None,
                 order_by: Optional[str] = None,
                 order_dir: Optional[str] = None,
                 process_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQuery'] = None,
                 show_present: Optional[bool] = None):
        """
        :param 'DashboardWidgetChangeDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param str change_type: Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
        :param str compare_to: Choose from when to compare current data to. Valid values are `hour_before`, `day_before`, `week_before`, `month_before`.
        :param bool increase_good: A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
        :param 'DashboardWidgetChangeDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param str order_by: What to order by. Valid values are `change`, `name`, `present`, `past`.
        :param str order_dir: Widget sorting method. Valid values are `asc`, `desc`.
        :param 'DashboardWidgetChangeDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetChangeDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetChangeDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param bool show_present: If set to `true`, displays the current value.
        """
        DashboardWidgetChangeDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_query=apm_query,
            change_type=change_type,
            compare_to=compare_to,
            formulas=formulas,
            increase_good=increase_good,
            log_query=log_query,
            order_by=order_by,
            order_dir=order_dir,
            process_query=process_query,
            q=q,
            queries=queries,
            rum_query=rum_query,
            security_query=security_query,
            show_present=show_present,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQuery'] = None,
             change_type: Optional[str] = None,
             compare_to: Optional[str] = None,
             formulas: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestFormula']] = None,
             increase_good: Optional[bool] = None,
             log_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQuery'] = None,
             order_by: Optional[str] = None,
             order_dir: Optional[str] = None,
             process_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestProcessQuery'] = None,
             q: Optional[str] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestQuery']] = None,
             rum_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQuery'] = None,
             show_present: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if change_type is not None:
            _setter("change_type", change_type)
        if compare_to is not None:
            _setter("compare_to", compare_to)
        if formulas is not None:
            _setter("formulas", formulas)
        if increase_good is not None:
            _setter("increase_good", increase_good)
        if log_query is not None:
            _setter("log_query", log_query)
        if order_by is not None:
            _setter("order_by", order_by)
        if order_dir is not None:
            _setter("order_dir", order_dir)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if queries is not None:
            _setter("queries", queries)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)
        if show_present is not None:
            _setter("show_present", show_present)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[str]:
        """
        Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
        """
        return pulumi.get(self, "change_type")

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[str]:
        """
        Choose from when to compare current data to. Valid values are `hour_before`, `day_before`, `week_before`, `month_before`.
        """
        return pulumi.get(self, "compare_to")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[bool]:
        """
        A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
        """
        return pulumi.get(self, "increase_good")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[str]:
        """
        What to order by. Valid values are `change`, `name`, `present`, `past`.
        """
        return pulumi.get(self, "order_by")

    @property
    @pulumi.getter(name="orderDir")
    def order_dir(self) -> Optional[str]:
        """
        Widget sorting method. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order_dir")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter(name="showPresent")
    def show_present(self) -> Optional[bool]:
        """
        If set to `true`, displays the current value.
        """
        return pulumi.get(self, "show_present")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetChangeDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetChangeDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetChangeDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetChangeDefinitionRequestApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetChangeDefinitionRequestApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetChangeDefinitionRequestApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetChangeDefinitionRequestApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetChangeDefinitionRequestApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetChangeDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetChangeDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetChangeDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetChangeDefinitionRequestFormulaLimitArgs' limit: The maximum number of items in the group.
        :param 'DashboardWidgetChangeDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetChangeDefinitionRequestFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formula_expression=formula_expression,
            alias=alias,
            cell_display_mode=cell_display_mode,
            conditional_formats=conditional_formats,
            limit=limit,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formula_expression: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat']] = None,
             limit: Optional['outputs.DashboardWidgetChangeDefinitionRequestFormulaLimit'] = None,
             style: Optional['outputs.DashboardWidgetChangeDefinitionRequestFormulaStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if limit is not None:
            _setter("limit", limit)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestFormulaLimit']:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetChangeDefinitionRequestFormulaLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        DashboardWidgetChangeDefinitionRequestFormulaStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_index=palette_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             palette_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)
        if palette_index is not None:
            _setter("palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetChangeDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetChangeDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetChangeDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetChangeDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetChangeDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetChangeDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetChangeDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetChangeDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetChangeDefinitionRequestProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetChangeDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetChangeDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetChangeDefinitionRequestQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetChangeDefinitionRequestQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetChangeDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetChangeDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetChangeDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetChangeDefinitionRequestQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetChangeDefinitionRequestQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetChangeDefinitionRequestQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetChangeDefinitionRequestQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetChangeDefinitionRequestQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetChangeDefinitionRequestQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetChangeDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetChangeDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetChangeDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetChangeDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetChangeDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetChangeDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetChangeDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetChangeDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetChangeDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetChangeDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetChangeDefinitionRequestSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetChangeDefinitionRequestSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetChangeDefinitionRequestSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetCheckStatusDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBies":
            suggest = "group_bies"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetCheckStatusDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetCheckStatusDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetCheckStatusDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check: str,
                 grouping: str,
                 group: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 live_span: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str check: The check to use in the widget.
        :param str grouping: The kind of grouping to use. Valid values are `check`, `cluster`.
        :param str group: The check group to use in the widget.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence[str] tags: A list of tags to use in the widget.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetCheckStatusDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            check=check,
            grouping=grouping,
            group=group,
            group_bies=group_bies,
            live_span=live_span,
            tags=tags,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             check: str,
             grouping: str,
             group: Optional[str] = None,
             group_bies: Optional[Sequence[str]] = None,
             live_span: Optional[str] = None,
             tags: Optional[Sequence[str]] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("check", check)
        _setter("grouping", grouping)
        if group is not None:
            _setter("group", group)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if live_span is not None:
            _setter("live_span", live_span)
        if tags is not None:
            _setter("tags", tags)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def check(self) -> str:
        """
        The check to use in the widget.
        """
        return pulumi.get(self, "check")

    @property
    @pulumi.getter
    def grouping(self) -> str:
        """
        The kind of grouping to use. Valid values are `check`, `cluster`.
        """
        return pulumi.get(self, "grouping")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        A list of tags to use in the widget.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetDistributionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str legend_size: The size of the legend displayed in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence['DashboardWidgetDistributionDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param bool show_legend: Whether or not to show the legend on this widget.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetDistributionDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            legend_size=legend_size,
            live_span=live_span,
            requests=requests,
            show_legend=show_legend,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             legend_size: Optional[str] = None,
             live_span: Optional[str] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequest']] = None,
             show_legend: Optional[bool] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if legend_size is not None:
            _setter("legend_size", legend_size)
        if live_span is not None:
            _setter("live_span", live_span)
        if requests is not None:
            _setter("requests", requests)
        if show_legend is not None:
            _setter("show_legend", show_legend)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "apmStatsQuery":
            suggest = "apm_stats_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQuery'] = None,
                 apm_stats_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmStatsQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetDistributionDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetDistributionDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetDistributionDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetDistributionDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetDistributionDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetDistributionDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'DashboardWidgetDistributionDefinitionRequestStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetDistributionDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_query=apm_query,
            apm_stats_query=apm_stats_query,
            log_query=log_query,
            process_query=process_query,
            q=q,
            rum_query=rum_query,
            security_query=security_query,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQuery'] = None,
             apm_stats_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmStatsQuery'] = None,
             log_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestProcessQuery'] = None,
             q: Optional[str] = None,
             rum_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQuery'] = None,
             style: Optional['outputs.DashboardWidgetDistributionDefinitionRequestStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if apm_stats_query is not None:
            _setter("apm_stats_query", apm_stats_query)
        if log_query is not None:
            _setter("log_query", log_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="apmStatsQuery")
    def apm_stats_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmStatsQuery']:
        return pulumi.get(self, "apm_stats_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetDistributionDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetDistributionDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetDistributionDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetDistributionDefinitionRequestApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetDistributionDefinitionRequestApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetDistributionDefinitionRequestApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetDistributionDefinitionRequestApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryTag":
            suggest = "primary_tag"
        elif key == "rowType":
            suggest = "row_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestApmStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env: str,
                 name: str,
                 primary_tag: str,
                 row_type: str,
                 service: str,
                 columns: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn']] = None,
                 resource: Optional[str] = None):
        """
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str primary_tag: The organization's host group name and value.
        :param str row_type: The level of detail for the request. Valid values are `service`, `resource`, `span`.
        :param str service: APM service.
        :param Sequence['DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumnArgs'] columns: Column properties used by the front end for display.
        :param str resource: The resource name.
        """
        DashboardWidgetDistributionDefinitionRequestApmStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            env=env,
            name=name,
            primary_tag=primary_tag,
            row_type=row_type,
            service=service,
            columns=columns,
            resource=resource,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             env: str,
             name: str,
             primary_tag: str,
             row_type: str,
             service: str,
             columns: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn']] = None,
             resource: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("env", env)
        _setter("name", name)
        _setter("primary_tag", primary_tag)
        _setter("row_type", row_type)
        _setter("service", service)
        if columns is not None:
            _setter("columns", columns)
        if resource is not None:
            _setter("resource", resource)

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryTag")
    def primary_tag(self) -> str:
        """
        The organization's host group name and value.
        """
        return pulumi.get(self, "primary_tag")

    @property
    @pulumi.getter(name="rowType")
    def row_type(self) -> str:
        """
        The level of detail for the request. Valid values are `service`, `resource`, `span`.
        """
        return pulumi.get(self, "row_type")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn']]:
        """
        Column properties used by the front end for display.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        The resource name.
        """
        return pulumi.get(self, "resource")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellDisplayMode":
            suggest = "cell_display_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            alias=alias,
            cell_display_mode=cell_display_mode,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetDistributionDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetDistributionDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetDistributionDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetDistributionDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetDistributionDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetDistributionDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetDistributionDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetDistributionDefinitionRequestProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetDistributionDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetDistributionDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetDistributionDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetDistributionDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetDistributionDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetDistributionDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetDistributionDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetDistributionDefinitionRequestSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetDistributionDefinitionRequestSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetDistributionDefinitionRequestSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        DashboardWidgetDistributionDefinitionRequestStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetEventStreamDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventSize":
            suggest = "event_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "tagsExecution":
            suggest = "tags_execution"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetEventStreamDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetEventStreamDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetEventStreamDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 event_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 tags_execution: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str event_size: The size to use to display an event. Valid values are `s`, `l`.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param str tags_execution: The execution method for multi-value filters, options: `and` or `or`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetEventStreamDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
            event_size=event_size,
            live_span=live_span,
            tags_execution=tags_execution,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             event_size: Optional[str] = None,
             live_span: Optional[str] = None,
             tags_execution: Optional[str] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)
        if event_size is not None:
            _setter("event_size", event_size)
        if live_span is not None:
            _setter("live_span", live_span)
        if tags_execution is not None:
            _setter("tags_execution", tags_execution)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[str]:
        """
        The size to use to display an event. Valid values are `s`, `l`.
        """
        return pulumi.get(self, "event_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        """
        The execution method for multi-value filters, options: `and` or `or`.
        """
        return pulumi.get(self, "tags_execution")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetEventTimelineDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"
        elif key == "tagsExecution":
            suggest = "tags_execution"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetEventTimelineDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetEventTimelineDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetEventTimelineDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 live_span: Optional[str] = None,
                 tags_execution: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param str tags_execution: The execution method for multi-value filters, options: `and` or `or`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetEventTimelineDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
            live_span=live_span,
            tags_execution=tags_execution,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             live_span: Optional[str] = None,
             tags_execution: Optional[str] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)
        if live_span is not None:
            _setter("live_span", live_span)
        if tags_execution is not None:
            _setter("tags_execution", tags_execution)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        """
        The execution method for multi-value filters, options: `and` or `or`.
        """
        return pulumi.get(self, "tags_execution")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetFreeTextDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontSize":
            suggest = "font_size"
        elif key == "textAlign":
            suggest = "text_align"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetFreeTextDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetFreeTextDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetFreeTextDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text: str,
                 color: Optional[str] = None,
                 font_size: Optional[str] = None,
                 text_align: Optional[str] = None):
        """
        :param str text: The text to display in the widget.
        :param str color: The color of the text in the widget.
        :param str font_size: The size of the text in the widget.
        :param str text_align: The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        DashboardWidgetFreeTextDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text=text,
            color=color,
            font_size=font_size,
            text_align=text_align,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text: str,
             color: Optional[str] = None,
             font_size: Optional[str] = None,
             text_align: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("text", text)
        if color is not None:
            _setter("color", color)
        if font_size is not None:
            _setter("font_size", font_size)
        if text_align is not None:
            _setter("text_align", text_align)

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The text to display in the widget.
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        The color of the text in the widget.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")


@pulumi.output_type
class DashboardWidgetGeomapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 view: 'outputs.DashboardWidgetGeomapDefinitionView',
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequest']] = None,
                 style: Optional['outputs.DashboardWidgetGeomapDefinitionStyle'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param 'DashboardWidgetGeomapDefinitionViewArgs' view: The view of the world that the map should render.
        :param Sequence['DashboardWidgetGeomapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence['DashboardWidgetGeomapDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param 'DashboardWidgetGeomapDefinitionStyleArgs' style: Styling options for widget formulas.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGeomapDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            view=view,
            custom_links=custom_links,
            live_span=live_span,
            requests=requests,
            style=style,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             view: 'outputs.DashboardWidgetGeomapDefinitionView',
             custom_links: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionCustomLink']] = None,
             live_span: Optional[str] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequest']] = None,
             style: Optional['outputs.DashboardWidgetGeomapDefinitionStyle'] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("view", view)
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if live_span is not None:
            _setter("live_span", live_span)
        if requests is not None:
            _setter("requests", requests)
        if style is not None:
            _setter("style", style)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def view(self) -> 'outputs.DashboardWidgetGeomapDefinitionView':
        """
        The view of the world that the map should render.
        """
        return pulumi.get(self, "view")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetGeomapDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logQuery":
            suggest = "log_query"
        elif key == "rumQuery":
            suggest = "rum_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formulas: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQuery'] = None):
        """
        :param 'DashboardWidgetGeomapDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetGeomapDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        """
        DashboardWidgetGeomapDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formulas=formulas,
            log_query=log_query,
            q=q,
            queries=queries,
            rum_query=rum_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formulas: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestFormula']] = None,
             log_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQuery'] = None,
             q: Optional[str] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQuery']] = None,
             rum_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if formulas is not None:
            _setter("formulas", formulas)
        if log_query is not None:
            _setter("log_query", log_query)
        if q is not None:
            _setter("q", q)
        if queries is not None:
            _setter("queries", queries)
        if rum_query is not None:
            _setter("rum_query", rum_query)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetGeomapDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetGeomapDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetGeomapDefinitionRequestFormulaLimitArgs' limit: The maximum number of items in the group.
        :param 'DashboardWidgetGeomapDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetGeomapDefinitionRequestFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formula_expression=formula_expression,
            alias=alias,
            cell_display_mode=cell_display_mode,
            conditional_formats=conditional_formats,
            limit=limit,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formula_expression: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat']] = None,
             limit: Optional['outputs.DashboardWidgetGeomapDefinitionRequestFormulaLimit'] = None,
             style: Optional['outputs.DashboardWidgetGeomapDefinitionRequestFormulaStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if limit is not None:
            _setter("limit", limit)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestFormulaLimit']:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGeomapDefinitionRequestFormulaLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        DashboardWidgetGeomapDefinitionRequestFormulaStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_index=palette_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             palette_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)
        if palette_index is not None:
            _setter("palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGeomapDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGeomapDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGeomapDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGeomapDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGeomapDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGeomapDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGeomapDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetGeomapDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetGeomapDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetGeomapDefinitionRequestQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetGeomapDefinitionRequestQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetGeomapDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGeomapDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetGeomapDefinitionRequestQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetGeomapDefinitionRequestQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetGeomapDefinitionRequestQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetGeomapDefinitionRequestQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGeomapDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGeomapDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGeomapDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGeomapDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGeomapDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGeomapDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGeomapDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteFlip":
            suggest = "palette_flip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: str,
                 palette_flip: bool):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param bool palette_flip: A Boolean indicating whether to flip the palette tones.
        """
        DashboardWidgetGeomapDefinitionStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_flip=palette_flip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: str,
             palette_flip: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("palette", palette)
        _setter("palette_flip", palette_flip)

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> bool:
        """
        A Boolean indicating whether to flip the palette tones.
        """
        return pulumi.get(self, "palette_flip")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionView(dict):
    def __init__(__self__, *,
                 focus: str):
        """
        :param str focus: The two-letter ISO code of a country to focus the map on (or `WORLD`).
        """
        DashboardWidgetGeomapDefinitionView._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            focus=focus,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             focus: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("focus", focus)

    @property
    @pulumi.getter
    def focus(self) -> str:
        """
        The two-letter ISO code of a country to focus the map on (or `WORLD`).
        """
        return pulumi.get(self, "focus")


@pulumi.output_type
class DashboardWidgetGroupDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layoutType":
            suggest = "layout_type"
        elif key == "backgroundColor":
            suggest = "background_color"
        elif key == "bannerImg":
            suggest = "banner_img"
        elif key == "showTitle":
            suggest = "show_title"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layout_type: str,
                 background_color: Optional[str] = None,
                 banner_img: Optional[str] = None,
                 show_title: Optional[bool] = None,
                 title: Optional[str] = None,
                 widgets: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidget']] = None):
        """
        :param str layout_type: The layout type of the group. Valid values are `ordered`.
        :param str background_color: The background color of the group title, options: `vivid_blue`, `vivid_purple`, `vivid_pink`, `vivid_orange`, `vivid_yellow`, `vivid_green`, `blue`, `purple`, `pink`, `orange`, `yellow`, `green`, `gray` or `white`
        :param str banner_img: The image URL to display as a banner for the group.
        :param bool show_title: Whether to show the title or not.
        :param str title: The title of the widget.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetArgs'] widgets: The list of widgets in this group.
        """
        DashboardWidgetGroupDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            layout_type=layout_type,
            background_color=background_color,
            banner_img=banner_img,
            show_title=show_title,
            title=title,
            widgets=widgets,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             layout_type: str,
             background_color: Optional[str] = None,
             banner_img: Optional[str] = None,
             show_title: Optional[bool] = None,
             title: Optional[str] = None,
             widgets: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidget']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("layout_type", layout_type)
        if background_color is not None:
            _setter("background_color", background_color)
        if banner_img is not None:
            _setter("banner_img", banner_img)
        if show_title is not None:
            _setter("show_title", show_title)
        if title is not None:
            _setter("title", title)
        if widgets is not None:
            _setter("widgets", widgets)

    @property
    @pulumi.getter(name="layoutType")
    def layout_type(self) -> str:
        """
        The layout type of the group. Valid values are `ordered`.
        """
        return pulumi.get(self, "layout_type")

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        """
        The background color of the group title, options: `vivid_blue`, `vivid_purple`, `vivid_pink`, `vivid_orange`, `vivid_yellow`, `vivid_green`, `blue`, `purple`, `pink`, `orange`, `yellow`, `green`, `gray` or `white`
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="bannerImg")
    def banner_img(self) -> Optional[str]:
        """
        The image URL to display as a banner for the group.
        """
        return pulumi.get(self, "banner_img")

    @property
    @pulumi.getter(name="showTitle")
    def show_title(self) -> Optional[bool]:
        """
        Whether to show the title or not.
        """
        return pulumi.get(self, "show_title")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def widgets(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidget']]:
        """
        The list of widgets in this group.
        """
        return pulumi.get(self, "widgets")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertGraphDefinition":
            suggest = "alert_graph_definition"
        elif key == "alertValueDefinition":
            suggest = "alert_value_definition"
        elif key == "changeDefinition":
            suggest = "change_definition"
        elif key == "checkStatusDefinition":
            suggest = "check_status_definition"
        elif key == "distributionDefinition":
            suggest = "distribution_definition"
        elif key == "eventStreamDefinition":
            suggest = "event_stream_definition"
        elif key == "eventTimelineDefinition":
            suggest = "event_timeline_definition"
        elif key == "freeTextDefinition":
            suggest = "free_text_definition"
        elif key == "geomapDefinition":
            suggest = "geomap_definition"
        elif key == "heatmapDefinition":
            suggest = "heatmap_definition"
        elif key == "hostmapDefinition":
            suggest = "hostmap_definition"
        elif key == "iframeDefinition":
            suggest = "iframe_definition"
        elif key == "imageDefinition":
            suggest = "image_definition"
        elif key == "listStreamDefinition":
            suggest = "list_stream_definition"
        elif key == "logStreamDefinition":
            suggest = "log_stream_definition"
        elif key == "manageStatusDefinition":
            suggest = "manage_status_definition"
        elif key == "noteDefinition":
            suggest = "note_definition"
        elif key == "queryTableDefinition":
            suggest = "query_table_definition"
        elif key == "queryValueDefinition":
            suggest = "query_value_definition"
        elif key == "runWorkflowDefinition":
            suggest = "run_workflow_definition"
        elif key == "scatterplotDefinition":
            suggest = "scatterplot_definition"
        elif key == "serviceLevelObjectiveDefinition":
            suggest = "service_level_objective_definition"
        elif key == "servicemapDefinition":
            suggest = "servicemap_definition"
        elif key == "sloListDefinition":
            suggest = "slo_list_definition"
        elif key == "sunburstDefinition":
            suggest = "sunburst_definition"
        elif key == "timeseriesDefinition":
            suggest = "timeseries_definition"
        elif key == "toplistDefinition":
            suggest = "toplist_definition"
        elif key == "topologyMapDefinition":
            suggest = "topology_map_definition"
        elif key == "traceServiceDefinition":
            suggest = "trace_service_definition"
        elif key == "treemapDefinition":
            suggest = "treemap_definition"
        elif key == "widgetLayout":
            suggest = "widget_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_graph_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition'] = None,
                 alert_value_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertValueDefinition'] = None,
                 change_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinition'] = None,
                 check_status_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition'] = None,
                 distribution_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinition'] = None,
                 event_stream_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventStreamDefinition'] = None,
                 event_timeline_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition'] = None,
                 free_text_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetFreeTextDefinition'] = None,
                 geomap_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinition'] = None,
                 heatmap_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinition'] = None,
                 hostmap_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinition'] = None,
                 id: Optional[int] = None,
                 iframe_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetIframeDefinition'] = None,
                 image_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetImageDefinition'] = None,
                 list_stream_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinition'] = None,
                 log_stream_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinition'] = None,
                 manage_status_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetManageStatusDefinition'] = None,
                 note_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetNoteDefinition'] = None,
                 query_table_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinition'] = None,
                 query_value_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinition'] = None,
                 run_workflow_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinition'] = None,
                 scatterplot_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinition'] = None,
                 service_level_objective_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition'] = None,
                 servicemap_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetServicemapDefinition'] = None,
                 slo_list_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSloListDefinition'] = None,
                 sunburst_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinition'] = None,
                 timeseries_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition'] = None,
                 toplist_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinition'] = None,
                 topology_map_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTopologyMapDefinition'] = None,
                 trace_service_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition'] = None,
                 treemap_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinition'] = None,
                 widget_layout: Optional['outputs.DashboardWidgetGroupDefinitionWidgetWidgetLayout'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetAlertGraphDefinitionArgs' alert_graph_definition: The definition for a Alert Graph widget.
        :param 'DashboardWidgetGroupDefinitionWidgetAlertValueDefinitionArgs' alert_value_definition: The definition for a Alert Value widget.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionArgs' change_definition: The definition for a Change widget.
        :param 'DashboardWidgetGroupDefinitionWidgetCheckStatusDefinitionArgs' check_status_definition: The definition for a Check Status widget.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionArgs' distribution_definition: The definition for a Distribution widget.
        :param 'DashboardWidgetGroupDefinitionWidgetEventStreamDefinitionArgs' event_stream_definition: The definition for a Event Stream widget.
        :param 'DashboardWidgetGroupDefinitionWidgetEventTimelineDefinitionArgs' event_timeline_definition: The definition for a Event Timeline widget.
        :param 'DashboardWidgetGroupDefinitionWidgetFreeTextDefinitionArgs' free_text_definition: The definition for a Free Text widget.
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionArgs' geomap_definition: The definition for a Geomap widget.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionArgs' heatmap_definition: The definition for a Heatmap widget.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionArgs' hostmap_definition: The definition for a Hostmap widget.
        :param int id: The ID of the widget.
        :param 'DashboardWidgetGroupDefinitionWidgetIframeDefinitionArgs' iframe_definition: The definition for an Iframe widget.
        :param 'DashboardWidgetGroupDefinitionWidgetImageDefinitionArgs' image_definition: The definition for an Image widget
        :param 'DashboardWidgetGroupDefinitionWidgetListStreamDefinitionArgs' list_stream_definition: The definition for a List Stream widget.
        :param 'DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionArgs' log_stream_definition: The definition for an Log Stream widget.
        :param 'DashboardWidgetGroupDefinitionWidgetManageStatusDefinitionArgs' manage_status_definition: The definition for an Manage Status widget.
        :param 'DashboardWidgetGroupDefinitionWidgetNoteDefinitionArgs' note_definition: The definition for a Note widget.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionArgs' query_table_definition: The definition for a Query Table widget.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionArgs' query_value_definition: The definition for a Query Value widget.
        :param 'DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionArgs' run_workflow_definition: The definition for a Run Workflow widget.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionArgs' scatterplot_definition: The definition for a Scatterplot widget.
        :param 'DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinitionArgs' service_level_objective_definition: The definition for a Service Level Objective widget.
        :param 'DashboardWidgetGroupDefinitionWidgetServicemapDefinitionArgs' servicemap_definition: The definition for a Service Map widget.
        :param 'DashboardWidgetGroupDefinitionWidgetSloListDefinitionArgs' slo_list_definition: The definition for an SLO (Service Level Objective) List widget.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionArgs' sunburst_definition: The definition for a Sunburst widget.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionArgs' timeseries_definition: The definition for a Timeseries widget.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionArgs' toplist_definition: The definition for a Toplist widget.
        :param 'DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionArgs' topology_map_definition: The definition for a Topology Map widget.
        :param 'DashboardWidgetGroupDefinitionWidgetTraceServiceDefinitionArgs' trace_service_definition: The definition for a Trace Service widget.
        :param 'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionArgs' treemap_definition: The definition for a Treemap widget.
        :param 'DashboardWidgetGroupDefinitionWidgetWidgetLayoutArgs' widget_layout: The layout of the widget on a 'free' dashboard.
        """
        DashboardWidgetGroupDefinitionWidget._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_graph_definition=alert_graph_definition,
            alert_value_definition=alert_value_definition,
            change_definition=change_definition,
            check_status_definition=check_status_definition,
            distribution_definition=distribution_definition,
            event_stream_definition=event_stream_definition,
            event_timeline_definition=event_timeline_definition,
            free_text_definition=free_text_definition,
            geomap_definition=geomap_definition,
            heatmap_definition=heatmap_definition,
            hostmap_definition=hostmap_definition,
            id=id,
            iframe_definition=iframe_definition,
            image_definition=image_definition,
            list_stream_definition=list_stream_definition,
            log_stream_definition=log_stream_definition,
            manage_status_definition=manage_status_definition,
            note_definition=note_definition,
            query_table_definition=query_table_definition,
            query_value_definition=query_value_definition,
            run_workflow_definition=run_workflow_definition,
            scatterplot_definition=scatterplot_definition,
            service_level_objective_definition=service_level_objective_definition,
            servicemap_definition=servicemap_definition,
            slo_list_definition=slo_list_definition,
            sunburst_definition=sunburst_definition,
            timeseries_definition=timeseries_definition,
            toplist_definition=toplist_definition,
            topology_map_definition=topology_map_definition,
            trace_service_definition=trace_service_definition,
            treemap_definition=treemap_definition,
            widget_layout=widget_layout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_graph_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition'] = None,
             alert_value_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertValueDefinition'] = None,
             change_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinition'] = None,
             check_status_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition'] = None,
             distribution_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinition'] = None,
             event_stream_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventStreamDefinition'] = None,
             event_timeline_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition'] = None,
             free_text_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetFreeTextDefinition'] = None,
             geomap_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinition'] = None,
             heatmap_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinition'] = None,
             hostmap_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinition'] = None,
             id: Optional[int] = None,
             iframe_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetIframeDefinition'] = None,
             image_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetImageDefinition'] = None,
             list_stream_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinition'] = None,
             log_stream_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinition'] = None,
             manage_status_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetManageStatusDefinition'] = None,
             note_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetNoteDefinition'] = None,
             query_table_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinition'] = None,
             query_value_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinition'] = None,
             run_workflow_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinition'] = None,
             scatterplot_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinition'] = None,
             service_level_objective_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition'] = None,
             servicemap_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetServicemapDefinition'] = None,
             slo_list_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSloListDefinition'] = None,
             sunburst_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinition'] = None,
             timeseries_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition'] = None,
             toplist_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinition'] = None,
             topology_map_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTopologyMapDefinition'] = None,
             trace_service_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition'] = None,
             treemap_definition: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinition'] = None,
             widget_layout: Optional['outputs.DashboardWidgetGroupDefinitionWidgetWidgetLayout'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if alert_graph_definition is not None:
            _setter("alert_graph_definition", alert_graph_definition)
        if alert_value_definition is not None:
            _setter("alert_value_definition", alert_value_definition)
        if change_definition is not None:
            _setter("change_definition", change_definition)
        if check_status_definition is not None:
            _setter("check_status_definition", check_status_definition)
        if distribution_definition is not None:
            _setter("distribution_definition", distribution_definition)
        if event_stream_definition is not None:
            _setter("event_stream_definition", event_stream_definition)
        if event_timeline_definition is not None:
            _setter("event_timeline_definition", event_timeline_definition)
        if free_text_definition is not None:
            _setter("free_text_definition", free_text_definition)
        if geomap_definition is not None:
            _setter("geomap_definition", geomap_definition)
        if heatmap_definition is not None:
            _setter("heatmap_definition", heatmap_definition)
        if hostmap_definition is not None:
            _setter("hostmap_definition", hostmap_definition)
        if id is not None:
            _setter("id", id)
        if iframe_definition is not None:
            _setter("iframe_definition", iframe_definition)
        if image_definition is not None:
            _setter("image_definition", image_definition)
        if list_stream_definition is not None:
            _setter("list_stream_definition", list_stream_definition)
        if log_stream_definition is not None:
            _setter("log_stream_definition", log_stream_definition)
        if manage_status_definition is not None:
            _setter("manage_status_definition", manage_status_definition)
        if note_definition is not None:
            _setter("note_definition", note_definition)
        if query_table_definition is not None:
            _setter("query_table_definition", query_table_definition)
        if query_value_definition is not None:
            _setter("query_value_definition", query_value_definition)
        if run_workflow_definition is not None:
            _setter("run_workflow_definition", run_workflow_definition)
        if scatterplot_definition is not None:
            _setter("scatterplot_definition", scatterplot_definition)
        if service_level_objective_definition is not None:
            _setter("service_level_objective_definition", service_level_objective_definition)
        if servicemap_definition is not None:
            _setter("servicemap_definition", servicemap_definition)
        if slo_list_definition is not None:
            _setter("slo_list_definition", slo_list_definition)
        if sunburst_definition is not None:
            _setter("sunburst_definition", sunburst_definition)
        if timeseries_definition is not None:
            _setter("timeseries_definition", timeseries_definition)
        if toplist_definition is not None:
            _setter("toplist_definition", toplist_definition)
        if topology_map_definition is not None:
            _setter("topology_map_definition", topology_map_definition)
        if trace_service_definition is not None:
            _setter("trace_service_definition", trace_service_definition)
        if treemap_definition is not None:
            _setter("treemap_definition", treemap_definition)
        if widget_layout is not None:
            _setter("widget_layout", widget_layout)

    @property
    @pulumi.getter(name="alertGraphDefinition")
    def alert_graph_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition']:
        """
        The definition for a Alert Graph widget.
        """
        return pulumi.get(self, "alert_graph_definition")

    @property
    @pulumi.getter(name="alertValueDefinition")
    def alert_value_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetAlertValueDefinition']:
        """
        The definition for a Alert Value widget.
        """
        return pulumi.get(self, "alert_value_definition")

    @property
    @pulumi.getter(name="changeDefinition")
    def change_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinition']:
        """
        The definition for a Change widget.
        """
        return pulumi.get(self, "change_definition")

    @property
    @pulumi.getter(name="checkStatusDefinition")
    def check_status_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition']:
        """
        The definition for a Check Status widget.
        """
        return pulumi.get(self, "check_status_definition")

    @property
    @pulumi.getter(name="distributionDefinition")
    def distribution_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinition']:
        """
        The definition for a Distribution widget.
        """
        return pulumi.get(self, "distribution_definition")

    @property
    @pulumi.getter(name="eventStreamDefinition")
    def event_stream_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventStreamDefinition']:
        """
        The definition for a Event Stream widget.
        """
        return pulumi.get(self, "event_stream_definition")

    @property
    @pulumi.getter(name="eventTimelineDefinition")
    def event_timeline_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition']:
        """
        The definition for a Event Timeline widget.
        """
        return pulumi.get(self, "event_timeline_definition")

    @property
    @pulumi.getter(name="freeTextDefinition")
    def free_text_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetFreeTextDefinition']:
        """
        The definition for a Free Text widget.
        """
        return pulumi.get(self, "free_text_definition")

    @property
    @pulumi.getter(name="geomapDefinition")
    def geomap_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinition']:
        """
        The definition for a Geomap widget.
        """
        return pulumi.get(self, "geomap_definition")

    @property
    @pulumi.getter(name="heatmapDefinition")
    def heatmap_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinition']:
        """
        The definition for a Heatmap widget.
        """
        return pulumi.get(self, "heatmap_definition")

    @property
    @pulumi.getter(name="hostmapDefinition")
    def hostmap_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinition']:
        """
        The definition for a Hostmap widget.
        """
        return pulumi.get(self, "hostmap_definition")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        The ID of the widget.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="iframeDefinition")
    def iframe_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetIframeDefinition']:
        """
        The definition for an Iframe widget.
        """
        return pulumi.get(self, "iframe_definition")

    @property
    @pulumi.getter(name="imageDefinition")
    def image_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetImageDefinition']:
        """
        The definition for an Image widget
        """
        return pulumi.get(self, "image_definition")

    @property
    @pulumi.getter(name="listStreamDefinition")
    def list_stream_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinition']:
        """
        The definition for a List Stream widget.
        """
        return pulumi.get(self, "list_stream_definition")

    @property
    @pulumi.getter(name="logStreamDefinition")
    def log_stream_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinition']:
        """
        The definition for an Log Stream widget.
        """
        return pulumi.get(self, "log_stream_definition")

    @property
    @pulumi.getter(name="manageStatusDefinition")
    def manage_status_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetManageStatusDefinition']:
        """
        The definition for an Manage Status widget.
        """
        return pulumi.get(self, "manage_status_definition")

    @property
    @pulumi.getter(name="noteDefinition")
    def note_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetNoteDefinition']:
        """
        The definition for a Note widget.
        """
        return pulumi.get(self, "note_definition")

    @property
    @pulumi.getter(name="queryTableDefinition")
    def query_table_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinition']:
        """
        The definition for a Query Table widget.
        """
        return pulumi.get(self, "query_table_definition")

    @property
    @pulumi.getter(name="queryValueDefinition")
    def query_value_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinition']:
        """
        The definition for a Query Value widget.
        """
        return pulumi.get(self, "query_value_definition")

    @property
    @pulumi.getter(name="runWorkflowDefinition")
    def run_workflow_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinition']:
        """
        The definition for a Run Workflow widget.
        """
        return pulumi.get(self, "run_workflow_definition")

    @property
    @pulumi.getter(name="scatterplotDefinition")
    def scatterplot_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinition']:
        """
        The definition for a Scatterplot widget.
        """
        return pulumi.get(self, "scatterplot_definition")

    @property
    @pulumi.getter(name="serviceLevelObjectiveDefinition")
    def service_level_objective_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition']:
        """
        The definition for a Service Level Objective widget.
        """
        return pulumi.get(self, "service_level_objective_definition")

    @property
    @pulumi.getter(name="servicemapDefinition")
    def servicemap_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetServicemapDefinition']:
        """
        The definition for a Service Map widget.
        """
        return pulumi.get(self, "servicemap_definition")

    @property
    @pulumi.getter(name="sloListDefinition")
    def slo_list_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSloListDefinition']:
        """
        The definition for an SLO (Service Level Objective) List widget.
        """
        return pulumi.get(self, "slo_list_definition")

    @property
    @pulumi.getter(name="sunburstDefinition")
    def sunburst_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinition']:
        """
        The definition for a Sunburst widget.
        """
        return pulumi.get(self, "sunburst_definition")

    @property
    @pulumi.getter(name="timeseriesDefinition")
    def timeseries_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition']:
        """
        The definition for a Timeseries widget.
        """
        return pulumi.get(self, "timeseries_definition")

    @property
    @pulumi.getter(name="toplistDefinition")
    def toplist_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinition']:
        """
        The definition for a Toplist widget.
        """
        return pulumi.get(self, "toplist_definition")

    @property
    @pulumi.getter(name="topologyMapDefinition")
    def topology_map_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTopologyMapDefinition']:
        """
        The definition for a Topology Map widget.
        """
        return pulumi.get(self, "topology_map_definition")

    @property
    @pulumi.getter(name="traceServiceDefinition")
    def trace_service_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition']:
        """
        The definition for a Trace Service widget.
        """
        return pulumi.get(self, "trace_service_definition")

    @property
    @pulumi.getter(name="treemapDefinition")
    def treemap_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinition']:
        """
        The definition for a Treemap widget.
        """
        return pulumi.get(self, "treemap_definition")

    @property
    @pulumi.getter(name="widgetLayout")
    def widget_layout(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetWidgetLayout']:
        """
        The layout of the widget on a 'free' dashboard.
        """
        return pulumi.get(self, "widget_layout")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertId":
            suggest = "alert_id"
        elif key == "vizType":
            suggest = "viz_type"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_id: str,
                 viz_type: str,
                 live_span: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str alert_id: The ID of the monitor used by the widget.
        :param str viz_type: Type of visualization to use when displaying the widget. Valid values are `timeseries`, `toplist`.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetAlertGraphDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_id=alert_id,
            viz_type=viz_type,
            live_span=live_span,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_id: str,
             viz_type: str,
             live_span: Optional[str] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("alert_id", alert_id)
        _setter("viz_type", viz_type)
        if live_span is not None:
            _setter("live_span", live_span)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        """
        The ID of the monitor used by the widget.
        """
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter(name="vizType")
    def viz_type(self) -> str:
        """
        Type of visualization to use when displaying the widget. Valid values are `timeseries`, `toplist`.
        """
        return pulumi.get(self, "viz_type")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetAlertValueDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertId":
            suggest = "alert_id"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetAlertValueDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetAlertValueDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetAlertValueDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_id: str,
                 precision: Optional[int] = None,
                 text_align: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 unit: Optional[str] = None):
        """
        :param str alert_id: The ID of the monitor used by the widget.
        :param int precision: The precision to use when displaying the value. Use `*` for maximum precision.
        :param str text_align: The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param str unit: The unit for the value displayed in the widget.
        """
        DashboardWidgetGroupDefinitionWidgetAlertValueDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            alert_id=alert_id,
            precision=precision,
            text_align=text_align,
            title=title,
            title_align=title_align,
            title_size=title_size,
            unit=unit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             alert_id: str,
             precision: Optional[int] = None,
             text_align: Optional[str] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             unit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("alert_id", alert_id)
        if precision is not None:
            _setter("precision", precision)
        if text_align is not None:
            _setter("text_align", text_align)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)
        if unit is not None:
            _setter("unit", unit)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        """
        The ID of the monitor used by the widget.
        """
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter
    def precision(self) -> Optional[int]:
        """
        The precision to use when displaying the value. Use `*` for maximum precision.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_links=custom_links,
            live_span=live_span,
            requests=requests,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink']] = None,
             live_span: Optional[str] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest']] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if live_span is not None:
            _setter("live_span", live_span)
        if requests is not None:
            _setter("requests", requests)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "changeType":
            suggest = "change_type"
        elif key == "compareTo":
            suggest = "compare_to"
        elif key == "increaseGood":
            suggest = "increase_good"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "orderBy":
            suggest = "order_by"
        elif key == "orderDir":
            suggest = "order_dir"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"
        elif key == "showPresent":
            suggest = "show_present"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery'] = None,
                 change_type: Optional[str] = None,
                 compare_to: Optional[str] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormula']] = None,
                 increase_good: Optional[bool] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery'] = None,
                 order_by: Optional[str] = None,
                 order_dir: Optional[str] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery'] = None,
                 show_present: Optional[bool] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param str change_type: Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
        :param str compare_to: Choose from when to compare current data to. Valid values are `hour_before`, `day_before`, `week_before`, `month_before`.
        :param bool increase_good: A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param str order_by: What to order by. Valid values are `change`, `name`, `present`, `past`.
        :param str order_dir: Widget sorting method. Valid values are `asc`, `desc`.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param bool show_present: If set to `true`, displays the current value.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_query=apm_query,
            change_type=change_type,
            compare_to=compare_to,
            formulas=formulas,
            increase_good=increase_good,
            log_query=log_query,
            order_by=order_by,
            order_dir=order_dir,
            process_query=process_query,
            q=q,
            queries=queries,
            rum_query=rum_query,
            security_query=security_query,
            show_present=show_present,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery'] = None,
             change_type: Optional[str] = None,
             compare_to: Optional[str] = None,
             formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormula']] = None,
             increase_good: Optional[bool] = None,
             log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery'] = None,
             order_by: Optional[str] = None,
             order_dir: Optional[str] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery'] = None,
             q: Optional[str] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuery']] = None,
             rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery'] = None,
             show_present: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if change_type is not None:
            _setter("change_type", change_type)
        if compare_to is not None:
            _setter("compare_to", compare_to)
        if formulas is not None:
            _setter("formulas", formulas)
        if increase_good is not None:
            _setter("increase_good", increase_good)
        if log_query is not None:
            _setter("log_query", log_query)
        if order_by is not None:
            _setter("order_by", order_by)
        if order_dir is not None:
            _setter("order_dir", order_dir)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if queries is not None:
            _setter("queries", queries)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)
        if show_present is not None:
            _setter("show_present", show_present)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[str]:
        """
        Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
        """
        return pulumi.get(self, "change_type")

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[str]:
        """
        Choose from when to compare current data to. Valid values are `hour_before`, `day_before`, `week_before`, `month_before`.
        """
        return pulumi.get(self, "compare_to")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[bool]:
        """
        A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
        """
        return pulumi.get(self, "increase_good")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[str]:
        """
        What to order by. Valid values are `change`, `name`, `present`, `past`.
        """
        return pulumi.get(self, "order_by")

    @property
    @pulumi.getter(name="orderDir")
    def order_dir(self) -> Optional[str]:
        """
        Widget sorting method. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order_dir")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter(name="showPresent")
    def show_present(self) -> Optional[bool]:
        """
        If set to `true`, displays the current value.
        """
        return pulumi.get(self, "show_present")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaLimitArgs' limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formula_expression=formula_expression,
            alias=alias,
            cell_display_mode=cell_display_mode,
            conditional_formats=conditional_formats,
            limit=limit,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formula_expression: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaConditionalFormat']] = None,
             limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaLimit'] = None,
             style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if limit is not None:
            _setter("limit", limit)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaLimit']:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestFormulaStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_index=palette_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             palette_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)
        if palette_index is not None:
            _setter("palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetChangeDefinitionRequestSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBies":
            suggest = "group_bies"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check: str,
                 grouping: str,
                 group: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 live_span: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str check: The check to use in the widget.
        :param str grouping: The kind of grouping to use. Valid values are `check`, `cluster`.
        :param str group: The check group to use in the widget.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence[str] tags: A list of tags to use in the widget.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetCheckStatusDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            check=check,
            grouping=grouping,
            group=group,
            group_bies=group_bies,
            live_span=live_span,
            tags=tags,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             check: str,
             grouping: str,
             group: Optional[str] = None,
             group_bies: Optional[Sequence[str]] = None,
             live_span: Optional[str] = None,
             tags: Optional[Sequence[str]] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("check", check)
        _setter("grouping", grouping)
        if group is not None:
            _setter("group", group)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if live_span is not None:
            _setter("live_span", live_span)
        if tags is not None:
            _setter("tags", tags)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def check(self) -> str:
        """
        The check to use in the widget.
        """
        return pulumi.get(self, "check")

    @property
    @pulumi.getter
    def grouping(self) -> str:
        """
        The kind of grouping to use. Valid values are `check`, `cluster`.
        """
        return pulumi.get(self, "grouping")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        A list of tags to use in the widget.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str legend_size: The size of the legend displayed in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param bool show_legend: Whether or not to show the legend on this widget.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            legend_size=legend_size,
            live_span=live_span,
            requests=requests,
            show_legend=show_legend,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             legend_size: Optional[str] = None,
             live_span: Optional[str] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest']] = None,
             show_legend: Optional[bool] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if legend_size is not None:
            _setter("legend_size", legend_size)
        if live_span is not None:
            _setter("live_span", live_span)
        if requests is not None:
            _setter("requests", requests)
        if show_legend is not None:
            _setter("show_legend", show_legend)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "apmStatsQuery":
            suggest = "apm_stats_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery'] = None,
                 apm_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_query=apm_query,
            apm_stats_query=apm_stats_query,
            log_query=log_query,
            process_query=process_query,
            q=q,
            rum_query=rum_query,
            security_query=security_query,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery'] = None,
             apm_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQuery'] = None,
             log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery'] = None,
             q: Optional[str] = None,
             rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery'] = None,
             style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if apm_stats_query is not None:
            _setter("apm_stats_query", apm_stats_query)
        if log_query is not None:
            _setter("log_query", log_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="apmStatsQuery")
    def apm_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQuery']:
        return pulumi.get(self, "apm_stats_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryTag":
            suggest = "primary_tag"
        elif key == "rowType":
            suggest = "row_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env: str,
                 name: str,
                 primary_tag: str,
                 row_type: str,
                 service: str,
                 columns: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQueryColumn']] = None,
                 resource: Optional[str] = None):
        """
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str primary_tag: The organization's host group name and value.
        :param str row_type: The level of detail for the request. Valid values are `service`, `resource`, `span`.
        :param str service: APM service.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQueryColumnArgs'] columns: Column properties used by the front end for display.
        :param str resource: The resource name.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            env=env,
            name=name,
            primary_tag=primary_tag,
            row_type=row_type,
            service=service,
            columns=columns,
            resource=resource,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             env: str,
             name: str,
             primary_tag: str,
             row_type: str,
             service: str,
             columns: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQueryColumn']] = None,
             resource: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("env", env)
        _setter("name", name)
        _setter("primary_tag", primary_tag)
        _setter("row_type", row_type)
        _setter("service", service)
        if columns is not None:
            _setter("columns", columns)
        if resource is not None:
            _setter("resource", resource)

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryTag")
    def primary_tag(self) -> str:
        """
        The organization's host group name and value.
        """
        return pulumi.get(self, "primary_tag")

    @property
    @pulumi.getter(name="rowType")
    def row_type(self) -> str:
        """
        The level of detail for the request. Valid values are `service`, `resource`, `span`.
        """
        return pulumi.get(self, "row_type")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQueryColumn']]:
        """
        Column properties used by the front end for display.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        The resource name.
        """
        return pulumi.get(self, "resource")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQueryColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellDisplayMode":
            suggest = "cell_display_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQueryColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestApmStatsQueryColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            alias=alias,
            cell_display_mode=cell_display_mode,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        DashboardWidgetGroupDefinitionWidgetDistributionDefinitionRequestStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetEventStreamDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventSize":
            suggest = "event_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "tagsExecution":
            suggest = "tags_execution"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetEventStreamDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetEventStreamDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetEventStreamDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 event_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 tags_execution: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str event_size: The size to use to display an event. Valid values are `s`, `l`.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param str tags_execution: The execution method for multi-value filters, options: `and` or `or`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetEventStreamDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
            event_size=event_size,
            live_span=live_span,
            tags_execution=tags_execution,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             event_size: Optional[str] = None,
             live_span: Optional[str] = None,
             tags_execution: Optional[str] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)
        if event_size is not None:
            _setter("event_size", event_size)
        if live_span is not None:
            _setter("live_span", live_span)
        if tags_execution is not None:
            _setter("tags_execution", tags_execution)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[str]:
        """
        The size to use to display an event. Valid values are `s`, `l`.
        """
        return pulumi.get(self, "event_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        """
        The execution method for multi-value filters, options: `and` or `or`.
        """
        return pulumi.get(self, "tags_execution")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"
        elif key == "tagsExecution":
            suggest = "tags_execution"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 live_span: Optional[str] = None,
                 tags_execution: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param str tags_execution: The execution method for multi-value filters, options: `and` or `or`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetEventTimelineDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
            live_span=live_span,
            tags_execution=tags_execution,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             live_span: Optional[str] = None,
             tags_execution: Optional[str] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)
        if live_span is not None:
            _setter("live_span", live_span)
        if tags_execution is not None:
            _setter("tags_execution", tags_execution)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        """
        The execution method for multi-value filters, options: `and` or `or`.
        """
        return pulumi.get(self, "tags_execution")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetFreeTextDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontSize":
            suggest = "font_size"
        elif key == "textAlign":
            suggest = "text_align"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetFreeTextDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetFreeTextDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetFreeTextDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text: str,
                 color: Optional[str] = None,
                 font_size: Optional[str] = None,
                 text_align: Optional[str] = None):
        """
        :param str text: The text to display in the widget.
        :param str color: The color of the text in the widget.
        :param str font_size: The size of the text in the widget.
        :param str text_align: The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        DashboardWidgetGroupDefinitionWidgetFreeTextDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            text=text,
            color=color,
            font_size=font_size,
            text_align=text_align,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             text: str,
             color: Optional[str] = None,
             font_size: Optional[str] = None,
             text_align: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("text", text)
        if color is not None:
            _setter("color", color)
        if font_size is not None:
            _setter("font_size", font_size)
        if text_align is not None:
            _setter("text_align", text_align)

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The text to display in the widget.
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        The color of the text in the widget.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 view: 'outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView',
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest']] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionViewArgs' view: The view of the world that the map should render.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyleArgs' style: Styling options for widget formulas.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            view=view,
            custom_links=custom_links,
            live_span=live_span,
            requests=requests,
            style=style,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             view: 'outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView',
             custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink']] = None,
             live_span: Optional[str] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest']] = None,
             style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle'] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("view", view)
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if live_span is not None:
            _setter("live_span", live_span)
        if requests is not None:
            _setter("requests", requests)
        if style is not None:
            _setter("style", style)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def view(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView':
        """
        The view of the world that the map should render.
        """
        return pulumi.get(self, "view")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logQuery":
            suggest = "log_query"
        elif key == "rumQuery":
            suggest = "rum_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formulas=formulas,
            log_query=log_query,
            q=q,
            queries=queries,
            rum_query=rum_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula']] = None,
             log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery'] = None,
             q: Optional[str] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery']] = None,
             rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if formulas is not None:
            _setter("formulas", formulas)
        if log_query is not None:
            _setter("log_query", log_query)
        if q is not None:
            _setter("q", q)
        if queries is not None:
            _setter("queries", queries)
        if rum_query is not None:
            _setter("rum_query", rum_query)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimitArgs' limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formula_expression=formula_expression,
            alias=alias,
            cell_display_mode=cell_display_mode,
            conditional_formats=conditional_formats,
            limit=limit,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formula_expression: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaConditionalFormat']] = None,
             limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit'] = None,
             style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if limit is not None:
            _setter("limit", limit)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit']:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestFormulaStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_index=palette_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             palette_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)
        if palette_index is not None:
            _setter("palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteFlip":
            suggest = "palette_flip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: str,
                 palette_flip: bool):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param bool palette_flip: A Boolean indicating whether to flip the palette tones.
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_flip=palette_flip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: str,
             palette_flip: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("palette", palette)
        _setter("palette_flip", palette_flip)

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> bool:
        """
        A Boolean indicating whether to flip the palette tones.
        """
        return pulumi.get(self, "palette_flip")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView(dict):
    def __init__(__self__, *,
                 focus: str):
        """
        :param str focus: The two-letter ISO code of a country to focus the map on (or `WORLD`).
        """
        DashboardWidgetGroupDefinitionWidgetGeomapDefinitionView._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            focus=focus,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             focus: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("focus", focus)

    @property
    @pulumi.getter
    def focus(self) -> str:
        """
        The two-letter ISO code of a country to focus the map on (or `WORLD`).
        """
        return pulumi.get(self, "focus")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink']] = None,
                 events: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent']] = None,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 yaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis'] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEventArgs'] events: The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        :param str legend_size: The size of the legend displayed in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param bool show_legend: Whether or not to show the legend on this widget.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_links=custom_links,
            events=events,
            legend_size=legend_size,
            live_span=live_span,
            requests=requests,
            show_legend=show_legend,
            title=title,
            title_align=title_align,
            title_size=title_size,
            yaxis=yaxis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink']] = None,
             events: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent']] = None,
             legend_size: Optional[str] = None,
             live_span: Optional[str] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest']] = None,
             show_legend: Optional[bool] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             yaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if events is not None:
            _setter("events", events)
        if legend_size is not None:
            _setter("legend_size", legend_size)
        if live_span is not None:
            _setter("live_span", live_span)
        if requests is not None:
            _setter("requests", requests)
        if show_legend is not None:
            _setter("show_legend", show_legend)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)
        if yaxis is not None:
            _setter("yaxis", yaxis)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent']]:
        """
        The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis']:
        """
        A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagsExecution":
            suggest = "tags_execution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 q: str,
                 tags_execution: Optional[str] = None):
        """
        :param str q: The metric query to use for this widget.
        :param str tags_execution: The execution method for multi-value filters, options: `and` or `or`.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionEvent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            q=q,
            tags_execution=tags_execution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             q: str,
             tags_execution: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("q", q)
        if tags_execution is not None:
            _setter("tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> str:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        """
        The execution method for multi-value filters, options: `and` or `or`.
        """
        return pulumi.get(self, "tags_execution")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_query=apm_query,
            log_query=log_query,
            process_query=process_query,
            q=q,
            rum_query=rum_query,
            security_query=security_query,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery'] = None,
             log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery'] = None,
             q: Optional[str] = None,
             rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery'] = None,
             style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if log_query is not None:
            _setter("log_query", log_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionRequestStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label for the custom link URL.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        DashboardWidgetGroupDefinitionWidgetHeatmapDefinitionYaxis._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            include_zero=include_zero,
            label=label,
            max=max,
            min=min,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             include_zero: Optional[bool] = None,
             label: Optional[str] = None,
             max: Optional[str] = None,
             min: Optional[str] = None,
             scale: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if include_zero is not None:
            _setter("include_zero", include_zero)
        if label is not None:
            _setter("label", label)
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "noGroupHosts":
            suggest = "no_group_hosts"
        elif key == "noMetricHosts":
            suggest = "no_metric_hosts"
        elif key == "nodeType":
            suggest = "node_type"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink']] = None,
                 groups: Optional[Sequence[str]] = None,
                 no_group_hosts: Optional[bool] = None,
                 no_metric_hosts: Optional[bool] = None,
                 node_type: Optional[str] = None,
                 request: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest'] = None,
                 scopes: Optional[Sequence[str]] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence[str] groups: The check group to use in the widget.
        :param bool no_group_hosts: A Boolean indicating whether to show ungrouped nodes.
        :param bool no_metric_hosts: A Boolean indicating whether to show nodes with no metrics.
        :param str node_type: The type of node used. Valid values are `host`, `container`.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestArgs' request: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param Sequence[str] scopes: The list of tags to filter nodes by.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyleArgs' style: Styling options for widget formulas.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_links=custom_links,
            groups=groups,
            no_group_hosts=no_group_hosts,
            no_metric_hosts=no_metric_hosts,
            node_type=node_type,
            request=request,
            scopes=scopes,
            style=style,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink']] = None,
             groups: Optional[Sequence[str]] = None,
             no_group_hosts: Optional[bool] = None,
             no_metric_hosts: Optional[bool] = None,
             node_type: Optional[str] = None,
             request: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest'] = None,
             scopes: Optional[Sequence[str]] = None,
             style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle'] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if groups is not None:
            _setter("groups", groups)
        if no_group_hosts is not None:
            _setter("no_group_hosts", no_group_hosts)
        if no_metric_hosts is not None:
            _setter("no_metric_hosts", no_metric_hosts)
        if node_type is not None:
            _setter("node_type", node_type)
        if request is not None:
            _setter("request", request)
        if scopes is not None:
            _setter("scopes", scopes)
        if style is not None:
            _setter("style", style)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="noGroupHosts")
    def no_group_hosts(self) -> Optional[bool]:
        """
        A Boolean indicating whether to show ungrouped nodes.
        """
        return pulumi.get(self, "no_group_hosts")

    @property
    @pulumi.getter(name="noMetricHosts")
    def no_metric_hosts(self) -> Optional[bool]:
        """
        A Boolean indicating whether to show nodes with no metrics.
        """
        return pulumi.get(self, "no_metric_hosts")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[str]:
        """
        The type of node used. Valid values are `host`, `container`.
        """
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest']:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        The list of tags to filter nodes by.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest(dict):
    def __init__(__self__, *,
                 fills: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill']] = None,
                 sizes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize']] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillArgs'] fills: The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeArgs'] sizes: The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fills=fills,
            sizes=sizes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fills: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill']] = None,
             sizes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if fills is not None:
            _setter("fills", fills)
        if sizes is not None:
            _setter("sizes", sizes)

    @property
    @pulumi.getter
    def fills(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill']]:
        """
        The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "fills")

    @property
    @pulumi.getter
    def sizes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize']]:
        """
        The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "sizes")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryArgs' security_query: The query to use for this widget.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFill._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_query=apm_query,
            log_query=log_query,
            process_query=process_query,
            q=q,
            rum_query=rum_query,
            security_query=security_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery'] = None,
             log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery'] = None,
             q: Optional[str] = None,
             rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if log_query is not None:
            _setter("log_query", log_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryArgs' security_query: The query to use for this widget.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSize._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_query=apm_query,
            log_query=log_query,
            process_query=process_query,
            q=q,
            rum_query=rum_query,
            security_query=security_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery'] = None,
             log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery'] = None,
             q: Optional[str] = None,
             rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if log_query is not None:
            _setter("log_query", log_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fillMax":
            suggest = "fill_max"
        elif key == "fillMin":
            suggest = "fill_min"
        elif key == "paletteFlip":
            suggest = "palette_flip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fill_max: Optional[str] = None,
                 fill_min: Optional[str] = None,
                 palette: Optional[str] = None,
                 palette_flip: Optional[bool] = None):
        """
        :param str fill_max: The max value to use to color the map.
        :param str fill_min: The min value to use to color the map.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param bool palette_flip: A Boolean indicating whether to flip the palette tones.
        """
        DashboardWidgetGroupDefinitionWidgetHostmapDefinitionStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fill_max=fill_max,
            fill_min=fill_min,
            palette=palette,
            palette_flip=palette_flip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fill_max: Optional[str] = None,
             fill_min: Optional[str] = None,
             palette: Optional[str] = None,
             palette_flip: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if fill_max is not None:
            _setter("fill_max", fill_max)
        if fill_min is not None:
            _setter("fill_min", fill_min)
        if palette is not None:
            _setter("palette", palette)
        if palette_flip is not None:
            _setter("palette_flip", palette_flip)

    @property
    @pulumi.getter(name="fillMax")
    def fill_max(self) -> Optional[str]:
        """
        The max value to use to color the map.
        """
        return pulumi.get(self, "fill_max")

    @property
    @pulumi.getter(name="fillMin")
    def fill_min(self) -> Optional[str]:
        """
        The min value to use to color the map.
        """
        return pulumi.get(self, "fill_min")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> Optional[bool]:
        """
        A Boolean indicating whether to flip the palette tones.
        """
        return pulumi.get(self, "palette_flip")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetIframeDefinition(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: The URL to use as a data source for the widget.
        """
        DashboardWidgetGroupDefinitionWidgetIframeDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL to use as a data source for the widget.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetImageDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hasBackground":
            suggest = "has_background"
        elif key == "hasBorder":
            suggest = "has_border"
        elif key == "horizontalAlign":
            suggest = "horizontal_align"
        elif key == "urlDarkTheme":
            suggest = "url_dark_theme"
        elif key == "verticalAlign":
            suggest = "vertical_align"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetImageDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetImageDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetImageDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 has_background: Optional[bool] = None,
                 has_border: Optional[bool] = None,
                 horizontal_align: Optional[str] = None,
                 margin: Optional[str] = None,
                 sizing: Optional[str] = None,
                 url_dark_theme: Optional[str] = None,
                 vertical_align: Optional[str] = None):
        """
        :param str url: The URL to use as a data source for the widget.
        :param bool has_background: Whether to display a background or not.
        :param bool has_border: Whether to display a border or not.
        :param str horizontal_align: The horizontal alignment for the widget. Valid values are `center`, `left`, `right`.
        :param str margin: The margins to use around the image. Note: `small` and `large` values are deprecated. Valid values are `sm`, `md`, `lg`, `small`, `large`.
        :param str sizing: The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated. Valid values are `fill`, `contain`, `cover`, `none`, `scale-down`, `zoom`, `fit`, `center`.
        :param str url_dark_theme: The URL in dark mode to use as a data source for the widget.
        :param str vertical_align: The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        DashboardWidgetGroupDefinitionWidgetImageDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            has_background=has_background,
            has_border=has_border,
            horizontal_align=horizontal_align,
            margin=margin,
            sizing=sizing,
            url_dark_theme=url_dark_theme,
            vertical_align=vertical_align,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: str,
             has_background: Optional[bool] = None,
             has_border: Optional[bool] = None,
             horizontal_align: Optional[str] = None,
             margin: Optional[str] = None,
             sizing: Optional[str] = None,
             url_dark_theme: Optional[str] = None,
             vertical_align: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("url", url)
        if has_background is not None:
            _setter("has_background", has_background)
        if has_border is not None:
            _setter("has_border", has_border)
        if horizontal_align is not None:
            _setter("horizontal_align", horizontal_align)
        if margin is not None:
            _setter("margin", margin)
        if sizing is not None:
            _setter("sizing", sizing)
        if url_dark_theme is not None:
            _setter("url_dark_theme", url_dark_theme)
        if vertical_align is not None:
            _setter("vertical_align", vertical_align)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL to use as a data source for the widget.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="hasBackground")
    def has_background(self) -> Optional[bool]:
        """
        Whether to display a background or not.
        """
        return pulumi.get(self, "has_background")

    @property
    @pulumi.getter(name="hasBorder")
    def has_border(self) -> Optional[bool]:
        """
        Whether to display a border or not.
        """
        return pulumi.get(self, "has_border")

    @property
    @pulumi.getter(name="horizontalAlign")
    def horizontal_align(self) -> Optional[str]:
        """
        The horizontal alignment for the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "horizontal_align")

    @property
    @pulumi.getter
    def margin(self) -> Optional[str]:
        """
        The margins to use around the image. Note: `small` and `large` values are deprecated. Valid values are `sm`, `md`, `lg`, `small`, `large`.
        """
        return pulumi.get(self, "margin")

    @property
    @pulumi.getter
    def sizing(self) -> Optional[str]:
        """
        The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated. Valid values are `fill`, `contain`, `cover`, `none`, `scale-down`, `zoom`, `fit`, `center`.
        """
        return pulumi.get(self, "sizing")

    @property
    @pulumi.getter(name="urlDarkTheme")
    def url_dark_theme(self) -> Optional[str]:
        """
        The URL in dark mode to use as a data source for the widget.
        """
        return pulumi.get(self, "url_dark_theme")

    @property
    @pulumi.getter(name="verticalAlign")
    def vertical_align(self) -> Optional[str]:
        """
        The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        return pulumi.get(self, "vertical_align")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetListStreamDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetListStreamDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetListStreamDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetListStreamDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 requests: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequest'],
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetListStreamDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            requests=requests,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             requests: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequest'],
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("requests", requests)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> Sequence['outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequest']:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseFormat":
            suggest = "response_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestColumn'],
                 query: 'outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuery',
                 response_format: str):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestColumnArgs'] columns: Column properties used by the front end for display.
        :param str response_format: Widget response format. Valid values are `event_list`.
        """
        DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            query=query,
            response_format=response_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestColumn'],
             query: 'outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuery',
             response_format: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("columns", columns)
        _setter("query", query)
        _setter("response_format", response_format)

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestColumn']:
        """
        Column properties used by the front end for display.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def query(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuery':
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="responseFormat")
    def response_format(self) -> str:
        """
        Widget response format. Valid values are `event_list`.
        """
        return pulumi.get(self, "response_format")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestColumn(dict):
    def __init__(__self__, *,
                 field: str,
                 width: str):
        """
        :param str field: Widget column field.
        :param str width: Widget column width. Valid values are `auto`, `compact`, `full`.
        """
        DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
            width=width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: str,
             width: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field", field)
        _setter("width", width)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Widget column field.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def width(self) -> str:
        """
        Widget column width. Valid values are `auto`, `compact`, `full`.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "eventSize":
            suggest = "event_size"
        elif key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 event_size: Optional[str] = None,
                 indexes: Optional[Sequence[str]] = None,
                 query_string: Optional[str] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuerySort'] = None,
                 storage: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str event_size: The size to use to display an event. Valid values are `s`, `l`.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param str query_string: Widget query.
        :param 'DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuerySortArgs' sort: The options for sorting group by results.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            event_size=event_size,
            indexes=indexes,
            query_string=query_string,
            sort=sort,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             event_size: Optional[str] = None,
             indexes: Optional[Sequence[str]] = None,
             query_string: Optional[str] = None,
             sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuerySort'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        if event_size is not None:
            _setter("event_size", event_size)
        if indexes is not None:
            _setter("indexes", indexes)
        if query_string is not None:
            _setter("query_string", query_string)
        if sort is not None:
            _setter("sort", sort)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[str]:
        """
        The size to use to display an event. Valid values are `s`, `l`.
        """
        return pulumi.get(self, "event_size")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[str]:
        """
        Widget query.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuerySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuerySort(dict):
    def __init__(__self__, *,
                 column: str,
                 order: str):
        """
        :param str column: The facet path for the column.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetListStreamDefinitionRequestQuerySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: str,
             order: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("order", order)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetLogStreamDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"
        elif key == "messageDisplay":
            suggest = "message_display"
        elif key == "showDateColumn":
            suggest = "show_date_column"
        elif key == "showMessageColumn":
            suggest = "show_message_column"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetLogStreamDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetLogStreamDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetLogStreamDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Optional[Sequence[str]] = None,
                 indexes: Optional[Sequence[str]] = None,
                 live_span: Optional[str] = None,
                 message_display: Optional[str] = None,
                 query: Optional[str] = None,
                 show_date_column: Optional[bool] = None,
                 show_message_column: Optional[bool] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence[str] columns: Column properties used by the front end for display.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param str message_display: The number of log lines to display. Valid values are `inline`, `expanded-md`, `expanded-lg`.
        :param bool show_date_column: If the date column should be displayed.
        :param bool show_message_column: If the message column should be displayed.
        :param 'DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSortArgs' sort: The options for sorting group by results.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetLogStreamDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            indexes=indexes,
            live_span=live_span,
            message_display=message_display,
            query=query,
            show_date_column=show_date_column,
            show_message_column=show_message_column,
            sort=sort,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Optional[Sequence[str]] = None,
             indexes: Optional[Sequence[str]] = None,
             live_span: Optional[str] = None,
             message_display: Optional[str] = None,
             query: Optional[str] = None,
             show_date_column: Optional[bool] = None,
             show_message_column: Optional[bool] = None,
             sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort'] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if columns is not None:
            _setter("columns", columns)
        if indexes is not None:
            _setter("indexes", indexes)
        if live_span is not None:
            _setter("live_span", live_span)
        if message_display is not None:
            _setter("message_display", message_display)
        if query is not None:
            _setter("query", query)
        if show_date_column is not None:
            _setter("show_date_column", show_date_column)
        if show_message_column is not None:
            _setter("show_message_column", show_message_column)
        if sort is not None:
            _setter("sort", sort)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence[str]]:
        """
        Column properties used by the front end for display.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="messageDisplay")
    def message_display(self) -> Optional[str]:
        """
        The number of log lines to display. Valid values are `inline`, `expanded-md`, `expanded-lg`.
        """
        return pulumi.get(self, "message_display")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="showDateColumn")
    def show_date_column(self) -> Optional[bool]:
        """
        If the date column should be displayed.
        """
        return pulumi.get(self, "show_date_column")

    @property
    @pulumi.getter(name="showMessageColumn")
    def show_message_column(self) -> Optional[bool]:
        """
        If the message column should be displayed.
        """
        return pulumi.get(self, "show_message_column")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort(dict):
    def __init__(__self__, *,
                 column: str,
                 order: str):
        """
        :param str column: The facet path for the column.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetLogStreamDefinitionSort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: str,
             order: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("order", order)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetManageStatusDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorPreference":
            suggest = "color_preference"
        elif key == "displayFormat":
            suggest = "display_format"
        elif key == "hideZeroCounts":
            suggest = "hide_zero_counts"
        elif key == "showLastTriggered":
            suggest = "show_last_triggered"
        elif key == "showPriority":
            suggest = "show_priority"
        elif key == "summaryType":
            suggest = "summary_type"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetManageStatusDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetManageStatusDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetManageStatusDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 color_preference: Optional[str] = None,
                 display_format: Optional[str] = None,
                 hide_zero_counts: Optional[bool] = None,
                 show_last_triggered: Optional[bool] = None,
                 show_priority: Optional[bool] = None,
                 sort: Optional[str] = None,
                 summary_type: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str color_preference: Whether to colorize text or background. Valid values are `background`, `text`.
        :param str display_format: The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
        :param bool hide_zero_counts: A Boolean indicating whether to hide empty categories.
        :param bool show_last_triggered: A Boolean indicating whether to show when monitors/groups last triggered.
        :param bool show_priority: Whether to show the priorities column.
        :param str sort: The options for sorting group by results.
        :param str summary_type: The summary type to use. Valid values are `monitors`, `groups`, `combined`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetManageStatusDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
            color_preference=color_preference,
            display_format=display_format,
            hide_zero_counts=hide_zero_counts,
            show_last_triggered=show_last_triggered,
            show_priority=show_priority,
            sort=sort,
            summary_type=summary_type,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             color_preference: Optional[str] = None,
             display_format: Optional[str] = None,
             hide_zero_counts: Optional[bool] = None,
             show_last_triggered: Optional[bool] = None,
             show_priority: Optional[bool] = None,
             sort: Optional[str] = None,
             summary_type: Optional[str] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)
        if color_preference is not None:
            _setter("color_preference", color_preference)
        if display_format is not None:
            _setter("display_format", display_format)
        if hide_zero_counts is not None:
            _setter("hide_zero_counts", hide_zero_counts)
        if show_last_triggered is not None:
            _setter("show_last_triggered", show_last_triggered)
        if show_priority is not None:
            _setter("show_priority", show_priority)
        if sort is not None:
            _setter("sort", sort)
        if summary_type is not None:
            _setter("summary_type", summary_type)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="colorPreference")
    def color_preference(self) -> Optional[str]:
        """
        Whether to colorize text or background. Valid values are `background`, `text`.
        """
        return pulumi.get(self, "color_preference")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        """
        The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
        """
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter(name="hideZeroCounts")
    def hide_zero_counts(self) -> Optional[bool]:
        """
        A Boolean indicating whether to hide empty categories.
        """
        return pulumi.get(self, "hide_zero_counts")

    @property
    @pulumi.getter(name="showLastTriggered")
    def show_last_triggered(self) -> Optional[bool]:
        """
        A Boolean indicating whether to show when monitors/groups last triggered.
        """
        return pulumi.get(self, "show_last_triggered")

    @property
    @pulumi.getter(name="showPriority")
    def show_priority(self) -> Optional[bool]:
        """
        Whether to show the priorities column.
        """
        return pulumi.get(self, "show_priority")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="summaryType")
    def summary_type(self) -> Optional[str]:
        """
        The summary type to use. Valid values are `monitors`, `groups`, `combined`.
        """
        return pulumi.get(self, "summary_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetNoteDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "hasPadding":
            suggest = "has_padding"
        elif key == "showTick":
            suggest = "show_tick"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "tickEdge":
            suggest = "tick_edge"
        elif key == "tickPos":
            suggest = "tick_pos"
        elif key == "verticalAlign":
            suggest = "vertical_align"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetNoteDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetNoteDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetNoteDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: str,
                 background_color: Optional[str] = None,
                 font_size: Optional[str] = None,
                 has_padding: Optional[bool] = None,
                 show_tick: Optional[bool] = None,
                 text_align: Optional[str] = None,
                 tick_edge: Optional[str] = None,
                 tick_pos: Optional[str] = None,
                 vertical_align: Optional[str] = None):
        """
        :param str content: The content of the note.
        :param str background_color: The background color of the group title, options: `vivid_blue`, `vivid_purple`, `vivid_pink`, `vivid_orange`, `vivid_yellow`, `vivid_green`, `blue`, `purple`, `pink`, `orange`, `yellow`, `green`, `gray` or `white`
        :param str font_size: The size of the text in the widget.
        :param bool has_padding: Whether to add padding or not.
        :param bool show_tick: Whether to show a tick or not.
        :param str text_align: The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        :param str tick_edge: When `tick = true`, a string indicating on which side of the widget the tick should be displayed. Valid values are `bottom`, `left`, `right`, `top`.
        :param str tick_pos: When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tick_pos = "50%"` is centered alignment.
        :param str vertical_align: The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        DashboardWidgetGroupDefinitionWidgetNoteDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            background_color=background_color,
            font_size=font_size,
            has_padding=has_padding,
            show_tick=show_tick,
            text_align=text_align,
            tick_edge=tick_edge,
            tick_pos=tick_pos,
            vertical_align=vertical_align,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: str,
             background_color: Optional[str] = None,
             font_size: Optional[str] = None,
             has_padding: Optional[bool] = None,
             show_tick: Optional[bool] = None,
             text_align: Optional[str] = None,
             tick_edge: Optional[str] = None,
             tick_pos: Optional[str] = None,
             vertical_align: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("content", content)
        if background_color is not None:
            _setter("background_color", background_color)
        if font_size is not None:
            _setter("font_size", font_size)
        if has_padding is not None:
            _setter("has_padding", has_padding)
        if show_tick is not None:
            _setter("show_tick", show_tick)
        if text_align is not None:
            _setter("text_align", text_align)
        if tick_edge is not None:
            _setter("tick_edge", tick_edge)
        if tick_pos is not None:
            _setter("tick_pos", tick_pos)
        if vertical_align is not None:
            _setter("vertical_align", vertical_align)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The content of the note.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        """
        The background color of the group title, options: `vivid_blue`, `vivid_purple`, `vivid_pink`, `vivid_orange`, `vivid_yellow`, `vivid_green`, `blue`, `purple`, `pink`, `orange`, `yellow`, `green`, `gray` or `white`
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="hasPadding")
    def has_padding(self) -> Optional[bool]:
        """
        Whether to add padding or not.
        """
        return pulumi.get(self, "has_padding")

    @property
    @pulumi.getter(name="showTick")
    def show_tick(self) -> Optional[bool]:
        """
        Whether to show a tick or not.
        """
        return pulumi.get(self, "show_tick")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter(name="tickEdge")
    def tick_edge(self) -> Optional[str]:
        """
        When `tick = true`, a string indicating on which side of the widget the tick should be displayed. Valid values are `bottom`, `left`, `right`, `top`.
        """
        return pulumi.get(self, "tick_edge")

    @property
    @pulumi.getter(name="tickPos")
    def tick_pos(self) -> Optional[str]:
        """
        When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tick_pos = "50%"` is centered alignment.
        """
        return pulumi.get(self, "tick_pos")

    @property
    @pulumi.getter(name="verticalAlign")
    def vertical_align(self) -> Optional[str]:
        """
        The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        return pulumi.get(self, "vertical_align")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "hasSearchBar":
            suggest = "has_search_bar"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink']] = None,
                 has_search_bar: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str has_search_bar: Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_links=custom_links,
            has_search_bar=has_search_bar,
            live_span=live_span,
            requests=requests,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink']] = None,
             has_search_bar: Optional[str] = None,
             live_span: Optional[str] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest']] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if has_search_bar is not None:
            _setter("has_search_bar", has_search_bar)
        if live_span is not None:
            _setter("live_span", live_span)
        if requests is not None:
            _setter("requests", requests)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="hasSearchBar")
    def has_search_bar(self) -> Optional[str]:
        """
        Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
        """
        return pulumi.get(self, "has_search_bar")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "apmStatsQuery":
            suggest = "apm_stats_query"
        elif key == "cellDisplayModes":
            suggest = "cell_display_modes"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 alias: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery'] = None,
                 apm_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery'] = None,
                 cell_display_modes: Optional[Sequence[str]] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat']] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormula']] = None,
                 limit: Optional[int] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery'] = None,
                 order: Optional[str] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery'] = None):
        """
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str alias: An expression alias.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param Sequence[str] cell_display_modes: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregator=aggregator,
            alias=alias,
            apm_query=apm_query,
            apm_stats_query=apm_stats_query,
            cell_display_modes=cell_display_modes,
            conditional_formats=conditional_formats,
            formulas=formulas,
            limit=limit,
            log_query=log_query,
            order=order,
            process_query=process_query,
            q=q,
            queries=queries,
            rum_query=rum_query,
            security_query=security_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregator: Optional[str] = None,
             alias: Optional[str] = None,
             apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery'] = None,
             apm_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery'] = None,
             cell_display_modes: Optional[Sequence[str]] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat']] = None,
             formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormula']] = None,
             limit: Optional[int] = None,
             log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery'] = None,
             order: Optional[str] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery'] = None,
             q: Optional[str] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuery']] = None,
             rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if alias is not None:
            _setter("alias", alias)
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if apm_stats_query is not None:
            _setter("apm_stats_query", apm_stats_query)
        if cell_display_modes is not None:
            _setter("cell_display_modes", cell_display_modes)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if formulas is not None:
            _setter("formulas", formulas)
        if limit is not None:
            _setter("limit", limit)
        if log_query is not None:
            _setter("log_query", log_query)
        if order is not None:
            _setter("order", order)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if queries is not None:
            _setter("queries", queries)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="apmStatsQuery")
    def apm_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery']:
        return pulumi.get(self, "apm_stats_query")

    @property
    @pulumi.getter(name="cellDisplayModes")
    def cell_display_modes(self) -> Optional[Sequence[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_modes")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryTag":
            suggest = "primary_tag"
        elif key == "rowType":
            suggest = "row_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env: str,
                 name: str,
                 primary_tag: str,
                 row_type: str,
                 service: str,
                 columns: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn']] = None,
                 resource: Optional[str] = None):
        """
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str primary_tag: The organization's host group name and value.
        :param str row_type: The level of detail for the request. Valid values are `service`, `resource`, `span`.
        :param str service: APM service.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumnArgs'] columns: Column properties used by the front end for display.
        :param str resource: The resource name.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            env=env,
            name=name,
            primary_tag=primary_tag,
            row_type=row_type,
            service=service,
            columns=columns,
            resource=resource,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             env: str,
             name: str,
             primary_tag: str,
             row_type: str,
             service: str,
             columns: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn']] = None,
             resource: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("env", env)
        _setter("name", name)
        _setter("primary_tag", primary_tag)
        _setter("row_type", row_type)
        _setter("service", service)
        if columns is not None:
            _setter("columns", columns)
        if resource is not None:
            _setter("resource", resource)

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryTag")
    def primary_tag(self) -> str:
        """
        The organization's host group name and value.
        """
        return pulumi.get(self, "primary_tag")

    @property
    @pulumi.getter(name="rowType")
    def row_type(self) -> str:
        """
        The level of detail for the request. Valid values are `service`, `resource`, `span`.
        """
        return pulumi.get(self, "row_type")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn']]:
        """
        Column properties used by the front end for display.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        The resource name.
        """
        return pulumi.get(self, "resource")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellDisplayMode":
            suggest = "cell_display_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestApmStatsQueryColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            alias=alias,
            cell_display_mode=cell_display_mode,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaLimitArgs' limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formula_expression=formula_expression,
            alias=alias,
            cell_display_mode=cell_display_mode,
            conditional_formats=conditional_formats,
            limit=limit,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formula_expression: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaConditionalFormat']] = None,
             limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaLimit'] = None,
             style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if limit is not None:
            _setter("limit", limit)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaLimit']:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestFormulaStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_index=palette_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             palette_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)
        if palette_index is not None:
            _setter("palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "customUnit":
            suggest = "custom_unit"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "timeseriesBackground":
            suggest = "timeseries_background"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscale: Optional[bool] = None,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink']] = None,
                 custom_unit: Optional[str] = None,
                 live_span: Optional[str] = None,
                 precision: Optional[int] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest']] = None,
                 text_align: Optional[str] = None,
                 timeseries_background: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackground'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param bool autoscale: A Boolean indicating whether to automatically scale the tile.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str custom_unit: The unit for the value displayed in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param int precision: The precision to use when displaying the value. Use `*` for maximum precision.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str text_align: The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackgroundArgs' timeseries_background: Set a timeseries on the widget background.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autoscale=autoscale,
            custom_links=custom_links,
            custom_unit=custom_unit,
            live_span=live_span,
            precision=precision,
            requests=requests,
            text_align=text_align,
            timeseries_background=timeseries_background,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autoscale: Optional[bool] = None,
             custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink']] = None,
             custom_unit: Optional[str] = None,
             live_span: Optional[str] = None,
             precision: Optional[int] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest']] = None,
             text_align: Optional[str] = None,
             timeseries_background: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackground'] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if autoscale is not None:
            _setter("autoscale", autoscale)
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if custom_unit is not None:
            _setter("custom_unit", custom_unit)
        if live_span is not None:
            _setter("live_span", live_span)
        if precision is not None:
            _setter("precision", precision)
        if requests is not None:
            _setter("requests", requests)
        if text_align is not None:
            _setter("text_align", text_align)
        if timeseries_background is not None:
            _setter("timeseries_background", timeseries_background)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[bool]:
        """
        A Boolean indicating whether to automatically scale the tile.
        """
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[str]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "custom_unit")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def precision(self) -> Optional[int]:
        """
        The precision to use when displaying the value. Use `*` for maximum precision.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter(name="timeseriesBackground")
    def timeseries_background(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackground']:
        """
        Set a timeseries on the widget background.
        """
        return pulumi.get(self, "timeseries_background")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "auditQuery":
            suggest = "audit_query"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery'] = None,
                 audit_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQuery'] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat']] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery'] = None):
        """
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryArgs' audit_query: The query to use for this widget.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregator=aggregator,
            apm_query=apm_query,
            audit_query=audit_query,
            conditional_formats=conditional_formats,
            formulas=formulas,
            log_query=log_query,
            process_query=process_query,
            q=q,
            queries=queries,
            rum_query=rum_query,
            security_query=security_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregator: Optional[str] = None,
             apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery'] = None,
             audit_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQuery'] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat']] = None,
             formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula']] = None,
             log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery'] = None,
             q: Optional[str] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery']] = None,
             rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if audit_query is not None:
            _setter("audit_query", audit_query)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if formulas is not None:
            _setter("formulas", formulas)
        if log_query is not None:
            _setter("log_query", log_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if queries is not None:
            _setter("queries", queries)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestAuditQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimitArgs' limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formula_expression=formula_expression,
            alias=alias,
            cell_display_mode=cell_display_mode,
            conditional_formats=conditional_formats,
            limit=limit,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formula_expression: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaConditionalFormat']] = None,
             limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit'] = None,
             style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if limit is not None:
            _setter("limit", limit)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit']:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestFormulaStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_index=palette_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             palette_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)
        if palette_index is not None:
            _setter("palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackground(dict):
    def __init__(__self__, *,
                 type: str,
                 yaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackgroundYaxis'] = None):
        """
        :param str type: Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        :param 'DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackgroundYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackground._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            yaxis=yaxis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             yaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackgroundYaxis'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if yaxis is not None:
            _setter("yaxis", yaxis)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackgroundYaxis']:
        """
        A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackgroundYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackgroundYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackgroundYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackgroundYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label for the custom link URL.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        DashboardWidgetGroupDefinitionWidgetQueryValueDefinitionTimeseriesBackgroundYaxis._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            include_zero=include_zero,
            label=label,
            max=max,
            min=min,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             include_zero: Optional[bool] = None,
             label: Optional[str] = None,
             max: Optional[str] = None,
             min: Optional[str] = None,
             scale: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if include_zero is not None:
            _setter("include_zero", include_zero)
        if label is not None:
            _setter("label", label)
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workflowId":
            suggest = "workflow_id"
        elif key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workflow_id: str,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionCustomLink']] = None,
                 inputs: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionInput']] = None,
                 live_span: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str workflow_id: Workflow ID
        :param Sequence['DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionInputArgs'] inputs: Array of workflow inputs to map to dashboard template variables.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            workflow_id=workflow_id,
            custom_links=custom_links,
            inputs=inputs,
            live_span=live_span,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             workflow_id: str,
             custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionCustomLink']] = None,
             inputs: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionInput']] = None,
             live_span: Optional[str] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("workflow_id", workflow_id)
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if inputs is not None:
            _setter("inputs", inputs)
        if live_span is not None:
            _setter("live_span", live_span)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> str:
        """
        Workflow ID
        """
        return pulumi.get(self, "workflow_id")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def inputs(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionInput']]:
        """
        Array of workflow inputs to map to dashboard template variables.
        """
        return pulumi.get(self, "inputs")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionInput(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the variable.
        :param str value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        DashboardWidgetGroupDefinitionWidgetRunWorkflowDefinitionInput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorByGroups":
            suggest = "color_by_groups"
        elif key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_by_groups: Optional[Sequence[str]] = None,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 request: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 xaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis'] = None,
                 yaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis'] = None):
        """
        :param Sequence[str] color_by_groups: List of groups used for colors.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestArgs' request: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxisArgs' xaxis: A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_by_groups=color_by_groups,
            custom_links=custom_links,
            live_span=live_span,
            request=request,
            title=title,
            title_align=title_align,
            title_size=title_size,
            xaxis=xaxis,
            yaxis=yaxis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_by_groups: Optional[Sequence[str]] = None,
             custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink']] = None,
             live_span: Optional[str] = None,
             request: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest'] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             xaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis'] = None,
             yaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color_by_groups is not None:
            _setter("color_by_groups", color_by_groups)
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if live_span is not None:
            _setter("live_span", live_span)
        if request is not None:
            _setter("request", request)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)
        if xaxis is not None:
            _setter("xaxis", xaxis)
        if yaxis is not None:
            _setter("yaxis", yaxis)

    @property
    @pulumi.getter(name="colorByGroups")
    def color_by_groups(self) -> Optional[Sequence[str]]:
        """
        List of groups used for colors.
        """
        return pulumi.get(self, "color_by_groups")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest']:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def xaxis(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis']:
        """
        A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "xaxis")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis']:
        """
        A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scatterplotTables":
            suggest = "scatterplot_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scatterplot_tables: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTable']] = None,
                 xes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX']] = None,
                 ys: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY']] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableArgs'] scatterplot_tables: Scatterplot request containing formulas and functions.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXArgs'] xes: The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYArgs'] ys: The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scatterplot_tables=scatterplot_tables,
            xes=xes,
            ys=ys,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scatterplot_tables: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTable']] = None,
             xes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX']] = None,
             ys: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if scatterplot_tables is not None:
            _setter("scatterplot_tables", scatterplot_tables)
        if xes is not None:
            _setter("xes", xes)
        if ys is not None:
            _setter("ys", ys)

    @property
    @pulumi.getter(name="scatterplotTables")
    def scatterplot_tables(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTable']]:
        """
        Scatterplot request containing formulas and functions.
        """
        return pulumi.get(self, "scatterplot_tables")

    @property
    @pulumi.getter
    def xes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX']]:
        """
        The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        return pulumi.get(self, "xes")

    @property
    @pulumi.getter
    def ys(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY']]:
        """
        The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        return pulumi.get(self, "ys")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTable(dict):
    def __init__(__self__, *,
                 formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableFormula']] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuery']] = None):
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formulas=formulas,
            queries=queries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableFormula']] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuery']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if formulas is not None:
            _setter("formulas", formulas)
        if queries is not None:
            _setter("queries", queries)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuery']]:
        return pulumi.get(self, "queries")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension: str,
                 formula_expression: str,
                 alias: Optional[str] = None):
        """
        :param str dimension: Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dimension=dimension,
            formula_expression=formula_expression,
            alias=alias,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dimension: str,
             formula_expression: str,
             alias: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dimension", dimension)
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)

    @property
    @pulumi.getter
    def dimension(self) -> str:
        """
        Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery'] = None):
        """
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryArgs' security_query: The query to use for this widget.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestX._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregator=aggregator,
            apm_query=apm_query,
            log_query=log_query,
            process_query=process_query,
            q=q,
            rum_query=rum_query,
            security_query=security_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregator: Optional[str] = None,
             apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery'] = None,
             log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery'] = None,
             q: Optional[str] = None,
             rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if log_query is not None:
            _setter("log_query", log_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery'] = None):
        """
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryArgs' security_query: The query to use for this widget.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestY._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregator=aggregator,
            apm_query=apm_query,
            log_query=log_query,
            process_query=process_query,
            q=q,
            rum_query=rum_query,
            security_query=security_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregator: Optional[str] = None,
             apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery'] = None,
             log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery'] = None,
             q: Optional[str] = None,
             rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if log_query is not None:
            _setter("log_query", log_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label for the custom link URL.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionXaxis._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            include_zero=include_zero,
            label=label,
            max=max,
            min=min,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             include_zero: Optional[bool] = None,
             label: Optional[str] = None,
             max: Optional[str] = None,
             min: Optional[str] = None,
             scale: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if include_zero is not None:
            _setter("include_zero", include_zero)
        if label is not None:
            _setter("label", label)
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label for the custom link URL.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        DashboardWidgetGroupDefinitionWidgetScatterplotDefinitionYaxis._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            include_zero=include_zero,
            label=label,
            max=max,
            min=min,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             include_zero: Optional[bool] = None,
             label: Optional[str] = None,
             max: Optional[str] = None,
             min: Optional[str] = None,
             scale: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if include_zero is not None:
            _setter("include_zero", include_zero)
        if label is not None:
            _setter("label", label)
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sloId":
            suggest = "slo_id"
        elif key == "timeWindows":
            suggest = "time_windows"
        elif key == "viewMode":
            suggest = "view_mode"
        elif key == "viewType":
            suggest = "view_type"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "globalTimeTarget":
            suggest = "global_time_target"
        elif key == "showErrorBudget":
            suggest = "show_error_budget"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slo_id: str,
                 time_windows: Sequence[str],
                 view_mode: str,
                 view_type: str,
                 additional_query_filters: Optional[str] = None,
                 global_time_target: Optional[str] = None,
                 show_error_budget: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str slo_id: ID of an SLO to query.
        :param Sequence[str] time_windows: A list of time windows to display in the widget. Valid values are `7d`, `30d`, `90d`, `week_to_date`, `previous_week`, `month_to_date`, `previous_month`, `global_time`.
        :param str view_mode: The view mode for the widget. Valid values are `overall`, `component`, `both`.
        :param str view_type: The type of view to use when displaying the widget. Only `detail` is supported.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str global_time_target: The global time target of the widget.
        :param bool show_error_budget: Whether to show the error budget or not.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetServiceLevelObjectiveDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            slo_id=slo_id,
            time_windows=time_windows,
            view_mode=view_mode,
            view_type=view_type,
            additional_query_filters=additional_query_filters,
            global_time_target=global_time_target,
            show_error_budget=show_error_budget,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             slo_id: str,
             time_windows: Sequence[str],
             view_mode: str,
             view_type: str,
             additional_query_filters: Optional[str] = None,
             global_time_target: Optional[str] = None,
             show_error_budget: Optional[bool] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("slo_id", slo_id)
        _setter("time_windows", time_windows)
        _setter("view_mode", view_mode)
        _setter("view_type", view_type)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if global_time_target is not None:
            _setter("global_time_target", global_time_target)
        if show_error_budget is not None:
            _setter("show_error_budget", show_error_budget)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Sequence[str]:
        """
        A list of time windows to display in the widget. Valid values are `7d`, `30d`, `90d`, `week_to_date`, `previous_week`, `month_to_date`, `previous_month`, `global_time`.
        """
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter(name="viewMode")
    def view_mode(self) -> str:
        """
        The view mode for the widget. Valid values are `overall`, `component`, `both`.
        """
        return pulumi.get(self, "view_mode")

    @property
    @pulumi.getter(name="viewType")
    def view_type(self) -> str:
        """
        The type of view to use when displaying the widget. Only `detail` is supported.
        """
        return pulumi.get(self, "view_type")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="globalTimeTarget")
    def global_time_target(self) -> Optional[str]:
        """
        The global time target of the widget.
        """
        return pulumi.get(self, "global_time_target")

    @property
    @pulumi.getter(name="showErrorBudget")
    def show_error_budget(self) -> Optional[bool]:
        """
        Whether to show the error budget or not.
        """
        return pulumi.get(self, "show_error_budget")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetServicemapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetServicemapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetServicemapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetServicemapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Sequence[str],
                 service: str,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence[str] filters: Your environment and primary tag (or `*` if enabled for your account).
        :param str service: APM service.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetServicemapDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filters=filters,
            service=service,
            custom_links=custom_links,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filters: Sequence[str],
             service: str,
             custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink']] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filters", filters)
        _setter("service", service)
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def filters(self) -> Sequence[str]:
        """
        Your environment and primary tag (or `*` if enabled for your account).
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetGroupDefinitionWidgetServicemapDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSloListDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSloListDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSloListDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSloListDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request: 'outputs.DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequest',
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestArgs' request: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetSloListDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            request=request,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             request: 'outputs.DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequest',
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("request", request)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def request(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequest':
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestType":
            suggest = "request_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: 'outputs.DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuery',
                 request_type: str):
        """
        :param str request_type: The request type for the SLO List request. Valid values are `slo_list`.
        """
        DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
            request_type=request_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: 'outputs.DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuery',
             request_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)
        _setter("request_type", request_type)

    @property
    @pulumi.getter
    def query(self) -> 'outputs.DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuery':
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> str:
        """
        The request type for the SLO List request. Valid values are `slo_list`.
        """
        return pulumi.get(self, "request_type")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_string: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuerySort'] = None):
        """
        :param str query_string: Widget query.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuerySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query_string=query_string,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query_string: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuerySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query_string", query_string)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> str:
        """
        Widget query.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuerySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuerySort(dict):
    def __init__(__self__, *,
                 column: str,
                 order: str):
        """
        :param str column: The facet path for the column.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetSloListDefinitionRequestQuerySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: str,
             order: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("order", order)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "hideTotal":
            suggest = "hide_total"
        elif key == "legendInline":
            suggest = "legend_inline"
        elif key == "legendTable":
            suggest = "legend_table"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionCustomLink']] = None,
                 hide_total: Optional[bool] = None,
                 legend_inline: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendInline'] = None,
                 legend_table: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendTable'] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetSunburstDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param bool hide_total: Whether or not to show the total value in the widget.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendInlineArgs' legend_inline: Used to configure the inline legend. Cannot be used in conjunction with legend*table.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendTableArgs' legend_table: Used to configure the table legend. Cannot be used in conjunction with legend*inline.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_links=custom_links,
            hide_total=hide_total,
            legend_inline=legend_inline,
            legend_table=legend_table,
            live_span=live_span,
            requests=requests,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionCustomLink']] = None,
             hide_total: Optional[bool] = None,
             legend_inline: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendInline'] = None,
             legend_table: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendTable'] = None,
             live_span: Optional[str] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequest']] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if hide_total is not None:
            _setter("hide_total", hide_total)
        if legend_inline is not None:
            _setter("legend_inline", legend_inline)
        if legend_table is not None:
            _setter("legend_table", legend_table)
        if live_span is not None:
            _setter("live_span", live_span)
        if requests is not None:
            _setter("requests", requests)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="hideTotal")
    def hide_total(self) -> Optional[bool]:
        """
        Whether or not to show the total value in the widget.
        """
        return pulumi.get(self, "hide_total")

    @property
    @pulumi.getter(name="legendInline")
    def legend_inline(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendInline']:
        """
        Used to configure the inline legend. Cannot be used in conjunction with legend*table.
        """
        return pulumi.get(self, "legend_inline")

    @property
    @pulumi.getter(name="legendTable")
    def legend_table(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendTable']:
        """
        Used to configure the table legend. Cannot be used in conjunction with legend*inline.
        """
        return pulumi.get(self, "legend_table")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendInline(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hidePercent":
            suggest = "hide_percent"
        elif key == "hideValue":
            suggest = "hide_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendInline. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendInline.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendInline.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 hide_percent: Optional[bool] = None,
                 hide_value: Optional[bool] = None):
        """
        :param str type: Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        :param bool hide_percent: Whether to hide the percentages of the groups.
        :param bool hide_value: Setting this to True hides values.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendInline._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            hide_percent=hide_percent,
            hide_value=hide_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             hide_percent: Optional[bool] = None,
             hide_value: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if hide_percent is not None:
            _setter("hide_percent", hide_percent)
        if hide_value is not None:
            _setter("hide_value", hide_value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="hidePercent")
    def hide_percent(self) -> Optional[bool]:
        """
        Whether to hide the percentages of the groups.
        """
        return pulumi.get(self, "hide_percent")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendTable(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionLegendTable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "auditQuery":
            suggest = "audit_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "networkQuery":
            suggest = "network_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQuery'] = None,
                 audit_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQuery'] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQuery'] = None,
                 network_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryArgs' audit_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryArgs' network_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_query=apm_query,
            audit_query=audit_query,
            formulas=formulas,
            log_query=log_query,
            network_query=network_query,
            process_query=process_query,
            q=q,
            queries=queries,
            rum_query=rum_query,
            security_query=security_query,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQuery'] = None,
             audit_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQuery'] = None,
             formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormula']] = None,
             log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQuery'] = None,
             network_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestProcessQuery'] = None,
             q: Optional[str] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuery']] = None,
             rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQuery'] = None,
             style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if audit_query is not None:
            _setter("audit_query", audit_query)
        if formulas is not None:
            _setter("formulas", formulas)
        if log_query is not None:
            _setter("log_query", log_query)
        if network_query is not None:
            _setter("network_query", network_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if queries is not None:
            _setter("queries", queries)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "network_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestAuditQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaLimitArgs' limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formula_expression=formula_expression,
            alias=alias,
            cell_display_mode=cell_display_mode,
            conditional_formats=conditional_formats,
            limit=limit,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formula_expression: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaConditionalFormat']] = None,
             limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaLimit'] = None,
             style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if limit is not None:
            _setter("limit", limit)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaLimit']:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestFormulaStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_index=palette_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             palette_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)
        if palette_index is not None:
            _setter("palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestNetworkQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        DashboardWidgetGroupDefinitionWidgetSunburstDefinitionRequestStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "legendColumns":
            suggest = "legend_columns"
        elif key == "legendLayout":
            suggest = "legend_layout"
        elif key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "rightYaxis":
            suggest = "right_yaxis"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink']] = None,
                 events: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent']] = None,
                 legend_columns: Optional[Sequence[str]] = None,
                 legend_layout: Optional[str] = None,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 markers: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker']] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest']] = None,
                 right_yaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis'] = None,
                 show_legend: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 yaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis'] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEventArgs'] events: The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        :param Sequence[str] legend_columns: A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
        :param str legend_layout: The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
        :param str legend_size: The size of the legend displayed in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarkerArgs'] markers: A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tile_def` block.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxisArgs' right_yaxis: A nested block describing the right Y-Axis Controls. See the `on_right_yaxis` property for which request will use this axis. The structure of this block is described below.
        :param bool show_legend: Whether or not to show the legend on this widget.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_links=custom_links,
            events=events,
            legend_columns=legend_columns,
            legend_layout=legend_layout,
            legend_size=legend_size,
            live_span=live_span,
            markers=markers,
            requests=requests,
            right_yaxis=right_yaxis,
            show_legend=show_legend,
            title=title,
            title_align=title_align,
            title_size=title_size,
            yaxis=yaxis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink']] = None,
             events: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent']] = None,
             legend_columns: Optional[Sequence[str]] = None,
             legend_layout: Optional[str] = None,
             legend_size: Optional[str] = None,
             live_span: Optional[str] = None,
             markers: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker']] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest']] = None,
             right_yaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis'] = None,
             show_legend: Optional[bool] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             yaxis: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if events is not None:
            _setter("events", events)
        if legend_columns is not None:
            _setter("legend_columns", legend_columns)
        if legend_layout is not None:
            _setter("legend_layout", legend_layout)
        if legend_size is not None:
            _setter("legend_size", legend_size)
        if live_span is not None:
            _setter("live_span", live_span)
        if markers is not None:
            _setter("markers", markers)
        if requests is not None:
            _setter("requests", requests)
        if right_yaxis is not None:
            _setter("right_yaxis", right_yaxis)
        if show_legend is not None:
            _setter("show_legend", show_legend)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)
        if yaxis is not None:
            _setter("yaxis", yaxis)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent']]:
        """
        The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="legendColumns")
    def legend_columns(self) -> Optional[Sequence[str]]:
        """
        A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
        """
        return pulumi.get(self, "legend_columns")

    @property
    @pulumi.getter(name="legendLayout")
    def legend_layout(self) -> Optional[str]:
        """
        The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
        """
        return pulumi.get(self, "legend_layout")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def markers(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker']]:
        """
        A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tile_def` block.
        """
        return pulumi.get(self, "markers")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="rightYaxis")
    def right_yaxis(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis']:
        """
        A nested block describing the right Y-Axis Controls. See the `on_right_yaxis` property for which request will use this axis. The structure of this block is described below.
        """
        return pulumi.get(self, "right_yaxis")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis']:
        """
        A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagsExecution":
            suggest = "tags_execution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 q: str,
                 tags_execution: Optional[str] = None):
        """
        :param str q: The metric query to use for this widget.
        :param str tags_execution: The execution method for multi-value filters, options: `and` or `or`.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionEvent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            q=q,
            tags_execution=tags_execution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             q: str,
             tags_execution: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("q", q)
        if tags_execution is not None:
            _setter("tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> str:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        """
        The execution method for multi-value filters, options: `and` or `or`.
        """
        return pulumi.get(self, "tags_execution")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayType":
            suggest = "display_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: str,
                 display_type: Optional[str] = None,
                 label: Optional[str] = None):
        """
        :param str value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str display_type: How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
        :param str label: The label for the custom link URL.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionMarker._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
            display_type=display_type,
            label=label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: str,
             display_type: Optional[str] = None,
             label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("value", value)
        if display_type is not None:
            _setter("display_type", display_type)
        if label is not None:
            _setter("label", label)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[str]:
        """
        How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
        """
        return pulumi.get(self, "display_type")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "auditQuery":
            suggest = "audit_query"
        elif key == "displayType":
            suggest = "display_type"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "networkQuery":
            suggest = "network_query"
        elif key == "onRightYaxis":
            suggest = "on_right_yaxis"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery'] = None,
                 audit_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQuery'] = None,
                 display_type: Optional[str] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery'] = None,
                 metadatas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata']] = None,
                 network_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery'] = None,
                 on_right_yaxis: Optional[bool] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryArgs' audit_query: The query to use for this widget.
        :param str display_type: How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadataArgs'] metadatas: Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryArgs' network_query: The query to use for this widget.
        :param bool on_right_yaxis: A Boolean indicating whether the request uses the right or left Y-Axis.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_query=apm_query,
            audit_query=audit_query,
            display_type=display_type,
            formulas=formulas,
            log_query=log_query,
            metadatas=metadatas,
            network_query=network_query,
            on_right_yaxis=on_right_yaxis,
            process_query=process_query,
            q=q,
            queries=queries,
            rum_query=rum_query,
            security_query=security_query,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery'] = None,
             audit_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQuery'] = None,
             display_type: Optional[str] = None,
             formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula']] = None,
             log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery'] = None,
             metadatas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata']] = None,
             network_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery'] = None,
             on_right_yaxis: Optional[bool] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery'] = None,
             q: Optional[str] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery']] = None,
             rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery'] = None,
             style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if audit_query is not None:
            _setter("audit_query", audit_query)
        if display_type is not None:
            _setter("display_type", display_type)
        if formulas is not None:
            _setter("formulas", formulas)
        if log_query is not None:
            _setter("log_query", log_query)
        if metadatas is not None:
            _setter("metadatas", metadatas)
        if network_query is not None:
            _setter("network_query", network_query)
        if on_right_yaxis is not None:
            _setter("on_right_yaxis", on_right_yaxis)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if queries is not None:
            _setter("queries", queries)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[str]:
        """
        How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
        """
        return pulumi.get(self, "display_type")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata']]:
        """
        Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "network_query")

    @property
    @pulumi.getter(name="onRightYaxis")
    def on_right_yaxis(self) -> Optional[bool]:
        """
        A Boolean indicating whether the request uses the right or left Y-Axis.
        """
        return pulumi.get(self, "on_right_yaxis")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimitArgs' limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formula_expression=formula_expression,
            alias=alias,
            cell_display_mode=cell_display_mode,
            conditional_formats=conditional_formats,
            limit=limit,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formula_expression: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaConditionalFormat']] = None,
             limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit'] = None,
             style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if limit is not None:
            _setter("limit", limit)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit']:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestFormulaStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_index=palette_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             palette_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)
        if palette_index is not None:
            _setter("palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasName":
            suggest = "alias_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 alias_name: Optional[str] = None):
        """
        :param str expression: The expression name.
        :param str alias_name: The expression alias.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestMetadata._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            alias_name=alias_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             alias_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        if alias_name is not None:
            _setter("alias_name", alias_name)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The expression name.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="aliasName")
    def alias_name(self) -> Optional[str]:
        """
        The expression alias.
        """
        return pulumi.get(self, "alias_name")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineType":
            suggest = "line_type"
        elif key == "lineWidth":
            suggest = "line_width"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 line_type: Optional[str] = None,
                 line_width: Optional[str] = None,
                 palette: Optional[str] = None):
        """
        :param str line_type: The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
        :param str line_width: The width of line displayed. Valid values are `normal`, `thick`, `thin`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRequestStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            line_type=line_type,
            line_width=line_width,
            palette=palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             line_type: Optional[str] = None,
             line_width: Optional[str] = None,
             palette: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if line_type is not None:
            _setter("line_type", line_type)
        if line_width is not None:
            _setter("line_width", line_width)
        if palette is not None:
            _setter("palette", palette)

    @property
    @pulumi.getter(name="lineType")
    def line_type(self) -> Optional[str]:
        """
        The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
        """
        return pulumi.get(self, "line_type")

    @property
    @pulumi.getter(name="lineWidth")
    def line_width(self) -> Optional[str]:
        """
        The width of line displayed. Valid values are `normal`, `thick`, `thin`.
        """
        return pulumi.get(self, "line_width")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label for the custom link URL.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionRightYaxis._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            include_zero=include_zero,
            label=label,
            max=max,
            min=min,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             include_zero: Optional[bool] = None,
             label: Optional[str] = None,
             max: Optional[str] = None,
             min: Optional[str] = None,
             scale: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if include_zero is not None:
            _setter("include_zero", include_zero)
        if label is not None:
            _setter("label", label)
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label for the custom link URL.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        DashboardWidgetGroupDefinitionWidgetTimeseriesDefinitionYaxis._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            include_zero=include_zero,
            label=label,
            max=max,
            min=min,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             include_zero: Optional[bool] = None,
             label: Optional[str] = None,
             max: Optional[str] = None,
             min: Optional[str] = None,
             scale: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if include_zero is not None:
            _setter("include_zero", include_zero)
        if label is not None:
            _setter("label", label)
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_links=custom_links,
            live_span=live_span,
            requests=requests,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink']] = None,
             live_span: Optional[str] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest']] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if live_span is not None:
            _setter("live_span", live_span)
        if requests is not None:
            _setter("requests", requests)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "auditQuery":
            suggest = "audit_query"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery'] = None,
                 audit_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQuery'] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat']] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryArgs' audit_query: The query to use for this widget.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_query=apm_query,
            audit_query=audit_query,
            conditional_formats=conditional_formats,
            formulas=formulas,
            log_query=log_query,
            process_query=process_query,
            q=q,
            queries=queries,
            rum_query=rum_query,
            security_query=security_query,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery'] = None,
             audit_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQuery'] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat']] = None,
             formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula']] = None,
             log_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery'] = None,
             q: Optional[str] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery']] = None,
             rum_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery'] = None,
             style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if audit_query is not None:
            _setter("audit_query", audit_query)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if formulas is not None:
            _setter("formulas", formulas)
        if log_query is not None:
            _setter("log_query", log_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if queries is not None:
            _setter("queries", queries)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestAuditQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimitArgs' limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formula_expression=formula_expression,
            alias=alias,
            cell_display_mode=cell_display_mode,
            conditional_formats=conditional_formats,
            limit=limit,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formula_expression: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaConditionalFormat']] = None,
             limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit'] = None,
             style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if limit is not None:
            _setter("limit", limit)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit']:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestFormulaStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_index=palette_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             palette_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)
        if palette_index is not None:
            _setter("palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        DashboardWidgetGroupDefinitionWidgetToplistDefinitionRequestStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTopologyMapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTopologyMapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTopologyMapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTopologyMapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionCustomLink']] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetTopologyMapDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_links=custom_links,
            requests=requests,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_links: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionCustomLink']] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequest']] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if requests is not None:
            _setter("requests", requests)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestType":
            suggest = "request_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queries: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequestQuery'],
                 request_type: str):
        """
        :param str request_type: The request type for the SLO List request. Valid values are `slo_list`.
        """
        DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            queries=queries,
            request_type=request_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             queries: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequestQuery'],
             request_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("queries", queries)
        _setter("request_type", request_type)

    @property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequestQuery']:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> str:
        """
        The request type for the SLO List request. Valid values are `slo_list`.
        """
        return pulumi.get(self, "request_type")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 filters: Sequence[str],
                 service: str):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param Sequence[str] filters: Your environment and primary tag (or `*` if enabled for your account).
        :param str service: APM service.
        """
        DashboardWidgetGroupDefinitionWidgetTopologyMapDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            filters=filters,
            service=service,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             filters: Sequence[str],
             service: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("filters", filters)
        _setter("service", service)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def filters(self) -> Sequence[str]:
        """
        Your environment and primary tag (or `*` if enabled for your account).
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spanName":
            suggest = "span_name"
        elif key == "displayFormat":
            suggest = "display_format"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showBreakdown":
            suggest = "show_breakdown"
        elif key == "showDistribution":
            suggest = "show_distribution"
        elif key == "showErrors":
            suggest = "show_errors"
        elif key == "showHits":
            suggest = "show_hits"
        elif key == "showLatency":
            suggest = "show_latency"
        elif key == "showResourceList":
            suggest = "show_resource_list"
        elif key == "sizeFormat":
            suggest = "size_format"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env: str,
                 service: str,
                 span_name: str,
                 display_format: Optional[str] = None,
                 live_span: Optional[str] = None,
                 show_breakdown: Optional[bool] = None,
                 show_distribution: Optional[bool] = None,
                 show_errors: Optional[bool] = None,
                 show_hits: Optional[bool] = None,
                 show_latency: Optional[bool] = None,
                 show_resource_list: Optional[bool] = None,
                 size_format: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str env: APM Environment.
        :param str service: APM service.
        :param str span_name: APM span name
        :param str display_format: The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param bool show_breakdown: Whether to show the latency breakdown or not.
        :param bool show_distribution: Whether to show the latency distribution or not.
        :param bool show_errors: Whether to show the error metrics or not.
        :param bool show_hits: Whether to show the hits metrics or not
        :param bool show_latency: Whether to show the latency metrics or not.
        :param bool show_resource_list: Whether to show the resource list or not.
        :param str size_format: The size of the widget. Valid values are `small`, `medium`, `large`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetGroupDefinitionWidgetTraceServiceDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            env=env,
            service=service,
            span_name=span_name,
            display_format=display_format,
            live_span=live_span,
            show_breakdown=show_breakdown,
            show_distribution=show_distribution,
            show_errors=show_errors,
            show_hits=show_hits,
            show_latency=show_latency,
            show_resource_list=show_resource_list,
            size_format=size_format,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             env: str,
             service: str,
             span_name: str,
             display_format: Optional[str] = None,
             live_span: Optional[str] = None,
             show_breakdown: Optional[bool] = None,
             show_distribution: Optional[bool] = None,
             show_errors: Optional[bool] = None,
             show_hits: Optional[bool] = None,
             show_latency: Optional[bool] = None,
             show_resource_list: Optional[bool] = None,
             size_format: Optional[str] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("env", env)
        _setter("service", service)
        _setter("span_name", span_name)
        if display_format is not None:
            _setter("display_format", display_format)
        if live_span is not None:
            _setter("live_span", live_span)
        if show_breakdown is not None:
            _setter("show_breakdown", show_breakdown)
        if show_distribution is not None:
            _setter("show_distribution", show_distribution)
        if show_errors is not None:
            _setter("show_errors", show_errors)
        if show_hits is not None:
            _setter("show_hits", show_hits)
        if show_latency is not None:
            _setter("show_latency", show_latency)
        if show_resource_list is not None:
            _setter("show_resource_list", show_resource_list)
        if size_format is not None:
            _setter("size_format", size_format)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="spanName")
    def span_name(self) -> str:
        """
        APM span name
        """
        return pulumi.get(self, "span_name")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        """
        The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
        """
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="showBreakdown")
    def show_breakdown(self) -> Optional[bool]:
        """
        Whether to show the latency breakdown or not.
        """
        return pulumi.get(self, "show_breakdown")

    @property
    @pulumi.getter(name="showDistribution")
    def show_distribution(self) -> Optional[bool]:
        """
        Whether to show the latency distribution or not.
        """
        return pulumi.get(self, "show_distribution")

    @property
    @pulumi.getter(name="showErrors")
    def show_errors(self) -> Optional[bool]:
        """
        Whether to show the error metrics or not.
        """
        return pulumi.get(self, "show_errors")

    @property
    @pulumi.getter(name="showHits")
    def show_hits(self) -> Optional[bool]:
        """
        Whether to show the hits metrics or not
        """
        return pulumi.get(self, "show_hits")

    @property
    @pulumi.getter(name="showLatency")
    def show_latency(self) -> Optional[bool]:
        """
        Whether to show the latency metrics or not.
        """
        return pulumi.get(self, "show_latency")

    @property
    @pulumi.getter(name="showResourceList")
    def show_resource_list(self) -> Optional[bool]:
        """
        Whether to show the resource list or not.
        """
        return pulumi.get(self, "show_resource_list")

    @property
    @pulumi.getter(name="sizeFormat")
    def size_format(self) -> Optional[str]:
        """
        The size of the widget. Valid values are `small`, `medium`, `large`.
        """
        return pulumi.get(self, "size_format")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTreemapDefinition(dict):
    def __init__(__self__, *,
                 requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequest']] = None,
                 title: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        """
        DashboardWidgetGroupDefinitionWidgetTreemapDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            requests=requests,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             requests: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequest']] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if requests is not None:
            _setter("requests", requests)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequest(dict):
    def __init__(__self__, *,
                 formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormula']] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuery']] = None):
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formulas=formulas,
            queries=queries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formulas: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormula']] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuery']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if formulas is not None:
            _setter("formulas", formulas)
        if queries is not None:
            _setter("queries", queries)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaLimitArgs' limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formula_expression=formula_expression,
            alias=alias,
            cell_display_mode=cell_display_mode,
            conditional_formats=conditional_formats,
            limit=limit,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formula_expression: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaConditionalFormat']] = None,
             limit: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaLimit'] = None,
             style: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if limit is not None:
            _setter("limit", limit)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaLimit']:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestFormulaStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_index=palette_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             palette_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)
        if palette_index is not None:
            _setter("palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetGroupDefinitionWidgetTreemapDefinitionRequestQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetWidgetLayout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isColumnBreak":
            suggest = "is_column_break"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetWidgetLayout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetWidgetLayout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetWidgetLayout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 height: int,
                 width: int,
                 x: int,
                 y: int,
                 is_column_break: Optional[bool] = None):
        """
        :param int height: The height of the widget.
        :param int width: Widget column width. Valid values are `auto`, `compact`, `full`.
        :param int x: The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        :param int y: The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        :param bool is_column_break: Whether the widget should be the first one on the second column in high density or not. Only for the new dashboard layout and only one widget in the dashboard should have this property set to `true`.
        """
        DashboardWidgetGroupDefinitionWidgetWidgetLayout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            height=height,
            width=width,
            x=x,
            y=y,
            is_column_break=is_column_break,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             height: int,
             width: int,
             x: int,
             y: int,
             is_column_break: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("height", height)
        _setter("width", width)
        _setter("x", x)
        _setter("y", y)
        if is_column_break is not None:
            _setter("is_column_break", is_column_break)

    @property
    @pulumi.getter
    def height(self) -> int:
        """
        The height of the widget.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> int:
        """
        Widget column width. Valid values are `auto`, `compact`, `full`.
        """
        return pulumi.get(self, "width")

    @property
    @pulumi.getter
    def x(self) -> int:
        """
        The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> int:
        """
        The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        return pulumi.get(self, "y")

    @property
    @pulumi.getter(name="isColumnBreak")
    def is_column_break(self) -> Optional[bool]:
        """
        Whether the widget should be the first one on the second column in high density or not. Only for the new dashboard layout and only one widget in the dashboard should have this property set to `true`.
        """
        return pulumi.get(self, "is_column_break")


@pulumi.output_type
class DashboardWidgetHeatmapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionCustomLink']] = None,
                 events: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionEvent']] = None,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 yaxis: Optional['outputs.DashboardWidgetHeatmapDefinitionYaxis'] = None):
        """
        :param Sequence['DashboardWidgetHeatmapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetHeatmapDefinitionEventArgs'] events: The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        :param str legend_size: The size of the legend displayed in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence['DashboardWidgetHeatmapDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param bool show_legend: Whether or not to show the legend on this widget.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param 'DashboardWidgetHeatmapDefinitionYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        DashboardWidgetHeatmapDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_links=custom_links,
            events=events,
            legend_size=legend_size,
            live_span=live_span,
            requests=requests,
            show_legend=show_legend,
            title=title,
            title_align=title_align,
            title_size=title_size,
            yaxis=yaxis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_links: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionCustomLink']] = None,
             events: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionEvent']] = None,
             legend_size: Optional[str] = None,
             live_span: Optional[str] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequest']] = None,
             show_legend: Optional[bool] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             yaxis: Optional['outputs.DashboardWidgetHeatmapDefinitionYaxis'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if events is not None:
            _setter("events", events)
        if legend_size is not None:
            _setter("legend_size", legend_size)
        if live_span is not None:
            _setter("live_span", live_span)
        if requests is not None:
            _setter("requests", requests)
        if show_legend is not None:
            _setter("show_legend", show_legend)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)
        if yaxis is not None:
            _setter("yaxis", yaxis)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionEvent']]:
        """
        The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionYaxis']:
        """
        A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetHeatmapDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagsExecution":
            suggest = "tags_execution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 q: str,
                 tags_execution: Optional[str] = None):
        """
        :param str q: The metric query to use for this widget.
        :param str tags_execution: The execution method for multi-value filters, options: `and` or `or`.
        """
        DashboardWidgetHeatmapDefinitionEvent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            q=q,
            tags_execution=tags_execution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             q: str,
             tags_execution: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("q", q)
        if tags_execution is not None:
            _setter("tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> str:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        """
        The execution method for multi-value filters, options: `and` or `or`.
        """
        return pulumi.get(self, "tags_execution")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetHeatmapDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetHeatmapDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetHeatmapDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetHeatmapDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetHeatmapDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'DashboardWidgetHeatmapDefinitionRequestStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetHeatmapDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_query=apm_query,
            log_query=log_query,
            process_query=process_query,
            q=q,
            rum_query=rum_query,
            security_query=security_query,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQuery'] = None,
             log_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestProcessQuery'] = None,
             q: Optional[str] = None,
             rum_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQuery'] = None,
             style: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if log_query is not None:
            _setter("log_query", log_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetHeatmapDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetHeatmapDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetHeatmapDefinitionRequestApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHeatmapDefinitionRequestApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHeatmapDefinitionRequestApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetHeatmapDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetHeatmapDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetHeatmapDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHeatmapDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHeatmapDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetHeatmapDefinitionRequestProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetHeatmapDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetHeatmapDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetHeatmapDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHeatmapDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHeatmapDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetHeatmapDefinitionRequestSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        DashboardWidgetHeatmapDefinitionRequestStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label for the custom link URL.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        DashboardWidgetHeatmapDefinitionYaxis._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            include_zero=include_zero,
            label=label,
            max=max,
            min=min,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             include_zero: Optional[bool] = None,
             label: Optional[str] = None,
             max: Optional[str] = None,
             min: Optional[str] = None,
             scale: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if include_zero is not None:
            _setter("include_zero", include_zero)
        if label is not None:
            _setter("label", label)
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetHostmapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "noGroupHosts":
            suggest = "no_group_hosts"
        elif key == "noMetricHosts":
            suggest = "no_metric_hosts"
        elif key == "nodeType":
            suggest = "node_type"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionCustomLink']] = None,
                 groups: Optional[Sequence[str]] = None,
                 no_group_hosts: Optional[bool] = None,
                 no_metric_hosts: Optional[bool] = None,
                 node_type: Optional[str] = None,
                 request: Optional['outputs.DashboardWidgetHostmapDefinitionRequest'] = None,
                 scopes: Optional[Sequence[str]] = None,
                 style: Optional['outputs.DashboardWidgetHostmapDefinitionStyle'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetHostmapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence[str] groups: The check group to use in the widget.
        :param bool no_group_hosts: A Boolean indicating whether to show ungrouped nodes.
        :param bool no_metric_hosts: A Boolean indicating whether to show nodes with no metrics.
        :param str node_type: The type of node used. Valid values are `host`, `container`.
        :param 'DashboardWidgetHostmapDefinitionRequestArgs' request: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param Sequence[str] scopes: The list of tags to filter nodes by.
        :param 'DashboardWidgetHostmapDefinitionStyleArgs' style: Styling options for widget formulas.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetHostmapDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_links=custom_links,
            groups=groups,
            no_group_hosts=no_group_hosts,
            no_metric_hosts=no_metric_hosts,
            node_type=node_type,
            request=request,
            scopes=scopes,
            style=style,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_links: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionCustomLink']] = None,
             groups: Optional[Sequence[str]] = None,
             no_group_hosts: Optional[bool] = None,
             no_metric_hosts: Optional[bool] = None,
             node_type: Optional[str] = None,
             request: Optional['outputs.DashboardWidgetHostmapDefinitionRequest'] = None,
             scopes: Optional[Sequence[str]] = None,
             style: Optional['outputs.DashboardWidgetHostmapDefinitionStyle'] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if groups is not None:
            _setter("groups", groups)
        if no_group_hosts is not None:
            _setter("no_group_hosts", no_group_hosts)
        if no_metric_hosts is not None:
            _setter("no_metric_hosts", no_metric_hosts)
        if node_type is not None:
            _setter("node_type", node_type)
        if request is not None:
            _setter("request", request)
        if scopes is not None:
            _setter("scopes", scopes)
        if style is not None:
            _setter("style", style)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="noGroupHosts")
    def no_group_hosts(self) -> Optional[bool]:
        """
        A Boolean indicating whether to show ungrouped nodes.
        """
        return pulumi.get(self, "no_group_hosts")

    @property
    @pulumi.getter(name="noMetricHosts")
    def no_metric_hosts(self) -> Optional[bool]:
        """
        A Boolean indicating whether to show nodes with no metrics.
        """
        return pulumi.get(self, "no_metric_hosts")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[str]:
        """
        The type of node used. Valid values are `host`, `container`.
        """
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequest']:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        The list of tags to filter nodes by.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetHostmapDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequest(dict):
    def __init__(__self__, *,
                 fills: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFill']] = None,
                 sizes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSize']] = None):
        """
        :param Sequence['DashboardWidgetHostmapDefinitionRequestFillArgs'] fills: The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param Sequence['DashboardWidgetHostmapDefinitionRequestSizeArgs'] sizes: The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        DashboardWidgetHostmapDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fills=fills,
            sizes=sizes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fills: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFill']] = None,
             sizes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSize']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if fills is not None:
            _setter("fills", fills)
        if sizes is not None:
            _setter("sizes", sizes)

    @property
    @pulumi.getter
    def fills(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFill']]:
        """
        The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "fills")

    @property
    @pulumi.getter
    def sizes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSize']]:
        """
        The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "sizes")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFill(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFill. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFill.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFill.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQuery'] = None):
        """
        :param 'DashboardWidgetHostmapDefinitionRequestFillApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetHostmapDefinitionRequestFillLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetHostmapDefinitionRequestFillProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetHostmapDefinitionRequestFillRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetHostmapDefinitionRequestFillSecurityQueryArgs' security_query: The query to use for this widget.
        """
        DashboardWidgetHostmapDefinitionRequestFill._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_query=apm_query,
            log_query=log_query,
            process_query=process_query,
            q=q,
            rum_query=rum_query,
            security_query=security_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQuery'] = None,
             log_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillProcessQuery'] = None,
             q: Optional[str] = None,
             rum_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if log_query is not None:
            _setter("log_query", log_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetHostmapDefinitionRequestFillApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHostmapDefinitionRequestFillApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHostmapDefinitionRequestFillApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetHostmapDefinitionRequestFillLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHostmapDefinitionRequestFillLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHostmapDefinitionRequestFillLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetHostmapDefinitionRequestFillProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetHostmapDefinitionRequestFillRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHostmapDefinitionRequestFillRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHostmapDefinitionRequestFillRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetHostmapDefinitionRequestFillSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSize(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSize. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSize.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSize.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery'] = None):
        """
        :param 'DashboardWidgetHostmapDefinitionRequestSizeApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetHostmapDefinitionRequestSizeLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetHostmapDefinitionRequestSizeProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetHostmapDefinitionRequestSizeRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryArgs' security_query: The query to use for this widget.
        """
        DashboardWidgetHostmapDefinitionRequestSize._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_query=apm_query,
            log_query=log_query,
            process_query=process_query,
            q=q,
            rum_query=rum_query,
            security_query=security_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQuery'] = None,
             log_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeProcessQuery'] = None,
             q: Optional[str] = None,
             rum_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if log_query is not None:
            _setter("log_query", log_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetHostmapDefinitionRequestSizeApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetHostmapDefinitionRequestSizeLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetHostmapDefinitionRequestSizeProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetHostmapDefinitionRequestSizeRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetHostmapDefinitionRequestSizeSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fillMax":
            suggest = "fill_max"
        elif key == "fillMin":
            suggest = "fill_min"
        elif key == "paletteFlip":
            suggest = "palette_flip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fill_max: Optional[str] = None,
                 fill_min: Optional[str] = None,
                 palette: Optional[str] = None,
                 palette_flip: Optional[bool] = None):
        """
        :param str fill_max: The max value to use to color the map.
        :param str fill_min: The min value to use to color the map.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param bool palette_flip: A Boolean indicating whether to flip the palette tones.
        """
        DashboardWidgetHostmapDefinitionStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            fill_max=fill_max,
            fill_min=fill_min,
            palette=palette,
            palette_flip=palette_flip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             fill_max: Optional[str] = None,
             fill_min: Optional[str] = None,
             palette: Optional[str] = None,
             palette_flip: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if fill_max is not None:
            _setter("fill_max", fill_max)
        if fill_min is not None:
            _setter("fill_min", fill_min)
        if palette is not None:
            _setter("palette", palette)
        if palette_flip is not None:
            _setter("palette_flip", palette_flip)

    @property
    @pulumi.getter(name="fillMax")
    def fill_max(self) -> Optional[str]:
        """
        The max value to use to color the map.
        """
        return pulumi.get(self, "fill_max")

    @property
    @pulumi.getter(name="fillMin")
    def fill_min(self) -> Optional[str]:
        """
        The min value to use to color the map.
        """
        return pulumi.get(self, "fill_min")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> Optional[bool]:
        """
        A Boolean indicating whether to flip the palette tones.
        """
        return pulumi.get(self, "palette_flip")


@pulumi.output_type
class DashboardWidgetIframeDefinition(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: The URL to use as a data source for the widget.
        """
        DashboardWidgetIframeDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL to use as a data source for the widget.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class DashboardWidgetImageDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hasBackground":
            suggest = "has_background"
        elif key == "hasBorder":
            suggest = "has_border"
        elif key == "horizontalAlign":
            suggest = "horizontal_align"
        elif key == "urlDarkTheme":
            suggest = "url_dark_theme"
        elif key == "verticalAlign":
            suggest = "vertical_align"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetImageDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetImageDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetImageDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 has_background: Optional[bool] = None,
                 has_border: Optional[bool] = None,
                 horizontal_align: Optional[str] = None,
                 margin: Optional[str] = None,
                 sizing: Optional[str] = None,
                 url_dark_theme: Optional[str] = None,
                 vertical_align: Optional[str] = None):
        """
        :param str url: The URL to use as a data source for the widget.
        :param bool has_background: Whether to display a background or not.
        :param bool has_border: Whether to display a border or not.
        :param str horizontal_align: The horizontal alignment for the widget. Valid values are `center`, `left`, `right`.
        :param str margin: The margins to use around the image. Note: `small` and `large` values are deprecated. Valid values are `sm`, `md`, `lg`, `small`, `large`.
        :param str sizing: The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated. Valid values are `fill`, `contain`, `cover`, `none`, `scale-down`, `zoom`, `fit`, `center`.
        :param str url_dark_theme: The URL in dark mode to use as a data source for the widget.
        :param str vertical_align: The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        DashboardWidgetImageDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            has_background=has_background,
            has_border=has_border,
            horizontal_align=horizontal_align,
            margin=margin,
            sizing=sizing,
            url_dark_theme=url_dark_theme,
            vertical_align=vertical_align,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: str,
             has_background: Optional[bool] = None,
             has_border: Optional[bool] = None,
             horizontal_align: Optional[str] = None,
             margin: Optional[str] = None,
             sizing: Optional[str] = None,
             url_dark_theme: Optional[str] = None,
             vertical_align: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("url", url)
        if has_background is not None:
            _setter("has_background", has_background)
        if has_border is not None:
            _setter("has_border", has_border)
        if horizontal_align is not None:
            _setter("horizontal_align", horizontal_align)
        if margin is not None:
            _setter("margin", margin)
        if sizing is not None:
            _setter("sizing", sizing)
        if url_dark_theme is not None:
            _setter("url_dark_theme", url_dark_theme)
        if vertical_align is not None:
            _setter("vertical_align", vertical_align)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL to use as a data source for the widget.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="hasBackground")
    def has_background(self) -> Optional[bool]:
        """
        Whether to display a background or not.
        """
        return pulumi.get(self, "has_background")

    @property
    @pulumi.getter(name="hasBorder")
    def has_border(self) -> Optional[bool]:
        """
        Whether to display a border or not.
        """
        return pulumi.get(self, "has_border")

    @property
    @pulumi.getter(name="horizontalAlign")
    def horizontal_align(self) -> Optional[str]:
        """
        The horizontal alignment for the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "horizontal_align")

    @property
    @pulumi.getter
    def margin(self) -> Optional[str]:
        """
        The margins to use around the image. Note: `small` and `large` values are deprecated. Valid values are `sm`, `md`, `lg`, `small`, `large`.
        """
        return pulumi.get(self, "margin")

    @property
    @pulumi.getter
    def sizing(self) -> Optional[str]:
        """
        The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated. Valid values are `fill`, `contain`, `cover`, `none`, `scale-down`, `zoom`, `fit`, `center`.
        """
        return pulumi.get(self, "sizing")

    @property
    @pulumi.getter(name="urlDarkTheme")
    def url_dark_theme(self) -> Optional[str]:
        """
        The URL in dark mode to use as a data source for the widget.
        """
        return pulumi.get(self, "url_dark_theme")

    @property
    @pulumi.getter(name="verticalAlign")
    def vertical_align(self) -> Optional[str]:
        """
        The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        return pulumi.get(self, "vertical_align")


@pulumi.output_type
class DashboardWidgetListStreamDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetListStreamDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetListStreamDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetListStreamDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 requests: Sequence['outputs.DashboardWidgetListStreamDefinitionRequest'],
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetListStreamDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetListStreamDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            requests=requests,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             requests: Sequence['outputs.DashboardWidgetListStreamDefinitionRequest'],
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("requests", requests)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> Sequence['outputs.DashboardWidgetListStreamDefinitionRequest']:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetListStreamDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseFormat":
            suggest = "response_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetListStreamDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetListStreamDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetListStreamDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Sequence['outputs.DashboardWidgetListStreamDefinitionRequestColumn'],
                 query: 'outputs.DashboardWidgetListStreamDefinitionRequestQuery',
                 response_format: str):
        """
        :param Sequence['DashboardWidgetListStreamDefinitionRequestColumnArgs'] columns: Column properties used by the front end for display.
        :param str response_format: Widget response format. Valid values are `event_list`.
        """
        DashboardWidgetListStreamDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            query=query,
            response_format=response_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Sequence['outputs.DashboardWidgetListStreamDefinitionRequestColumn'],
             query: 'outputs.DashboardWidgetListStreamDefinitionRequestQuery',
             response_format: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("columns", columns)
        _setter("query", query)
        _setter("response_format", response_format)

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.DashboardWidgetListStreamDefinitionRequestColumn']:
        """
        Column properties used by the front end for display.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def query(self) -> 'outputs.DashboardWidgetListStreamDefinitionRequestQuery':
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="responseFormat")
    def response_format(self) -> str:
        """
        Widget response format. Valid values are `event_list`.
        """
        return pulumi.get(self, "response_format")


@pulumi.output_type
class DashboardWidgetListStreamDefinitionRequestColumn(dict):
    def __init__(__self__, *,
                 field: str,
                 width: str):
        """
        :param str field: Widget column field.
        :param str width: Widget column width. Valid values are `auto`, `compact`, `full`.
        """
        DashboardWidgetListStreamDefinitionRequestColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            field=field,
            width=width,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             field: str,
             width: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("field", field)
        _setter("width", width)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Widget column field.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def width(self) -> str:
        """
        Widget column width. Valid values are `auto`, `compact`, `full`.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class DashboardWidgetListStreamDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "eventSize":
            suggest = "event_size"
        elif key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetListStreamDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetListStreamDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetListStreamDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 event_size: Optional[str] = None,
                 indexes: Optional[Sequence[str]] = None,
                 query_string: Optional[str] = None,
                 sort: Optional['outputs.DashboardWidgetListStreamDefinitionRequestQuerySort'] = None,
                 storage: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str event_size: The size to use to display an event. Valid values are `s`, `l`.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param str query_string: Widget query.
        :param 'DashboardWidgetListStreamDefinitionRequestQuerySortArgs' sort: The options for sorting group by results.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetListStreamDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            event_size=event_size,
            indexes=indexes,
            query_string=query_string,
            sort=sort,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             event_size: Optional[str] = None,
             indexes: Optional[Sequence[str]] = None,
             query_string: Optional[str] = None,
             sort: Optional['outputs.DashboardWidgetListStreamDefinitionRequestQuerySort'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        if event_size is not None:
            _setter("event_size", event_size)
        if indexes is not None:
            _setter("indexes", indexes)
        if query_string is not None:
            _setter("query_string", query_string)
        if sort is not None:
            _setter("sort", sort)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[str]:
        """
        The size to use to display an event. Valid values are `s`, `l`.
        """
        return pulumi.get(self, "event_size")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[str]:
        """
        Widget query.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetListStreamDefinitionRequestQuerySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetListStreamDefinitionRequestQuerySort(dict):
    def __init__(__self__, *,
                 column: str,
                 order: str):
        """
        :param str column: The facet path for the column.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetListStreamDefinitionRequestQuerySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: str,
             order: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("order", order)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetLogStreamDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"
        elif key == "messageDisplay":
            suggest = "message_display"
        elif key == "showDateColumn":
            suggest = "show_date_column"
        elif key == "showMessageColumn":
            suggest = "show_message_column"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetLogStreamDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetLogStreamDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetLogStreamDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Optional[Sequence[str]] = None,
                 indexes: Optional[Sequence[str]] = None,
                 live_span: Optional[str] = None,
                 message_display: Optional[str] = None,
                 query: Optional[str] = None,
                 show_date_column: Optional[bool] = None,
                 show_message_column: Optional[bool] = None,
                 sort: Optional['outputs.DashboardWidgetLogStreamDefinitionSort'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence[str] columns: Column properties used by the front end for display.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param str message_display: The number of log lines to display. Valid values are `inline`, `expanded-md`, `expanded-lg`.
        :param bool show_date_column: If the date column should be displayed.
        :param bool show_message_column: If the message column should be displayed.
        :param 'DashboardWidgetLogStreamDefinitionSortArgs' sort: The options for sorting group by results.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetLogStreamDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            columns=columns,
            indexes=indexes,
            live_span=live_span,
            message_display=message_display,
            query=query,
            show_date_column=show_date_column,
            show_message_column=show_message_column,
            sort=sort,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             columns: Optional[Sequence[str]] = None,
             indexes: Optional[Sequence[str]] = None,
             live_span: Optional[str] = None,
             message_display: Optional[str] = None,
             query: Optional[str] = None,
             show_date_column: Optional[bool] = None,
             show_message_column: Optional[bool] = None,
             sort: Optional['outputs.DashboardWidgetLogStreamDefinitionSort'] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if columns is not None:
            _setter("columns", columns)
        if indexes is not None:
            _setter("indexes", indexes)
        if live_span is not None:
            _setter("live_span", live_span)
        if message_display is not None:
            _setter("message_display", message_display)
        if query is not None:
            _setter("query", query)
        if show_date_column is not None:
            _setter("show_date_column", show_date_column)
        if show_message_column is not None:
            _setter("show_message_column", show_message_column)
        if sort is not None:
            _setter("sort", sort)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence[str]]:
        """
        Column properties used by the front end for display.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="messageDisplay")
    def message_display(self) -> Optional[str]:
        """
        The number of log lines to display. Valid values are `inline`, `expanded-md`, `expanded-lg`.
        """
        return pulumi.get(self, "message_display")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="showDateColumn")
    def show_date_column(self) -> Optional[bool]:
        """
        If the date column should be displayed.
        """
        return pulumi.get(self, "show_date_column")

    @property
    @pulumi.getter(name="showMessageColumn")
    def show_message_column(self) -> Optional[bool]:
        """
        If the message column should be displayed.
        """
        return pulumi.get(self, "show_message_column")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetLogStreamDefinitionSort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetLogStreamDefinitionSort(dict):
    def __init__(__self__, *,
                 column: str,
                 order: str):
        """
        :param str column: The facet path for the column.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetLogStreamDefinitionSort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: str,
             order: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("order", order)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetManageStatusDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorPreference":
            suggest = "color_preference"
        elif key == "displayFormat":
            suggest = "display_format"
        elif key == "hideZeroCounts":
            suggest = "hide_zero_counts"
        elif key == "showLastTriggered":
            suggest = "show_last_triggered"
        elif key == "showPriority":
            suggest = "show_priority"
        elif key == "summaryType":
            suggest = "summary_type"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetManageStatusDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetManageStatusDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetManageStatusDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 color_preference: Optional[str] = None,
                 display_format: Optional[str] = None,
                 hide_zero_counts: Optional[bool] = None,
                 show_last_triggered: Optional[bool] = None,
                 show_priority: Optional[bool] = None,
                 sort: Optional[str] = None,
                 summary_type: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str color_preference: Whether to colorize text or background. Valid values are `background`, `text`.
        :param str display_format: The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
        :param bool hide_zero_counts: A Boolean indicating whether to hide empty categories.
        :param bool show_last_triggered: A Boolean indicating whether to show when monitors/groups last triggered.
        :param bool show_priority: Whether to show the priorities column.
        :param str sort: The options for sorting group by results.
        :param str summary_type: The summary type to use. Valid values are `monitors`, `groups`, `combined`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetManageStatusDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
            color_preference=color_preference,
            display_format=display_format,
            hide_zero_counts=hide_zero_counts,
            show_last_triggered=show_last_triggered,
            show_priority=show_priority,
            sort=sort,
            summary_type=summary_type,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             color_preference: Optional[str] = None,
             display_format: Optional[str] = None,
             hide_zero_counts: Optional[bool] = None,
             show_last_triggered: Optional[bool] = None,
             show_priority: Optional[bool] = None,
             sort: Optional[str] = None,
             summary_type: Optional[str] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)
        if color_preference is not None:
            _setter("color_preference", color_preference)
        if display_format is not None:
            _setter("display_format", display_format)
        if hide_zero_counts is not None:
            _setter("hide_zero_counts", hide_zero_counts)
        if show_last_triggered is not None:
            _setter("show_last_triggered", show_last_triggered)
        if show_priority is not None:
            _setter("show_priority", show_priority)
        if sort is not None:
            _setter("sort", sort)
        if summary_type is not None:
            _setter("summary_type", summary_type)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="colorPreference")
    def color_preference(self) -> Optional[str]:
        """
        Whether to colorize text or background. Valid values are `background`, `text`.
        """
        return pulumi.get(self, "color_preference")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        """
        The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
        """
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter(name="hideZeroCounts")
    def hide_zero_counts(self) -> Optional[bool]:
        """
        A Boolean indicating whether to hide empty categories.
        """
        return pulumi.get(self, "hide_zero_counts")

    @property
    @pulumi.getter(name="showLastTriggered")
    def show_last_triggered(self) -> Optional[bool]:
        """
        A Boolean indicating whether to show when monitors/groups last triggered.
        """
        return pulumi.get(self, "show_last_triggered")

    @property
    @pulumi.getter(name="showPriority")
    def show_priority(self) -> Optional[bool]:
        """
        Whether to show the priorities column.
        """
        return pulumi.get(self, "show_priority")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="summaryType")
    def summary_type(self) -> Optional[str]:
        """
        The summary type to use. Valid values are `monitors`, `groups`, `combined`.
        """
        return pulumi.get(self, "summary_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetNoteDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "hasPadding":
            suggest = "has_padding"
        elif key == "showTick":
            suggest = "show_tick"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "tickEdge":
            suggest = "tick_edge"
        elif key == "tickPos":
            suggest = "tick_pos"
        elif key == "verticalAlign":
            suggest = "vertical_align"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetNoteDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetNoteDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetNoteDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: str,
                 background_color: Optional[str] = None,
                 font_size: Optional[str] = None,
                 has_padding: Optional[bool] = None,
                 show_tick: Optional[bool] = None,
                 text_align: Optional[str] = None,
                 tick_edge: Optional[str] = None,
                 tick_pos: Optional[str] = None,
                 vertical_align: Optional[str] = None):
        """
        :param str content: The content of the note.
        :param str background_color: The background color of the group title, options: `vivid_blue`, `vivid_purple`, `vivid_pink`, `vivid_orange`, `vivid_yellow`, `vivid_green`, `blue`, `purple`, `pink`, `orange`, `yellow`, `green`, `gray` or `white`
        :param str font_size: The size of the text in the widget.
        :param bool has_padding: Whether to add padding or not.
        :param bool show_tick: Whether to show a tick or not.
        :param str text_align: The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        :param str tick_edge: When `tick = true`, a string indicating on which side of the widget the tick should be displayed. Valid values are `bottom`, `left`, `right`, `top`.
        :param str tick_pos: When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tick_pos = "50%"` is centered alignment.
        :param str vertical_align: The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        DashboardWidgetNoteDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            background_color=background_color,
            font_size=font_size,
            has_padding=has_padding,
            show_tick=show_tick,
            text_align=text_align,
            tick_edge=tick_edge,
            tick_pos=tick_pos,
            vertical_align=vertical_align,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: str,
             background_color: Optional[str] = None,
             font_size: Optional[str] = None,
             has_padding: Optional[bool] = None,
             show_tick: Optional[bool] = None,
             text_align: Optional[str] = None,
             tick_edge: Optional[str] = None,
             tick_pos: Optional[str] = None,
             vertical_align: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("content", content)
        if background_color is not None:
            _setter("background_color", background_color)
        if font_size is not None:
            _setter("font_size", font_size)
        if has_padding is not None:
            _setter("has_padding", has_padding)
        if show_tick is not None:
            _setter("show_tick", show_tick)
        if text_align is not None:
            _setter("text_align", text_align)
        if tick_edge is not None:
            _setter("tick_edge", tick_edge)
        if tick_pos is not None:
            _setter("tick_pos", tick_pos)
        if vertical_align is not None:
            _setter("vertical_align", vertical_align)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The content of the note.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        """
        The background color of the group title, options: `vivid_blue`, `vivid_purple`, `vivid_pink`, `vivid_orange`, `vivid_yellow`, `vivid_green`, `blue`, `purple`, `pink`, `orange`, `yellow`, `green`, `gray` or `white`
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="hasPadding")
    def has_padding(self) -> Optional[bool]:
        """
        Whether to add padding or not.
        """
        return pulumi.get(self, "has_padding")

    @property
    @pulumi.getter(name="showTick")
    def show_tick(self) -> Optional[bool]:
        """
        Whether to show a tick or not.
        """
        return pulumi.get(self, "show_tick")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter(name="tickEdge")
    def tick_edge(self) -> Optional[str]:
        """
        When `tick = true`, a string indicating on which side of the widget the tick should be displayed. Valid values are `bottom`, `left`, `right`, `top`.
        """
        return pulumi.get(self, "tick_edge")

    @property
    @pulumi.getter(name="tickPos")
    def tick_pos(self) -> Optional[str]:
        """
        When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tick_pos = "50%"` is centered alignment.
        """
        return pulumi.get(self, "tick_pos")

    @property
    @pulumi.getter(name="verticalAlign")
    def vertical_align(self) -> Optional[str]:
        """
        The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        return pulumi.get(self, "vertical_align")


@pulumi.output_type
class DashboardWidgetQueryTableDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "hasSearchBar":
            suggest = "has_search_bar"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionCustomLink']] = None,
                 has_search_bar: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetQueryTableDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str has_search_bar: Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetQueryTableDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_links=custom_links,
            has_search_bar=has_search_bar,
            live_span=live_span,
            requests=requests,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_links: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionCustomLink']] = None,
             has_search_bar: Optional[str] = None,
             live_span: Optional[str] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequest']] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if has_search_bar is not None:
            _setter("has_search_bar", has_search_bar)
        if live_span is not None:
            _setter("live_span", live_span)
        if requests is not None:
            _setter("requests", requests)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="hasSearchBar")
    def has_search_bar(self) -> Optional[str]:
        """
        Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
        """
        return pulumi.get(self, "has_search_bar")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetQueryTableDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "apmStatsQuery":
            suggest = "apm_stats_query"
        elif key == "cellDisplayModes":
            suggest = "cell_display_modes"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 alias: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQuery'] = None,
                 apm_stats_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQuery'] = None,
                 cell_display_modes: Optional[Sequence[str]] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestConditionalFormat']] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestFormula']] = None,
                 limit: Optional[int] = None,
                 log_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQuery'] = None,
                 order: Optional[str] = None,
                 process_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQuery'] = None):
        """
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str alias: An expression alias.
        :param 'DashboardWidgetQueryTableDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param Sequence[str] cell_display_modes: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetQueryTableDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param 'DashboardWidgetQueryTableDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetQueryTableDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetQueryTableDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        """
        DashboardWidgetQueryTableDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregator=aggregator,
            alias=alias,
            apm_query=apm_query,
            apm_stats_query=apm_stats_query,
            cell_display_modes=cell_display_modes,
            conditional_formats=conditional_formats,
            formulas=formulas,
            limit=limit,
            log_query=log_query,
            order=order,
            process_query=process_query,
            q=q,
            queries=queries,
            rum_query=rum_query,
            security_query=security_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregator: Optional[str] = None,
             alias: Optional[str] = None,
             apm_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQuery'] = None,
             apm_stats_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQuery'] = None,
             cell_display_modes: Optional[Sequence[str]] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestConditionalFormat']] = None,
             formulas: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestFormula']] = None,
             limit: Optional[int] = None,
             log_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQuery'] = None,
             order: Optional[str] = None,
             process_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestProcessQuery'] = None,
             q: Optional[str] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestQuery']] = None,
             rum_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if alias is not None:
            _setter("alias", alias)
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if apm_stats_query is not None:
            _setter("apm_stats_query", apm_stats_query)
        if cell_display_modes is not None:
            _setter("cell_display_modes", cell_display_modes)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if formulas is not None:
            _setter("formulas", formulas)
        if limit is not None:
            _setter("limit", limit)
        if log_query is not None:
            _setter("log_query", log_query)
        if order is not None:
            _setter("order", order)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if queries is not None:
            _setter("queries", queries)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="apmStatsQuery")
    def apm_stats_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQuery']:
        return pulumi.get(self, "apm_stats_query")

    @property
    @pulumi.getter(name="cellDisplayModes")
    def cell_display_modes(self) -> Optional[Sequence[str]]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_modes")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetQueryTableDefinitionRequestApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryTableDefinitionRequestApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryTableDefinitionRequestApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryTag":
            suggest = "primary_tag"
        elif key == "rowType":
            suggest = "row_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestApmStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env: str,
                 name: str,
                 primary_tag: str,
                 row_type: str,
                 service: str,
                 columns: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn']] = None,
                 resource: Optional[str] = None):
        """
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str primary_tag: The organization's host group name and value.
        :param str row_type: The level of detail for the request. Valid values are `service`, `resource`, `span`.
        :param str service: APM service.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumnArgs'] columns: Column properties used by the front end for display.
        :param str resource: The resource name.
        """
        DashboardWidgetQueryTableDefinitionRequestApmStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            env=env,
            name=name,
            primary_tag=primary_tag,
            row_type=row_type,
            service=service,
            columns=columns,
            resource=resource,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             env: str,
             name: str,
             primary_tag: str,
             row_type: str,
             service: str,
             columns: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn']] = None,
             resource: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("env", env)
        _setter("name", name)
        _setter("primary_tag", primary_tag)
        _setter("row_type", row_type)
        _setter("service", service)
        if columns is not None:
            _setter("columns", columns)
        if resource is not None:
            _setter("resource", resource)

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryTag")
    def primary_tag(self) -> str:
        """
        The organization's host group name and value.
        """
        return pulumi.get(self, "primary_tag")

    @property
    @pulumi.getter(name="rowType")
    def row_type(self) -> str:
        """
        The level of detail for the request. Valid values are `service`, `resource`, `span`.
        """
        return pulumi.get(self, "row_type")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn']]:
        """
        Column properties used by the front end for display.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        The resource name.
        """
        return pulumi.get(self, "resource")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellDisplayMode":
            suggest = "cell_display_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            alias=alias,
            cell_display_mode=cell_display_mode,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetQueryTableDefinitionRequestConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetQueryTableDefinitionRequestFormulaLimitArgs' limit: The maximum number of items in the group.
        :param 'DashboardWidgetQueryTableDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetQueryTableDefinitionRequestFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formula_expression=formula_expression,
            alias=alias,
            cell_display_mode=cell_display_mode,
            conditional_formats=conditional_formats,
            limit=limit,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formula_expression: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat']] = None,
             limit: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestFormulaLimit'] = None,
             style: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestFormulaStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if limit is not None:
            _setter("limit", limit)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestFormulaLimit']:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetQueryTableDefinitionRequestFormulaLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        DashboardWidgetQueryTableDefinitionRequestFormulaStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_index=palette_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             palette_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)
        if palette_index is not None:
            _setter("palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetQueryTableDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryTableDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryTableDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetQueryTableDefinitionRequestProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetQueryTableDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetQueryTableDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetQueryTableDefinitionRequestQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetQueryTableDefinitionRequestQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetQueryTableDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetQueryTableDefinitionRequestQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetQueryTableDefinitionRequestQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetQueryTableDefinitionRequestQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetQueryTableDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryTableDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryTableDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetQueryTableDefinitionRequestSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "customUnit":
            suggest = "custom_unit"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "timeseriesBackground":
            suggest = "timeseries_background"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscale: Optional[bool] = None,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionCustomLink']] = None,
                 custom_unit: Optional[str] = None,
                 live_span: Optional[str] = None,
                 precision: Optional[int] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequest']] = None,
                 text_align: Optional[str] = None,
                 timeseries_background: Optional['outputs.DashboardWidgetQueryValueDefinitionTimeseriesBackground'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param bool autoscale: A Boolean indicating whether to automatically scale the tile.
        :param Sequence['DashboardWidgetQueryValueDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str custom_unit: The unit for the value displayed in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param int precision: The precision to use when displaying the value. Use `*` for maximum precision.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str text_align: The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        :param 'DashboardWidgetQueryValueDefinitionTimeseriesBackgroundArgs' timeseries_background: Set a timeseries on the widget background.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetQueryValueDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            autoscale=autoscale,
            custom_links=custom_links,
            custom_unit=custom_unit,
            live_span=live_span,
            precision=precision,
            requests=requests,
            text_align=text_align,
            timeseries_background=timeseries_background,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             autoscale: Optional[bool] = None,
             custom_links: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionCustomLink']] = None,
             custom_unit: Optional[str] = None,
             live_span: Optional[str] = None,
             precision: Optional[int] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequest']] = None,
             text_align: Optional[str] = None,
             timeseries_background: Optional['outputs.DashboardWidgetQueryValueDefinitionTimeseriesBackground'] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if autoscale is not None:
            _setter("autoscale", autoscale)
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if custom_unit is not None:
            _setter("custom_unit", custom_unit)
        if live_span is not None:
            _setter("live_span", live_span)
        if precision is not None:
            _setter("precision", precision)
        if requests is not None:
            _setter("requests", requests)
        if text_align is not None:
            _setter("text_align", text_align)
        if timeseries_background is not None:
            _setter("timeseries_background", timeseries_background)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[bool]:
        """
        A Boolean indicating whether to automatically scale the tile.
        """
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[str]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "custom_unit")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def precision(self) -> Optional[int]:
        """
        The precision to use when displaying the value. Use `*` for maximum precision.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter(name="timeseriesBackground")
    def timeseries_background(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionTimeseriesBackground']:
        """
        Set a timeseries on the widget background.
        """
        return pulumi.get(self, "timeseries_background")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetQueryValueDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "auditQuery":
            suggest = "audit_query"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQuery'] = None,
                 audit_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQuery'] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestConditionalFormat']] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQuery'] = None):
        """
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param 'DashboardWidgetQueryValueDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetQueryValueDefinitionRequestAuditQueryArgs' audit_query: The query to use for this widget.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetQueryValueDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetQueryValueDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetQueryValueDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetQueryValueDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        """
        DashboardWidgetQueryValueDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregator=aggregator,
            apm_query=apm_query,
            audit_query=audit_query,
            conditional_formats=conditional_formats,
            formulas=formulas,
            log_query=log_query,
            process_query=process_query,
            q=q,
            queries=queries,
            rum_query=rum_query,
            security_query=security_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregator: Optional[str] = None,
             apm_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQuery'] = None,
             audit_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQuery'] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestConditionalFormat']] = None,
             formulas: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestFormula']] = None,
             log_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestProcessQuery'] = None,
             q: Optional[str] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQuery']] = None,
             rum_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if audit_query is not None:
            _setter("audit_query", audit_query)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if formulas is not None:
            _setter("formulas", formulas)
        if log_query is not None:
            _setter("log_query", log_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if queries is not None:
            _setter("queries", queries)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetQueryValueDefinitionRequestApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryValueDefinitionRequestApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryValueDefinitionRequestApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestAuditQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestAuditQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestAuditQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestAuditQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetQueryValueDefinitionRequestAuditQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetQueryValueDefinitionRequestConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetQueryValueDefinitionRequestFormulaLimitArgs' limit: The maximum number of items in the group.
        :param 'DashboardWidgetQueryValueDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetQueryValueDefinitionRequestFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formula_expression=formula_expression,
            alias=alias,
            cell_display_mode=cell_display_mode,
            conditional_formats=conditional_formats,
            limit=limit,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formula_expression: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat']] = None,
             limit: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestFormulaLimit'] = None,
             style: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestFormulaStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if limit is not None:
            _setter("limit", limit)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestFormulaLimit']:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetQueryValueDefinitionRequestFormulaLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        DashboardWidgetQueryValueDefinitionRequestFormulaStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_index=palette_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             palette_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)
        if palette_index is not None:
            _setter("palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetQueryValueDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryValueDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryValueDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetQueryValueDefinitionRequestProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetQueryValueDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetQueryValueDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetQueryValueDefinitionRequestQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetQueryValueDefinitionRequestQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetQueryValueDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetQueryValueDefinitionRequestQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetQueryValueDefinitionRequestQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetQueryValueDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryValueDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryValueDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetQueryValueDefinitionRequestSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionTimeseriesBackground(dict):
    def __init__(__self__, *,
                 type: str,
                 yaxis: Optional['outputs.DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis'] = None):
        """
        :param str type: Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        :param 'DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        DashboardWidgetQueryValueDefinitionTimeseriesBackground._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            yaxis=yaxis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             yaxis: Optional['outputs.DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if yaxis is not None:
            _setter("yaxis", yaxis)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis']:
        """
        A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label for the custom link URL.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            include_zero=include_zero,
            label=label,
            max=max,
            min=min,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             include_zero: Optional[bool] = None,
             label: Optional[str] = None,
             max: Optional[str] = None,
             min: Optional[str] = None,
             scale: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if include_zero is not None:
            _setter("include_zero", include_zero)
        if label is not None:
            _setter("label", label)
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetRunWorkflowDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workflowId":
            suggest = "workflow_id"
        elif key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetRunWorkflowDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetRunWorkflowDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetRunWorkflowDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workflow_id: str,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetRunWorkflowDefinitionCustomLink']] = None,
                 inputs: Optional[Sequence['outputs.DashboardWidgetRunWorkflowDefinitionInput']] = None,
                 live_span: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str workflow_id: Workflow ID
        :param Sequence['DashboardWidgetRunWorkflowDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetRunWorkflowDefinitionInputArgs'] inputs: Array of workflow inputs to map to dashboard template variables.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetRunWorkflowDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            workflow_id=workflow_id,
            custom_links=custom_links,
            inputs=inputs,
            live_span=live_span,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             workflow_id: str,
             custom_links: Optional[Sequence['outputs.DashboardWidgetRunWorkflowDefinitionCustomLink']] = None,
             inputs: Optional[Sequence['outputs.DashboardWidgetRunWorkflowDefinitionInput']] = None,
             live_span: Optional[str] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("workflow_id", workflow_id)
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if inputs is not None:
            _setter("inputs", inputs)
        if live_span is not None:
            _setter("live_span", live_span)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> str:
        """
        Workflow ID
        """
        return pulumi.get(self, "workflow_id")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetRunWorkflowDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def inputs(self) -> Optional[Sequence['outputs.DashboardWidgetRunWorkflowDefinitionInput']]:
        """
        Array of workflow inputs to map to dashboard template variables.
        """
        return pulumi.get(self, "inputs")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetRunWorkflowDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetRunWorkflowDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetRunWorkflowDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetRunWorkflowDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetRunWorkflowDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetRunWorkflowDefinitionInput(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: The name of the variable.
        :param str value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        DashboardWidgetRunWorkflowDefinitionInput._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardWidgetScatterplotDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorByGroups":
            suggest = "color_by_groups"
        elif key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_by_groups: Optional[Sequence[str]] = None,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 request: Optional['outputs.DashboardWidgetScatterplotDefinitionRequest'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 xaxis: Optional['outputs.DashboardWidgetScatterplotDefinitionXaxis'] = None,
                 yaxis: Optional['outputs.DashboardWidgetScatterplotDefinitionYaxis'] = None):
        """
        :param Sequence[str] color_by_groups: List of groups used for colors.
        :param Sequence['DashboardWidgetScatterplotDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param 'DashboardWidgetScatterplotDefinitionRequestArgs' request: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param 'DashboardWidgetScatterplotDefinitionXaxisArgs' xaxis: A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
        :param 'DashboardWidgetScatterplotDefinitionYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        DashboardWidgetScatterplotDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            color_by_groups=color_by_groups,
            custom_links=custom_links,
            live_span=live_span,
            request=request,
            title=title,
            title_align=title_align,
            title_size=title_size,
            xaxis=xaxis,
            yaxis=yaxis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             color_by_groups: Optional[Sequence[str]] = None,
             custom_links: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionCustomLink']] = None,
             live_span: Optional[str] = None,
             request: Optional['outputs.DashboardWidgetScatterplotDefinitionRequest'] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             xaxis: Optional['outputs.DashboardWidgetScatterplotDefinitionXaxis'] = None,
             yaxis: Optional['outputs.DashboardWidgetScatterplotDefinitionYaxis'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if color_by_groups is not None:
            _setter("color_by_groups", color_by_groups)
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if live_span is not None:
            _setter("live_span", live_span)
        if request is not None:
            _setter("request", request)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)
        if xaxis is not None:
            _setter("xaxis", xaxis)
        if yaxis is not None:
            _setter("yaxis", yaxis)

    @property
    @pulumi.getter(name="colorByGroups")
    def color_by_groups(self) -> Optional[Sequence[str]]:
        """
        List of groups used for colors.
        """
        return pulumi.get(self, "color_by_groups")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequest']:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def xaxis(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionXaxis']:
        """
        A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "xaxis")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionYaxis']:
        """
        A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetScatterplotDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scatterplotTables":
            suggest = "scatterplot_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scatterplot_tables: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTable']] = None,
                 xes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestX']] = None,
                 ys: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestY']] = None):
        """
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestScatterplotTableArgs'] scatterplot_tables: Scatterplot request containing formulas and functions.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestXArgs'] xes: The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestYArgs'] ys: The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        DashboardWidgetScatterplotDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            scatterplot_tables=scatterplot_tables,
            xes=xes,
            ys=ys,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             scatterplot_tables: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTable']] = None,
             xes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestX']] = None,
             ys: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestY']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if scatterplot_tables is not None:
            _setter("scatterplot_tables", scatterplot_tables)
        if xes is not None:
            _setter("xes", xes)
        if ys is not None:
            _setter("ys", ys)

    @property
    @pulumi.getter(name="scatterplotTables")
    def scatterplot_tables(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTable']]:
        """
        Scatterplot request containing formulas and functions.
        """
        return pulumi.get(self, "scatterplot_tables")

    @property
    @pulumi.getter
    def xes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestX']]:
        """
        The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        return pulumi.get(self, "xes")

    @property
    @pulumi.getter
    def ys(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestY']]:
        """
        The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        return pulumi.get(self, "ys")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTable(dict):
    def __init__(__self__, *,
                 formulas: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula']] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery']] = None):
        DashboardWidgetScatterplotDefinitionRequestScatterplotTable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formulas=formulas,
            queries=queries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formulas: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula']] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if formulas is not None:
            _setter("formulas", formulas)
        if queries is not None:
            _setter("queries", queries)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery']]:
        return pulumi.get(self, "queries")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension: str,
                 formula_expression: str,
                 alias: Optional[str] = None):
        """
        :param str dimension: Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        """
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dimension=dimension,
            formula_expression=formula_expression,
            alias=alias,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dimension: str,
             formula_expression: str,
             alias: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dimension", dimension)
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)

    @property
    @pulumi.getter
    def dimension(self) -> str:
        """
        Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestX(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestX. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestX.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestX.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQuery'] = None):
        """
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param 'DashboardWidgetScatterplotDefinitionRequestXApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetScatterplotDefinitionRequestXLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetScatterplotDefinitionRequestXProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetScatterplotDefinitionRequestXRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetScatterplotDefinitionRequestXSecurityQueryArgs' security_query: The query to use for this widget.
        """
        DashboardWidgetScatterplotDefinitionRequestX._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregator=aggregator,
            apm_query=apm_query,
            log_query=log_query,
            process_query=process_query,
            q=q,
            rum_query=rum_query,
            security_query=security_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregator: Optional[str] = None,
             apm_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQuery'] = None,
             log_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXProcessQuery'] = None,
             q: Optional[str] = None,
             rum_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if log_query is not None:
            _setter("log_query", log_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetScatterplotDefinitionRequestXApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetScatterplotDefinitionRequestXApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetScatterplotDefinitionRequestXApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetScatterplotDefinitionRequestXLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetScatterplotDefinitionRequestXLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetScatterplotDefinitionRequestXLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetScatterplotDefinitionRequestXProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetScatterplotDefinitionRequestXRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetScatterplotDefinitionRequestXRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetScatterplotDefinitionRequestXRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetScatterplotDefinitionRequestXSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestY(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestY. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestY.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestY.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQuery'] = None):
        """
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param 'DashboardWidgetScatterplotDefinitionRequestYApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetScatterplotDefinitionRequestYLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetScatterplotDefinitionRequestYProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetScatterplotDefinitionRequestYRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetScatterplotDefinitionRequestYSecurityQueryArgs' security_query: The query to use for this widget.
        """
        DashboardWidgetScatterplotDefinitionRequestY._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregator=aggregator,
            apm_query=apm_query,
            log_query=log_query,
            process_query=process_query,
            q=q,
            rum_query=rum_query,
            security_query=security_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregator: Optional[str] = None,
             apm_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQuery'] = None,
             log_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYProcessQuery'] = None,
             q: Optional[str] = None,
             rum_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if log_query is not None:
            _setter("log_query", log_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetScatterplotDefinitionRequestYApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetScatterplotDefinitionRequestYApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetScatterplotDefinitionRequestYApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetScatterplotDefinitionRequestYLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetScatterplotDefinitionRequestYLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetScatterplotDefinitionRequestYLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetScatterplotDefinitionRequestYProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetScatterplotDefinitionRequestYRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetScatterplotDefinitionRequestYRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetScatterplotDefinitionRequestYRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetScatterplotDefinitionRequestYSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionXaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionXaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionXaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionXaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label for the custom link URL.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        DashboardWidgetScatterplotDefinitionXaxis._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            include_zero=include_zero,
            label=label,
            max=max,
            min=min,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             include_zero: Optional[bool] = None,
             label: Optional[str] = None,
             max: Optional[str] = None,
             min: Optional[str] = None,
             scale: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if include_zero is not None:
            _setter("include_zero", include_zero)
        if label is not None:
            _setter("label", label)
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label for the custom link URL.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        DashboardWidgetScatterplotDefinitionYaxis._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            include_zero=include_zero,
            label=label,
            max=max,
            min=min,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             include_zero: Optional[bool] = None,
             label: Optional[str] = None,
             max: Optional[str] = None,
             min: Optional[str] = None,
             scale: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if include_zero is not None:
            _setter("include_zero", include_zero)
        if label is not None:
            _setter("label", label)
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetServiceLevelObjectiveDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sloId":
            suggest = "slo_id"
        elif key == "timeWindows":
            suggest = "time_windows"
        elif key == "viewMode":
            suggest = "view_mode"
        elif key == "viewType":
            suggest = "view_type"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "globalTimeTarget":
            suggest = "global_time_target"
        elif key == "showErrorBudget":
            suggest = "show_error_budget"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetServiceLevelObjectiveDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetServiceLevelObjectiveDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetServiceLevelObjectiveDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slo_id: str,
                 time_windows: Sequence[str],
                 view_mode: str,
                 view_type: str,
                 additional_query_filters: Optional[str] = None,
                 global_time_target: Optional[str] = None,
                 show_error_budget: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str slo_id: ID of an SLO to query.
        :param Sequence[str] time_windows: A list of time windows to display in the widget. Valid values are `7d`, `30d`, `90d`, `week_to_date`, `previous_week`, `month_to_date`, `previous_month`, `global_time`.
        :param str view_mode: The view mode for the widget. Valid values are `overall`, `component`, `both`.
        :param str view_type: The type of view to use when displaying the widget. Only `detail` is supported.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str global_time_target: The global time target of the widget.
        :param bool show_error_budget: Whether to show the error budget or not.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetServiceLevelObjectiveDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            slo_id=slo_id,
            time_windows=time_windows,
            view_mode=view_mode,
            view_type=view_type,
            additional_query_filters=additional_query_filters,
            global_time_target=global_time_target,
            show_error_budget=show_error_budget,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             slo_id: str,
             time_windows: Sequence[str],
             view_mode: str,
             view_type: str,
             additional_query_filters: Optional[str] = None,
             global_time_target: Optional[str] = None,
             show_error_budget: Optional[bool] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("slo_id", slo_id)
        _setter("time_windows", time_windows)
        _setter("view_mode", view_mode)
        _setter("view_type", view_type)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if global_time_target is not None:
            _setter("global_time_target", global_time_target)
        if show_error_budget is not None:
            _setter("show_error_budget", show_error_budget)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Sequence[str]:
        """
        A list of time windows to display in the widget. Valid values are `7d`, `30d`, `90d`, `week_to_date`, `previous_week`, `month_to_date`, `previous_month`, `global_time`.
        """
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter(name="viewMode")
    def view_mode(self) -> str:
        """
        The view mode for the widget. Valid values are `overall`, `component`, `both`.
        """
        return pulumi.get(self, "view_mode")

    @property
    @pulumi.getter(name="viewType")
    def view_type(self) -> str:
        """
        The type of view to use when displaying the widget. Only `detail` is supported.
        """
        return pulumi.get(self, "view_type")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="globalTimeTarget")
    def global_time_target(self) -> Optional[str]:
        """
        The global time target of the widget.
        """
        return pulumi.get(self, "global_time_target")

    @property
    @pulumi.getter(name="showErrorBudget")
    def show_error_budget(self) -> Optional[bool]:
        """
        Whether to show the error budget or not.
        """
        return pulumi.get(self, "show_error_budget")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetServicemapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetServicemapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetServicemapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetServicemapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Sequence[str],
                 service: str,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetServicemapDefinitionCustomLink']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence[str] filters: Your environment and primary tag (or `*` if enabled for your account).
        :param str service: APM service.
        :param Sequence['DashboardWidgetServicemapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetServicemapDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filters=filters,
            service=service,
            custom_links=custom_links,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filters: Sequence[str],
             service: str,
             custom_links: Optional[Sequence['outputs.DashboardWidgetServicemapDefinitionCustomLink']] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filters", filters)
        _setter("service", service)
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def filters(self) -> Sequence[str]:
        """
        Your environment and primary tag (or `*` if enabled for your account).
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetServicemapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetServicemapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetServicemapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetServicemapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetServicemapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetServicemapDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetSloListDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSloListDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSloListDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSloListDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request: 'outputs.DashboardWidgetSloListDefinitionRequest',
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param 'DashboardWidgetSloListDefinitionRequestArgs' request: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetSloListDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            request=request,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             request: 'outputs.DashboardWidgetSloListDefinitionRequest',
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("request", request)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def request(self) -> 'outputs.DashboardWidgetSloListDefinitionRequest':
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetSloListDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestType":
            suggest = "request_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSloListDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSloListDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSloListDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: 'outputs.DashboardWidgetSloListDefinitionRequestQuery',
                 request_type: str):
        """
        :param str request_type: The request type for the SLO List request. Valid values are `slo_list`.
        """
        DashboardWidgetSloListDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
            request_type=request_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: 'outputs.DashboardWidgetSloListDefinitionRequestQuery',
             request_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)
        _setter("request_type", request_type)

    @property
    @pulumi.getter
    def query(self) -> 'outputs.DashboardWidgetSloListDefinitionRequestQuery':
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> str:
        """
        The request type for the SLO List request. Valid values are `slo_list`.
        """
        return pulumi.get(self, "request_type")


@pulumi.output_type
class DashboardWidgetSloListDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSloListDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSloListDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSloListDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_string: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetSloListDefinitionRequestQuerySort'] = None):
        """
        :param str query_string: Widget query.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetSloListDefinitionRequestQuerySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetSloListDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query_string=query_string,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query_string: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetSloListDefinitionRequestQuerySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query_string", query_string)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> str:
        """
        Widget query.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetSloListDefinitionRequestQuerySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetSloListDefinitionRequestQuerySort(dict):
    def __init__(__self__, *,
                 column: str,
                 order: str):
        """
        :param str column: The facet path for the column.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetSloListDefinitionRequestQuerySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            column=column,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             column: str,
             order: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("column", column)
        _setter("order", order)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetSunburstDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "hideTotal":
            suggest = "hide_total"
        elif key == "legendInline":
            suggest = "legend_inline"
        elif key == "legendTable":
            suggest = "legend_table"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionCustomLink']] = None,
                 hide_total: Optional[bool] = None,
                 legend_inline: Optional['outputs.DashboardWidgetSunburstDefinitionLegendInline'] = None,
                 legend_table: Optional['outputs.DashboardWidgetSunburstDefinitionLegendTable'] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetSunburstDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param bool hide_total: Whether or not to show the total value in the widget.
        :param 'DashboardWidgetSunburstDefinitionLegendInlineArgs' legend_inline: Used to configure the inline legend. Cannot be used in conjunction with legend*table.
        :param 'DashboardWidgetSunburstDefinitionLegendTableArgs' legend_table: Used to configure the table legend. Cannot be used in conjunction with legend*inline.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetSunburstDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_links=custom_links,
            hide_total=hide_total,
            legend_inline=legend_inline,
            legend_table=legend_table,
            live_span=live_span,
            requests=requests,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_links: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionCustomLink']] = None,
             hide_total: Optional[bool] = None,
             legend_inline: Optional['outputs.DashboardWidgetSunburstDefinitionLegendInline'] = None,
             legend_table: Optional['outputs.DashboardWidgetSunburstDefinitionLegendTable'] = None,
             live_span: Optional[str] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequest']] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if hide_total is not None:
            _setter("hide_total", hide_total)
        if legend_inline is not None:
            _setter("legend_inline", legend_inline)
        if legend_table is not None:
            _setter("legend_table", legend_table)
        if live_span is not None:
            _setter("live_span", live_span)
        if requests is not None:
            _setter("requests", requests)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="hideTotal")
    def hide_total(self) -> Optional[bool]:
        """
        Whether or not to show the total value in the widget.
        """
        return pulumi.get(self, "hide_total")

    @property
    @pulumi.getter(name="legendInline")
    def legend_inline(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionLegendInline']:
        """
        Used to configure the inline legend. Cannot be used in conjunction with legend*table.
        """
        return pulumi.get(self, "legend_inline")

    @property
    @pulumi.getter(name="legendTable")
    def legend_table(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionLegendTable']:
        """
        Used to configure the table legend. Cannot be used in conjunction with legend*inline.
        """
        return pulumi.get(self, "legend_table")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetSunburstDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionLegendInline(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hidePercent":
            suggest = "hide_percent"
        elif key == "hideValue":
            suggest = "hide_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionLegendInline. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionLegendInline.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionLegendInline.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 hide_percent: Optional[bool] = None,
                 hide_value: Optional[bool] = None):
        """
        :param str type: Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        :param bool hide_percent: Whether to hide the percentages of the groups.
        :param bool hide_value: Setting this to True hides values.
        """
        DashboardWidgetSunburstDefinitionLegendInline._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            hide_percent=hide_percent,
            hide_value=hide_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             hide_percent: Optional[bool] = None,
             hide_value: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if hide_percent is not None:
            _setter("hide_percent", hide_percent)
        if hide_value is not None:
            _setter("hide_value", hide_value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="hidePercent")
    def hide_percent(self) -> Optional[bool]:
        """
        Whether to hide the percentages of the groups.
        """
        return pulumi.get(self, "hide_percent")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionLegendTable(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        """
        DashboardWidgetSunburstDefinitionLegendTable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "auditQuery":
            suggest = "audit_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "networkQuery":
            suggest = "network_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestApmQuery'] = None,
                 audit_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestAuditQuery'] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestLogQuery'] = None,
                 network_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetSunburstDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetSunburstDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetSunburstDefinitionRequestAuditQueryArgs' audit_query: The query to use for this widget.
        :param 'DashboardWidgetSunburstDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetSunburstDefinitionRequestNetworkQueryArgs' network_query: The query to use for this widget.
        :param 'DashboardWidgetSunburstDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetSunburstDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetSunburstDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'DashboardWidgetSunburstDefinitionRequestStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetSunburstDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_query=apm_query,
            audit_query=audit_query,
            formulas=formulas,
            log_query=log_query,
            network_query=network_query,
            process_query=process_query,
            q=q,
            queries=queries,
            rum_query=rum_query,
            security_query=security_query,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestApmQuery'] = None,
             audit_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestAuditQuery'] = None,
             formulas: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestFormula']] = None,
             log_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestLogQuery'] = None,
             network_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestProcessQuery'] = None,
             q: Optional[str] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestQuery']] = None,
             rum_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestSecurityQuery'] = None,
             style: Optional['outputs.DashboardWidgetSunburstDefinitionRequestStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if audit_query is not None:
            _setter("audit_query", audit_query)
        if formulas is not None:
            _setter("formulas", formulas)
        if log_query is not None:
            _setter("log_query", log_query)
        if network_query is not None:
            _setter("network_query", network_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if queries is not None:
            _setter("queries", queries)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestAuditQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "network_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetSunburstDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetSunburstDefinitionRequestApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetSunburstDefinitionRequestApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetSunburstDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetSunburstDefinitionRequestApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetSunburstDefinitionRequestApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestAuditQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestAuditQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestAuditQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestAuditQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestAuditQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestAuditQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetSunburstDefinitionRequestAuditQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestAuditQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetSunburstDefinitionRequestAuditQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetSunburstDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetSunburstDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetSunburstDefinitionRequestFormulaLimitArgs' limit: The maximum number of items in the group.
        :param 'DashboardWidgetSunburstDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetSunburstDefinitionRequestFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formula_expression=formula_expression,
            alias=alias,
            cell_display_mode=cell_display_mode,
            conditional_formats=conditional_formats,
            limit=limit,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formula_expression: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat']] = None,
             limit: Optional['outputs.DashboardWidgetSunburstDefinitionRequestFormulaLimit'] = None,
             style: Optional['outputs.DashboardWidgetSunburstDefinitionRequestFormulaStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if limit is not None:
            _setter("limit", limit)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestFormulaLimit']:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetSunburstDefinitionRequestFormulaLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        DashboardWidgetSunburstDefinitionRequestFormulaStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_index=palette_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             palette_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)
        if palette_index is not None:
            _setter("palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetSunburstDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetSunburstDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetSunburstDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetSunburstDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetSunburstDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetSunburstDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestNetworkQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestNetworkQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestNetworkQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestNetworkQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetSunburstDefinitionRequestNetworkQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetSunburstDefinitionRequestProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetSunburstDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetSunburstDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetSunburstDefinitionRequestQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetSunburstDefinitionRequestQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetSunburstDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetSunburstDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetSunburstDefinitionRequestQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetSunburstDefinitionRequestQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetSunburstDefinitionRequestQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetSunburstDefinitionRequestQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetSunburstDefinitionRequestQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetSunburstDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetSunburstDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetSunburstDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetSunburstDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetSunburstDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetSunburstDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetSunburstDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetSunburstDefinitionRequestSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetSunburstDefinitionRequestSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetSunburstDefinitionRequestSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        DashboardWidgetSunburstDefinitionRequestStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "legendColumns":
            suggest = "legend_columns"
        elif key == "legendLayout":
            suggest = "legend_layout"
        elif key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "rightYaxis":
            suggest = "right_yaxis"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionCustomLink']] = None,
                 events: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionEvent']] = None,
                 legend_columns: Optional[Sequence[str]] = None,
                 legend_layout: Optional[str] = None,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 markers: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionMarker']] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequest']] = None,
                 right_yaxis: Optional['outputs.DashboardWidgetTimeseriesDefinitionRightYaxis'] = None,
                 show_legend: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 yaxis: Optional['outputs.DashboardWidgetTimeseriesDefinitionYaxis'] = None):
        """
        :param Sequence['DashboardWidgetTimeseriesDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionEventArgs'] events: The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        :param Sequence[str] legend_columns: A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
        :param str legend_layout: The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
        :param str legend_size: The size of the legend displayed in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence['DashboardWidgetTimeseriesDefinitionMarkerArgs'] markers: A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tile_def` block.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param 'DashboardWidgetTimeseriesDefinitionRightYaxisArgs' right_yaxis: A nested block describing the right Y-Axis Controls. See the `on_right_yaxis` property for which request will use this axis. The structure of this block is described below.
        :param bool show_legend: Whether or not to show the legend on this widget.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param 'DashboardWidgetTimeseriesDefinitionYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        DashboardWidgetTimeseriesDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_links=custom_links,
            events=events,
            legend_columns=legend_columns,
            legend_layout=legend_layout,
            legend_size=legend_size,
            live_span=live_span,
            markers=markers,
            requests=requests,
            right_yaxis=right_yaxis,
            show_legend=show_legend,
            title=title,
            title_align=title_align,
            title_size=title_size,
            yaxis=yaxis,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_links: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionCustomLink']] = None,
             events: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionEvent']] = None,
             legend_columns: Optional[Sequence[str]] = None,
             legend_layout: Optional[str] = None,
             legend_size: Optional[str] = None,
             live_span: Optional[str] = None,
             markers: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionMarker']] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequest']] = None,
             right_yaxis: Optional['outputs.DashboardWidgetTimeseriesDefinitionRightYaxis'] = None,
             show_legend: Optional[bool] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             yaxis: Optional['outputs.DashboardWidgetTimeseriesDefinitionYaxis'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if events is not None:
            _setter("events", events)
        if legend_columns is not None:
            _setter("legend_columns", legend_columns)
        if legend_layout is not None:
            _setter("legend_layout", legend_layout)
        if legend_size is not None:
            _setter("legend_size", legend_size)
        if live_span is not None:
            _setter("live_span", live_span)
        if markers is not None:
            _setter("markers", markers)
        if requests is not None:
            _setter("requests", requests)
        if right_yaxis is not None:
            _setter("right_yaxis", right_yaxis)
        if show_legend is not None:
            _setter("show_legend", show_legend)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)
        if yaxis is not None:
            _setter("yaxis", yaxis)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionEvent']]:
        """
        The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="legendColumns")
    def legend_columns(self) -> Optional[Sequence[str]]:
        """
        A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
        """
        return pulumi.get(self, "legend_columns")

    @property
    @pulumi.getter(name="legendLayout")
    def legend_layout(self) -> Optional[str]:
        """
        The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
        """
        return pulumi.get(self, "legend_layout")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def markers(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionMarker']]:
        """
        A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tile_def` block.
        """
        return pulumi.get(self, "markers")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="rightYaxis")
    def right_yaxis(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRightYaxis']:
        """
        A nested block describing the right Y-Axis Controls. See the `on_right_yaxis` property for which request will use this axis. The structure of this block is described below.
        """
        return pulumi.get(self, "right_yaxis")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionYaxis']:
        """
        A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetTimeseriesDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagsExecution":
            suggest = "tags_execution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 q: str,
                 tags_execution: Optional[str] = None):
        """
        :param str q: The metric query to use for this widget.
        :param str tags_execution: The execution method for multi-value filters, options: `and` or `or`.
        """
        DashboardWidgetTimeseriesDefinitionEvent._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            q=q,
            tags_execution=tags_execution,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             q: str,
             tags_execution: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("q", q)
        if tags_execution is not None:
            _setter("tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> str:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        """
        The execution method for multi-value filters, options: `and` or `or`.
        """
        return pulumi.get(self, "tags_execution")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionMarker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayType":
            suggest = "display_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionMarker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionMarker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionMarker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: str,
                 display_type: Optional[str] = None,
                 label: Optional[str] = None):
        """
        :param str value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str display_type: How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
        :param str label: The label for the custom link URL.
        """
        DashboardWidgetTimeseriesDefinitionMarker._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
            display_type=display_type,
            label=label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: str,
             display_type: Optional[str] = None,
             label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("value", value)
        if display_type is not None:
            _setter("display_type", display_type)
        if label is not None:
            _setter("label", label)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[str]:
        """
        How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
        """
        return pulumi.get(self, "display_type")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "auditQuery":
            suggest = "audit_query"
        elif key == "displayType":
            suggest = "display_type"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "networkQuery":
            suggest = "network_query"
        elif key == "onRightYaxis":
            suggest = "on_right_yaxis"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQuery'] = None,
                 audit_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQuery'] = None,
                 display_type: Optional[str] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQuery'] = None,
                 metadatas: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestMetadata']] = None,
                 network_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQuery'] = None,
                 on_right_yaxis: Optional[bool] = None,
                 process_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetTimeseriesDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetTimeseriesDefinitionRequestAuditQueryArgs' audit_query: The query to use for this widget.
        :param str display_type: How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
        :param 'DashboardWidgetTimeseriesDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestMetadataArgs'] metadatas: Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
        :param 'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryArgs' network_query: The query to use for this widget.
        :param bool on_right_yaxis: A Boolean indicating whether the request uses the right or left Y-Axis.
        :param 'DashboardWidgetTimeseriesDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetTimeseriesDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetTimeseriesDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'DashboardWidgetTimeseriesDefinitionRequestStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetTimeseriesDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_query=apm_query,
            audit_query=audit_query,
            display_type=display_type,
            formulas=formulas,
            log_query=log_query,
            metadatas=metadatas,
            network_query=network_query,
            on_right_yaxis=on_right_yaxis,
            process_query=process_query,
            q=q,
            queries=queries,
            rum_query=rum_query,
            security_query=security_query,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQuery'] = None,
             audit_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQuery'] = None,
             display_type: Optional[str] = None,
             formulas: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestFormula']] = None,
             log_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQuery'] = None,
             metadatas: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestMetadata']] = None,
             network_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQuery'] = None,
             on_right_yaxis: Optional[bool] = None,
             process_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestProcessQuery'] = None,
             q: Optional[str] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQuery']] = None,
             rum_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQuery'] = None,
             style: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if audit_query is not None:
            _setter("audit_query", audit_query)
        if display_type is not None:
            _setter("display_type", display_type)
        if formulas is not None:
            _setter("formulas", formulas)
        if log_query is not None:
            _setter("log_query", log_query)
        if metadatas is not None:
            _setter("metadatas", metadatas)
        if network_query is not None:
            _setter("network_query", network_query)
        if on_right_yaxis is not None:
            _setter("on_right_yaxis", on_right_yaxis)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if queries is not None:
            _setter("queries", queries)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[str]:
        """
        How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
        """
        return pulumi.get(self, "display_type")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestMetadata']]:
        """
        Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "network_query")

    @property
    @pulumi.getter(name="onRightYaxis")
    def on_right_yaxis(self) -> Optional[bool]:
        """
        A Boolean indicating whether the request uses the right or left Y-Axis.
        """
        return pulumi.get(self, "on_right_yaxis")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetTimeseriesDefinitionRequestApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetTimeseriesDefinitionRequestApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetTimeseriesDefinitionRequestApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestAuditQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestAuditQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestAuditQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestAuditQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetTimeseriesDefinitionRequestAuditQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetTimeseriesDefinitionRequestFormulaLimitArgs' limit: The maximum number of items in the group.
        :param 'DashboardWidgetTimeseriesDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetTimeseriesDefinitionRequestFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formula_expression=formula_expression,
            alias=alias,
            cell_display_mode=cell_display_mode,
            conditional_formats=conditional_formats,
            limit=limit,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formula_expression: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat']] = None,
             limit: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaLimit'] = None,
             style: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if limit is not None:
            _setter("limit", limit)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaLimit']:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetTimeseriesDefinitionRequestFormulaLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        DashboardWidgetTimeseriesDefinitionRequestFormulaStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_index=palette_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             palette_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)
        if palette_index is not None:
            _setter("palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetTimeseriesDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetTimeseriesDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetTimeseriesDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasName":
            suggest = "alias_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 alias_name: Optional[str] = None):
        """
        :param str expression: The expression name.
        :param str alias_name: The expression alias.
        """
        DashboardWidgetTimeseriesDefinitionRequestMetadata._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            alias_name=alias_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             alias_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        if alias_name is not None:
            _setter("alias_name", alias_name)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The expression name.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="aliasName")
    def alias_name(self) -> Optional[str]:
        """
        The expression alias.
        """
        return pulumi.get(self, "alias_name")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestNetworkQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestNetworkQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestNetworkQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetTimeseriesDefinitionRequestNetworkQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetTimeseriesDefinitionRequestProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetTimeseriesDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetTimeseriesDefinitionRequestQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetTimeseriesDefinitionRequestQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetTimeseriesDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetTimeseriesDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetTimeseriesDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetTimeseriesDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetTimeseriesDefinitionRequestSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineType":
            suggest = "line_type"
        elif key == "lineWidth":
            suggest = "line_width"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 line_type: Optional[str] = None,
                 line_width: Optional[str] = None,
                 palette: Optional[str] = None):
        """
        :param str line_type: The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
        :param str line_width: The width of line displayed. Valid values are `normal`, `thick`, `thin`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        DashboardWidgetTimeseriesDefinitionRequestStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            line_type=line_type,
            line_width=line_width,
            palette=palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             line_type: Optional[str] = None,
             line_width: Optional[str] = None,
             palette: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if line_type is not None:
            _setter("line_type", line_type)
        if line_width is not None:
            _setter("line_width", line_width)
        if palette is not None:
            _setter("palette", palette)

    @property
    @pulumi.getter(name="lineType")
    def line_type(self) -> Optional[str]:
        """
        The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
        """
        return pulumi.get(self, "line_type")

    @property
    @pulumi.getter(name="lineWidth")
    def line_width(self) -> Optional[str]:
        """
        The width of line displayed. Valid values are `normal`, `thick`, `thin`.
        """
        return pulumi.get(self, "line_width")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRightYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRightYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRightYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRightYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label for the custom link URL.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        DashboardWidgetTimeseriesDefinitionRightYaxis._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            include_zero=include_zero,
            label=label,
            max=max,
            min=min,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             include_zero: Optional[bool] = None,
             label: Optional[str] = None,
             max: Optional[str] = None,
             min: Optional[str] = None,
             scale: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if include_zero is not None:
            _setter("include_zero", include_zero)
        if label is not None:
            _setter("label", label)
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label for the custom link URL.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        DashboardWidgetTimeseriesDefinitionYaxis._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            include_zero=include_zero,
            label=label,
            max=max,
            min=min,
            scale=scale,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             include_zero: Optional[bool] = None,
             label: Optional[str] = None,
             max: Optional[str] = None,
             min: Optional[str] = None,
             scale: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if include_zero is not None:
            _setter("include_zero", include_zero)
        if label is not None:
            _setter("label", label)
        if max is not None:
            _setter("max", max)
        if min is not None:
            _setter("min", min)
        if scale is not None:
            _setter("scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetToplistDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetToplistDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param Sequence['DashboardWidgetToplistDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetToplistDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_links=custom_links,
            live_span=live_span,
            requests=requests,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_links: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionCustomLink']] = None,
             live_span: Optional[str] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequest']] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if live_span is not None:
            _setter("live_span", live_span)
        if requests is not None:
            _setter("requests", requests)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetToplistDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetToplistDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "auditQuery":
            suggest = "audit_query"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQuery'] = None,
                 audit_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestAuditQuery'] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestConditionalFormat']] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetToplistDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetToplistDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetToplistDefinitionRequestAuditQueryArgs' audit_query: The query to use for this widget.
        :param Sequence['DashboardWidgetToplistDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetToplistDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetToplistDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetToplistDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetToplistDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'DashboardWidgetToplistDefinitionRequestStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetToplistDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_query=apm_query,
            audit_query=audit_query,
            conditional_formats=conditional_formats,
            formulas=formulas,
            log_query=log_query,
            process_query=process_query,
            q=q,
            queries=queries,
            rum_query=rum_query,
            security_query=security_query,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQuery'] = None,
             audit_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestAuditQuery'] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestConditionalFormat']] = None,
             formulas: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestFormula']] = None,
             log_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestProcessQuery'] = None,
             q: Optional[str] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestQuery']] = None,
             rum_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQuery'] = None,
             security_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQuery'] = None,
             style: Optional['outputs.DashboardWidgetToplistDefinitionRequestStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_query is not None:
            _setter("apm_query", apm_query)
        if audit_query is not None:
            _setter("audit_query", audit_query)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if formulas is not None:
            _setter("formulas", formulas)
        if log_query is not None:
            _setter("log_query", log_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if q is not None:
            _setter("q", q)
        if queries is not None:
            _setter("queries", queries)
        if rum_query is not None:
            _setter("rum_query", rum_query)
        if security_query is not None:
            _setter("security_query", security_query)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestAuditQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetToplistDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetToplistDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetToplistDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetToplistDefinitionRequestApmQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetToplistDefinitionRequestApmQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetToplistDefinitionRequestApmQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetToplistDefinitionRequestApmQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetToplistDefinitionRequestApmQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestAuditQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestAuditQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestAuditQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestAuditQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetToplistDefinitionRequestAuditQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetToplistDefinitionRequestAuditQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetToplistDefinitionRequestAuditQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetToplistDefinitionRequestAuditQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestAuditQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetToplistDefinitionRequestAuditQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestAuditQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetToplistDefinitionRequestAuditQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetToplistDefinitionRequestConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetToplistDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetToplistDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetToplistDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetToplistDefinitionRequestFormulaLimitArgs' limit: The maximum number of items in the group.
        :param 'DashboardWidgetToplistDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetToplistDefinitionRequestFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formula_expression=formula_expression,
            alias=alias,
            cell_display_mode=cell_display_mode,
            conditional_formats=conditional_formats,
            limit=limit,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formula_expression: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat']] = None,
             limit: Optional['outputs.DashboardWidgetToplistDefinitionRequestFormulaLimit'] = None,
             style: Optional['outputs.DashboardWidgetToplistDefinitionRequestFormulaStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if limit is not None:
            _setter("limit", limit)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestFormulaLimit']:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetToplistDefinitionRequestFormulaLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        DashboardWidgetToplistDefinitionRequestFormulaStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_index=palette_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             palette_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)
        if palette_index is not None:
            _setter("palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetToplistDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetToplistDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetToplistDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetToplistDefinitionRequestLogQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetToplistDefinitionRequestLogQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetToplistDefinitionRequestLogQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetToplistDefinitionRequestLogQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetToplistDefinitionRequestLogQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: The metric from the request to correlate with this conditional format.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The maximum number of items in the group.
        :param str search_by: Your chosen search term.
        """
        DashboardWidgetToplistDefinitionRequestProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metric=metric,
            filter_bies=filter_bies,
            limit=limit,
            search_by=search_by,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metric: str,
             filter_bies: Optional[Sequence[str]] = None,
             limit: Optional[int] = None,
             search_by: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metric", metric)
        if filter_bies is not None:
            _setter("filter_bies", filter_bies)
        if limit is not None:
            _setter("limit", limit)
        if search_by is not None:
            _setter("search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetToplistDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetToplistDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetToplistDefinitionRequestQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetToplistDefinitionRequestQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetToplistDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetToplistDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetToplistDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetToplistDefinitionRequestQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetToplistDefinitionRequestQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetToplistDefinitionRequestQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetToplistDefinitionRequestQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetToplistDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetToplistDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetToplistDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetToplistDefinitionRequestRumQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestRumQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetToplistDefinitionRequestRumQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetToplistDefinitionRequestRumQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetToplistDefinitionRequestRumQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetToplistDefinitionRequestRumQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetToplistDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetToplistDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        DashboardWidgetToplistDefinitionRequestSecurityQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            index=index,
            compute_query=compute_query,
            group_bies=group_bies,
            multi_computes=multi_computes,
            search_query=search_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             index: str,
             compute_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery'] = None,
             group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy']] = None,
             multi_computes: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute']] = None,
             search_query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("index", index)
        if compute_query is not None:
            _setter("compute_query", compute_query)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if multi_computes is not None:
            _setter("multi_computes", multi_computes)
        if search_query is not None:
            _setter("search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetToplistDefinitionRequestSecurityQueryComputeQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort_query=sort_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: Optional[str] = None,
             limit: Optional[int] = None,
             sort_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if facet is not None:
            _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort_query is not None:
            _setter("sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        DashboardWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            order=order,
            facet=facet,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             order: str,
             facet: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        _setter("order", order)
        if facet is not None:
            _setter("facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        DashboardWidgetToplistDefinitionRequestSecurityQueryMultiCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            facet=facet,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             facet: Optional[str] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if facet is not None:
            _setter("facet", facet)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        DashboardWidgetToplistDefinitionRequestStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetTopologyMapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTopologyMapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTopologyMapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTopologyMapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetTopologyMapDefinitionCustomLink']] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetTopologyMapDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetTopologyMapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetTopologyMapDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetTopologyMapDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_links=custom_links,
            requests=requests,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_links: Optional[Sequence['outputs.DashboardWidgetTopologyMapDefinitionCustomLink']] = None,
             requests: Optional[Sequence['outputs.DashboardWidgetTopologyMapDefinitionRequest']] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_links is not None:
            _setter("custom_links", custom_links)
        if requests is not None:
            _setter("requests", requests)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetTopologyMapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetTopologyMapDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetTopologyMapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTopologyMapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTopologyMapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTopologyMapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        DashboardWidgetTopologyMapDefinitionCustomLink._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_hidden=is_hidden,
            label=label,
            link=link,
            override_label=override_label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_hidden: Optional[bool] = None,
             label: Optional[str] = None,
             link: Optional[str] = None,
             override_label: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if is_hidden is not None:
            _setter("is_hidden", is_hidden)
        if label is not None:
            _setter("label", label)
        if link is not None:
            _setter("link", link)
        if override_label is not None:
            _setter("override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetTopologyMapDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestType":
            suggest = "request_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTopologyMapDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTopologyMapDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTopologyMapDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queries: Sequence['outputs.DashboardWidgetTopologyMapDefinitionRequestQuery'],
                 request_type: str):
        """
        :param str request_type: The request type for the SLO List request. Valid values are `slo_list`.
        """
        DashboardWidgetTopologyMapDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            queries=queries,
            request_type=request_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             queries: Sequence['outputs.DashboardWidgetTopologyMapDefinitionRequestQuery'],
             request_type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("queries", queries)
        _setter("request_type", request_type)

    @property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.DashboardWidgetTopologyMapDefinitionRequestQuery']:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> str:
        """
        The request type for the SLO List request. Valid values are `slo_list`.
        """
        return pulumi.get(self, "request_type")


@pulumi.output_type
class DashboardWidgetTopologyMapDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTopologyMapDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTopologyMapDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTopologyMapDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 filters: Sequence[str],
                 service: str):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param Sequence[str] filters: Your environment and primary tag (or `*` if enabled for your account).
        :param str service: APM service.
        """
        DashboardWidgetTopologyMapDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            filters=filters,
            service=service,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             filters: Sequence[str],
             service: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("filters", filters)
        _setter("service", service)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def filters(self) -> Sequence[str]:
        """
        Your environment and primary tag (or `*` if enabled for your account).
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class DashboardWidgetTraceServiceDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spanName":
            suggest = "span_name"
        elif key == "displayFormat":
            suggest = "display_format"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showBreakdown":
            suggest = "show_breakdown"
        elif key == "showDistribution":
            suggest = "show_distribution"
        elif key == "showErrors":
            suggest = "show_errors"
        elif key == "showHits":
            suggest = "show_hits"
        elif key == "showLatency":
            suggest = "show_latency"
        elif key == "showResourceList":
            suggest = "show_resource_list"
        elif key == "sizeFormat":
            suggest = "size_format"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTraceServiceDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTraceServiceDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTraceServiceDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env: str,
                 service: str,
                 span_name: str,
                 display_format: Optional[str] = None,
                 live_span: Optional[str] = None,
                 show_breakdown: Optional[bool] = None,
                 show_distribution: Optional[bool] = None,
                 show_errors: Optional[bool] = None,
                 show_hits: Optional[bool] = None,
                 show_latency: Optional[bool] = None,
                 show_resource_list: Optional[bool] = None,
                 size_format: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str env: APM Environment.
        :param str service: APM service.
        :param str span_name: APM span name
        :param str display_format: The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        :param bool show_breakdown: Whether to show the latency breakdown or not.
        :param bool show_distribution: Whether to show the latency distribution or not.
        :param bool show_errors: Whether to show the error metrics or not.
        :param bool show_hits: Whether to show the hits metrics or not
        :param bool show_latency: Whether to show the latency metrics or not.
        :param bool show_resource_list: Whether to show the resource list or not.
        :param str size_format: The size of the widget. Valid values are `small`, `medium`, `large`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        DashboardWidgetTraceServiceDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            env=env,
            service=service,
            span_name=span_name,
            display_format=display_format,
            live_span=live_span,
            show_breakdown=show_breakdown,
            show_distribution=show_distribution,
            show_errors=show_errors,
            show_hits=show_hits,
            show_latency=show_latency,
            show_resource_list=show_resource_list,
            size_format=size_format,
            title=title,
            title_align=title_align,
            title_size=title_size,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             env: str,
             service: str,
             span_name: str,
             display_format: Optional[str] = None,
             live_span: Optional[str] = None,
             show_breakdown: Optional[bool] = None,
             show_distribution: Optional[bool] = None,
             show_errors: Optional[bool] = None,
             show_hits: Optional[bool] = None,
             show_latency: Optional[bool] = None,
             show_resource_list: Optional[bool] = None,
             size_format: Optional[str] = None,
             title: Optional[str] = None,
             title_align: Optional[str] = None,
             title_size: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("env", env)
        _setter("service", service)
        _setter("span_name", span_name)
        if display_format is not None:
            _setter("display_format", display_format)
        if live_span is not None:
            _setter("live_span", live_span)
        if show_breakdown is not None:
            _setter("show_breakdown", show_breakdown)
        if show_distribution is not None:
            _setter("show_distribution", show_distribution)
        if show_errors is not None:
            _setter("show_errors", show_errors)
        if show_hits is not None:
            _setter("show_hits", show_hits)
        if show_latency is not None:
            _setter("show_latency", show_latency)
        if show_resource_list is not None:
            _setter("show_resource_list", show_resource_list)
        if size_format is not None:
            _setter("size_format", size_format)
        if title is not None:
            _setter("title", title)
        if title_align is not None:
            _setter("title_align", title_align)
        if title_size is not None:
            _setter("title_size", title_size)

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="spanName")
    def span_name(self) -> str:
        """
        APM span name
        """
        return pulumi.get(self, "span_name")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        """
        The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
        """
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="showBreakdown")
    def show_breakdown(self) -> Optional[bool]:
        """
        Whether to show the latency breakdown or not.
        """
        return pulumi.get(self, "show_breakdown")

    @property
    @pulumi.getter(name="showDistribution")
    def show_distribution(self) -> Optional[bool]:
        """
        Whether to show the latency distribution or not.
        """
        return pulumi.get(self, "show_distribution")

    @property
    @pulumi.getter(name="showErrors")
    def show_errors(self) -> Optional[bool]:
        """
        Whether to show the error metrics or not.
        """
        return pulumi.get(self, "show_errors")

    @property
    @pulumi.getter(name="showHits")
    def show_hits(self) -> Optional[bool]:
        """
        Whether to show the hits metrics or not
        """
        return pulumi.get(self, "show_hits")

    @property
    @pulumi.getter(name="showLatency")
    def show_latency(self) -> Optional[bool]:
        """
        Whether to show the latency metrics or not.
        """
        return pulumi.get(self, "show_latency")

    @property
    @pulumi.getter(name="showResourceList")
    def show_resource_list(self) -> Optional[bool]:
        """
        Whether to show the resource list or not.
        """
        return pulumi.get(self, "show_resource_list")

    @property
    @pulumi.getter(name="sizeFormat")
    def size_format(self) -> Optional[str]:
        """
        The size of the widget. Valid values are `small`, `medium`, `large`.
        """
        return pulumi.get(self, "size_format")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetTreemapDefinition(dict):
    def __init__(__self__, *,
                 requests: Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequest']] = None,
                 title: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetTreemapDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        """
        DashboardWidgetTreemapDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            requests=requests,
            title=title,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             requests: Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequest']] = None,
             title: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if requests is not None:
            _setter("requests", requests)
        if title is not None:
            _setter("title", title)

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequest(dict):
    def __init__(__self__, *,
                 formulas: Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestFormula']] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestQuery']] = None):
        DashboardWidgetTreemapDefinitionRequest._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formulas=formulas,
            queries=queries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formulas: Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestFormula']] = None,
             queries: Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestQuery']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if formulas is not None:
            _setter("formulas", formulas)
        if queries is not None:
            _setter("queries", queries)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetTreemapDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetTreemapDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetTreemapDefinitionRequestFormulaLimitArgs' limit: The maximum number of items in the group.
        :param 'DashboardWidgetTreemapDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        DashboardWidgetTreemapDefinitionRequestFormula._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            formula_expression=formula_expression,
            alias=alias,
            cell_display_mode=cell_display_mode,
            conditional_formats=conditional_formats,
            limit=limit,
            style=style,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             formula_expression: str,
             alias: Optional[str] = None,
             cell_display_mode: Optional[str] = None,
             conditional_formats: Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat']] = None,
             limit: Optional['outputs.DashboardWidgetTreemapDefinitionRequestFormulaLimit'] = None,
             style: Optional['outputs.DashboardWidgetTreemapDefinitionRequestFormulaStyle'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("formula_expression", formula_expression)
        if alias is not None:
            _setter("alias", alias)
        if cell_display_mode is not None:
            _setter("cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            _setter("conditional_formats", conditional_formats)
        if limit is not None:
            _setter("limit", limit)
        if style is not None:
            _setter("style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestFormulaLimit']:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            comparator=comparator,
            palette=palette,
            value=value,
            custom_bg_color=custom_bg_color,
            custom_fg_color=custom_fg_color,
            hide_value=hide_value,
            image_url=image_url,
            metric=metric,
            timeframe=timeframe,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             comparator: str,
             palette: str,
             value: float,
             custom_bg_color: Optional[str] = None,
             custom_fg_color: Optional[str] = None,
             hide_value: Optional[bool] = None,
             image_url: Optional[str] = None,
             metric: Optional[str] = None,
             timeframe: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("comparator", comparator)
        _setter("palette", palette)
        _setter("value", value)
        if custom_bg_color is not None:
            _setter("custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            _setter("custom_fg_color", custom_fg_color)
        if hide_value is not None:
            _setter("hide_value", hide_value)
        if image_url is not None:
            _setter("image_url", image_url)
        if metric is not None:
            _setter("metric", metric)
        if timeframe is not None:
            _setter("timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetTreemapDefinitionRequestFormulaLimit._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        DashboardWidgetTreemapDefinitionRequestFormulaStyle._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            palette=palette,
            palette_index=palette_index,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             palette: Optional[str] = None,
             palette_index: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if palette is not None:
            _setter("palette", palette)
        if palette_index is not None:
            _setter("palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetTreemapDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetTreemapDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetTreemapDefinitionRequestQueryProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param 'DashboardWidgetTreemapDefinitionRequestQuerySloQueryArgs' slo_query: The slo query using formulas and functions.
        """
        DashboardWidgetTreemapDefinitionRequestQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            apm_dependency_stats_query=apm_dependency_stats_query,
            apm_resource_stats_query=apm_resource_stats_query,
            event_query=event_query,
            metric_query=metric_query,
            process_query=process_query,
            slo_query=slo_query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             apm_dependency_stats_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery'] = None,
             apm_resource_stats_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery'] = None,
             event_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQuery'] = None,
             metric_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryMetricQuery'] = None,
             process_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryProcessQuery'] = None,
             slo_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQuerySloQuery'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if apm_dependency_stats_query is not None:
            _setter("apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            _setter("apm_resource_stats_query", apm_resource_stats_query)
        if event_query is not None:
            _setter("event_query", event_query)
        if metric_query is not None:
            _setter("metric_query", metric_query)
        if process_query is not None:
            _setter("process_query", process_query)
        if slo_query is not None:
            _setter("slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestQuerySloQuery']:
        """
        The slo query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            operation_name=operation_name,
            resource_name=resource_name,
            service=service,
            stat=stat,
            is_upstream=is_upstream,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             operation_name: str,
             resource_name: str,
             service: str,
             stat: str,
             is_upstream: Optional[bool] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("operation_name", operation_name)
        _setter("resource_name", resource_name)
        _setter("service", service)
        _setter("stat", stat)
        if is_upstream is not None:
            _setter("is_upstream", is_upstream)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM Environment.
        :param str name: The name of the variable.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param Sequence[str] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            env=env,
            name=name,
            service=service,
            stat=stat,
            group_bies=group_bies,
            operation_name=operation_name,
            primary_tag_name=primary_tag_name,
            primary_tag_value=primary_tag_value,
            resource_name=resource_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             env: str,
             name: str,
             service: str,
             stat: str,
             group_bies: Optional[Sequence[str]] = None,
             operation_name: Optional[str] = None,
             primary_tag_name: Optional[str] = None,
             primary_tag_value: Optional[str] = None,
             resource_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("env", env)
        _setter("name", name)
        _setter("service", service)
        _setter("stat", stat)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if operation_name is not None:
            _setter("operation_name", operation_name)
        if primary_tag_name is not None:
            _setter("primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            _setter("primary_tag_value", primary_tag_value)
        if resource_name is not None:
            _setter("resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM Environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetTreemapDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str name: The name of the variable.
        :param Sequence['DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        DashboardWidgetTreemapDefinitionRequestQueryEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            group_bies=group_bies,
            indexes=indexes,
            search=search,
            storage=storage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryCompute'],
             data_source: str,
             name: str,
             group_bies: Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             search: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearch'] = None,
             storage: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)
        if search is not None:
            _setter("search", search)
        if storage is not None:
            _setter("storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param int interval: Define the time interval in seconds.
        :param str metric: The metric from the request to correlate with this conditional format.
        """
        DashboardWidgetTreemapDefinitionRequestQueryEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        DashboardWidgetTreemapDefinitionRequestQueryMetricQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
            aggregator=aggregator,
            data_source=data_source,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             aggregator: Optional[str] = None,
             data_source: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if data_source is not None:
            _setter("data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str name: The name of the variable.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The maximum number of items in the group.
        :param str sort: The options for sorting group by results.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        DashboardWidgetTreemapDefinitionRequestQueryProcessQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            metric=metric,
            name=name,
            aggregator=aggregator,
            is_normalized_cpu=is_normalized_cpu,
            limit=limit,
            sort=sort,
            tag_filters=tag_filters,
            text_filter=text_filter,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             metric: str,
             name: str,
             aggregator: Optional[str] = None,
             is_normalized_cpu: Optional[bool] = None,
             limit: Optional[int] = None,
             sort: Optional[str] = None,
             tag_filters: Optional[Sequence[str]] = None,
             text_filter: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("metric", metric)
        _setter("name", name)
        if aggregator is not None:
            _setter("aggregator", aggregator)
        if is_normalized_cpu is not None:
            _setter("is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)
        if tag_filters is not None:
            _setter("tag_filters", tag_filters)
        if text_filter is not None:
            _setter("text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`.
        :param str name: The name of the variable.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`.
        """
        DashboardWidgetTreemapDefinitionRequestQuerySloQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            data_source=data_source,
            measure=measure,
            slo_id=slo_id,
            additional_query_filters=additional_query_filters,
            group_mode=group_mode,
            name=name,
            slo_query_type=slo_query_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             data_source: str,
             measure: str,
             slo_id: str,
             additional_query_filters: Optional[str] = None,
             group_mode: Optional[str] = None,
             name: Optional[str] = None,
             slo_query_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("data_source", data_source)
        _setter("measure", measure)
        _setter("slo_id", slo_id)
        if additional_query_filters is not None:
            _setter("additional_query_filters", additional_query_filters)
        if group_mode is not None:
            _setter("group_mode", group_mode)
        if name is not None:
            _setter("name", name)
        if slo_query_type is not None:
            _setter("slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetWidgetLayout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isColumnBreak":
            suggest = "is_column_break"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetWidgetLayout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetWidgetLayout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetWidgetLayout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 height: int,
                 width: int,
                 x: int,
                 y: int,
                 is_column_break: Optional[bool] = None):
        """
        :param int height: The height of the widget.
        :param int width: Widget column width. Valid values are `auto`, `compact`, `full`.
        :param int x: The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        :param int y: The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        :param bool is_column_break: Whether the widget should be the first one on the second column in high density or not. Only for the new dashboard layout and only one widget in the dashboard should have this property set to `true`.
        """
        DashboardWidgetWidgetLayout._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            height=height,
            width=width,
            x=x,
            y=y,
            is_column_break=is_column_break,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             height: int,
             width: int,
             x: int,
             y: int,
             is_column_break: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("height", height)
        _setter("width", width)
        _setter("x", x)
        _setter("y", y)
        if is_column_break is not None:
            _setter("is_column_break", is_column_break)

    @property
    @pulumi.getter
    def height(self) -> int:
        """
        The height of the widget.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> int:
        """
        Widget column width. Valid values are `auto`, `compact`, `full`.
        """
        return pulumi.get(self, "width")

    @property
    @pulumi.getter
    def x(self) -> int:
        """
        The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> int:
        """
        The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        return pulumi.get(self, "y")

    @property
    @pulumi.getter(name="isColumnBreak")
    def is_column_break(self) -> Optional[bool]:
        """
        Whether the widget should be the first one on the second column in high density or not. Only for the new dashboard layout and only one widget in the dashboard should have this property set to `true`.
        """
        return pulumi.get(self, "is_column_break")


@pulumi.output_type
class DowntimeRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "untilDate":
            suggest = "until_date"
        elif key == "untilOccurrences":
            suggest = "until_occurrences"
        elif key == "weekDays":
            suggest = "week_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DowntimeRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DowntimeRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DowntimeRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 period: Optional[int] = None,
                 rrule: Optional[str] = None,
                 until_date: Optional[int] = None,
                 until_occurrences: Optional[int] = None,
                 week_days: Optional[Sequence[str]] = None):
        """
        :param str type: One of `days`, `weeks`, `months`, `years`, or `rrule`.
        :param int period: How often to repeat as an integer. For example to repeat every 3 days, select a `type` of `days` and a `period` of `3`.
        :param str rrule: The RRULE standard for defining recurring events. For example, to have a recurring event on the first day of each month, use `FREQ=MONTHLY;INTERVAL=1`. Most common rrule options from the iCalendar Spec are supported. Attributes specifying the duration in RRULE are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). Only applicable when `type` is `rrule`.
        :param int until_date: The date at which the recurrence should end as a POSIX timestamp. `until_occurrences` and `until_date` are mutually exclusive.
        :param int until_occurrences: How many times the downtime will be rescheduled. `until_occurrences` and `until_date` are mutually exclusive.
        :param Sequence[str] week_days: A list of week days to repeat on. Choose from: `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`. Only applicable when `type` is `weeks`. First letter must be capitalized.
        """
        DowntimeRecurrence._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            period=period,
            rrule=rrule,
            until_date=until_date,
            until_occurrences=until_occurrences,
            week_days=week_days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             period: Optional[int] = None,
             rrule: Optional[str] = None,
             until_date: Optional[int] = None,
             until_occurrences: Optional[int] = None,
             week_days: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if period is not None:
            _setter("period", period)
        if rrule is not None:
            _setter("rrule", rrule)
        if until_date is not None:
            _setter("until_date", until_date)
        if until_occurrences is not None:
            _setter("until_occurrences", until_occurrences)
        if week_days is not None:
            _setter("week_days", week_days)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        One of `days`, `weeks`, `months`, `years`, or `rrule`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        """
        How often to repeat as an integer. For example to repeat every 3 days, select a `type` of `days` and a `period` of `3`.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def rrule(self) -> Optional[str]:
        """
        The RRULE standard for defining recurring events. For example, to have a recurring event on the first day of each month, use `FREQ=MONTHLY;INTERVAL=1`. Most common rrule options from the iCalendar Spec are supported. Attributes specifying the duration in RRULE are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). Only applicable when `type` is `rrule`.
        """
        return pulumi.get(self, "rrule")

    @property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[int]:
        """
        The date at which the recurrence should end as a POSIX timestamp. `until_occurrences` and `until_date` are mutually exclusive.
        """
        return pulumi.get(self, "until_date")

    @property
    @pulumi.getter(name="untilOccurrences")
    def until_occurrences(self) -> Optional[int]:
        """
        How many times the downtime will be rescheduled. `until_occurrences` and `until_date` are mutually exclusive.
        """
        return pulumi.get(self, "until_occurrences")

    @property
    @pulumi.getter(name="weekDays")
    def week_days(self) -> Optional[Sequence[str]]:
        """
        A list of week days to repeat on. Choose from: `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`. Only applicable when `type` is `weeks`. First letter must be capitalized.
        """
        return pulumi.get(self, "week_days")


@pulumi.output_type
class DowntimeScheduleMonitorIdentifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitorId":
            suggest = "monitor_id"
        elif key == "monitorTags":
            suggest = "monitor_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DowntimeScheduleMonitorIdentifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DowntimeScheduleMonitorIdentifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DowntimeScheduleMonitorIdentifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitor_id: Optional[int] = None,
                 monitor_tags: Optional[Sequence[str]] = None):
        """
        :param int monitor_id: ID of the monitor to prevent notifications.
        :param Sequence[str] monitor_tags: A list of monitor tags. For example, tags that are applied directly to monitors, not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies. The resulting downtime applies to monitors that match **all** provided monitor tags. Setting `monitor_tags` to `[*]` configures the downtime to mute all monitors for the given scope.
        """
        DowntimeScheduleMonitorIdentifier._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            monitor_id=monitor_id,
            monitor_tags=monitor_tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             monitor_id: Optional[int] = None,
             monitor_tags: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if monitor_id is not None:
            _setter("monitor_id", monitor_id)
        if monitor_tags is not None:
            _setter("monitor_tags", monitor_tags)

    @property
    @pulumi.getter(name="monitorId")
    def monitor_id(self) -> Optional[int]:
        """
        ID of the monitor to prevent notifications.
        """
        return pulumi.get(self, "monitor_id")

    @property
    @pulumi.getter(name="monitorTags")
    def monitor_tags(self) -> Optional[Sequence[str]]:
        """
        A list of monitor tags. For example, tags that are applied directly to monitors, not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies. The resulting downtime applies to monitors that match **all** provided monitor tags. Setting `monitor_tags` to `[*]` configures the downtime to mute all monitors for the given scope.
        """
        return pulumi.get(self, "monitor_tags")


@pulumi.output_type
class DowntimeScheduleOneTimeSchedule(dict):
    def __init__(__self__, *,
                 end: Optional[str] = None,
                 start: Optional[str] = None):
        """
        :param str end: ISO-8601 Datetime to end the downtime. Must include a UTC offset of zero. If not provided, the downtime never ends.
        :param str start: ISO-8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
        """
        DowntimeScheduleOneTimeSchedule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end=end,
            start=start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end: Optional[str] = None,
             start: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if end is not None:
            _setter("end", end)
        if start is not None:
            _setter("start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[str]:
        """
        ISO-8601 Datetime to end the downtime. Must include a UTC offset of zero. If not provided, the downtime never ends.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> Optional[str]:
        """
        ISO-8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class DowntimeScheduleRecurringSchedule(dict):
    def __init__(__self__, *,
                 recurrences: Optional[Sequence['outputs.DowntimeScheduleRecurringScheduleRecurrence']] = None,
                 timezone: Optional[str] = None):
        """
        :param str timezone: The timezone in which to schedule the downtime.
        """
        DowntimeScheduleRecurringSchedule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            recurrences=recurrences,
            timezone=timezone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             recurrences: Optional[Sequence['outputs.DowntimeScheduleRecurringScheduleRecurrence']] = None,
             timezone: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if recurrences is not None:
            _setter("recurrences", recurrences)
        if timezone is not None:
            _setter("timezone", timezone)

    @property
    @pulumi.getter
    def recurrences(self) -> Optional[Sequence['outputs.DowntimeScheduleRecurringScheduleRecurrence']]:
        return pulumi.get(self, "recurrences")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        The timezone in which to schedule the downtime.
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class DowntimeScheduleRecurringScheduleRecurrence(dict):
    def __init__(__self__, *,
                 duration: str,
                 rrule: str,
                 start: Optional[str] = None):
        """
        :param str duration: The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
        :param str rrule: The `RRULE` standard for defining recurring events. For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`. Most common `rrule` options from the [iCalendar Spec](https://tools.ietf.org/html/rfc5545) are supported.  **Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api).
        :param str start: ISO-8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
        """
        DowntimeScheduleRecurringScheduleRecurrence._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            duration=duration,
            rrule=rrule,
            start=start,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             duration: str,
             rrule: str,
             start: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("duration", duration)
        _setter("rrule", rrule)
        if start is not None:
            _setter("start", start)

    @property
    @pulumi.getter
    def duration(self) -> str:
        """
        The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def rrule(self) -> str:
        """
        The `RRULE` standard for defining recurring events. For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`. Most common `rrule` options from the [iCalendar Spec](https://tools.ietf.org/html/rfc5545) are supported.  **Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api).
        """
        return pulumi.get(self, "rrule")

    @property
    @pulumi.getter
    def start(self) -> Optional[str]:
        """
        ISO-8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class IpAllowlistEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrBlock":
            suggest = "cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpAllowlistEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpAllowlistEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpAllowlistEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_block: str,
                 note: Optional[str] = None):
        """
        :param str note: Note accompanying IP address.
        """
        IpAllowlistEntry._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cidr_block=cidr_block,
            note=note,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cidr_block: str,
             note: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cidr_block", cidr_block)
        if note is not None:
            _setter("note", note)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> str:
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter
    def note(self) -> Optional[str]:
        """
        Note accompanying IP address.
        """
        return pulumi.get(self, "note")


@pulumi.output_type
class LogsArchiveAzureArchive(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "storageAccount":
            suggest = "storage_account"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsArchiveAzureArchive. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsArchiveAzureArchive.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsArchiveAzureArchive.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 container: str,
                 storage_account: str,
                 tenant_id: str,
                 path: Optional[str] = None):
        """
        :param str client_id: Your client id.
        :param str container: The container where the archive is stored.
        :param str storage_account: The associated storage account.
        :param str tenant_id: Your tenant id.
        :param str path: The path where the archive is stored.
        """
        LogsArchiveAzureArchive._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            client_id=client_id,
            container=container,
            storage_account=storage_account,
            tenant_id=tenant_id,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             client_id: str,
             container: str,
             storage_account: str,
             tenant_id: str,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("client_id", client_id)
        _setter("container", container)
        _setter("storage_account", storage_account)
        _setter("tenant_id", tenant_id)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Your client id.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def container(self) -> str:
        """
        The container where the archive is stored.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="storageAccount")
    def storage_account(self) -> str:
        """
        The associated storage account.
        """
        return pulumi.get(self, "storage_account")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Your tenant id.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path where the archive is stored.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class LogsArchiveGcsArchive(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientEmail":
            suggest = "client_email"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsArchiveGcsArchive. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsArchiveGcsArchive.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsArchiveGcsArchive.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 client_email: str,
                 project_id: str,
                 path: Optional[str] = None):
        """
        :param str bucket: Name of your GCS bucket.
        :param str client_email: Your client email.
        :param str project_id: Your project id.
        :param str path: Path where the archive is stored.
        """
        LogsArchiveGcsArchive._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            bucket=bucket,
            client_email=client_email,
            project_id=project_id,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             bucket: str,
             client_email: str,
             project_id: str,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("bucket", bucket)
        _setter("client_email", client_email)
        _setter("project_id", project_id)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of your GCS bucket.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> str:
        """
        Your client email.
        """
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> str:
        """
        Your project id.
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path where the archive is stored.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class LogsArchiveS3Archive(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "roleName":
            suggest = "role_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsArchiveS3Archive. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsArchiveS3Archive.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsArchiveS3Archive.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str,
                 bucket: str,
                 role_name: str,
                 path: Optional[str] = None):
        """
        :param str account_id: Your AWS account id.
        :param str bucket: Name of your s3 bucket.
        :param str role_name: Your AWS role name
        :param str path: Path where the archive is stored.
        """
        LogsArchiveS3Archive._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            account_id=account_id,
            bucket=bucket,
            role_name=role_name,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             account_id: str,
             bucket: str,
             role_name: str,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("account_id", account_id)
        _setter("bucket", bucket)
        _setter("role_name", role_name)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        Your AWS account id.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of your s3 bucket.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Your AWS role name
        """
        return pulumi.get(self, "role_name")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path where the archive is stored.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class LogsCustomPipelineFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Filter criteria of the category.
        """
        LogsCustomPipelineFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Filter criteria of the category.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsCustomPipelineProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arithmeticProcessor":
            suggest = "arithmetic_processor"
        elif key == "attributeRemapper":
            suggest = "attribute_remapper"
        elif key == "categoryProcessor":
            suggest = "category_processor"
        elif key == "dateRemapper":
            suggest = "date_remapper"
        elif key == "geoIpParser":
            suggest = "geo_ip_parser"
        elif key == "grokParser":
            suggest = "grok_parser"
        elif key == "lookupProcessor":
            suggest = "lookup_processor"
        elif key == "messageRemapper":
            suggest = "message_remapper"
        elif key == "referenceTableLookupProcessor":
            suggest = "reference_table_lookup_processor"
        elif key == "serviceRemapper":
            suggest = "service_remapper"
        elif key == "statusRemapper":
            suggest = "status_remapper"
        elif key == "stringBuilderProcessor":
            suggest = "string_builder_processor"
        elif key == "traceIdRemapper":
            suggest = "trace_id_remapper"
        elif key == "urlParser":
            suggest = "url_parser"
        elif key == "userAgentParser":
            suggest = "user_agent_parser"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arithmetic_processor: Optional['outputs.LogsCustomPipelineProcessorArithmeticProcessor'] = None,
                 attribute_remapper: Optional['outputs.LogsCustomPipelineProcessorAttributeRemapper'] = None,
                 category_processor: Optional['outputs.LogsCustomPipelineProcessorCategoryProcessor'] = None,
                 date_remapper: Optional['outputs.LogsCustomPipelineProcessorDateRemapper'] = None,
                 geo_ip_parser: Optional['outputs.LogsCustomPipelineProcessorGeoIpParser'] = None,
                 grok_parser: Optional['outputs.LogsCustomPipelineProcessorGrokParser'] = None,
                 lookup_processor: Optional['outputs.LogsCustomPipelineProcessorLookupProcessor'] = None,
                 message_remapper: Optional['outputs.LogsCustomPipelineProcessorMessageRemapper'] = None,
                 pipeline: Optional['outputs.LogsCustomPipelineProcessorPipeline'] = None,
                 reference_table_lookup_processor: Optional['outputs.LogsCustomPipelineProcessorReferenceTableLookupProcessor'] = None,
                 service_remapper: Optional['outputs.LogsCustomPipelineProcessorServiceRemapper'] = None,
                 status_remapper: Optional['outputs.LogsCustomPipelineProcessorStatusRemapper'] = None,
                 string_builder_processor: Optional['outputs.LogsCustomPipelineProcessorStringBuilderProcessor'] = None,
                 trace_id_remapper: Optional['outputs.LogsCustomPipelineProcessorTraceIdRemapper'] = None,
                 url_parser: Optional['outputs.LogsCustomPipelineProcessorUrlParser'] = None,
                 user_agent_parser: Optional['outputs.LogsCustomPipelineProcessorUserAgentParser'] = None):
        """
        :param 'LogsCustomPipelineProcessorArithmeticProcessorArgs' arithmetic_processor: Arithmetic Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#arithmetic-processor)
        :param 'LogsCustomPipelineProcessorAttributeRemapperArgs' attribute_remapper: Attribute Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#remapper)
        :param 'LogsCustomPipelineProcessorCategoryProcessorArgs' category_processor: Category Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#category-processor)
        :param 'LogsCustomPipelineProcessorDateRemapperArgs' date_remapper: Date Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-date-remapper)
        :param 'LogsCustomPipelineProcessorGeoIpParserArgs' geo_ip_parser: Date GeoIP Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#geoip-parser)
        :param 'LogsCustomPipelineProcessorGrokParserArgs' grok_parser: Grok Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#grok-parser)
        :param 'LogsCustomPipelineProcessorLookupProcessorArgs' lookup_processor: Lookup Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        :param 'LogsCustomPipelineProcessorMessageRemapperArgs' message_remapper: Message Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-message-remapper)
        :param 'LogsCustomPipelineProcessorReferenceTableLookupProcessorArgs' reference_table_lookup_processor: Reference Table Lookup Processor. Reference Tables are in public beta. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        :param 'LogsCustomPipelineProcessorServiceRemapperArgs' service_remapper: Service Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#service-remapper)
        :param 'LogsCustomPipelineProcessorStatusRemapperArgs' status_remapper: Status Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-status-remapper)
        :param 'LogsCustomPipelineProcessorStringBuilderProcessorArgs' string_builder_processor: String Builder Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#string-builder-processor)
        :param 'LogsCustomPipelineProcessorTraceIdRemapperArgs' trace_id_remapper: Trace ID Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#trace-remapper)
        :param 'LogsCustomPipelineProcessorUrlParserArgs' url_parser: URL Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#url-parser)
        :param 'LogsCustomPipelineProcessorUserAgentParserArgs' user_agent_parser: User-Agent Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#user-agent-parser)
        """
        LogsCustomPipelineProcessor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arithmetic_processor=arithmetic_processor,
            attribute_remapper=attribute_remapper,
            category_processor=category_processor,
            date_remapper=date_remapper,
            geo_ip_parser=geo_ip_parser,
            grok_parser=grok_parser,
            lookup_processor=lookup_processor,
            message_remapper=message_remapper,
            pipeline=pipeline,
            reference_table_lookup_processor=reference_table_lookup_processor,
            service_remapper=service_remapper,
            status_remapper=status_remapper,
            string_builder_processor=string_builder_processor,
            trace_id_remapper=trace_id_remapper,
            url_parser=url_parser,
            user_agent_parser=user_agent_parser,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arithmetic_processor: Optional['outputs.LogsCustomPipelineProcessorArithmeticProcessor'] = None,
             attribute_remapper: Optional['outputs.LogsCustomPipelineProcessorAttributeRemapper'] = None,
             category_processor: Optional['outputs.LogsCustomPipelineProcessorCategoryProcessor'] = None,
             date_remapper: Optional['outputs.LogsCustomPipelineProcessorDateRemapper'] = None,
             geo_ip_parser: Optional['outputs.LogsCustomPipelineProcessorGeoIpParser'] = None,
             grok_parser: Optional['outputs.LogsCustomPipelineProcessorGrokParser'] = None,
             lookup_processor: Optional['outputs.LogsCustomPipelineProcessorLookupProcessor'] = None,
             message_remapper: Optional['outputs.LogsCustomPipelineProcessorMessageRemapper'] = None,
             pipeline: Optional['outputs.LogsCustomPipelineProcessorPipeline'] = None,
             reference_table_lookup_processor: Optional['outputs.LogsCustomPipelineProcessorReferenceTableLookupProcessor'] = None,
             service_remapper: Optional['outputs.LogsCustomPipelineProcessorServiceRemapper'] = None,
             status_remapper: Optional['outputs.LogsCustomPipelineProcessorStatusRemapper'] = None,
             string_builder_processor: Optional['outputs.LogsCustomPipelineProcessorStringBuilderProcessor'] = None,
             trace_id_remapper: Optional['outputs.LogsCustomPipelineProcessorTraceIdRemapper'] = None,
             url_parser: Optional['outputs.LogsCustomPipelineProcessorUrlParser'] = None,
             user_agent_parser: Optional['outputs.LogsCustomPipelineProcessorUserAgentParser'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arithmetic_processor is not None:
            _setter("arithmetic_processor", arithmetic_processor)
        if attribute_remapper is not None:
            _setter("attribute_remapper", attribute_remapper)
        if category_processor is not None:
            _setter("category_processor", category_processor)
        if date_remapper is not None:
            _setter("date_remapper", date_remapper)
        if geo_ip_parser is not None:
            _setter("geo_ip_parser", geo_ip_parser)
        if grok_parser is not None:
            _setter("grok_parser", grok_parser)
        if lookup_processor is not None:
            _setter("lookup_processor", lookup_processor)
        if message_remapper is not None:
            _setter("message_remapper", message_remapper)
        if pipeline is not None:
            _setter("pipeline", pipeline)
        if reference_table_lookup_processor is not None:
            _setter("reference_table_lookup_processor", reference_table_lookup_processor)
        if service_remapper is not None:
            _setter("service_remapper", service_remapper)
        if status_remapper is not None:
            _setter("status_remapper", status_remapper)
        if string_builder_processor is not None:
            _setter("string_builder_processor", string_builder_processor)
        if trace_id_remapper is not None:
            _setter("trace_id_remapper", trace_id_remapper)
        if url_parser is not None:
            _setter("url_parser", url_parser)
        if user_agent_parser is not None:
            _setter("user_agent_parser", user_agent_parser)

    @property
    @pulumi.getter(name="arithmeticProcessor")
    def arithmetic_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorArithmeticProcessor']:
        """
        Arithmetic Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#arithmetic-processor)
        """
        return pulumi.get(self, "arithmetic_processor")

    @property
    @pulumi.getter(name="attributeRemapper")
    def attribute_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorAttributeRemapper']:
        """
        Attribute Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#remapper)
        """
        return pulumi.get(self, "attribute_remapper")

    @property
    @pulumi.getter(name="categoryProcessor")
    def category_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorCategoryProcessor']:
        """
        Category Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#category-processor)
        """
        return pulumi.get(self, "category_processor")

    @property
    @pulumi.getter(name="dateRemapper")
    def date_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorDateRemapper']:
        """
        Date Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-date-remapper)
        """
        return pulumi.get(self, "date_remapper")

    @property
    @pulumi.getter(name="geoIpParser")
    def geo_ip_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorGeoIpParser']:
        """
        Date GeoIP Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#geoip-parser)
        """
        return pulumi.get(self, "geo_ip_parser")

    @property
    @pulumi.getter(name="grokParser")
    def grok_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorGrokParser']:
        """
        Grok Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#grok-parser)
        """
        return pulumi.get(self, "grok_parser")

    @property
    @pulumi.getter(name="lookupProcessor")
    def lookup_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorLookupProcessor']:
        """
        Lookup Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        """
        return pulumi.get(self, "lookup_processor")

    @property
    @pulumi.getter(name="messageRemapper")
    def message_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorMessageRemapper']:
        """
        Message Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-message-remapper)
        """
        return pulumi.get(self, "message_remapper")

    @property
    @pulumi.getter
    def pipeline(self) -> Optional['outputs.LogsCustomPipelineProcessorPipeline']:
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter(name="referenceTableLookupProcessor")
    def reference_table_lookup_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorReferenceTableLookupProcessor']:
        """
        Reference Table Lookup Processor. Reference Tables are in public beta. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        """
        return pulumi.get(self, "reference_table_lookup_processor")

    @property
    @pulumi.getter(name="serviceRemapper")
    def service_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorServiceRemapper']:
        """
        Service Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#service-remapper)
        """
        return pulumi.get(self, "service_remapper")

    @property
    @pulumi.getter(name="statusRemapper")
    def status_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorStatusRemapper']:
        """
        Status Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-status-remapper)
        """
        return pulumi.get(self, "status_remapper")

    @property
    @pulumi.getter(name="stringBuilderProcessor")
    def string_builder_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorStringBuilderProcessor']:
        """
        String Builder Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#string-builder-processor)
        """
        return pulumi.get(self, "string_builder_processor")

    @property
    @pulumi.getter(name="traceIdRemapper")
    def trace_id_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorTraceIdRemapper']:
        """
        Trace ID Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#trace-remapper)
        """
        return pulumi.get(self, "trace_id_remapper")

    @property
    @pulumi.getter(name="urlParser")
    def url_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorUrlParser']:
        """
        URL Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#url-parser)
        """
        return pulumi.get(self, "url_parser")

    @property
    @pulumi.getter(name="userAgentParser")
    def user_agent_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorUserAgentParser']:
        """
        User-Agent Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#user-agent-parser)
        """
        return pulumi.get(self, "user_agent_parser")


@pulumi.output_type
class LogsCustomPipelineProcessorArithmeticProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isReplaceMissing":
            suggest = "is_replace_missing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorArithmeticProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorArithmeticProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorArithmeticProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 target: str,
                 is_enabled: Optional[bool] = None,
                 is_replace_missing: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str expression: Arithmetic operation between one or more log attributes.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param bool is_replace_missing: If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorArithmeticProcessor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            target=target,
            is_enabled=is_enabled,
            is_replace_missing=is_replace_missing,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             target: str,
             is_enabled: Optional[bool] = None,
             is_replace_missing: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        _setter("target", target)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if is_replace_missing is not None:
            _setter("is_replace_missing", is_replace_missing)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Arithmetic operation between one or more log attributes.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[bool]:
        """
        If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
        """
        return pulumi.get(self, "is_replace_missing")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorAttributeRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"
        elif key == "targetType":
            suggest = "target_type"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "overrideOnConflict":
            suggest = "override_on_conflict"
        elif key == "preserveSource":
            suggest = "preserve_source"
        elif key == "targetFormat":
            suggest = "target_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorAttributeRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorAttributeRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorAttributeRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 sources: Sequence[str],
                 target: str,
                 target_type: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 override_on_conflict: Optional[bool] = None,
                 preserve_source: Optional[bool] = None,
                 target_format: Optional[str] = None):
        """
        :param str source_type: Defines where the sources are from (log `attribute` or `tag`).
        :param Sequence[str] sources: List of source attributes or tags.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param str target_type: Defines if the target is a log `attribute` or `tag`.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        :param bool override_on_conflict: Override the target element if already set.
        :param bool preserve_source: Remove or preserve the remapped source element.
        :param str target_format: If the `target_type` of the remapper is `attribute`, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. `string`, `integer`, or `double` are the possible types. If the `target_type` is `tag`, this parameter may not be specified.
        """
        LogsCustomPipelineProcessorAttributeRemapper._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_type=source_type,
            sources=sources,
            target=target,
            target_type=target_type,
            is_enabled=is_enabled,
            name=name,
            override_on_conflict=override_on_conflict,
            preserve_source=preserve_source,
            target_format=target_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_type: str,
             sources: Sequence[str],
             target: str,
             target_type: str,
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             override_on_conflict: Optional[bool] = None,
             preserve_source: Optional[bool] = None,
             target_format: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("source_type", source_type)
        _setter("sources", sources)
        _setter("target", target)
        _setter("target_type", target_type)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)
        if override_on_conflict is not None:
            _setter("override_on_conflict", override_on_conflict)
        if preserve_source is not None:
            _setter("preserve_source", preserve_source)
        if target_format is not None:
            _setter("target_format", target_format)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Defines where the sources are from (log `attribute` or `tag`).
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> str:
        """
        Defines if the target is a log `attribute` or `tag`.
        """
        return pulumi.get(self, "target_type")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideOnConflict")
    def override_on_conflict(self) -> Optional[bool]:
        """
        Override the target element if already set.
        """
        return pulumi.get(self, "override_on_conflict")

    @property
    @pulumi.getter(name="preserveSource")
    def preserve_source(self) -> Optional[bool]:
        """
        Remove or preserve the remapped source element.
        """
        return pulumi.get(self, "preserve_source")

    @property
    @pulumi.getter(name="targetFormat")
    def target_format(self) -> Optional[str]:
        """
        If the `target_type` of the remapper is `attribute`, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. `string`, `integer`, or `double` are the possible types. If the `target_type` is `tag`, this parameter may not be specified.
        """
        return pulumi.get(self, "target_format")


@pulumi.output_type
class LogsCustomPipelineProcessorCategoryProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorCategoryProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorCategoryProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorCategoryProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 categories: Sequence['outputs.LogsCustomPipelineProcessorCategoryProcessorCategory'],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence['LogsCustomPipelineProcessorCategoryProcessorCategoryArgs'] categories: List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorCategoryProcessor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            categories=categories,
            target=target,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             categories: Sequence['outputs.LogsCustomPipelineProcessorCategoryProcessorCategory'],
             target: str,
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("categories", categories)
        _setter("target", target)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def categories(self) -> Sequence['outputs.LogsCustomPipelineProcessorCategoryProcessorCategory']:
        """
        List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        """
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorCategoryProcessorCategory(dict):
    def __init__(__self__, *,
                 filter: 'outputs.LogsCustomPipelineProcessorCategoryProcessorCategoryFilter',
                 name: str):
        """
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorCategoryProcessorCategory._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter=filter,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter: 'outputs.LogsCustomPipelineProcessorCategoryProcessorCategoryFilter',
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter", filter)
        _setter("name", name)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.LogsCustomPipelineProcessorCategoryProcessorCategoryFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorCategoryProcessorCategoryFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Filter criteria of the category.
        """
        LogsCustomPipelineProcessorCategoryProcessorCategoryFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Filter criteria of the category.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsCustomPipelineProcessorDateRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorDateRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorDateRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorDateRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes or tags.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorDateRemapper._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sources=sources,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sources: Sequence[str],
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sources", sources)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorGeoIpParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorGeoIpParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorGeoIpParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorGeoIpParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes or tags.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorGeoIpParser._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sources=sources,
            target=target,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sources: Sequence[str],
             target: str,
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sources", sources)
        _setter("target", target)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorGrokParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorGrokParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorGrokParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorGrokParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grok: 'outputs.LogsCustomPipelineProcessorGrokParserGrok',
                 source: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 samples: Optional[Sequence[str]] = None):
        """
        :param str source: Name of the log attribute to parse.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        :param Sequence[str] samples: List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        LogsCustomPipelineProcessorGrokParser._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grok=grok,
            source=source,
            is_enabled=is_enabled,
            name=name,
            samples=samples,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grok: 'outputs.LogsCustomPipelineProcessorGrokParserGrok',
             source: str,
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             samples: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("grok", grok)
        _setter("source", source)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)
        if samples is not None:
            _setter("samples", samples)

    @property
    @pulumi.getter
    def grok(self) -> 'outputs.LogsCustomPipelineProcessorGrokParserGrok':
        return pulumi.get(self, "grok")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Name of the log attribute to parse.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def samples(self) -> Optional[Sequence[str]]:
        """
        List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        return pulumi.get(self, "samples")


@pulumi.output_type
class LogsCustomPipelineProcessorGrokParserGrok(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchRules":
            suggest = "match_rules"
        elif key == "supportRules":
            suggest = "support_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorGrokParserGrok. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorGrokParserGrok.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorGrokParserGrok.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_rules: str,
                 support_rules: str):
        """
        :param str match_rules: Match rules for your grok parser.
        :param str support_rules: Support rules for your grok parser.
        """
        LogsCustomPipelineProcessorGrokParserGrok._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_rules=match_rules,
            support_rules=support_rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_rules: str,
             support_rules: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("match_rules", match_rules)
        _setter("support_rules", support_rules)

    @property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> str:
        """
        Match rules for your grok parser.
        """
        return pulumi.get(self, "match_rules")

    @property
    @pulumi.getter(name="supportRules")
    def support_rules(self) -> str:
        """
        Support rules for your grok parser.
        """
        return pulumi.get(self, "support_rules")


@pulumi.output_type
class LogsCustomPipelineProcessorLookupProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lookupTables":
            suggest = "lookup_tables"
        elif key == "defaultLookup":
            suggest = "default_lookup"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorLookupProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorLookupProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorLookupProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lookup_tables: Sequence[str],
                 source: str,
                 target: str,
                 default_lookup: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] lookup_tables: List of entries of the lookup table using `key,value` format.
        :param str source: Name of the log attribute to parse.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param str default_lookup: Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorLookupProcessor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lookup_tables=lookup_tables,
            source=source,
            target=target,
            default_lookup=default_lookup,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lookup_tables: Sequence[str],
             source: str,
             target: str,
             default_lookup: Optional[str] = None,
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("lookup_tables", lookup_tables)
        _setter("source", source)
        _setter("target", target)
        if default_lookup is not None:
            _setter("default_lookup", default_lookup)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="lookupTables")
    def lookup_tables(self) -> Sequence[str]:
        """
        List of entries of the lookup table using `key,value` format.
        """
        return pulumi.get(self, "lookup_tables")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Name of the log attribute to parse.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="defaultLookup")
    def default_lookup(self) -> Optional[str]:
        """
        Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        """
        return pulumi.get(self, "default_lookup")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorMessageRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorMessageRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorMessageRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorMessageRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes or tags.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorMessageRemapper._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sources=sources,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sources: Sequence[str],
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sources", sources)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipeline(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipeline. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipeline.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipeline.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Sequence['outputs.LogsCustomPipelineProcessorPipelineFilter'],
                 name: str,
                 is_enabled: Optional[bool] = None,
                 processors: Optional[Sequence['outputs.LogsCustomPipelineProcessorPipelineProcessor']] = None):
        """
        :param str name: Your pipeline name.
        :param bool is_enabled: Boolean value to enable your pipeline.
        """
        LogsCustomPipelineProcessorPipeline._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filters=filters,
            name=name,
            is_enabled=is_enabled,
            processors=processors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filters: Sequence['outputs.LogsCustomPipelineProcessorPipelineFilter'],
             name: str,
             is_enabled: Optional[bool] = None,
             processors: Optional[Sequence['outputs.LogsCustomPipelineProcessorPipelineProcessor']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filters", filters)
        _setter("name", name)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if processors is not None:
            _setter("processors", processors)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.LogsCustomPipelineProcessorPipelineFilter']:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def processors(self) -> Optional[Sequence['outputs.LogsCustomPipelineProcessorPipelineProcessor']]:
        return pulumi.get(self, "processors")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Filter criteria of the category.
        """
        LogsCustomPipelineProcessorPipelineFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Filter criteria of the category.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arithmeticProcessor":
            suggest = "arithmetic_processor"
        elif key == "attributeRemapper":
            suggest = "attribute_remapper"
        elif key == "categoryProcessor":
            suggest = "category_processor"
        elif key == "dateRemapper":
            suggest = "date_remapper"
        elif key == "geoIpParser":
            suggest = "geo_ip_parser"
        elif key == "grokParser":
            suggest = "grok_parser"
        elif key == "lookupProcessor":
            suggest = "lookup_processor"
        elif key == "messageRemapper":
            suggest = "message_remapper"
        elif key == "referenceTableLookupProcessor":
            suggest = "reference_table_lookup_processor"
        elif key == "serviceRemapper":
            suggest = "service_remapper"
        elif key == "statusRemapper":
            suggest = "status_remapper"
        elif key == "stringBuilderProcessor":
            suggest = "string_builder_processor"
        elif key == "traceIdRemapper":
            suggest = "trace_id_remapper"
        elif key == "urlParser":
            suggest = "url_parser"
        elif key == "userAgentParser":
            suggest = "user_agent_parser"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arithmetic_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor'] = None,
                 attribute_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper'] = None,
                 category_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor'] = None,
                 date_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorDateRemapper'] = None,
                 geo_ip_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGeoIpParser'] = None,
                 grok_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParser'] = None,
                 lookup_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorLookupProcessor'] = None,
                 message_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorMessageRemapper'] = None,
                 reference_table_lookup_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor'] = None,
                 service_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorServiceRemapper'] = None,
                 status_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStatusRemapper'] = None,
                 string_builder_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor'] = None,
                 trace_id_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper'] = None,
                 url_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUrlParser'] = None,
                 user_agent_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUserAgentParser'] = None):
        """
        :param 'LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessorArgs' arithmetic_processor: Arithmetic Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#arithmetic-processor)
        :param 'LogsCustomPipelineProcessorPipelineProcessorAttributeRemapperArgs' attribute_remapper: Attribute Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#remapper)
        :param 'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorArgs' category_processor: Category Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#category-processor)
        :param 'LogsCustomPipelineProcessorPipelineProcessorDateRemapperArgs' date_remapper: Date Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-date-remapper)
        :param 'LogsCustomPipelineProcessorPipelineProcessorGeoIpParserArgs' geo_ip_parser: Date GeoIP Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#geoip-parser)
        :param 'LogsCustomPipelineProcessorPipelineProcessorGrokParserArgs' grok_parser: Grok Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#grok-parser)
        :param 'LogsCustomPipelineProcessorPipelineProcessorLookupProcessorArgs' lookup_processor: Lookup Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        :param 'LogsCustomPipelineProcessorPipelineProcessorMessageRemapperArgs' message_remapper: Message Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-message-remapper)
        :param 'LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessorArgs' reference_table_lookup_processor: Reference Table Lookup Processor. Reference Tables are in public beta. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        :param 'LogsCustomPipelineProcessorPipelineProcessorServiceRemapperArgs' service_remapper: Service Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#service-remapper)
        :param 'LogsCustomPipelineProcessorPipelineProcessorStatusRemapperArgs' status_remapper: Status Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-status-remapper)
        :param 'LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessorArgs' string_builder_processor: String Builder Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#string-builder-processor)
        :param 'LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapperArgs' trace_id_remapper: Trace ID Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#trace-remapper)
        :param 'LogsCustomPipelineProcessorPipelineProcessorUrlParserArgs' url_parser: URL Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#url-parser)
        :param 'LogsCustomPipelineProcessorPipelineProcessorUserAgentParserArgs' user_agent_parser: User-Agent Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#user-agent-parser)
        """
        LogsCustomPipelineProcessorPipelineProcessor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            arithmetic_processor=arithmetic_processor,
            attribute_remapper=attribute_remapper,
            category_processor=category_processor,
            date_remapper=date_remapper,
            geo_ip_parser=geo_ip_parser,
            grok_parser=grok_parser,
            lookup_processor=lookup_processor,
            message_remapper=message_remapper,
            reference_table_lookup_processor=reference_table_lookup_processor,
            service_remapper=service_remapper,
            status_remapper=status_remapper,
            string_builder_processor=string_builder_processor,
            trace_id_remapper=trace_id_remapper,
            url_parser=url_parser,
            user_agent_parser=user_agent_parser,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             arithmetic_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor'] = None,
             attribute_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper'] = None,
             category_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor'] = None,
             date_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorDateRemapper'] = None,
             geo_ip_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGeoIpParser'] = None,
             grok_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParser'] = None,
             lookup_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorLookupProcessor'] = None,
             message_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorMessageRemapper'] = None,
             reference_table_lookup_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor'] = None,
             service_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorServiceRemapper'] = None,
             status_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStatusRemapper'] = None,
             string_builder_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor'] = None,
             trace_id_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper'] = None,
             url_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUrlParser'] = None,
             user_agent_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUserAgentParser'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if arithmetic_processor is not None:
            _setter("arithmetic_processor", arithmetic_processor)
        if attribute_remapper is not None:
            _setter("attribute_remapper", attribute_remapper)
        if category_processor is not None:
            _setter("category_processor", category_processor)
        if date_remapper is not None:
            _setter("date_remapper", date_remapper)
        if geo_ip_parser is not None:
            _setter("geo_ip_parser", geo_ip_parser)
        if grok_parser is not None:
            _setter("grok_parser", grok_parser)
        if lookup_processor is not None:
            _setter("lookup_processor", lookup_processor)
        if message_remapper is not None:
            _setter("message_remapper", message_remapper)
        if reference_table_lookup_processor is not None:
            _setter("reference_table_lookup_processor", reference_table_lookup_processor)
        if service_remapper is not None:
            _setter("service_remapper", service_remapper)
        if status_remapper is not None:
            _setter("status_remapper", status_remapper)
        if string_builder_processor is not None:
            _setter("string_builder_processor", string_builder_processor)
        if trace_id_remapper is not None:
            _setter("trace_id_remapper", trace_id_remapper)
        if url_parser is not None:
            _setter("url_parser", url_parser)
        if user_agent_parser is not None:
            _setter("user_agent_parser", user_agent_parser)

    @property
    @pulumi.getter(name="arithmeticProcessor")
    def arithmetic_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor']:
        """
        Arithmetic Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#arithmetic-processor)
        """
        return pulumi.get(self, "arithmetic_processor")

    @property
    @pulumi.getter(name="attributeRemapper")
    def attribute_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper']:
        """
        Attribute Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#remapper)
        """
        return pulumi.get(self, "attribute_remapper")

    @property
    @pulumi.getter(name="categoryProcessor")
    def category_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor']:
        """
        Category Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#category-processor)
        """
        return pulumi.get(self, "category_processor")

    @property
    @pulumi.getter(name="dateRemapper")
    def date_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorDateRemapper']:
        """
        Date Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-date-remapper)
        """
        return pulumi.get(self, "date_remapper")

    @property
    @pulumi.getter(name="geoIpParser")
    def geo_ip_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGeoIpParser']:
        """
        Date GeoIP Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#geoip-parser)
        """
        return pulumi.get(self, "geo_ip_parser")

    @property
    @pulumi.getter(name="grokParser")
    def grok_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParser']:
        """
        Grok Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#grok-parser)
        """
        return pulumi.get(self, "grok_parser")

    @property
    @pulumi.getter(name="lookupProcessor")
    def lookup_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorLookupProcessor']:
        """
        Lookup Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        """
        return pulumi.get(self, "lookup_processor")

    @property
    @pulumi.getter(name="messageRemapper")
    def message_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorMessageRemapper']:
        """
        Message Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-message-remapper)
        """
        return pulumi.get(self, "message_remapper")

    @property
    @pulumi.getter(name="referenceTableLookupProcessor")
    def reference_table_lookup_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor']:
        """
        Reference Table Lookup Processor. Reference Tables are in public beta. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        """
        return pulumi.get(self, "reference_table_lookup_processor")

    @property
    @pulumi.getter(name="serviceRemapper")
    def service_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorServiceRemapper']:
        """
        Service Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#service-remapper)
        """
        return pulumi.get(self, "service_remapper")

    @property
    @pulumi.getter(name="statusRemapper")
    def status_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStatusRemapper']:
        """
        Status Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-status-remapper)
        """
        return pulumi.get(self, "status_remapper")

    @property
    @pulumi.getter(name="stringBuilderProcessor")
    def string_builder_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor']:
        """
        String Builder Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#string-builder-processor)
        """
        return pulumi.get(self, "string_builder_processor")

    @property
    @pulumi.getter(name="traceIdRemapper")
    def trace_id_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper']:
        """
        Trace ID Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#trace-remapper)
        """
        return pulumi.get(self, "trace_id_remapper")

    @property
    @pulumi.getter(name="urlParser")
    def url_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUrlParser']:
        """
        URL Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#url-parser)
        """
        return pulumi.get(self, "url_parser")

    @property
    @pulumi.getter(name="userAgentParser")
    def user_agent_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUserAgentParser']:
        """
        User-Agent Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#user-agent-parser)
        """
        return pulumi.get(self, "user_agent_parser")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isReplaceMissing":
            suggest = "is_replace_missing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 target: str,
                 is_enabled: Optional[bool] = None,
                 is_replace_missing: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str expression: Arithmetic operation between one or more log attributes.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param bool is_replace_missing: If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
            target=target,
            is_enabled=is_enabled,
            is_replace_missing=is_replace_missing,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: str,
             target: str,
             is_enabled: Optional[bool] = None,
             is_replace_missing: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)
        _setter("target", target)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if is_replace_missing is not None:
            _setter("is_replace_missing", is_replace_missing)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Arithmetic operation between one or more log attributes.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[bool]:
        """
        If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
        """
        return pulumi.get(self, "is_replace_missing")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"
        elif key == "targetType":
            suggest = "target_type"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "overrideOnConflict":
            suggest = "override_on_conflict"
        elif key == "preserveSource":
            suggest = "preserve_source"
        elif key == "targetFormat":
            suggest = "target_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 sources: Sequence[str],
                 target: str,
                 target_type: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 override_on_conflict: Optional[bool] = None,
                 preserve_source: Optional[bool] = None,
                 target_format: Optional[str] = None):
        """
        :param str source_type: Defines where the sources are from (log `attribute` or `tag`).
        :param Sequence[str] sources: List of source attributes or tags.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param str target_type: Defines if the target is a log `attribute` or `tag`.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        :param bool override_on_conflict: Override the target element if already set.
        :param bool preserve_source: Remove or preserve the remapped source element.
        :param str target_format: If the `target_type` of the remapper is `attribute`, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. `string`, `integer`, or `double` are the possible types. If the `target_type` is `tag`, this parameter may not be specified.
        """
        LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            source_type=source_type,
            sources=sources,
            target=target,
            target_type=target_type,
            is_enabled=is_enabled,
            name=name,
            override_on_conflict=override_on_conflict,
            preserve_source=preserve_source,
            target_format=target_format,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             source_type: str,
             sources: Sequence[str],
             target: str,
             target_type: str,
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             override_on_conflict: Optional[bool] = None,
             preserve_source: Optional[bool] = None,
             target_format: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("source_type", source_type)
        _setter("sources", sources)
        _setter("target", target)
        _setter("target_type", target_type)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)
        if override_on_conflict is not None:
            _setter("override_on_conflict", override_on_conflict)
        if preserve_source is not None:
            _setter("preserve_source", preserve_source)
        if target_format is not None:
            _setter("target_format", target_format)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Defines where the sources are from (log `attribute` or `tag`).
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> str:
        """
        Defines if the target is a log `attribute` or `tag`.
        """
        return pulumi.get(self, "target_type")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideOnConflict")
    def override_on_conflict(self) -> Optional[bool]:
        """
        Override the target element if already set.
        """
        return pulumi.get(self, "override_on_conflict")

    @property
    @pulumi.getter(name="preserveSource")
    def preserve_source(self) -> Optional[bool]:
        """
        Remove or preserve the remapped source element.
        """
        return pulumi.get(self, "preserve_source")

    @property
    @pulumi.getter(name="targetFormat")
    def target_format(self) -> Optional[str]:
        """
        If the `target_type` of the remapper is `attribute`, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. `string`, `integer`, or `double` are the possible types. If the `target_type` is `tag`, this parameter may not be specified.
        """
        return pulumi.get(self, "target_format")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 categories: Sequence['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory'],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryArgs'] categories: List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            categories=categories,
            target=target,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             categories: Sequence['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory'],
             target: str,
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("categories", categories)
        _setter("target", target)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def categories(self) -> Sequence['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory']:
        """
        List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        """
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory(dict):
    def __init__(__self__, *,
                 filter: 'outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter',
                 name: str):
        """
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filter=filter,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filter: 'outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter',
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filter", filter)
        _setter("name", name)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Filter criteria of the category.
        """
        LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Filter criteria of the category.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorDateRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorDateRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorDateRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorDateRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes or tags.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorPipelineProcessorDateRemapper._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sources=sources,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sources: Sequence[str],
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sources", sources)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorGeoIpParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorGeoIpParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGeoIpParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGeoIpParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes or tags.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorPipelineProcessorGeoIpParser._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sources=sources,
            target=target,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sources: Sequence[str],
             target: str,
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sources", sources)
        _setter("target", target)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorGrokParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorGrokParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGrokParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGrokParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grok: 'outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok',
                 source: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 samples: Optional[Sequence[str]] = None):
        """
        :param str source: Name of the log attribute to parse.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        :param Sequence[str] samples: List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        LogsCustomPipelineProcessorPipelineProcessorGrokParser._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            grok=grok,
            source=source,
            is_enabled=is_enabled,
            name=name,
            samples=samples,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             grok: 'outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok',
             source: str,
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             samples: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("grok", grok)
        _setter("source", source)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)
        if samples is not None:
            _setter("samples", samples)

    @property
    @pulumi.getter
    def grok(self) -> 'outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok':
        return pulumi.get(self, "grok")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Name of the log attribute to parse.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def samples(self) -> Optional[Sequence[str]]:
        """
        List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        return pulumi.get(self, "samples")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchRules":
            suggest = "match_rules"
        elif key == "supportRules":
            suggest = "support_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_rules: str,
                 support_rules: str):
        """
        :param str match_rules: Match rules for your grok parser.
        :param str support_rules: Support rules for your grok parser.
        """
        LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            match_rules=match_rules,
            support_rules=support_rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             match_rules: str,
             support_rules: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("match_rules", match_rules)
        _setter("support_rules", support_rules)

    @property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> str:
        """
        Match rules for your grok parser.
        """
        return pulumi.get(self, "match_rules")

    @property
    @pulumi.getter(name="supportRules")
    def support_rules(self) -> str:
        """
        Support rules for your grok parser.
        """
        return pulumi.get(self, "support_rules")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorLookupProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lookupTables":
            suggest = "lookup_tables"
        elif key == "defaultLookup":
            suggest = "default_lookup"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorLookupProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorLookupProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorLookupProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lookup_tables: Sequence[str],
                 source: str,
                 target: str,
                 default_lookup: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] lookup_tables: List of entries of the lookup table using `key,value` format.
        :param str source: Name of the log attribute to parse.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param str default_lookup: Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorPipelineProcessorLookupProcessor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lookup_tables=lookup_tables,
            source=source,
            target=target,
            default_lookup=default_lookup,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lookup_tables: Sequence[str],
             source: str,
             target: str,
             default_lookup: Optional[str] = None,
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("lookup_tables", lookup_tables)
        _setter("source", source)
        _setter("target", target)
        if default_lookup is not None:
            _setter("default_lookup", default_lookup)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="lookupTables")
    def lookup_tables(self) -> Sequence[str]:
        """
        List of entries of the lookup table using `key,value` format.
        """
        return pulumi.get(self, "lookup_tables")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Name of the log attribute to parse.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="defaultLookup")
    def default_lookup(self) -> Optional[str]:
        """
        Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        """
        return pulumi.get(self, "default_lookup")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorMessageRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorMessageRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorMessageRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorMessageRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes or tags.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorPipelineProcessorMessageRemapper._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sources=sources,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sources: Sequence[str],
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sources", sources)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lookupEnrichmentTable":
            suggest = "lookup_enrichment_table"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lookup_enrichment_table: str,
                 source: str,
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str lookup_enrichment_table: Name of the Reference Table for the source attribute and their associated target attribute values.
        :param str source: Name of the log attribute to parse.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lookup_enrichment_table=lookup_enrichment_table,
            source=source,
            target=target,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lookup_enrichment_table: str,
             source: str,
             target: str,
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("lookup_enrichment_table", lookup_enrichment_table)
        _setter("source", source)
        _setter("target", target)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="lookupEnrichmentTable")
    def lookup_enrichment_table(self) -> str:
        """
        Name of the Reference Table for the source attribute and their associated target attribute values.
        """
        return pulumi.get(self, "lookup_enrichment_table")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Name of the log attribute to parse.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorServiceRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorServiceRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorServiceRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorServiceRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes or tags.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorPipelineProcessorServiceRemapper._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sources=sources,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sources: Sequence[str],
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sources", sources)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorStatusRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorStatusRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorStatusRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorStatusRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes or tags.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorPipelineProcessorStatusRemapper._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sources=sources,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sources: Sequence[str],
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sources", sources)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isReplaceMissing":
            suggest = "is_replace_missing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: str,
                 template: str,
                 is_enabled: Optional[bool] = None,
                 is_replace_missing: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param str template: The formula with one or more attributes and raw text.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param bool is_replace_missing: If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            template=template,
            is_enabled=is_enabled,
            is_replace_missing=is_replace_missing,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: str,
             template: str,
             is_enabled: Optional[bool] = None,
             is_replace_missing: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target", target)
        _setter("template", template)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if is_replace_missing is not None:
            _setter("is_replace_missing", is_replace_missing)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def template(self) -> str:
        """
        The formula with one or more attributes and raw text.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[bool]:
        """
        If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
        """
        return pulumi.get(self, "is_replace_missing")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes or tags.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sources=sources,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sources: Sequence[str],
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sources", sources)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorUrlParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "normalizeEndingSlashes":
            suggest = "normalize_ending_slashes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorUrlParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorUrlParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorUrlParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 normalize_ending_slashes: Optional[bool] = None):
        """
        :param Sequence[str] sources: List of source attributes or tags.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        :param bool normalize_ending_slashes: Normalize the ending slashes or not.
        """
        LogsCustomPipelineProcessorPipelineProcessorUrlParser._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sources=sources,
            target=target,
            is_enabled=is_enabled,
            name=name,
            normalize_ending_slashes=normalize_ending_slashes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sources: Sequence[str],
             target: str,
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             normalize_ending_slashes: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sources", sources)
        _setter("target", target)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)
        if normalize_ending_slashes is not None:
            _setter("normalize_ending_slashes", normalize_ending_slashes)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="normalizeEndingSlashes")
    def normalize_ending_slashes(self) -> Optional[bool]:
        """
        Normalize the ending slashes or not.
        """
        return pulumi.get(self, "normalize_ending_slashes")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorUserAgentParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isEncoded":
            suggest = "is_encoded"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorUserAgentParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorUserAgentParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorUserAgentParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 is_encoded: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes or tags.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param bool is_encoded: If the source attribute is URL encoded or not.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorPipelineProcessorUserAgentParser._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sources=sources,
            target=target,
            is_enabled=is_enabled,
            is_encoded=is_encoded,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sources: Sequence[str],
             target: str,
             is_enabled: Optional[bool] = None,
             is_encoded: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sources", sources)
        _setter("target", target)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if is_encoded is not None:
            _setter("is_encoded", is_encoded)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isEncoded")
    def is_encoded(self) -> Optional[bool]:
        """
        If the source attribute is URL encoded or not.
        """
        return pulumi.get(self, "is_encoded")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorReferenceTableLookupProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lookupEnrichmentTable":
            suggest = "lookup_enrichment_table"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorReferenceTableLookupProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorReferenceTableLookupProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorReferenceTableLookupProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lookup_enrichment_table: str,
                 source: str,
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str lookup_enrichment_table: Name of the Reference Table for the source attribute and their associated target attribute values.
        :param str source: Name of the log attribute to parse.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorReferenceTableLookupProcessor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lookup_enrichment_table=lookup_enrichment_table,
            source=source,
            target=target,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lookup_enrichment_table: str,
             source: str,
             target: str,
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("lookup_enrichment_table", lookup_enrichment_table)
        _setter("source", source)
        _setter("target", target)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="lookupEnrichmentTable")
    def lookup_enrichment_table(self) -> str:
        """
        Name of the Reference Table for the source attribute and their associated target attribute values.
        """
        return pulumi.get(self, "lookup_enrichment_table")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Name of the log attribute to parse.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorServiceRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorServiceRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorServiceRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorServiceRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes or tags.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorServiceRemapper._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sources=sources,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sources: Sequence[str],
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sources", sources)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorStatusRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorStatusRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorStatusRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorStatusRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes or tags.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorStatusRemapper._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sources=sources,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sources: Sequence[str],
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sources", sources)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorStringBuilderProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isReplaceMissing":
            suggest = "is_replace_missing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorStringBuilderProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorStringBuilderProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorStringBuilderProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: str,
                 template: str,
                 is_enabled: Optional[bool] = None,
                 is_replace_missing: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param str template: The formula with one or more attributes and raw text.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param bool is_replace_missing: If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorStringBuilderProcessor._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            template=template,
            is_enabled=is_enabled,
            is_replace_missing=is_replace_missing,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: str,
             template: str,
             is_enabled: Optional[bool] = None,
             is_replace_missing: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target", target)
        _setter("template", template)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if is_replace_missing is not None:
            _setter("is_replace_missing", is_replace_missing)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def template(self) -> str:
        """
        The formula with one or more attributes and raw text.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[bool]:
        """
        If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
        """
        return pulumi.get(self, "is_replace_missing")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorTraceIdRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorTraceIdRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorTraceIdRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorTraceIdRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes or tags.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorTraceIdRemapper._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sources=sources,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sources: Sequence[str],
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sources", sources)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorUrlParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "normalizeEndingSlashes":
            suggest = "normalize_ending_slashes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorUrlParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorUrlParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorUrlParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 normalize_ending_slashes: Optional[bool] = None):
        """
        :param Sequence[str] sources: List of source attributes or tags.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param str name: Your pipeline name.
        :param bool normalize_ending_slashes: Normalize the ending slashes or not.
        """
        LogsCustomPipelineProcessorUrlParser._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sources=sources,
            target=target,
            is_enabled=is_enabled,
            name=name,
            normalize_ending_slashes=normalize_ending_slashes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sources: Sequence[str],
             target: str,
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             normalize_ending_slashes: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sources", sources)
        _setter("target", target)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)
        if normalize_ending_slashes is not None:
            _setter("normalize_ending_slashes", normalize_ending_slashes)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="normalizeEndingSlashes")
    def normalize_ending_slashes(self) -> Optional[bool]:
        """
        Normalize the ending slashes or not.
        """
        return pulumi.get(self, "normalize_ending_slashes")


@pulumi.output_type
class LogsCustomPipelineProcessorUserAgentParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isEncoded":
            suggest = "is_encoded"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorUserAgentParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorUserAgentParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorUserAgentParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 is_encoded: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes or tags.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param bool is_encoded: If the source attribute is URL encoded or not.
        :param str name: Your pipeline name.
        """
        LogsCustomPipelineProcessorUserAgentParser._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sources=sources,
            target=target,
            is_enabled=is_enabled,
            is_encoded=is_encoded,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sources: Sequence[str],
             target: str,
             is_enabled: Optional[bool] = None,
             is_encoded: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("sources", sources)
        _setter("target", target)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if is_encoded is not None:
            _setter("is_encoded", is_encoded)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isEncoded")
    def is_encoded(self) -> Optional[bool]:
        """
        If the source attribute is URL encoded or not.
        """
        return pulumi.get(self, "is_encoded")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsIndexExclusionFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsIndexExclusionFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsIndexExclusionFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsIndexExclusionFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.LogsIndexExclusionFilterFilter']] = None,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param bool is_enabled: A boolean stating if the exclusion is active or not.
        :param str name: The name of the exclusion filter.
        """
        LogsIndexExclusionFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filters=filters,
            is_enabled=is_enabled,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filters: Optional[Sequence['outputs.LogsIndexExclusionFilterFilter']] = None,
             is_enabled: Optional[bool] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if filters is not None:
            _setter("filters", filters)
        if is_enabled is not None:
            _setter("is_enabled", is_enabled)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.LogsIndexExclusionFilterFilter']]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        A boolean stating if the exclusion is active or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the exclusion filter.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsIndexExclusionFilterFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sampleRate":
            suggest = "sample_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsIndexExclusionFilterFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsIndexExclusionFilterFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsIndexExclusionFilterFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: Optional[str] = None,
                 sample_rate: Optional[float] = None):
        """
        :param str query: Logs filter criteria. Only logs matching this filter criteria are considered for this index.
        :param float sample_rate: The fraction of logs excluded by the exclusion filter, when active.
        """
        LogsIndexExclusionFilterFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
            sample_rate=sample_rate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: Optional[str] = None,
             sample_rate: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if query is not None:
            _setter("query", query)
        if sample_rate is not None:
            _setter("sample_rate", sample_rate)

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        Logs filter criteria. Only logs matching this filter criteria are considered for this index.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[float]:
        """
        The fraction of logs excluded by the exclusion filter, when active.
        """
        return pulumi.get(self, "sample_rate")


@pulumi.output_type
class LogsIndexFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Logs filter criteria. Only logs matching this filter criteria are considered for this index.
        """
        LogsIndexFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Logs filter criteria. Only logs matching this filter criteria are considered for this index.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsMetricCompute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"
        elif key == "includePercentiles":
            suggest = "include_percentiles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsMetricCompute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsMetricCompute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsMetricCompute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_type: str,
                 include_percentiles: Optional[bool] = None,
                 path: Optional[str] = None):
        """
        :param str aggregation_type: The type of aggregation to use. This field can't be updated after creation. Valid values are `count`, `distribution`.
        :param bool include_percentiles: Toggle to include/exclude percentiles for a distribution metric. Defaults to false. Can only be applied to metrics that have an `aggregation_type` of distribution.
        :param str path: The path to the value the log-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
        """
        LogsMetricCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation_type=aggregation_type,
            include_percentiles=include_percentiles,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation_type: str,
             include_percentiles: Optional[bool] = None,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation_type", aggregation_type)
        if include_percentiles is not None:
            _setter("include_percentiles", include_percentiles)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> str:
        """
        The type of aggregation to use. This field can't be updated after creation. Valid values are `count`, `distribution`.
        """
        return pulumi.get(self, "aggregation_type")

    @property
    @pulumi.getter(name="includePercentiles")
    def include_percentiles(self) -> Optional[bool]:
        """
        Toggle to include/exclude percentiles for a distribution metric. Defaults to false. Can only be applied to metrics that have an `aggregation_type` of distribution.
        """
        return pulumi.get(self, "include_percentiles")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to the value the log-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class LogsMetricFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The search query - following the log search syntax.
        """
        LogsMetricFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The search query - following the log search syntax.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsMetricGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagName":
            suggest = "tag_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsMetricGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsMetricGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsMetricGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 tag_name: str):
        """
        :param str path: The path to the value the log-based metric will be aggregated over.
        :param str tag_name: Name of the tag that gets created.
        """
        LogsMetricGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            tag_name=tag_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: str,
             tag_name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("path", path)
        _setter("tag_name", tag_name)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path to the value the log-based metric will be aggregated over.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> str:
        """
        Name of the tag that gets created.
        """
        return pulumi.get(self, "tag_name")


@pulumi.output_type
class MetricTagConfigurationAggregation(dict):
    def __init__(__self__, *,
                 space: str,
                 time: str):
        """
        :param str space: A space aggregation for use in query. Valid values are `avg`, `max`, `min`, `sum`.
        :param str time: A time aggregation for use in query. Valid values are `avg`, `count`, `max`, `min`, `sum`.
        """
        MetricTagConfigurationAggregation._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            space=space,
            time=time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             space: str,
             time: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("space", space)
        _setter("time", time)

    @property
    @pulumi.getter
    def space(self) -> str:
        """
        A space aggregation for use in query. Valid values are `avg`, `max`, `min`, `sum`.
        """
        return pulumi.get(self, "space")

    @property
    @pulumi.getter
    def time(self) -> str:
        """
        A time aggregation for use in query. Valid values are `avg`, `count`, `max`, `min`, `sum`.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class MonitorConfigPolicyTagPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"
        elif key == "tagKeyRequired":
            suggest = "tag_key_required"
        elif key == "validTagValues":
            suggest = "valid_tag_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorConfigPolicyTagPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorConfigPolicyTagPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorConfigPolicyTagPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_key: str,
                 tag_key_required: bool,
                 valid_tag_values: Sequence[str]):
        """
        :param str tag_key: The key of the tag
        :param bool tag_key_required: If a tag key is required for monitor creation
        :param Sequence[str] valid_tag_values: Valid values for the tag
        """
        MonitorConfigPolicyTagPolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tag_key=tag_key,
            tag_key_required=tag_key_required,
            valid_tag_values=valid_tag_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tag_key: str,
             tag_key_required: bool,
             valid_tag_values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("tag_key", tag_key)
        _setter("tag_key_required", tag_key_required)
        _setter("valid_tag_values", valid_tag_values)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> str:
        """
        The key of the tag
        """
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter(name="tagKeyRequired")
    def tag_key_required(self) -> bool:
        """
        If a tag key is required for monitor creation
        """
        return pulumi.get(self, "tag_key_required")

    @property
    @pulumi.getter(name="validTagValues")
    def valid_tag_values(self) -> Sequence[str]:
        """
        Valid values for the tag
        """
        return pulumi.get(self, "valid_tag_values")


@pulumi.output_type
class MonitorMonitorThresholdWindows(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recoveryWindow":
            suggest = "recovery_window"
        elif key == "triggerWindow":
            suggest = "trigger_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorMonitorThresholdWindows. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorMonitorThresholdWindows.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorMonitorThresholdWindows.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recovery_window: Optional[str] = None,
                 trigger_window: Optional[str] = None):
        """
        :param str recovery_window: Describes how long an anomalous metric must be normal before the alert recovers.
        :param str trigger_window: Describes how long a metric must be anomalous before an alert triggers.
        """
        MonitorMonitorThresholdWindows._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            recovery_window=recovery_window,
            trigger_window=trigger_window,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             recovery_window: Optional[str] = None,
             trigger_window: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if recovery_window is not None:
            _setter("recovery_window", recovery_window)
        if trigger_window is not None:
            _setter("trigger_window", trigger_window)

    @property
    @pulumi.getter(name="recoveryWindow")
    def recovery_window(self) -> Optional[str]:
        """
        Describes how long an anomalous metric must be normal before the alert recovers.
        """
        return pulumi.get(self, "recovery_window")

    @property
    @pulumi.getter(name="triggerWindow")
    def trigger_window(self) -> Optional[str]:
        """
        Describes how long a metric must be anomalous before an alert triggers.
        """
        return pulumi.get(self, "trigger_window")


@pulumi.output_type
class MonitorMonitorThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "criticalRecovery":
            suggest = "critical_recovery"
        elif key == "warningRecovery":
            suggest = "warning_recovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorMonitorThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorMonitorThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorMonitorThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 critical: Optional[str] = None,
                 critical_recovery: Optional[str] = None,
                 ok: Optional[str] = None,
                 unknown: Optional[str] = None,
                 warning: Optional[str] = None,
                 warning_recovery: Optional[str] = None):
        """
        :param str critical: The monitor `CRITICAL` threshold. Must be a number.
        :param str critical_recovery: The monitor `CRITICAL` recovery threshold. Must be a number.
        :param str ok: The monitor `OK` threshold. Only supported in monitor type `service check`. Must be a number.
        :param str unknown: The monitor `UNKNOWN` threshold. Only supported in monitor type `service check`. Must be a number.
        :param str warning: The monitor `WARNING` threshold. Must be a number.
        :param str warning_recovery: The monitor `WARNING` recovery threshold. Must be a number.
        """
        MonitorMonitorThresholds._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            critical=critical,
            critical_recovery=critical_recovery,
            ok=ok,
            unknown=unknown,
            warning=warning,
            warning_recovery=warning_recovery,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             critical: Optional[str] = None,
             critical_recovery: Optional[str] = None,
             ok: Optional[str] = None,
             unknown: Optional[str] = None,
             warning: Optional[str] = None,
             warning_recovery: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if critical is not None:
            _setter("critical", critical)
        if critical_recovery is not None:
            _setter("critical_recovery", critical_recovery)
        if ok is not None:
            _setter("ok", ok)
        if unknown is not None:
            _setter("unknown", unknown)
        if warning is not None:
            _setter("warning", warning)
        if warning_recovery is not None:
            _setter("warning_recovery", warning_recovery)

    @property
    @pulumi.getter
    def critical(self) -> Optional[str]:
        """
        The monitor `CRITICAL` threshold. Must be a number.
        """
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter(name="criticalRecovery")
    def critical_recovery(self) -> Optional[str]:
        """
        The monitor `CRITICAL` recovery threshold. Must be a number.
        """
        return pulumi.get(self, "critical_recovery")

    @property
    @pulumi.getter
    def ok(self) -> Optional[str]:
        """
        The monitor `OK` threshold. Only supported in monitor type `service check`. Must be a number.
        """
        return pulumi.get(self, "ok")

    @property
    @pulumi.getter
    def unknown(self) -> Optional[str]:
        """
        The monitor `UNKNOWN` threshold. Only supported in monitor type `service check`. Must be a number.
        """
        return pulumi.get(self, "unknown")

    @property
    @pulumi.getter
    def warning(self) -> Optional[str]:
        """
        The monitor `WARNING` threshold. Must be a number.
        """
        return pulumi.get(self, "warning")

    @property
    @pulumi.getter(name="warningRecovery")
    def warning_recovery(self) -> Optional[str]:
        """
        The monitor `WARNING` recovery threshold. Must be a number.
        """
        return pulumi.get(self, "warning_recovery")


@pulumi.output_type
class MonitorSchedulingOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluationWindows":
            suggest = "evaluation_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorSchedulingOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorSchedulingOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorSchedulingOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluation_windows: Sequence['outputs.MonitorSchedulingOptionEvaluationWindow']):
        """
        :param Sequence['MonitorSchedulingOptionEvaluationWindowArgs'] evaluation_windows: Configuration options for the evaluation window. If `hour_starts` is set, no other fields may be set. Otherwise, `day_starts` and `month_starts` must be set together.
        """
        MonitorSchedulingOption._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            evaluation_windows=evaluation_windows,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             evaluation_windows: Sequence['outputs.MonitorSchedulingOptionEvaluationWindow'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("evaluation_windows", evaluation_windows)

    @property
    @pulumi.getter(name="evaluationWindows")
    def evaluation_windows(self) -> Sequence['outputs.MonitorSchedulingOptionEvaluationWindow']:
        """
        Configuration options for the evaluation window. If `hour_starts` is set, no other fields may be set. Otherwise, `day_starts` and `month_starts` must be set together.
        """
        return pulumi.get(self, "evaluation_windows")


@pulumi.output_type
class MonitorSchedulingOptionEvaluationWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayStarts":
            suggest = "day_starts"
        elif key == "hourStarts":
            suggest = "hour_starts"
        elif key == "monthStarts":
            suggest = "month_starts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorSchedulingOptionEvaluationWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorSchedulingOptionEvaluationWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorSchedulingOptionEvaluationWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_starts: Optional[str] = None,
                 hour_starts: Optional[int] = None,
                 month_starts: Optional[int] = None):
        """
        :param str day_starts: The time of the day at which a one day cumulative evaluation window starts. Must be defined in UTC time in `HH:mm` format.
        :param int hour_starts: The minute of the hour at which a one hour cumulative evaluation window starts. Must be between 0 and 59.
        :param int month_starts: The day of the month at which a one month cumulative evaluation window starts. Must be a value of 1.
        """
        MonitorSchedulingOptionEvaluationWindow._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            day_starts=day_starts,
            hour_starts=hour_starts,
            month_starts=month_starts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             day_starts: Optional[str] = None,
             hour_starts: Optional[int] = None,
             month_starts: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if day_starts is not None:
            _setter("day_starts", day_starts)
        if hour_starts is not None:
            _setter("hour_starts", hour_starts)
        if month_starts is not None:
            _setter("month_starts", month_starts)

    @property
    @pulumi.getter(name="dayStarts")
    def day_starts(self) -> Optional[str]:
        """
        The time of the day at which a one day cumulative evaluation window starts. Must be defined in UTC time in `HH:mm` format.
        """
        return pulumi.get(self, "day_starts")

    @property
    @pulumi.getter(name="hourStarts")
    def hour_starts(self) -> Optional[int]:
        """
        The minute of the hour at which a one hour cumulative evaluation window starts. Must be between 0 and 59.
        """
        return pulumi.get(self, "hour_starts")

    @property
    @pulumi.getter(name="monthStarts")
    def month_starts(self) -> Optional[int]:
        """
        The day of the month at which a one month cumulative evaluation window starts. Must be a value of 1.
        """
        return pulumi.get(self, "month_starts")


@pulumi.output_type
class MonitorVariables(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventQueries":
            suggest = "event_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorVariables. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorVariables.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorVariables.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_queries: Optional[Sequence['outputs.MonitorVariablesEventQuery']] = None):
        """
        :param Sequence['MonitorVariablesEventQueryArgs'] event_queries: A timeseries formula and functions events query.
        """
        MonitorVariables._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            event_queries=event_queries,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             event_queries: Optional[Sequence['outputs.MonitorVariablesEventQuery']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if event_queries is not None:
            _setter("event_queries", event_queries)

    @property
    @pulumi.getter(name="eventQueries")
    def event_queries(self) -> Optional[Sequence['outputs.MonitorVariablesEventQuery']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_queries")


@pulumi.output_type
class MonitorVariablesEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorVariablesEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorVariablesEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorVariablesEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.MonitorVariablesEventQueryCompute'],
                 data_source: str,
                 name: str,
                 search: 'outputs.MonitorVariablesEventQuerySearch',
                 group_bies: Optional[Sequence['outputs.MonitorVariablesEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None):
        """
        :param Sequence['MonitorVariablesEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `rum`, `ci_pipelines`, `ci_tests`, `audit`, `events`, `logs`, `spans`.
        :param str name: The name of query for use in formulas.
        :param 'MonitorVariablesEventQuerySearchArgs' search: The search options.
        :param Sequence['MonitorVariablesEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        """
        MonitorVariablesEventQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            computes=computes,
            data_source=data_source,
            name=name,
            search=search,
            group_bies=group_bies,
            indexes=indexes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             computes: Sequence['outputs.MonitorVariablesEventQueryCompute'],
             data_source: str,
             name: str,
             search: 'outputs.MonitorVariablesEventQuerySearch',
             group_bies: Optional[Sequence['outputs.MonitorVariablesEventQueryGroupBy']] = None,
             indexes: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("computes", computes)
        _setter("data_source", data_source)
        _setter("name", name)
        _setter("search", search)
        if group_bies is not None:
            _setter("group_bies", group_bies)
        if indexes is not None:
            _setter("indexes", indexes)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.MonitorVariablesEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `rum`, `ci_pipelines`, `ci_tests`, `audit`, `events`, `logs`, `spans`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def search(self) -> 'outputs.MonitorVariablesEventQuerySearch':
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.MonitorVariablesEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")


@pulumi.output_type
class MonitorVariablesEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        MonitorVariablesEventQueryCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            interval=interval,
            metric=metric,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             interval: Optional[int] = None,
             metric: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if interval is not None:
            _setter("interval", interval)
        if metric is not None:
            _setter("metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class MonitorVariablesEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.MonitorVariablesEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'MonitorVariablesEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        MonitorVariablesEventQueryGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            facet=facet,
            limit=limit,
            sort=sort,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             facet: str,
             limit: Optional[int] = None,
             sort: Optional['outputs.MonitorVariablesEventQueryGroupBySort'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("facet", facet)
        if limit is not None:
            _setter("limit", limit)
        if sort is not None:
            _setter("sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.MonitorVariablesEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class MonitorVariablesEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The measurable attribute to compute.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        MonitorVariablesEventQueryGroupBySort._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation=aggregation,
            metric=metric,
            order=order,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation: str,
             metric: Optional[str] = None,
             order: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation", aggregation)
        if metric is not None:
            _setter("metric", metric)
        if order is not None:
            _setter("order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class MonitorVariablesEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        MonitorVariablesEventQuerySearch._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class OrganizationSettingsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samlAutocreateUsersDomains":
            suggest = "saml_autocreate_users_domains"
        elif key == "samlIdpInitiatedLogin":
            suggest = "saml_idp_initiated_login"
        elif key == "samlStrictMode":
            suggest = "saml_strict_mode"
        elif key == "privateWidgetShare":
            suggest = "private_widget_share"
        elif key == "samlAutocreateAccessRole":
            suggest = "saml_autocreate_access_role"
        elif key == "samlCanBeEnabled":
            suggest = "saml_can_be_enabled"
        elif key == "samlIdpEndpoint":
            suggest = "saml_idp_endpoint"
        elif key == "samlIdpMetadataUploaded":
            suggest = "saml_idp_metadata_uploaded"
        elif key == "samlLoginUrl":
            suggest = "saml_login_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationSettingsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationSettingsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationSettingsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 saml: 'outputs.OrganizationSettingsSettingsSaml',
                 saml_autocreate_users_domains: 'outputs.OrganizationSettingsSettingsSamlAutocreateUsersDomains',
                 saml_idp_initiated_login: 'outputs.OrganizationSettingsSettingsSamlIdpInitiatedLogin',
                 saml_strict_mode: 'outputs.OrganizationSettingsSettingsSamlStrictMode',
                 private_widget_share: Optional[bool] = None,
                 saml_autocreate_access_role: Optional[str] = None,
                 saml_can_be_enabled: Optional[bool] = None,
                 saml_idp_endpoint: Optional[str] = None,
                 saml_idp_metadata_uploaded: Optional[bool] = None,
                 saml_login_url: Optional[str] = None):
        """
        :param 'OrganizationSettingsSettingsSamlArgs' saml: SAML properties
        :param 'OrganizationSettingsSettingsSamlAutocreateUsersDomainsArgs' saml_autocreate_users_domains: List of domains where the SAML automated user creation is enabled.
        :param 'OrganizationSettingsSettingsSamlIdpInitiatedLoginArgs' saml_idp_initiated_login: Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        :param 'OrganizationSettingsSettingsSamlStrictModeArgs' saml_strict_mode: Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
        :param bool private_widget_share: Whether or not the organization users can share widgets outside of Datadog.
        :param str saml_autocreate_access_role: The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm` , `ro`, `ERROR`
        :param bool saml_can_be_enabled: Whether or not SAML can be enabled for this organization.
        :param str saml_idp_endpoint: Identity provider endpoint for SAML authentication.
        :param bool saml_idp_metadata_uploaded: Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        :param str saml_login_url: URL for SAML logging.
        """
        OrganizationSettingsSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            saml=saml,
            saml_autocreate_users_domains=saml_autocreate_users_domains,
            saml_idp_initiated_login=saml_idp_initiated_login,
            saml_strict_mode=saml_strict_mode,
            private_widget_share=private_widget_share,
            saml_autocreate_access_role=saml_autocreate_access_role,
            saml_can_be_enabled=saml_can_be_enabled,
            saml_idp_endpoint=saml_idp_endpoint,
            saml_idp_metadata_uploaded=saml_idp_metadata_uploaded,
            saml_login_url=saml_login_url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             saml: 'outputs.OrganizationSettingsSettingsSaml',
             saml_autocreate_users_domains: 'outputs.OrganizationSettingsSettingsSamlAutocreateUsersDomains',
             saml_idp_initiated_login: 'outputs.OrganizationSettingsSettingsSamlIdpInitiatedLogin',
             saml_strict_mode: 'outputs.OrganizationSettingsSettingsSamlStrictMode',
             private_widget_share: Optional[bool] = None,
             saml_autocreate_access_role: Optional[str] = None,
             saml_can_be_enabled: Optional[bool] = None,
             saml_idp_endpoint: Optional[str] = None,
             saml_idp_metadata_uploaded: Optional[bool] = None,
             saml_login_url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("saml", saml)
        _setter("saml_autocreate_users_domains", saml_autocreate_users_domains)
        _setter("saml_idp_initiated_login", saml_idp_initiated_login)
        _setter("saml_strict_mode", saml_strict_mode)
        if private_widget_share is not None:
            _setter("private_widget_share", private_widget_share)
        if saml_autocreate_access_role is not None:
            _setter("saml_autocreate_access_role", saml_autocreate_access_role)
        if saml_can_be_enabled is not None:
            _setter("saml_can_be_enabled", saml_can_be_enabled)
        if saml_idp_endpoint is not None:
            _setter("saml_idp_endpoint", saml_idp_endpoint)
        if saml_idp_metadata_uploaded is not None:
            _setter("saml_idp_metadata_uploaded", saml_idp_metadata_uploaded)
        if saml_login_url is not None:
            _setter("saml_login_url", saml_login_url)

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.OrganizationSettingsSettingsSaml':
        """
        SAML properties
        """
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="samlAutocreateUsersDomains")
    def saml_autocreate_users_domains(self) -> 'outputs.OrganizationSettingsSettingsSamlAutocreateUsersDomains':
        """
        List of domains where the SAML automated user creation is enabled.
        """
        return pulumi.get(self, "saml_autocreate_users_domains")

    @property
    @pulumi.getter(name="samlIdpInitiatedLogin")
    def saml_idp_initiated_login(self) -> 'outputs.OrganizationSettingsSettingsSamlIdpInitiatedLogin':
        """
        Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        """
        return pulumi.get(self, "saml_idp_initiated_login")

    @property
    @pulumi.getter(name="samlStrictMode")
    def saml_strict_mode(self) -> 'outputs.OrganizationSettingsSettingsSamlStrictMode':
        """
        Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
        """
        return pulumi.get(self, "saml_strict_mode")

    @property
    @pulumi.getter(name="privateWidgetShare")
    def private_widget_share(self) -> Optional[bool]:
        """
        Whether or not the organization users can share widgets outside of Datadog.
        """
        return pulumi.get(self, "private_widget_share")

    @property
    @pulumi.getter(name="samlAutocreateAccessRole")
    def saml_autocreate_access_role(self) -> Optional[str]:
        """
        The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm` , `ro`, `ERROR`
        """
        return pulumi.get(self, "saml_autocreate_access_role")

    @property
    @pulumi.getter(name="samlCanBeEnabled")
    def saml_can_be_enabled(self) -> Optional[bool]:
        """
        Whether or not SAML can be enabled for this organization.
        """
        return pulumi.get(self, "saml_can_be_enabled")

    @property
    @pulumi.getter(name="samlIdpEndpoint")
    def saml_idp_endpoint(self) -> Optional[str]:
        """
        Identity provider endpoint for SAML authentication.
        """
        return pulumi.get(self, "saml_idp_endpoint")

    @property
    @pulumi.getter(name="samlIdpMetadataUploaded")
    def saml_idp_metadata_uploaded(self) -> Optional[bool]:
        """
        Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        """
        return pulumi.get(self, "saml_idp_metadata_uploaded")

    @property
    @pulumi.getter(name="samlLoginUrl")
    def saml_login_url(self) -> Optional[str]:
        """
        URL for SAML logging.
        """
        return pulumi.get(self, "saml_login_url")


@pulumi.output_type
class OrganizationSettingsSettingsSaml(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Whether or not SAML is enabled for this organization.
        """
        OrganizationSettingsSettingsSaml._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not SAML is enabled for this organization.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class OrganizationSettingsSettingsSamlAutocreateUsersDomains(dict):
    def __init__(__self__, *,
                 domains: Optional[Sequence[str]] = None,
                 enabled: Optional[bool] = None):
        """
        :param Sequence[str] domains: List of domains where the SAML automated user creation is enabled.
        :param bool enabled: Whether or not SAML is enabled for this organization.
        """
        OrganizationSettingsSettingsSamlAutocreateUsersDomains._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domains=domains,
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domains: Optional[Sequence[str]] = None,
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if domains is not None:
            _setter("domains", domains)
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def domains(self) -> Optional[Sequence[str]]:
        """
        List of domains where the SAML automated user creation is enabled.
        """
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not SAML is enabled for this organization.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class OrganizationSettingsSettingsSamlIdpInitiatedLogin(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Whether or not SAML is enabled for this organization.
        """
        OrganizationSettingsSettingsSamlIdpInitiatedLogin._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not SAML is enabled for this organization.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class OrganizationSettingsSettingsSamlStrictMode(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Whether or not SAML is enabled for this organization.
        """
        OrganizationSettingsSettingsSamlStrictMode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not SAML is enabled for this organization.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class RestrictionPolicyBinding(dict):
    def __init__(__self__, *,
                 principals: Sequence[str],
                 relation: str):
        """
        :param Sequence[str] principals: An array of principals. A principal is a subject or group of subjects. Each principal is formatted as `type:id`. Supported types: `role` and `org`. The org ID can be obtained through the api/v2/users API.
        :param str relation: The role/level of access. See this page for more details https://docs.datadoghq.com/api/latest/restriction-policies/#supported-relations-for-resources
        """
        RestrictionPolicyBinding._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            principals=principals,
            relation=relation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             principals: Sequence[str],
             relation: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("principals", principals)
        _setter("relation", relation)

    @property
    @pulumi.getter
    def principals(self) -> Sequence[str]:
        """
        An array of principals. A principal is a subject or group of subjects. Each principal is formatted as `type:id`. Supported types: `role` and `org`. The org ID can be obtained through the api/v2/users API.
        """
        return pulumi.get(self, "principals")

    @property
    @pulumi.getter
    def relation(self) -> str:
        """
        The role/level of access. See this page for more details https://docs.datadoghq.com/api/latest/restriction-policies/#supported-relations-for-resources
        """
        return pulumi.get(self, "relation")


@pulumi.output_type
class RolePermission(dict):
    def __init__(__self__, *,
                 id: str,
                 name: Optional[str] = None):
        """
        :param str id: ID of the permission to assign.
        :param str name: Name of the permission.
        """
        RolePermission._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the permission to assign.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the permission.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecurityMonitoringDefaultRuleCase(dict):
    def __init__(__self__, *,
                 notifications: Sequence[str],
                 status: str):
        """
        :param Sequence[str] notifications: Notification targets for each rule case.
        :param str status: Status of the rule case to match. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        """
        SecurityMonitoringDefaultRuleCase._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            notifications=notifications,
            status=status,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             notifications: Sequence[str],
             status: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("notifications", notifications)
        _setter("status", status)

    @property
    @pulumi.getter
    def notifications(self) -> Sequence[str]:
        """
        Notification targets for each rule case.
        """
        return pulumi.get(self, "notifications")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the rule case to match. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SecurityMonitoringDefaultRuleFilter(dict):
    def __init__(__self__, *,
                 action: str,
                 query: str):
        """
        :param str action: The type of filtering action. Allowed enum values: require, suppress Valid values are `require`, `suppress`.
        :param str query: Query for selecting logs to apply the filtering action.
        """
        SecurityMonitoringDefaultRuleFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("query", query)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The type of filtering action. Allowed enum values: require, suppress Valid values are `require`, `suppress`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for selecting logs to apply the filtering action.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SecurityMonitoringDefaultRuleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decreaseCriticalityBasedOnEnv":
            suggest = "decrease_criticality_based_on_env"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringDefaultRuleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringDefaultRuleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringDefaultRuleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decrease_criticality_based_on_env: Optional[bool] = None):
        """
        :param bool decrease_criticality_based_on_env: If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `log_detection`.
        """
        SecurityMonitoringDefaultRuleOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            decrease_criticality_based_on_env=decrease_criticality_based_on_env,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             decrease_criticality_based_on_env: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if decrease_criticality_based_on_env is not None:
            _setter("decrease_criticality_based_on_env", decrease_criticality_based_on_env)

    @property
    @pulumi.getter(name="decreaseCriticalityBasedOnEnv")
    def decrease_criticality_based_on_env(self) -> Optional[bool]:
        """
        If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `log_detection`.
        """
        return pulumi.get(self, "decrease_criticality_based_on_env")


@pulumi.output_type
class SecurityMonitoringFilterExclusionFilter(dict):
    def __init__(__self__, *,
                 name: str,
                 query: str):
        """
        :param str name: Exclusion filter name.
        :param str query: Exclusion filter query. Logs that match this query are excluded from the security filter.
        """
        SecurityMonitoringFilterExclusionFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Exclusion filter name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Exclusion filter query. Logs that match this query are excluded from the security filter.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SecurityMonitoringRuleCase(dict):
    def __init__(__self__, *,
                 status: str,
                 condition: Optional[str] = None,
                 name: Optional[str] = None,
                 notifications: Optional[Sequence[str]] = None):
        """
        :param str status: Severity of the Security Signal. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        :param str condition: A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated based on the event counts in the previously defined queries.
        :param str name: Name of the case.
        :param Sequence[str] notifications: Notification targets for each rule case.
        """
        SecurityMonitoringRuleCase._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
            condition=condition,
            name=name,
            notifications=notifications,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: str,
             condition: Optional[str] = None,
             name: Optional[str] = None,
             notifications: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("status", status)
        if condition is not None:
            _setter("condition", condition)
        if name is not None:
            _setter("name", name)
        if notifications is not None:
            _setter("notifications", notifications)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Severity of the Security Signal. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated based on the event counts in the previously defined queries.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the case.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def notifications(self) -> Optional[Sequence[str]]:
        """
        Notification targets for each rule case.
        """
        return pulumi.get(self, "notifications")


@pulumi.output_type
class SecurityMonitoringRuleFilter(dict):
    def __init__(__self__, *,
                 action: str,
                 query: str):
        """
        :param str action: The type of filtering action. Valid values are `require`, `suppress`.
        :param str query: Query for selecting logs to apply the filtering action.
        """
        SecurityMonitoringRuleFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("query", query)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The type of filtering action. Valid values are `require`, `suppress`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for selecting logs to apply the filtering action.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SecurityMonitoringRuleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepAlive":
            suggest = "keep_alive"
        elif key == "maxSignalDuration":
            suggest = "max_signal_duration"
        elif key == "decreaseCriticalityBasedOnEnv":
            suggest = "decrease_criticality_based_on_env"
        elif key == "detectionMethod":
            suggest = "detection_method"
        elif key == "evaluationWindow":
            suggest = "evaluation_window"
        elif key == "impossibleTravelOptions":
            suggest = "impossible_travel_options"
        elif key == "newValueOptions":
            suggest = "new_value_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringRuleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringRuleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringRuleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 keep_alive: int,
                 max_signal_duration: int,
                 decrease_criticality_based_on_env: Optional[bool] = None,
                 detection_method: Optional[str] = None,
                 evaluation_window: Optional[int] = None,
                 impossible_travel_options: Optional['outputs.SecurityMonitoringRuleOptionsImpossibleTravelOptions'] = None,
                 new_value_options: Optional['outputs.SecurityMonitoringRuleOptionsNewValueOptions'] = None):
        """
        :param int keep_alive: Once a signal is generated, the signal will remain open if a case is matched at least once within this keep alive window (in seconds). Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`.
        :param int max_signal_duration: A signal will close regardless of the query being matched once the time exceeds the maximum duration (in seconds). This time is calculated from the first seen timestamp. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`, `43200`, `86400`.
        :param bool decrease_criticality_based_on_env: If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `log_detection`.
        :param str detection_method: The detection method. Valid values are `threshold`, `new_value`, `anomaly_detection`, `impossible_travel`, `hardcoded`, `third_party`.
        :param int evaluation_window: A time window is specified to match when at least one of the cases matches true. This is a sliding window and evaluates in real time. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`.
        :param 'SecurityMonitoringRuleOptionsImpossibleTravelOptionsArgs' impossible_travel_options: Options for rules using the impossible travel detection method.
        :param 'SecurityMonitoringRuleOptionsNewValueOptionsArgs' new_value_options: New value rules specific options.
        """
        SecurityMonitoringRuleOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            keep_alive=keep_alive,
            max_signal_duration=max_signal_duration,
            decrease_criticality_based_on_env=decrease_criticality_based_on_env,
            detection_method=detection_method,
            evaluation_window=evaluation_window,
            impossible_travel_options=impossible_travel_options,
            new_value_options=new_value_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             keep_alive: int,
             max_signal_duration: int,
             decrease_criticality_based_on_env: Optional[bool] = None,
             detection_method: Optional[str] = None,
             evaluation_window: Optional[int] = None,
             impossible_travel_options: Optional['outputs.SecurityMonitoringRuleOptionsImpossibleTravelOptions'] = None,
             new_value_options: Optional['outputs.SecurityMonitoringRuleOptionsNewValueOptions'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("keep_alive", keep_alive)
        _setter("max_signal_duration", max_signal_duration)
        if decrease_criticality_based_on_env is not None:
            _setter("decrease_criticality_based_on_env", decrease_criticality_based_on_env)
        if detection_method is not None:
            _setter("detection_method", detection_method)
        if evaluation_window is not None:
            _setter("evaluation_window", evaluation_window)
        if impossible_travel_options is not None:
            _setter("impossible_travel_options", impossible_travel_options)
        if new_value_options is not None:
            _setter("new_value_options", new_value_options)

    @property
    @pulumi.getter(name="keepAlive")
    def keep_alive(self) -> int:
        """
        Once a signal is generated, the signal will remain open if a case is matched at least once within this keep alive window (in seconds). Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`.
        """
        return pulumi.get(self, "keep_alive")

    @property
    @pulumi.getter(name="maxSignalDuration")
    def max_signal_duration(self) -> int:
        """
        A signal will close regardless of the query being matched once the time exceeds the maximum duration (in seconds). This time is calculated from the first seen timestamp. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`, `43200`, `86400`.
        """
        return pulumi.get(self, "max_signal_duration")

    @property
    @pulumi.getter(name="decreaseCriticalityBasedOnEnv")
    def decrease_criticality_based_on_env(self) -> Optional[bool]:
        """
        If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `log_detection`.
        """
        return pulumi.get(self, "decrease_criticality_based_on_env")

    @property
    @pulumi.getter(name="detectionMethod")
    def detection_method(self) -> Optional[str]:
        """
        The detection method. Valid values are `threshold`, `new_value`, `anomaly_detection`, `impossible_travel`, `hardcoded`, `third_party`.
        """
        return pulumi.get(self, "detection_method")

    @property
    @pulumi.getter(name="evaluationWindow")
    def evaluation_window(self) -> Optional[int]:
        """
        A time window is specified to match when at least one of the cases matches true. This is a sliding window and evaluates in real time. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`.
        """
        return pulumi.get(self, "evaluation_window")

    @property
    @pulumi.getter(name="impossibleTravelOptions")
    def impossible_travel_options(self) -> Optional['outputs.SecurityMonitoringRuleOptionsImpossibleTravelOptions']:
        """
        Options for rules using the impossible travel detection method.
        """
        return pulumi.get(self, "impossible_travel_options")

    @property
    @pulumi.getter(name="newValueOptions")
    def new_value_options(self) -> Optional['outputs.SecurityMonitoringRuleOptionsNewValueOptions']:
        """
        New value rules specific options.
        """
        return pulumi.get(self, "new_value_options")


@pulumi.output_type
class SecurityMonitoringRuleOptionsImpossibleTravelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baselineUserLocations":
            suggest = "baseline_user_locations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringRuleOptionsImpossibleTravelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringRuleOptionsImpossibleTravelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringRuleOptionsImpossibleTravelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 baseline_user_locations: Optional[bool] = None):
        """
        :param bool baseline_user_locations: If true, signals are suppressed for the first 24 hours. During that time, Datadog learns the user's regular access locations. This can be helpful to reduce noise and infer VPN usage or credentialed API access.
        """
        SecurityMonitoringRuleOptionsImpossibleTravelOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            baseline_user_locations=baseline_user_locations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             baseline_user_locations: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if baseline_user_locations is not None:
            _setter("baseline_user_locations", baseline_user_locations)

    @property
    @pulumi.getter(name="baselineUserLocations")
    def baseline_user_locations(self) -> Optional[bool]:
        """
        If true, signals are suppressed for the first 24 hours. During that time, Datadog learns the user's regular access locations. This can be helpful to reduce noise and infer VPN usage or credentialed API access.
        """
        return pulumi.get(self, "baseline_user_locations")


@pulumi.output_type
class SecurityMonitoringRuleOptionsNewValueOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forgetAfter":
            suggest = "forget_after"
        elif key == "learningDuration":
            suggest = "learning_duration"
        elif key == "learningMethod":
            suggest = "learning_method"
        elif key == "learningThreshold":
            suggest = "learning_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringRuleOptionsNewValueOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringRuleOptionsNewValueOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringRuleOptionsNewValueOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forget_after: int,
                 learning_duration: Optional[int] = None,
                 learning_method: Optional[str] = None,
                 learning_threshold: Optional[int] = None):
        """
        :param int forget_after: The duration in days after which a learned value is forgotten. Valid values are `1`, `2`, `7`, `14`, `21`, `28`.
        :param int learning_duration: The duration in days during which values are learned, and after which signals will be generated for values that weren't learned. If set to 0, a signal will be generated for all new values after the first value is learned. Valid values are `0`, `1`, `7`.
        :param str learning_method: The learning method used to determine when signals should be generated for values that weren't learned. Valid values are `duration`, `threshold`.
        :param int learning_threshold: A number of occurrences after which signals are generated for values that weren't learned. Valid values are `0`, `1`.
        """
        SecurityMonitoringRuleOptionsNewValueOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            forget_after=forget_after,
            learning_duration=learning_duration,
            learning_method=learning_method,
            learning_threshold=learning_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             forget_after: int,
             learning_duration: Optional[int] = None,
             learning_method: Optional[str] = None,
             learning_threshold: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("forget_after", forget_after)
        if learning_duration is not None:
            _setter("learning_duration", learning_duration)
        if learning_method is not None:
            _setter("learning_method", learning_method)
        if learning_threshold is not None:
            _setter("learning_threshold", learning_threshold)

    @property
    @pulumi.getter(name="forgetAfter")
    def forget_after(self) -> int:
        """
        The duration in days after which a learned value is forgotten. Valid values are `1`, `2`, `7`, `14`, `21`, `28`.
        """
        return pulumi.get(self, "forget_after")

    @property
    @pulumi.getter(name="learningDuration")
    def learning_duration(self) -> Optional[int]:
        """
        The duration in days during which values are learned, and after which signals will be generated for values that weren't learned. If set to 0, a signal will be generated for all new values after the first value is learned. Valid values are `0`, `1`, `7`.
        """
        return pulumi.get(self, "learning_duration")

    @property
    @pulumi.getter(name="learningMethod")
    def learning_method(self) -> Optional[str]:
        """
        The learning method used to determine when signals should be generated for values that weren't learned. Valid values are `duration`, `threshold`.
        """
        return pulumi.get(self, "learning_method")

    @property
    @pulumi.getter(name="learningThreshold")
    def learning_threshold(self) -> Optional[int]:
        """
        A number of occurrences after which signals are generated for values that weren't learned. Valid values are `0`, `1`.
        """
        return pulumi.get(self, "learning_threshold")


@pulumi.output_type
class SecurityMonitoringRuleQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentRules":
            suggest = "agent_rules"
        elif key == "distinctFields":
            suggest = "distinct_fields"
        elif key == "groupByFields":
            suggest = "group_by_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringRuleQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringRuleQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringRuleQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 agent_rules: Optional[Sequence['outputs.SecurityMonitoringRuleQueryAgentRule']] = None,
                 aggregation: Optional[str] = None,
                 distinct_fields: Optional[Sequence[str]] = None,
                 group_by_fields: Optional[Sequence[str]] = None,
                 metric: Optional[str] = None,
                 metrics: Optional[Sequence[str]] = None,
                 name: Optional[str] = None):
        """
        :param str query: Query to run on logs.
        :param Sequence['SecurityMonitoringRuleQueryAgentRuleArgs'] agent_rules: **Deprecated**. It won't be applied anymore. **Deprecated.** `agent_rule` has been deprecated in favor of new Agent Rule resource.
        :param str aggregation: The aggregation type. For Signal Correlation rules, it must be event_count. Valid values are `count`, `cardinality`, `sum`, `max`, `new_value`, `geo_data`, `event_count`, `none`.
        :param Sequence[str] distinct_fields: Field for which the cardinality is measured. Sent as an array.
        :param Sequence[str] group_by_fields: Fields to group by.
        :param str metric: The target field to aggregate over when using the `sum`, `max`, or `geo_data` aggregations. **Deprecated.** Configure `metrics` instead. This attribute will be removed in the next major version of the provider.
        :param Sequence[str] metrics: Group of target fields to aggregate over when using the `sum`, `max`, `geo_data`, or `new_value` aggregations. The `sum`, `max`, and `geo_data` aggregations only accept one value in this list, whereas the `new_value` aggregation accepts up to five values.
        :param str name: Name of the query. Not compatible with `new_value` aggregations.
        """
        SecurityMonitoringRuleQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
            agent_rules=agent_rules,
            aggregation=aggregation,
            distinct_fields=distinct_fields,
            group_by_fields=group_by_fields,
            metric=metric,
            metrics=metrics,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             agent_rules: Optional[Sequence['outputs.SecurityMonitoringRuleQueryAgentRule']] = None,
             aggregation: Optional[str] = None,
             distinct_fields: Optional[Sequence[str]] = None,
             group_by_fields: Optional[Sequence[str]] = None,
             metric: Optional[str] = None,
             metrics: Optional[Sequence[str]] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)
        if agent_rules is not None:
            _setter("agent_rules", agent_rules)
        if aggregation is not None:
            _setter("aggregation", aggregation)
        if distinct_fields is not None:
            _setter("distinct_fields", distinct_fields)
        if group_by_fields is not None:
            _setter("group_by_fields", group_by_fields)
        if metric is not None:
            _setter("metric", metric)
        if metrics is not None:
            _setter("metrics", metrics)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query to run on logs.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="agentRules")
    def agent_rules(self) -> Optional[Sequence['outputs.SecurityMonitoringRuleQueryAgentRule']]:
        """
        **Deprecated**. It won't be applied anymore. **Deprecated.** `agent_rule` has been deprecated in favor of new Agent Rule resource.
        """
        warnings.warn("""`agent_rule` has been deprecated in favor of new Agent Rule resource.""", DeprecationWarning)
        pulumi.log.warn("""agent_rules is deprecated: `agent_rule` has been deprecated in favor of new Agent Rule resource.""")

        return pulumi.get(self, "agent_rules")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        The aggregation type. For Signal Correlation rules, it must be event_count. Valid values are `count`, `cardinality`, `sum`, `max`, `new_value`, `geo_data`, `event_count`, `none`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="distinctFields")
    def distinct_fields(self) -> Optional[Sequence[str]]:
        """
        Field for which the cardinality is measured. Sent as an array.
        """
        return pulumi.get(self, "distinct_fields")

    @property
    @pulumi.getter(name="groupByFields")
    def group_by_fields(self) -> Optional[Sequence[str]]:
        """
        Fields to group by.
        """
        return pulumi.get(self, "group_by_fields")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The target field to aggregate over when using the `sum`, `max`, or `geo_data` aggregations. **Deprecated.** Configure `metrics` instead. This attribute will be removed in the next major version of the provider.
        """
        warnings.warn("""Configure `metrics` instead. This attribute will be removed in the next major version of the provider.""", DeprecationWarning)
        pulumi.log.warn("""metric is deprecated: Configure `metrics` instead. This attribute will be removed in the next major version of the provider.""")

        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence[str]]:
        """
        Group of target fields to aggregate over when using the `sum`, `max`, `geo_data`, or `new_value` aggregations. The `sum`, `max`, and `geo_data` aggregations only accept one value in this list, whereas the `new_value` aggregation accepts up to five values.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the query. Not compatible with `new_value` aggregations.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecurityMonitoringRuleQueryAgentRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentRuleId":
            suggest = "agent_rule_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringRuleQueryAgentRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringRuleQueryAgentRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringRuleQueryAgentRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_rule_id: str,
                 expression: str):
        """
        :param str agent_rule_id: **Deprecated**. It won't be applied anymore.
        :param str expression: **Deprecated**. It won't be applied anymore.
        """
        SecurityMonitoringRuleQueryAgentRule._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            agent_rule_id=agent_rule_id,
            expression=expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             agent_rule_id: str,
             expression: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("agent_rule_id", agent_rule_id)
        _setter("expression", expression)

    @property
    @pulumi.getter(name="agentRuleId")
    def agent_rule_id(self) -> str:
        """
        **Deprecated**. It won't be applied anymore.
        """
        return pulumi.get(self, "agent_rule_id")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        **Deprecated**. It won't be applied anymore.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class SecurityMonitoringRuleSignalQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleId":
            suggest = "rule_id"
        elif key == "correlatedByFields":
            suggest = "correlated_by_fields"
        elif key == "correlatedQueryIndex":
            suggest = "correlated_query_index"
        elif key == "defaultRuleId":
            suggest = "default_rule_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringRuleSignalQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringRuleSignalQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringRuleSignalQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_id: str,
                 aggregation: Optional[str] = None,
                 correlated_by_fields: Optional[Sequence[str]] = None,
                 correlated_query_index: Optional[str] = None,
                 default_rule_id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str rule_id: Rule ID of the signal to correlate.
        :param str aggregation: The aggregation type. For Signal Correlation rules, it must be event_count. Valid values are `count`, `cardinality`, `sum`, `max`, `new_value`, `geo_data`, `event_count`, `none`.
        :param Sequence[str] correlated_by_fields: Fields to correlate by.
        :param str correlated_query_index: Index of the rule query used to retrieve the correlated field. An empty string applies correlation on the non-projected per query attributes of the rule.
        :param str default_rule_id: Default Rule ID of the signal to correlate. This value is READ-ONLY.
        :param str name: Name of the query. Not compatible with `new_value` aggregations.
        """
        SecurityMonitoringRuleSignalQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rule_id=rule_id,
            aggregation=aggregation,
            correlated_by_fields=correlated_by_fields,
            correlated_query_index=correlated_query_index,
            default_rule_id=default_rule_id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rule_id: str,
             aggregation: Optional[str] = None,
             correlated_by_fields: Optional[Sequence[str]] = None,
             correlated_query_index: Optional[str] = None,
             default_rule_id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("rule_id", rule_id)
        if aggregation is not None:
            _setter("aggregation", aggregation)
        if correlated_by_fields is not None:
            _setter("correlated_by_fields", correlated_by_fields)
        if correlated_query_index is not None:
            _setter("correlated_query_index", correlated_query_index)
        if default_rule_id is not None:
            _setter("default_rule_id", default_rule_id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> str:
        """
        Rule ID of the signal to correlate.
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        The aggregation type. For Signal Correlation rules, it must be event_count. Valid values are `count`, `cardinality`, `sum`, `max`, `new_value`, `geo_data`, `event_count`, `none`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="correlatedByFields")
    def correlated_by_fields(self) -> Optional[Sequence[str]]:
        """
        Fields to correlate by.
        """
        return pulumi.get(self, "correlated_by_fields")

    @property
    @pulumi.getter(name="correlatedQueryIndex")
    def correlated_query_index(self) -> Optional[str]:
        """
        Index of the rule query used to retrieve the correlated field. An empty string applies correlation on the non-projected per query attributes of the rule.
        """
        return pulumi.get(self, "correlated_query_index")

    @property
    @pulumi.getter(name="defaultRuleId")
    def default_rule_id(self) -> Optional[str]:
        """
        Default Rule ID of the signal to correlate. This value is READ-ONLY.
        """
        return pulumi.get(self, "default_rule_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the query. Not compatible with `new_value` aggregations.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SensitiveDataScannerGroupFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query to filter the events.
        """
        SensitiveDataScannerGroupFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query to filter the events.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SensitiveDataScannerRuleTextReplacement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfChars":
            suggest = "number_of_chars"
        elif key == "replacementString":
            suggest = "replacement_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SensitiveDataScannerRuleTextReplacement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SensitiveDataScannerRuleTextReplacement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SensitiveDataScannerRuleTextReplacement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 number_of_chars: Optional[int] = None,
                 replacement_string: Optional[str] = None):
        """
        :param str type: Type of the replacement text. None means no replacement. hash means the data will be stubbed. replacement*string means that one can chose a text to replace the data. partial*replacement*from*beginning allows a user to partially replace the data from the beginning, and partial*replacement*from_end on the other hand, allows to replace data from the end. Valid values are `none`, `hash`, `replacement_string`, `partial_replacement_from_beginning`, `partial_replacement_from_end`.
        :param int number_of_chars: Required if type == 'partial*replacement*from*beginning' or 'partial*replacement*from*end'. It must be > 0.
        :param str replacement_string: Required if type == 'replacement_string'.
        """
        SensitiveDataScannerRuleTextReplacement._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            number_of_chars=number_of_chars,
            replacement_string=replacement_string,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             number_of_chars: Optional[int] = None,
             replacement_string: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if number_of_chars is not None:
            _setter("number_of_chars", number_of_chars)
        if replacement_string is not None:
            _setter("replacement_string", replacement_string)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the replacement text. None means no replacement. hash means the data will be stubbed. replacement*string means that one can chose a text to replace the data. partial*replacement*from*beginning allows a user to partially replace the data from the beginning, and partial*replacement*from_end on the other hand, allows to replace data from the end. Valid values are `none`, `hash`, `replacement_string`, `partial_replacement_from_beginning`, `partial_replacement_from_end`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="numberOfChars")
    def number_of_chars(self) -> Optional[int]:
        """
        Required if type == 'partial*replacement*from*beginning' or 'partial*replacement*from*end'. It must be > 0.
        """
        return pulumi.get(self, "number_of_chars")

    @property
    @pulumi.getter(name="replacementString")
    def replacement_string(self) -> Optional[str]:
        """
        Required if type == 'replacement_string'.
        """
        return pulumi.get(self, "replacement_string")


@pulumi.output_type
class ServiceLevelObjectiveQuery(dict):
    def __init__(__self__, *,
                 denominator: str,
                 numerator: str):
        """
        :param str denominator: The sum of the `total` events.
        :param str numerator: The sum of all the `good` events.
        """
        ServiceLevelObjectiveQuery._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            denominator=denominator,
            numerator=numerator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             denominator: str,
             numerator: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("denominator", denominator)
        _setter("numerator", numerator)

    @property
    @pulumi.getter
    def denominator(self) -> str:
        """
        The sum of the `total` events.
        """
        return pulumi.get(self, "denominator")

    @property
    @pulumi.getter
    def numerator(self) -> str:
        """
        The sum of all the `good` events.
        """
        return pulumi.get(self, "numerator")


@pulumi.output_type
class ServiceLevelObjectiveThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetDisplay":
            suggest = "target_display"
        elif key == "warningDisplay":
            suggest = "warning_display"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceLevelObjectiveThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceLevelObjectiveThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceLevelObjectiveThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: float,
                 timeframe: str,
                 target_display: Optional[str] = None,
                 warning: Optional[float] = None,
                 warning_display: Optional[str] = None):
        """
        :param float target: The objective's target in `(0,100)`.
        :param str timeframe: The time frame for the objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API documentation page. Valid values are `7d`, `30d`, `90d`, `custom`.
        :param str target_display: A string representation of the target that indicates its precision. It uses trailing zeros to show significant decimal places (e.g. `98.00`).
        :param float warning: The objective's warning value in `(0,100)`. This must be greater than the target value.
        :param str warning_display: A string representation of the warning target (see the description of the target_display field for details).
        """
        ServiceLevelObjectiveThreshold._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            timeframe=timeframe,
            target_display=target_display,
            warning=warning,
            warning_display=warning_display,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: float,
             timeframe: str,
             target_display: Optional[str] = None,
             warning: Optional[float] = None,
             warning_display: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target", target)
        _setter("timeframe", timeframe)
        if target_display is not None:
            _setter("target_display", target_display)
        if warning is not None:
            _setter("warning", warning)
        if warning_display is not None:
            _setter("warning_display", warning_display)

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        The objective's target in `(0,100)`.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def timeframe(self) -> str:
        """
        The time frame for the objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API documentation page. Valid values are `7d`, `30d`, `90d`, `custom`.
        """
        return pulumi.get(self, "timeframe")

    @property
    @pulumi.getter(name="targetDisplay")
    def target_display(self) -> Optional[str]:
        """
        A string representation of the target that indicates its precision. It uses trailing zeros to show significant decimal places (e.g. `98.00`).
        """
        return pulumi.get(self, "target_display")

    @property
    @pulumi.getter
    def warning(self) -> Optional[float]:
        """
        The objective's warning value in `(0,100)`. This must be greater than the target value.
        """
        return pulumi.get(self, "warning")

    @property
    @pulumi.getter(name="warningDisplay")
    def warning_display(self) -> Optional[str]:
        """
        A string representation of the warning target (see the description of the target_display field for details).
        """
        return pulumi.get(self, "warning_display")


@pulumi.output_type
class SpansMetricCompute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"
        elif key == "includePercentiles":
            suggest = "include_percentiles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpansMetricCompute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpansMetricCompute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpansMetricCompute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_type: str,
                 include_percentiles: Optional[bool] = None,
                 path: Optional[str] = None):
        """
        :param str aggregation_type: The type of aggregation to use. This field can't be updated after creation.
        :param bool include_percentiles: Toggle to include or exclude percentile aggregations for distribution metrics. Only present when the `aggregation_type` is `distribution`.
        :param str path: The path to the value the span-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
        """
        SpansMetricCompute._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregation_type=aggregation_type,
            include_percentiles=include_percentiles,
            path=path,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregation_type: str,
             include_percentiles: Optional[bool] = None,
             path: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aggregation_type", aggregation_type)
        if include_percentiles is not None:
            _setter("include_percentiles", include_percentiles)
        if path is not None:
            _setter("path", path)

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> str:
        """
        The type of aggregation to use. This field can't be updated after creation.
        """
        return pulumi.get(self, "aggregation_type")

    @property
    @pulumi.getter(name="includePercentiles")
    def include_percentiles(self) -> Optional[bool]:
        """
        Toggle to include or exclude percentile aggregations for distribution metrics. Only present when the `aggregation_type` is `distribution`.
        """
        return pulumi.get(self, "include_percentiles")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to the value the span-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class SpansMetricFilter(dict):
    def __init__(__self__, *,
                 query: Optional[str] = None):
        """
        :param str query: The search query - following the span search syntax.
        """
        SpansMetricFilter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if query is not None:
            _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        The search query - following the span search syntax.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SpansMetricGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagName":
            suggest = "tag_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpansMetricGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpansMetricGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpansMetricGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 tag_name: Optional[str] = None):
        """
        :param str path: The path to the value the span-based metric will be aggregated over.
        :param str tag_name: Eventual name of the tag that gets created. By default, the path attribute is used as the tag name.
        """
        SpansMetricGroupBy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            tag_name=tag_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: str,
             tag_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("path", path)
        if tag_name is not None:
            _setter("tag_name", tag_name)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path to the value the span-based metric will be aggregated over.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[str]:
        """
        Eventual name of the tag that gets created. By default, the path attribute is used as the tag name.
        """
        return pulumi.get(self, "tag_name")


@pulumi.output_type
class SyntheticsGlobalVariableOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "totpParameters":
            suggest = "totp_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsGlobalVariableOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsGlobalVariableOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsGlobalVariableOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 totp_parameters: Optional['outputs.SyntheticsGlobalVariableOptionsTotpParameters'] = None):
        """
        :param 'SyntheticsGlobalVariableOptionsTotpParametersArgs' totp_parameters: Parameters needed for MFA/TOTP.
        """
        SyntheticsGlobalVariableOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            totp_parameters=totp_parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             totp_parameters: Optional['outputs.SyntheticsGlobalVariableOptionsTotpParameters'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if totp_parameters is not None:
            _setter("totp_parameters", totp_parameters)

    @property
    @pulumi.getter(name="totpParameters")
    def totp_parameters(self) -> Optional['outputs.SyntheticsGlobalVariableOptionsTotpParameters']:
        """
        Parameters needed for MFA/TOTP.
        """
        return pulumi.get(self, "totp_parameters")


@pulumi.output_type
class SyntheticsGlobalVariableOptionsTotpParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "refreshInterval":
            suggest = "refresh_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsGlobalVariableOptionsTotpParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsGlobalVariableOptionsTotpParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsGlobalVariableOptionsTotpParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 digits: int,
                 refresh_interval: int):
        """
        :param int digits: Number of digits for the OTP.
        :param int refresh_interval: Interval for which to refresh the token (in seconds).
        """
        SyntheticsGlobalVariableOptionsTotpParameters._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            digits=digits,
            refresh_interval=refresh_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             digits: int,
             refresh_interval: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("digits", digits)
        _setter("refresh_interval", refresh_interval)

    @property
    @pulumi.getter
    def digits(self) -> int:
        """
        Number of digits for the OTP.
        """
        return pulumi.get(self, "digits")

    @property
    @pulumi.getter(name="refreshInterval")
    def refresh_interval(self) -> int:
        """
        Interval for which to refresh the token (in seconds).
        """
        return pulumi.get(self, "refresh_interval")


@pulumi.output_type
class SyntheticsGlobalVariableParseTestOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localVariableName":
            suggest = "local_variable_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsGlobalVariableParseTestOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsGlobalVariableParseTestOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsGlobalVariableParseTestOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 field: Optional[str] = None,
                 local_variable_name: Optional[str] = None,
                 parser: Optional['outputs.SyntheticsGlobalVariableParseTestOptionsParser'] = None):
        """
        :param str type: Defines the source to use to extract the value. Valid values are `http_body`, `http_header`, `local_variable`.
        :param str field: Required when type = `http_header`. Defines the header to use to extract the value
        :param str local_variable_name: When type is `local_variable`, name of the local variable to use to extract the value.
        """
        SyntheticsGlobalVariableParseTestOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            field=field,
            local_variable_name=local_variable_name,
            parser=parser,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             field: Optional[str] = None,
             local_variable_name: Optional[str] = None,
             parser: Optional['outputs.SyntheticsGlobalVariableParseTestOptionsParser'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if field is not None:
            _setter("field", field)
        if local_variable_name is not None:
            _setter("local_variable_name", local_variable_name)
        if parser is not None:
            _setter("parser", parser)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines the source to use to extract the value. Valid values are `http_body`, `http_header`, `local_variable`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        """
        Required when type = `http_header`. Defines the header to use to extract the value
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter(name="localVariableName")
    def local_variable_name(self) -> Optional[str]:
        """
        When type is `local_variable`, name of the local variable to use to extract the value.
        """
        return pulumi.get(self, "local_variable_name")

    @property
    @pulumi.getter
    def parser(self) -> Optional['outputs.SyntheticsGlobalVariableParseTestOptionsParser']:
        return pulumi.get(self, "parser")


@pulumi.output_type
class SyntheticsGlobalVariableParseTestOptionsParser(dict):
    def __init__(__self__, *,
                 type: str,
                 value: Optional[str] = None):
        """
        :param str type: Type of parser to extract the value. Valid values are `raw`, `json_path`, `regex`, `x_path`.
        :param str value: Value for the parser to use, required for type `json_path` or `regex`.
        """
        SyntheticsGlobalVariableParseTestOptionsParser._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of parser to extract the value. Valid values are `raw`, `json_path`, `regex`, `x_path`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value for the parser to use, required for type `json_path` or `regex`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SyntheticsPrivateLocationMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restrictedRoles":
            suggest = "restricted_roles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsPrivateLocationMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsPrivateLocationMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsPrivateLocationMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 restricted_roles: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] restricted_roles: A list of role identifiers pulled from the Roles API to restrict read and write access.
        """
        SyntheticsPrivateLocationMetadata._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            restricted_roles=restricted_roles,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             restricted_roles: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if restricted_roles is not None:
            _setter("restricted_roles", restricted_roles)

    @property
    @pulumi.getter(name="restrictedRoles")
    def restricted_roles(self) -> Optional[Sequence[str]]:
        """
        A list of role identifiers pulled from the Roles API to restrict read and write access.
        """
        return pulumi.get(self, "restricted_roles")


@pulumi.output_type
class SyntheticsTestApiStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowFailure":
            suggest = "allow_failure"
        elif key == "extractedValues":
            suggest = "extracted_values"
        elif key == "isCritical":
            suggest = "is_critical"
        elif key == "requestBasicauth":
            suggest = "request_basicauth"
        elif key == "requestClientCertificate":
            suggest = "request_client_certificate"
        elif key == "requestDefinition":
            suggest = "request_definition"
        elif key == "requestHeaders":
            suggest = "request_headers"
        elif key == "requestProxy":
            suggest = "request_proxy"
        elif key == "requestQuery":
            suggest = "request_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestApiStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestApiStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestApiStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 allow_failure: Optional[bool] = None,
                 assertions: Optional[Sequence['outputs.SyntheticsTestApiStepAssertion']] = None,
                 extracted_values: Optional[Sequence['outputs.SyntheticsTestApiStepExtractedValue']] = None,
                 is_critical: Optional[bool] = None,
                 request_basicauth: Optional['outputs.SyntheticsTestApiStepRequestBasicauth'] = None,
                 request_client_certificate: Optional['outputs.SyntheticsTestApiStepRequestClientCertificate'] = None,
                 request_definition: Optional['outputs.SyntheticsTestApiStepRequestDefinition'] = None,
                 request_headers: Optional[Mapping[str, Any]] = None,
                 request_proxy: Optional['outputs.SyntheticsTestApiStepRequestProxy'] = None,
                 request_query: Optional[Mapping[str, Any]] = None,
                 retry: Optional['outputs.SyntheticsTestApiStepRetry'] = None,
                 subtype: Optional[str] = None):
        """
        :param str name: The name of the step.
        :param bool allow_failure: Determines whether or not to continue with test if this step fails.
        :param Sequence['SyntheticsTestApiStepAssertionArgs'] assertions: Assertions used for the test. Multiple `assertion` blocks are allowed with the structure below.
        :param Sequence['SyntheticsTestApiStepExtractedValueArgs'] extracted_values: Values to parse and save as variables from the response.
        :param bool is_critical: Determines whether or not to consider the entire test as failed if this step fails. Can be used only if `allow_failure` is `true`.
        :param 'SyntheticsTestApiStepRequestBasicauthArgs' request_basicauth: The HTTP basic authentication credentials. Exactly one nested block is allowed with the structure below.
        :param 'SyntheticsTestApiStepRequestClientCertificateArgs' request_client_certificate: Client certificate to use when performing the test request. Exactly one nested block is allowed with the structure below.
        :param 'SyntheticsTestApiStepRequestDefinitionArgs' request_definition: The request for the api step.
        :param Mapping[str, Any] request_headers: Header name and value map.
        :param 'SyntheticsTestApiStepRequestProxyArgs' request_proxy: The proxy to perform the test.
        :param Mapping[str, Any] request_query: Query arguments name and value map.
        :param str subtype: The subtype of the Synthetic multistep API test step. Valid values are `http`.
        """
        SyntheticsTestApiStep._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            allow_failure=allow_failure,
            assertions=assertions,
            extracted_values=extracted_values,
            is_critical=is_critical,
            request_basicauth=request_basicauth,
            request_client_certificate=request_client_certificate,
            request_definition=request_definition,
            request_headers=request_headers,
            request_proxy=request_proxy,
            request_query=request_query,
            retry=retry,
            subtype=subtype,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             allow_failure: Optional[bool] = None,
             assertions: Optional[Sequence['outputs.SyntheticsTestApiStepAssertion']] = None,
             extracted_values: Optional[Sequence['outputs.SyntheticsTestApiStepExtractedValue']] = None,
             is_critical: Optional[bool] = None,
             request_basicauth: Optional['outputs.SyntheticsTestApiStepRequestBasicauth'] = None,
             request_client_certificate: Optional['outputs.SyntheticsTestApiStepRequestClientCertificate'] = None,
             request_definition: Optional['outputs.SyntheticsTestApiStepRequestDefinition'] = None,
             request_headers: Optional[Mapping[str, Any]] = None,
             request_proxy: Optional['outputs.SyntheticsTestApiStepRequestProxy'] = None,
             request_query: Optional[Mapping[str, Any]] = None,
             retry: Optional['outputs.SyntheticsTestApiStepRetry'] = None,
             subtype: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        if allow_failure is not None:
            _setter("allow_failure", allow_failure)
        if assertions is not None:
            _setter("assertions", assertions)
        if extracted_values is not None:
            _setter("extracted_values", extracted_values)
        if is_critical is not None:
            _setter("is_critical", is_critical)
        if request_basicauth is not None:
            _setter("request_basicauth", request_basicauth)
        if request_client_certificate is not None:
            _setter("request_client_certificate", request_client_certificate)
        if request_definition is not None:
            _setter("request_definition", request_definition)
        if request_headers is not None:
            _setter("request_headers", request_headers)
        if request_proxy is not None:
            _setter("request_proxy", request_proxy)
        if request_query is not None:
            _setter("request_query", request_query)
        if retry is not None:
            _setter("retry", retry)
        if subtype is not None:
            _setter("subtype", subtype)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the step.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="allowFailure")
    def allow_failure(self) -> Optional[bool]:
        """
        Determines whether or not to continue with test if this step fails.
        """
        return pulumi.get(self, "allow_failure")

    @property
    @pulumi.getter
    def assertions(self) -> Optional[Sequence['outputs.SyntheticsTestApiStepAssertion']]:
        """
        Assertions used for the test. Multiple `assertion` blocks are allowed with the structure below.
        """
        return pulumi.get(self, "assertions")

    @property
    @pulumi.getter(name="extractedValues")
    def extracted_values(self) -> Optional[Sequence['outputs.SyntheticsTestApiStepExtractedValue']]:
        """
        Values to parse and save as variables from the response.
        """
        return pulumi.get(self, "extracted_values")

    @property
    @pulumi.getter(name="isCritical")
    def is_critical(self) -> Optional[bool]:
        """
        Determines whether or not to consider the entire test as failed if this step fails. Can be used only if `allow_failure` is `true`.
        """
        return pulumi.get(self, "is_critical")

    @property
    @pulumi.getter(name="requestBasicauth")
    def request_basicauth(self) -> Optional['outputs.SyntheticsTestApiStepRequestBasicauth']:
        """
        The HTTP basic authentication credentials. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "request_basicauth")

    @property
    @pulumi.getter(name="requestClientCertificate")
    def request_client_certificate(self) -> Optional['outputs.SyntheticsTestApiStepRequestClientCertificate']:
        """
        Client certificate to use when performing the test request. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "request_client_certificate")

    @property
    @pulumi.getter(name="requestDefinition")
    def request_definition(self) -> Optional['outputs.SyntheticsTestApiStepRequestDefinition']:
        """
        The request for the api step.
        """
        return pulumi.get(self, "request_definition")

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[Mapping[str, Any]]:
        """
        Header name and value map.
        """
        return pulumi.get(self, "request_headers")

    @property
    @pulumi.getter(name="requestProxy")
    def request_proxy(self) -> Optional['outputs.SyntheticsTestApiStepRequestProxy']:
        """
        The proxy to perform the test.
        """
        return pulumi.get(self, "request_proxy")

    @property
    @pulumi.getter(name="requestQuery")
    def request_query(self) -> Optional[Mapping[str, Any]]:
        """
        Query arguments name and value map.
        """
        return pulumi.get(self, "request_query")

    @property
    @pulumi.getter
    def retry(self) -> Optional['outputs.SyntheticsTestApiStepRetry']:
        return pulumi.get(self, "retry")

    @property
    @pulumi.getter
    def subtype(self) -> Optional[str]:
        """
        The subtype of the Synthetic multistep API test step. Valid values are `http`.
        """
        return pulumi.get(self, "subtype")


@pulumi.output_type
class SyntheticsTestApiStepAssertion(dict):
    def __init__(__self__, *,
                 operator: str,
                 type: str,
                 property: Optional[str] = None,
                 target: Optional[str] = None,
                 targetjsonpath: Optional['outputs.SyntheticsTestApiStepAssertionTargetjsonpath'] = None,
                 targetxpath: Optional['outputs.SyntheticsTestApiStepAssertionTargetxpath'] = None):
        """
        :param str operator: Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        :param str type: Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
        :param str property: If assertion type is `header`, this is the header name.
        :param str target: Expected value. Depends on the assertion type, refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test) for details.
        :param 'SyntheticsTestApiStepAssertionTargetjsonpathArgs' targetjsonpath: Expected structure if `operator` is `validatesJSONPath`. Exactly one nested block is allowed with the structure below.
        :param 'SyntheticsTestApiStepAssertionTargetxpathArgs' targetxpath: Expected structure if `operator` is `validatesXPath`. Exactly one nested block is allowed with the structure below.
        """
        SyntheticsTestApiStepAssertion._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type=type,
            property=property,
            target=target,
            targetjsonpath=targetjsonpath,
            targetxpath=targetxpath,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: str,
             type: str,
             property: Optional[str] = None,
             target: Optional[str] = None,
             targetjsonpath: Optional['outputs.SyntheticsTestApiStepAssertionTargetjsonpath'] = None,
             targetxpath: Optional['outputs.SyntheticsTestApiStepAssertionTargetxpath'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("operator", operator)
        _setter("type", type)
        if property is not None:
            _setter("property", property)
        if target is not None:
            _setter("target", target)
        if targetjsonpath is not None:
            _setter("targetjsonpath", targetjsonpath)
        if targetxpath is not None:
            _setter("targetxpath", targetxpath)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Expected value. Depends on the assertion type, refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test) for details.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def targetjsonpath(self) -> Optional['outputs.SyntheticsTestApiStepAssertionTargetjsonpath']:
        """
        Expected structure if `operator` is `validatesJSONPath`. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "targetjsonpath")

    @property
    @pulumi.getter
    def targetxpath(self) -> Optional['outputs.SyntheticsTestApiStepAssertionTargetxpath']:
        """
        Expected structure if `operator` is `validatesXPath`. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "targetxpath")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        """
        If assertion type is `header`, this is the header name.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class SyntheticsTestApiStepAssertionTargetjsonpath(dict):
    def __init__(__self__, *,
                 jsonpath: str,
                 operator: str,
                 targetvalue: Optional[str] = None):
        """
        :param str jsonpath: The JSON path to assert.
        :param str operator: Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        :param str targetvalue: Expected matching value.
        """
        SyntheticsTestApiStepAssertionTargetjsonpath._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jsonpath=jsonpath,
            operator=operator,
            targetvalue=targetvalue,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jsonpath: str,
             operator: str,
             targetvalue: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("jsonpath", jsonpath)
        _setter("operator", operator)
        if targetvalue is not None:
            _setter("targetvalue", targetvalue)

    @property
    @pulumi.getter
    def jsonpath(self) -> str:
        """
        The JSON path to assert.
        """
        return pulumi.get(self, "jsonpath")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def targetvalue(self) -> Optional[str]:
        """
        Expected matching value.
        """
        return pulumi.get(self, "targetvalue")


@pulumi.output_type
class SyntheticsTestApiStepAssertionTargetxpath(dict):
    def __init__(__self__, *,
                 operator: str,
                 xpath: str,
                 targetvalue: Optional[str] = None):
        """
        :param str operator: Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        :param str xpath: The xpath to assert.
        :param str targetvalue: Expected matching value.
        """
        SyntheticsTestApiStepAssertionTargetxpath._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            xpath=xpath,
            targetvalue=targetvalue,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: str,
             xpath: str,
             targetvalue: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("operator", operator)
        _setter("xpath", xpath)
        if targetvalue is not None:
            _setter("targetvalue", targetvalue)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def xpath(self) -> str:
        """
        The xpath to assert.
        """
        return pulumi.get(self, "xpath")

    @property
    @pulumi.getter
    def targetvalue(self) -> Optional[str]:
        """
        Expected matching value.
        """
        return pulumi.get(self, "targetvalue")


@pulumi.output_type
class SyntheticsTestApiStepExtractedValue(dict):
    def __init__(__self__, *,
                 name: str,
                 parser: 'outputs.SyntheticsTestApiStepExtractedValueParser',
                 type: str,
                 field: Optional[str] = None,
                 secure: Optional[bool] = None):
        """
        :param str type: Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
        :param str field: When type is `http_header`, name of the header to use to extract the value.
        :param bool secure: Determines whether or not the extracted value will be obfuscated.
        """
        SyntheticsTestApiStepExtractedValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parser=parser,
            type=type,
            field=field,
            secure=secure,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             parser: 'outputs.SyntheticsTestApiStepExtractedValueParser',
             type: str,
             field: Optional[str] = None,
             secure: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("parser", parser)
        _setter("type", type)
        if field is not None:
            _setter("field", field)
        if secure is not None:
            _setter("secure", secure)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parser(self) -> 'outputs.SyntheticsTestApiStepExtractedValueParser':
        return pulumi.get(self, "parser")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        """
        When type is `http_header`, name of the header to use to extract the value.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def secure(self) -> Optional[bool]:
        """
        Determines whether or not the extracted value will be obfuscated.
        """
        return pulumi.get(self, "secure")


@pulumi.output_type
class SyntheticsTestApiStepExtractedValueParser(dict):
    def __init__(__self__, *,
                 type: str,
                 value: Optional[str] = None):
        """
        :param str type: Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
        :param str value: Regex or JSON path used for the parser. Not used with type `raw`.
        """
        SyntheticsTestApiStepExtractedValueParser._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: str,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Regex or JSON path used for the parser. Not used with type `raw`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SyntheticsTestApiStepRequestBasicauth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accessTokenUrl":
            suggest = "access_token_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "sessionToken":
            suggest = "session_token"
        elif key == "tokenApiAuthentication":
            suggest = "token_api_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestApiStepRequestBasicauth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestApiStepRequestBasicauth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestApiStepRequestBasicauth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 access_token_url: Optional[str] = None,
                 audience: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 domain: Optional[str] = None,
                 password: Optional[str] = None,
                 region: Optional[str] = None,
                 resource: Optional[str] = None,
                 scope: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 service_name: Optional[str] = None,
                 session_token: Optional[str] = None,
                 token_api_authentication: Optional[str] = None,
                 type: Optional[str] = None,
                 username: Optional[str] = None,
                 workstation: Optional[str] = None):
        """
        :param str access_key: Access key for `SIGV4` authentication.
        :param str access_token_url: Access token url for `oauth-client` or `oauth-rop` authentication.
        :param str audience: Audience for `oauth-client` or `oauth-rop` authentication.
        :param str client_id: Client ID for `oauth-client` or `oauth-rop` authentication.
        :param str client_secret: Client secret for `oauth-client` or `oauth-rop` authentication.
        :param str domain: Domain for `ntlm` authentication.
        :param str password: Password for authentication.
        :param str region: Region for `SIGV4` authentication.
        :param str resource: Resource for `oauth-client` or `oauth-rop` authentication.
        :param str scope: Scope for `oauth-client` or `oauth-rop` authentication.
        :param str secret_key: Secret key for `SIGV4` authentication.
        :param str service_name: Service name for `SIGV4` authentication.
        :param str session_token: Session token for `SIGV4` authentication.
        :param str token_api_authentication: Token API Authentication for `oauth-client` or `oauth-rop` authentication. Valid values are `header`, `body`.
        :param str type: Type of basic authentication to use when performing the test.
        :param str username: Username for authentication.
        :param str workstation: Workstation for `ntlm` authentication.
        """
        SyntheticsTestApiStepRequestBasicauth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_key=access_key,
            access_token_url=access_token_url,
            audience=audience,
            client_id=client_id,
            client_secret=client_secret,
            domain=domain,
            password=password,
            region=region,
            resource=resource,
            scope=scope,
            secret_key=secret_key,
            service_name=service_name,
            session_token=session_token,
            token_api_authentication=token_api_authentication,
            type=type,
            username=username,
            workstation=workstation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_key: Optional[str] = None,
             access_token_url: Optional[str] = None,
             audience: Optional[str] = None,
             client_id: Optional[str] = None,
             client_secret: Optional[str] = None,
             domain: Optional[str] = None,
             password: Optional[str] = None,
             region: Optional[str] = None,
             resource: Optional[str] = None,
             scope: Optional[str] = None,
             secret_key: Optional[str] = None,
             service_name: Optional[str] = None,
             session_token: Optional[str] = None,
             token_api_authentication: Optional[str] = None,
             type: Optional[str] = None,
             username: Optional[str] = None,
             workstation: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if access_key is not None:
            _setter("access_key", access_key)
        if access_token_url is not None:
            _setter("access_token_url", access_token_url)
        if audience is not None:
            _setter("audience", audience)
        if client_id is not None:
            _setter("client_id", client_id)
        if client_secret is not None:
            _setter("client_secret", client_secret)
        if domain is not None:
            _setter("domain", domain)
        if password is not None:
            _setter("password", password)
        if region is not None:
            _setter("region", region)
        if resource is not None:
            _setter("resource", resource)
        if scope is not None:
            _setter("scope", scope)
        if secret_key is not None:
            _setter("secret_key", secret_key)
        if service_name is not None:
            _setter("service_name", service_name)
        if session_token is not None:
            _setter("session_token", session_token)
        if token_api_authentication is not None:
            _setter("token_api_authentication", token_api_authentication)
        if type is not None:
            _setter("type", type)
        if username is not None:
            _setter("username", username)
        if workstation is not None:
            _setter("workstation", workstation)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Access key for `SIGV4` authentication.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accessTokenUrl")
    def access_token_url(self) -> Optional[str]:
        """
        Access token url for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "access_token_url")

    @property
    @pulumi.getter
    def audience(self) -> Optional[str]:
        """
        Audience for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Client ID for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        Client secret for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Domain for `ntlm` authentication.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region for `SIGV4` authentication.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        Resource for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        Scope for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Secret key for `SIGV4` authentication.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        Service name for `SIGV4` authentication.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[str]:
        """
        Session token for `SIGV4` authentication.
        """
        return pulumi.get(self, "session_token")

    @property
    @pulumi.getter(name="tokenApiAuthentication")
    def token_api_authentication(self) -> Optional[str]:
        """
        Token API Authentication for `oauth-client` or `oauth-rop` authentication. Valid values are `header`, `body`.
        """
        return pulumi.get(self, "token_api_authentication")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of basic authentication to use when performing the test.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def workstation(self) -> Optional[str]:
        """
        Workstation for `ntlm` authentication.
        """
        return pulumi.get(self, "workstation")


@pulumi.output_type
class SyntheticsTestApiStepRequestClientCertificate(dict):
    def __init__(__self__, *,
                 cert: 'outputs.SyntheticsTestApiStepRequestClientCertificateCert',
                 key: 'outputs.SyntheticsTestApiStepRequestClientCertificateKey'):
        SyntheticsTestApiStepRequestClientCertificate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cert=cert,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cert: 'outputs.SyntheticsTestApiStepRequestClientCertificateCert',
             key: 'outputs.SyntheticsTestApiStepRequestClientCertificateKey',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cert", cert)
        _setter("key", key)

    @property
    @pulumi.getter
    def cert(self) -> 'outputs.SyntheticsTestApiStepRequestClientCertificateCert':
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def key(self) -> 'outputs.SyntheticsTestApiStepRequestClientCertificateKey':
        return pulumi.get(self, "key")


@pulumi.output_type
class SyntheticsTestApiStepRequestClientCertificateCert(dict):
    def __init__(__self__, *,
                 content: str,
                 filename: Optional[str] = None):
        """
        :param str content: Content of the certificate.
        :param str filename: File name for the certificate.
        """
        SyntheticsTestApiStepRequestClientCertificateCert._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            filename=filename,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: str,
             filename: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("content", content)
        if filename is not None:
            _setter("filename", filename)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Content of the certificate.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        """
        File name for the certificate.
        """
        return pulumi.get(self, "filename")


@pulumi.output_type
class SyntheticsTestApiStepRequestClientCertificateKey(dict):
    def __init__(__self__, *,
                 content: str,
                 filename: Optional[str] = None):
        """
        :param str content: Content of the certificate.
        :param str filename: File name for the certificate.
        """
        SyntheticsTestApiStepRequestClientCertificateKey._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            filename=filename,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: str,
             filename: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("content", content)
        if filename is not None:
            _setter("filename", filename)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Content of the certificate.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        """
        File name for the certificate.
        """
        return pulumi.get(self, "filename")


@pulumi.output_type
class SyntheticsTestApiStepRequestDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowInsecure":
            suggest = "allow_insecure"
        elif key == "bodyType":
            suggest = "body_type"
        elif key == "callType":
            suggest = "call_type"
        elif key == "certificateDomains":
            suggest = "certificate_domains"
        elif key == "dnsServer":
            suggest = "dns_server"
        elif key == "dnsServerPort":
            suggest = "dns_server_port"
        elif key == "followRedirects":
            suggest = "follow_redirects"
        elif key == "noSavingResponseBody":
            suggest = "no_saving_response_body"
        elif key == "numberOfPackets":
            suggest = "number_of_packets"
        elif key == "persistCookies":
            suggest = "persist_cookies"
        elif key == "shouldTrackHops":
            suggest = "should_track_hops"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestApiStepRequestDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestApiStepRequestDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestApiStepRequestDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_insecure: Optional[bool] = None,
                 body: Optional[str] = None,
                 body_type: Optional[str] = None,
                 call_type: Optional[str] = None,
                 certificate_domains: Optional[Sequence[str]] = None,
                 dns_server: Optional[str] = None,
                 dns_server_port: Optional[int] = None,
                 follow_redirects: Optional[bool] = None,
                 host: Optional[str] = None,
                 message: Optional[str] = None,
                 method: Optional[str] = None,
                 no_saving_response_body: Optional[bool] = None,
                 number_of_packets: Optional[int] = None,
                 persist_cookies: Optional[bool] = None,
                 port: Optional[int] = None,
                 servername: Optional[str] = None,
                 service: Optional[str] = None,
                 should_track_hops: Optional[bool] = None,
                 timeout: Optional[int] = None,
                 url: Optional[str] = None):
        """
        :param bool allow_insecure: Allows loading insecure content for an HTTP request in an API test or in a multistep API test step.
        :param str body: The request body.
        :param str body_type: Type of the request body. Valid values are `text/plain`, `application/json`, `text/xml`, `text/html`, `application/x-www-form-urlencoded`, `graphql`.
        :param str call_type: The type of gRPC call to perform. Valid values are `healthcheck`, `unary`.
        :param Sequence[str] certificate_domains: By default, the client certificate is applied on the domain of the starting URL for browser tests. If you want your client certificate to be applied on other domains instead, add them in `certificate_domains`.
        :param str dns_server: DNS server to use for DNS tests (`subtype = "dns"`).
        :param int dns_server_port: DNS server port to use for DNS tests.
        :param bool follow_redirects: Determines whether or not the API HTTP test should follow redirects.
        :param str host: Host name to perform the test with.
        :param str message: For UDP and websocket tests, message to send with the request.
        :param str method: Either the HTTP method/verb to use or a gRPC method available on the service set in the `service` field. Required if `subtype` is `HTTP` or if `subtype` is `grpc` and `callType` is `unary`.
        :param bool no_saving_response_body: Determines whether or not to save the response body.
        :param int number_of_packets: Number of pings to use per test for ICMP tests (`subtype = "icmp"`) between 0 and 10.
        :param bool persist_cookies: Persist cookies across redirects.
        :param int port: Port to use when performing the test.
        :param str servername: For SSL tests, it specifies on which server you want to initiate the TLS handshake, allowing the server to present one of multiple possible certificates on the same IP address and TCP port number.
        :param str service: The gRPC service on which you want to perform the gRPC call.
        :param bool should_track_hops: This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (`subtype = "icmp"`).
        :param int timeout: Timeout in seconds for the test. Defaults to `60`.
        :param str url: The URL to send the request to.
        """
        SyntheticsTestApiStepRequestDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_insecure=allow_insecure,
            body=body,
            body_type=body_type,
            call_type=call_type,
            certificate_domains=certificate_domains,
            dns_server=dns_server,
            dns_server_port=dns_server_port,
            follow_redirects=follow_redirects,
            host=host,
            message=message,
            method=method,
            no_saving_response_body=no_saving_response_body,
            number_of_packets=number_of_packets,
            persist_cookies=persist_cookies,
            port=port,
            servername=servername,
            service=service,
            should_track_hops=should_track_hops,
            timeout=timeout,
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_insecure: Optional[bool] = None,
             body: Optional[str] = None,
             body_type: Optional[str] = None,
             call_type: Optional[str] = None,
             certificate_domains: Optional[Sequence[str]] = None,
             dns_server: Optional[str] = None,
             dns_server_port: Optional[int] = None,
             follow_redirects: Optional[bool] = None,
             host: Optional[str] = None,
             message: Optional[str] = None,
             method: Optional[str] = None,
             no_saving_response_body: Optional[bool] = None,
             number_of_packets: Optional[int] = None,
             persist_cookies: Optional[bool] = None,
             port: Optional[int] = None,
             servername: Optional[str] = None,
             service: Optional[str] = None,
             should_track_hops: Optional[bool] = None,
             timeout: Optional[int] = None,
             url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allow_insecure is not None:
            _setter("allow_insecure", allow_insecure)
        if body is not None:
            _setter("body", body)
        if body_type is not None:
            _setter("body_type", body_type)
        if call_type is not None:
            _setter("call_type", call_type)
        if certificate_domains is not None:
            _setter("certificate_domains", certificate_domains)
        if dns_server is not None:
            _setter("dns_server", dns_server)
        if dns_server_port is not None:
            _setter("dns_server_port", dns_server_port)
        if follow_redirects is not None:
            _setter("follow_redirects", follow_redirects)
        if host is not None:
            _setter("host", host)
        if message is not None:
            _setter("message", message)
        if method is not None:
            _setter("method", method)
        if no_saving_response_body is not None:
            _setter("no_saving_response_body", no_saving_response_body)
        if number_of_packets is not None:
            _setter("number_of_packets", number_of_packets)
        if persist_cookies is not None:
            _setter("persist_cookies", persist_cookies)
        if port is not None:
            _setter("port", port)
        if servername is not None:
            _setter("servername", servername)
        if service is not None:
            _setter("service", service)
        if should_track_hops is not None:
            _setter("should_track_hops", should_track_hops)
        if timeout is not None:
            _setter("timeout", timeout)
        if url is not None:
            _setter("url", url)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[bool]:
        """
        Allows loading insecure content for an HTTP request in an API test or in a multistep API test step.
        """
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        The request body.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="bodyType")
    def body_type(self) -> Optional[str]:
        """
        Type of the request body. Valid values are `text/plain`, `application/json`, `text/xml`, `text/html`, `application/x-www-form-urlencoded`, `graphql`.
        """
        return pulumi.get(self, "body_type")

    @property
    @pulumi.getter(name="callType")
    def call_type(self) -> Optional[str]:
        """
        The type of gRPC call to perform. Valid values are `healthcheck`, `unary`.
        """
        return pulumi.get(self, "call_type")

    @property
    @pulumi.getter(name="certificateDomains")
    def certificate_domains(self) -> Optional[Sequence[str]]:
        """
        By default, the client certificate is applied on the domain of the starting URL for browser tests. If you want your client certificate to be applied on other domains instead, add them in `certificate_domains`.
        """
        return pulumi.get(self, "certificate_domains")

    @property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> Optional[str]:
        """
        DNS server to use for DNS tests (`subtype = "dns"`).
        """
        return pulumi.get(self, "dns_server")

    @property
    @pulumi.getter(name="dnsServerPort")
    def dns_server_port(self) -> Optional[int]:
        """
        DNS server port to use for DNS tests.
        """
        return pulumi.get(self, "dns_server_port")

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[bool]:
        """
        Determines whether or not the API HTTP test should follow redirects.
        """
        return pulumi.get(self, "follow_redirects")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to perform the test with.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        For UDP and websocket tests, message to send with the request.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Either the HTTP method/verb to use or a gRPC method available on the service set in the `service` field. Required if `subtype` is `HTTP` or if `subtype` is `grpc` and `callType` is `unary`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="noSavingResponseBody")
    def no_saving_response_body(self) -> Optional[bool]:
        """
        Determines whether or not to save the response body.
        """
        return pulumi.get(self, "no_saving_response_body")

    @property
    @pulumi.getter(name="numberOfPackets")
    def number_of_packets(self) -> Optional[int]:
        """
        Number of pings to use per test for ICMP tests (`subtype = "icmp"`) between 0 and 10.
        """
        return pulumi.get(self, "number_of_packets")

    @property
    @pulumi.getter(name="persistCookies")
    def persist_cookies(self) -> Optional[bool]:
        """
        Persist cookies across redirects.
        """
        return pulumi.get(self, "persist_cookies")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port to use when performing the test.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def servername(self) -> Optional[str]:
        """
        For SSL tests, it specifies on which server you want to initiate the TLS handshake, allowing the server to present one of multiple possible certificates on the same IP address and TCP port number.
        """
        return pulumi.get(self, "servername")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        The gRPC service on which you want to perform the gRPC call.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="shouldTrackHops")
    def should_track_hops(self) -> Optional[bool]:
        """
        This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (`subtype = "icmp"`).
        """
        return pulumi.get(self, "should_track_hops")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        Timeout in seconds for the test. Defaults to `60`.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL to send the request to.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class SyntheticsTestApiStepRequestProxy(dict):
    def __init__(__self__, *,
                 url: str,
                 headers: Optional[Mapping[str, Any]] = None):
        """
        :param str url: URL of the proxy to perform the test.
        :param Mapping[str, Any] headers: Header name and value map.
        """
        SyntheticsTestApiStepRequestProxy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            headers=headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: str,
             headers: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("url", url)
        if headers is not None:
            _setter("headers", headers)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL of the proxy to perform the test.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, Any]]:
        """
        Header name and value map.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class SyntheticsTestApiStepRetry(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 interval: Optional[int] = None):
        """
        :param int count: Number of retries needed to consider a location as failed before sending a notification alert.
        :param int interval: Interval between a failed test and the next retry in milliseconds.
        """
        SyntheticsTestApiStepRetry._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        Number of retries needed to consider a location as failed before sending a notification alert.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Interval between a failed test and the next retry in milliseconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class SyntheticsTestAssertion(dict):
    def __init__(__self__, *,
                 operator: str,
                 type: str,
                 property: Optional[str] = None,
                 target: Optional[str] = None,
                 targetjsonpath: Optional['outputs.SyntheticsTestAssertionTargetjsonpath'] = None,
                 targetxpath: Optional['outputs.SyntheticsTestAssertionTargetxpath'] = None):
        """
        :param str operator: Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        :param str type: Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
        :param str property: If assertion type is `header`, this is the header name.
        :param str target: Expected value. Depends on the assertion type, refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test) for details.
        :param 'SyntheticsTestAssertionTargetjsonpathArgs' targetjsonpath: Expected structure if `operator` is `validatesJSONPath`. Exactly one nested block is allowed with the structure below.
        :param 'SyntheticsTestAssertionTargetxpathArgs' targetxpath: Expected structure if `operator` is `validatesXPath`. Exactly one nested block is allowed with the structure below.
        """
        SyntheticsTestAssertion._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            type=type,
            property=property,
            target=target,
            targetjsonpath=targetjsonpath,
            targetxpath=targetxpath,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: str,
             type: str,
             property: Optional[str] = None,
             target: Optional[str] = None,
             targetjsonpath: Optional['outputs.SyntheticsTestAssertionTargetjsonpath'] = None,
             targetxpath: Optional['outputs.SyntheticsTestAssertionTargetxpath'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("operator", operator)
        _setter("type", type)
        if property is not None:
            _setter("property", property)
        if target is not None:
            _setter("target", target)
        if targetjsonpath is not None:
            _setter("targetjsonpath", targetjsonpath)
        if targetxpath is not None:
            _setter("targetxpath", targetxpath)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Expected value. Depends on the assertion type, refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test) for details.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def targetjsonpath(self) -> Optional['outputs.SyntheticsTestAssertionTargetjsonpath']:
        """
        Expected structure if `operator` is `validatesJSONPath`. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "targetjsonpath")

    @property
    @pulumi.getter
    def targetxpath(self) -> Optional['outputs.SyntheticsTestAssertionTargetxpath']:
        """
        Expected structure if `operator` is `validatesXPath`. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "targetxpath")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        """
        If assertion type is `header`, this is the header name.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class SyntheticsTestAssertionTargetjsonpath(dict):
    def __init__(__self__, *,
                 jsonpath: str,
                 operator: str,
                 targetvalue: Optional[str] = None):
        """
        :param str jsonpath: The JSON path to assert.
        :param str operator: Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        :param str targetvalue: Expected matching value.
        """
        SyntheticsTestAssertionTargetjsonpath._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            jsonpath=jsonpath,
            operator=operator,
            targetvalue=targetvalue,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             jsonpath: str,
             operator: str,
             targetvalue: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("jsonpath", jsonpath)
        _setter("operator", operator)
        if targetvalue is not None:
            _setter("targetvalue", targetvalue)

    @property
    @pulumi.getter
    def jsonpath(self) -> str:
        """
        The JSON path to assert.
        """
        return pulumi.get(self, "jsonpath")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def targetvalue(self) -> Optional[str]:
        """
        Expected matching value.
        """
        return pulumi.get(self, "targetvalue")


@pulumi.output_type
class SyntheticsTestAssertionTargetxpath(dict):
    def __init__(__self__, *,
                 operator: str,
                 xpath: str,
                 targetvalue: Optional[str] = None):
        """
        :param str operator: Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        :param str xpath: The xpath to assert.
        :param str targetvalue: Expected matching value.
        """
        SyntheticsTestAssertionTargetxpath._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            xpath=xpath,
            targetvalue=targetvalue,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: str,
             xpath: str,
             targetvalue: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("operator", operator)
        _setter("xpath", xpath)
        if targetvalue is not None:
            _setter("targetvalue", targetvalue)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def xpath(self) -> str:
        """
        The xpath to assert.
        """
        return pulumi.get(self, "xpath")

    @property
    @pulumi.getter
    def targetvalue(self) -> Optional[str]:
        """
        Expected matching value.
        """
        return pulumi.get(self, "targetvalue")


@pulumi.output_type
class SyntheticsTestBrowserStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowFailure":
            suggest = "allow_failure"
        elif key == "forceElementUpdate":
            suggest = "force_element_update"
        elif key == "isCritical":
            suggest = "is_critical"
        elif key == "noScreenshot":
            suggest = "no_screenshot"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestBrowserStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestBrowserStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestBrowserStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 params: 'outputs.SyntheticsTestBrowserStepParams',
                 type: str,
                 allow_failure: Optional[bool] = None,
                 force_element_update: Optional[bool] = None,
                 is_critical: Optional[bool] = None,
                 no_screenshot: Optional[bool] = None,
                 timeout: Optional[int] = None):
        """
        :param str name: Name of the step.
        :param 'SyntheticsTestBrowserStepParamsArgs' params: Parameters for the step.
        :param str type: Type of the step. Valid values are `assertCurrentUrl`, `assertElementAttribute`, `assertElementContent`, `assertElementPresent`, `assertEmail`, `assertFileDownload`, `assertFromJavascript`, `assertPageContains`, `assertPageLacks`, `click`, `extractFromJavascript`, `extractVariable`, `goToEmailLink`, `goToUrl`, `goToUrlAndMeasureTti`, `hover`, `playSubTest`, `pressKey`, `refresh`, `runApiTest`, `scroll`, `selectOption`, `typeText`, `uploadFiles`, `wait`.
        :param bool allow_failure: Determines if the step should be allowed to fail.
        :param bool force_element_update: Force update of the "element" parameter for the step
        :param bool is_critical: Determines whether or not to consider the entire test as failed if this step fails. Can be used only if `allow_failure` is `true`.
        :param bool no_screenshot: Prevents saving screenshots of the step.
        :param int timeout: Used to override the default timeout of a step.
        """
        SyntheticsTestBrowserStep._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            params=params,
            type=type,
            allow_failure=allow_failure,
            force_element_update=force_element_update,
            is_critical=is_critical,
            no_screenshot=no_screenshot,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             params: 'outputs.SyntheticsTestBrowserStepParams',
             type: str,
             allow_failure: Optional[bool] = None,
             force_element_update: Optional[bool] = None,
             is_critical: Optional[bool] = None,
             no_screenshot: Optional[bool] = None,
             timeout: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("params", params)
        _setter("type", type)
        if allow_failure is not None:
            _setter("allow_failure", allow_failure)
        if force_element_update is not None:
            _setter("force_element_update", force_element_update)
        if is_critical is not None:
            _setter("is_critical", is_critical)
        if no_screenshot is not None:
            _setter("no_screenshot", no_screenshot)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the step.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def params(self) -> 'outputs.SyntheticsTestBrowserStepParams':
        """
        Parameters for the step.
        """
        return pulumi.get(self, "params")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the step. Valid values are `assertCurrentUrl`, `assertElementAttribute`, `assertElementContent`, `assertElementPresent`, `assertEmail`, `assertFileDownload`, `assertFromJavascript`, `assertPageContains`, `assertPageLacks`, `click`, `extractFromJavascript`, `extractVariable`, `goToEmailLink`, `goToUrl`, `goToUrlAndMeasureTti`, `hover`, `playSubTest`, `pressKey`, `refresh`, `runApiTest`, `scroll`, `selectOption`, `typeText`, `uploadFiles`, `wait`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="allowFailure")
    def allow_failure(self) -> Optional[bool]:
        """
        Determines if the step should be allowed to fail.
        """
        return pulumi.get(self, "allow_failure")

    @property
    @pulumi.getter(name="forceElementUpdate")
    def force_element_update(self) -> Optional[bool]:
        """
        Force update of the "element" parameter for the step
        """
        return pulumi.get(self, "force_element_update")

    @property
    @pulumi.getter(name="isCritical")
    def is_critical(self) -> Optional[bool]:
        """
        Determines whether or not to consider the entire test as failed if this step fails. Can be used only if `allow_failure` is `true`.
        """
        return pulumi.get(self, "is_critical")

    @property
    @pulumi.getter(name="noScreenshot")
    def no_screenshot(self) -> Optional[bool]:
        """
        Prevents saving screenshots of the step.
        """
        return pulumi.get(self, "no_screenshot")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        Used to override the default timeout of a step.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class SyntheticsTestBrowserStepParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clickType":
            suggest = "click_type"
        elif key == "elementUserLocator":
            suggest = "element_user_locator"
        elif key == "playingTabId":
            suggest = "playing_tab_id"
        elif key == "subtestPublicId":
            suggest = "subtest_public_id"
        elif key == "withClick":
            suggest = "with_click"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestBrowserStepParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestBrowserStepParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestBrowserStepParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: Optional[str] = None,
                 check: Optional[str] = None,
                 click_type: Optional[str] = None,
                 code: Optional[str] = None,
                 delay: Optional[int] = None,
                 element: Optional[str] = None,
                 element_user_locator: Optional['outputs.SyntheticsTestBrowserStepParamsElementUserLocator'] = None,
                 email: Optional[str] = None,
                 file: Optional[str] = None,
                 files: Optional[str] = None,
                 modifiers: Optional[Sequence[str]] = None,
                 playing_tab_id: Optional[str] = None,
                 request: Optional[str] = None,
                 subtest_public_id: Optional[str] = None,
                 value: Optional[str] = None,
                 variable: Optional['outputs.SyntheticsTestBrowserStepParamsVariable'] = None,
                 with_click: Optional[bool] = None,
                 x: Optional[int] = None,
                 y: Optional[int] = None):
        """
        :param str attribute: Name of the attribute to use for an "assert attribute" step.
        :param str check: Check type to use for an assertion step. Valid values are `equals`, `notEquals`, `contains`, `notContains`, `startsWith`, `notStartsWith`, `greater`, `lower`, `greaterEquals`, `lowerEquals`, `matchRegex`, `between`, `isEmpty`, `notIsEmpty`.
        :param str click_type: Type of click to use for a "click" step.
        :param str code: Javascript code to use for the step.
        :param int delay: Delay between each key stroke for a "type test" step.
        :param str element: Element to use for the step, json encoded string.
        :param 'SyntheticsTestBrowserStepParamsElementUserLocatorArgs' element_user_locator: Custom user selector to use for the step.
        :param str email: Details of the email for an "assert email" step.
        :param str file: For an "assert download" step.
        :param str files: Details of the files for an "upload files" step, json encoded string.
        :param Sequence[str] modifiers: Modifier to use for a "press key" step.
        :param str playing_tab_id: ID of the tab to play the subtest.
        :param str request: Request for an API step.
        :param str subtest_public_id: ID of the Synthetics test to use as subtest.
        :param str value: Regex or JSON path used for the parser. Not used with type `raw`.
        :param 'SyntheticsTestBrowserStepParamsVariableArgs' variable: Details of the variable to extract.
        :param bool with_click: For "file upload" steps.
        :param int x: X coordinates for a "scroll step".
        :param int y: Y coordinates for a "scroll step".
        """
        SyntheticsTestBrowserStepParams._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            attribute=attribute,
            check=check,
            click_type=click_type,
            code=code,
            delay=delay,
            element=element,
            element_user_locator=element_user_locator,
            email=email,
            file=file,
            files=files,
            modifiers=modifiers,
            playing_tab_id=playing_tab_id,
            request=request,
            subtest_public_id=subtest_public_id,
            value=value,
            variable=variable,
            with_click=with_click,
            x=x,
            y=y,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             attribute: Optional[str] = None,
             check: Optional[str] = None,
             click_type: Optional[str] = None,
             code: Optional[str] = None,
             delay: Optional[int] = None,
             element: Optional[str] = None,
             element_user_locator: Optional['outputs.SyntheticsTestBrowserStepParamsElementUserLocator'] = None,
             email: Optional[str] = None,
             file: Optional[str] = None,
             files: Optional[str] = None,
             modifiers: Optional[Sequence[str]] = None,
             playing_tab_id: Optional[str] = None,
             request: Optional[str] = None,
             subtest_public_id: Optional[str] = None,
             value: Optional[str] = None,
             variable: Optional['outputs.SyntheticsTestBrowserStepParamsVariable'] = None,
             with_click: Optional[bool] = None,
             x: Optional[int] = None,
             y: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if attribute is not None:
            _setter("attribute", attribute)
        if check is not None:
            _setter("check", check)
        if click_type is not None:
            _setter("click_type", click_type)
        if code is not None:
            _setter("code", code)
        if delay is not None:
            _setter("delay", delay)
        if element is not None:
            _setter("element", element)
        if element_user_locator is not None:
            _setter("element_user_locator", element_user_locator)
        if email is not None:
            _setter("email", email)
        if file is not None:
            _setter("file", file)
        if files is not None:
            _setter("files", files)
        if modifiers is not None:
            _setter("modifiers", modifiers)
        if playing_tab_id is not None:
            _setter("playing_tab_id", playing_tab_id)
        if request is not None:
            _setter("request", request)
        if subtest_public_id is not None:
            _setter("subtest_public_id", subtest_public_id)
        if value is not None:
            _setter("value", value)
        if variable is not None:
            _setter("variable", variable)
        if with_click is not None:
            _setter("with_click", with_click)
        if x is not None:
            _setter("x", x)
        if y is not None:
            _setter("y", y)

    @property
    @pulumi.getter
    def attribute(self) -> Optional[str]:
        """
        Name of the attribute to use for an "assert attribute" step.
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def check(self) -> Optional[str]:
        """
        Check type to use for an assertion step. Valid values are `equals`, `notEquals`, `contains`, `notContains`, `startsWith`, `notStartsWith`, `greater`, `lower`, `greaterEquals`, `lowerEquals`, `matchRegex`, `between`, `isEmpty`, `notIsEmpty`.
        """
        return pulumi.get(self, "check")

    @property
    @pulumi.getter(name="clickType")
    def click_type(self) -> Optional[str]:
        """
        Type of click to use for a "click" step.
        """
        return pulumi.get(self, "click_type")

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        Javascript code to use for the step.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def delay(self) -> Optional[int]:
        """
        Delay between each key stroke for a "type test" step.
        """
        return pulumi.get(self, "delay")

    @property
    @pulumi.getter
    def element(self) -> Optional[str]:
        """
        Element to use for the step, json encoded string.
        """
        return pulumi.get(self, "element")

    @property
    @pulumi.getter(name="elementUserLocator")
    def element_user_locator(self) -> Optional['outputs.SyntheticsTestBrowserStepParamsElementUserLocator']:
        """
        Custom user selector to use for the step.
        """
        return pulumi.get(self, "element_user_locator")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        Details of the email for an "assert email" step.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def file(self) -> Optional[str]:
        """
        For an "assert download" step.
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def files(self) -> Optional[str]:
        """
        Details of the files for an "upload files" step, json encoded string.
        """
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def modifiers(self) -> Optional[Sequence[str]]:
        """
        Modifier to use for a "press key" step.
        """
        return pulumi.get(self, "modifiers")

    @property
    @pulumi.getter(name="playingTabId")
    def playing_tab_id(self) -> Optional[str]:
        """
        ID of the tab to play the subtest.
        """
        return pulumi.get(self, "playing_tab_id")

    @property
    @pulumi.getter
    def request(self) -> Optional[str]:
        """
        Request for an API step.
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter(name="subtestPublicId")
    def subtest_public_id(self) -> Optional[str]:
        """
        ID of the Synthetics test to use as subtest.
        """
        return pulumi.get(self, "subtest_public_id")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Regex or JSON path used for the parser. Not used with type `raw`.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def variable(self) -> Optional['outputs.SyntheticsTestBrowserStepParamsVariable']:
        """
        Details of the variable to extract.
        """
        return pulumi.get(self, "variable")

    @property
    @pulumi.getter(name="withClick")
    def with_click(self) -> Optional[bool]:
        """
        For "file upload" steps.
        """
        return pulumi.get(self, "with_click")

    @property
    @pulumi.getter
    def x(self) -> Optional[int]:
        """
        X coordinates for a "scroll step".
        """
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> Optional[int]:
        """
        Y coordinates for a "scroll step".
        """
        return pulumi.get(self, "y")


@pulumi.output_type
class SyntheticsTestBrowserStepParamsElementUserLocator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failTestOnCannotLocate":
            suggest = "fail_test_on_cannot_locate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestBrowserStepParamsElementUserLocator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestBrowserStepParamsElementUserLocator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestBrowserStepParamsElementUserLocator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: 'outputs.SyntheticsTestBrowserStepParamsElementUserLocatorValue',
                 fail_test_on_cannot_locate: Optional[bool] = None):
        """
        :param 'SyntheticsTestBrowserStepParamsElementUserLocatorValueArgs' value: Regex or JSON path used for the parser. Not used with type `raw`.
        """
        SyntheticsTestBrowserStepParamsElementUserLocator._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
            fail_test_on_cannot_locate=fail_test_on_cannot_locate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: 'outputs.SyntheticsTestBrowserStepParamsElementUserLocatorValue',
             fail_test_on_cannot_locate: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("value", value)
        if fail_test_on_cannot_locate is not None:
            _setter("fail_test_on_cannot_locate", fail_test_on_cannot_locate)

    @property
    @pulumi.getter
    def value(self) -> 'outputs.SyntheticsTestBrowserStepParamsElementUserLocatorValue':
        """
        Regex or JSON path used for the parser. Not used with type `raw`.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="failTestOnCannotLocate")
    def fail_test_on_cannot_locate(self) -> Optional[bool]:
        return pulumi.get(self, "fail_test_on_cannot_locate")


@pulumi.output_type
class SyntheticsTestBrowserStepParamsElementUserLocatorValue(dict):
    def __init__(__self__, *,
                 value: str,
                 type: Optional[str] = None):
        """
        :param str value: Regex or JSON path used for the parser. Not used with type `raw`.
        :param str type: Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
        """
        SyntheticsTestBrowserStepParamsElementUserLocatorValue._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: str,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("value", value)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Regex or JSON path used for the parser. Not used with type `raw`.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SyntheticsTestBrowserStepParamsVariable(dict):
    def __init__(__self__, *,
                 example: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str example: Example of the extracted variable.
        """
        SyntheticsTestBrowserStepParamsVariable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            example=example,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             example: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if example is not None:
            _setter("example", example)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def example(self) -> Optional[str]:
        """
        Example of the extracted variable.
        """
        return pulumi.get(self, "example")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class SyntheticsTestBrowserVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 example: Optional[str] = None,
                 id: Optional[str] = None,
                 pattern: Optional[str] = None,
                 secure: Optional[bool] = None):
        """
        :param str name: Name of the variable.
        :param str type: Type of browser test variable. Valid values are `element`, `email`, `global`, `javascript`, `text`.
        :param str example: Example for the variable.
        :param str id: ID of the global variable to use. This is actually only used (and required) in the case of using a variable of type `global`.
        :param str pattern: Pattern of the variable.
        :param bool secure: Determines whether or not the browser test variable is obfuscated. Can only be used with a browser variable of type `text`
        """
        SyntheticsTestBrowserVariable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
            example=example,
            id=id,
            pattern=pattern,
            secure=secure,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             type: str,
             example: Optional[str] = None,
             id: Optional[str] = None,
             pattern: Optional[str] = None,
             secure: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("type", type)
        if example is not None:
            _setter("example", example)
        if id is not None:
            _setter("id", id)
        if pattern is not None:
            _setter("pattern", pattern)
        if secure is not None:
            _setter("secure", secure)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of browser test variable. Valid values are `element`, `email`, `global`, `javascript`, `text`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def example(self) -> Optional[str]:
        """
        Example for the variable.
        """
        return pulumi.get(self, "example")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the global variable to use. This is actually only used (and required) in the case of using a variable of type `global`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        """
        Pattern of the variable.
        """
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter
    def secure(self) -> Optional[bool]:
        """
        Determines whether or not the browser test variable is obfuscated. Can only be used with a browser variable of type `text`
        """
        return pulumi.get(self, "secure")


@pulumi.output_type
class SyntheticsTestConfigVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 example: Optional[str] = None,
                 id: Optional[str] = None,
                 pattern: Optional[str] = None,
                 secure: Optional[bool] = None):
        """
        :param str name: Name of the variable.
        :param str type: Type of test configuration variable. Valid values are `global`, `text`.
        :param str id: When type = `global`, ID of the global variable to use.
        :param bool secure: Whether the value of this variable will be obfuscated in test results.
        """
        SyntheticsTestConfigVariable._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
            example=example,
            id=id,
            pattern=pattern,
            secure=secure,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             type: str,
             example: Optional[str] = None,
             id: Optional[str] = None,
             pattern: Optional[str] = None,
             secure: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("type", type)
        if example is not None:
            _setter("example", example)
        if id is not None:
            _setter("id", id)
        if pattern is not None:
            _setter("pattern", pattern)
        if secure is not None:
            _setter("secure", secure)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of test configuration variable. Valid values are `global`, `text`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def example(self) -> Optional[str]:
        return pulumi.get(self, "example")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        When type = `global`, ID of the global variable to use.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter
    def secure(self) -> Optional[bool]:
        """
        Whether the value of this variable will be obfuscated in test results.
        """
        return pulumi.get(self, "secure")


@pulumi.output_type
class SyntheticsTestOptionsList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tickEvery":
            suggest = "tick_every"
        elif key == "acceptSelfSigned":
            suggest = "accept_self_signed"
        elif key == "allowInsecure":
            suggest = "allow_insecure"
        elif key == "checkCertificateRevocation":
            suggest = "check_certificate_revocation"
        elif key == "disableCors":
            suggest = "disable_cors"
        elif key == "disableCsp":
            suggest = "disable_csp"
        elif key == "followRedirects":
            suggest = "follow_redirects"
        elif key == "httpVersion":
            suggest = "http_version"
        elif key == "ignoreServerCertificateError":
            suggest = "ignore_server_certificate_error"
        elif key == "initialNavigationTimeout":
            suggest = "initial_navigation_timeout"
        elif key == "minFailureDuration":
            suggest = "min_failure_duration"
        elif key == "minLocationFailed":
            suggest = "min_location_failed"
        elif key == "monitorName":
            suggest = "monitor_name"
        elif key == "monitorOptions":
            suggest = "monitor_options"
        elif key == "monitorPriority":
            suggest = "monitor_priority"
        elif key == "noScreenshot":
            suggest = "no_screenshot"
        elif key == "restrictedRoles":
            suggest = "restricted_roles"
        elif key == "rumSettings":
            suggest = "rum_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestOptionsList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestOptionsList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestOptionsList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tick_every: int,
                 accept_self_signed: Optional[bool] = None,
                 allow_insecure: Optional[bool] = None,
                 check_certificate_revocation: Optional[bool] = None,
                 ci: Optional['outputs.SyntheticsTestOptionsListCi'] = None,
                 disable_cors: Optional[bool] = None,
                 disable_csp: Optional[bool] = None,
                 follow_redirects: Optional[bool] = None,
                 http_version: Optional[str] = None,
                 ignore_server_certificate_error: Optional[bool] = None,
                 initial_navigation_timeout: Optional[int] = None,
                 min_failure_duration: Optional[int] = None,
                 min_location_failed: Optional[int] = None,
                 monitor_name: Optional[str] = None,
                 monitor_options: Optional['outputs.SyntheticsTestOptionsListMonitorOptions'] = None,
                 monitor_priority: Optional[int] = None,
                 no_screenshot: Optional[bool] = None,
                 restricted_roles: Optional[Sequence[str]] = None,
                 retry: Optional['outputs.SyntheticsTestOptionsListRetry'] = None,
                 rum_settings: Optional['outputs.SyntheticsTestOptionsListRumSettings'] = None,
                 scheduling: Optional['outputs.SyntheticsTestOptionsListScheduling'] = None):
        """
        :param int tick_every: How often the test should run (in seconds).
        :param bool accept_self_signed: For SSL test, whether or not the test should allow self signed certificates.
        :param bool allow_insecure: Allows loading insecure content for an HTTP request in an API test or in a multistep API test step.
        :param bool check_certificate_revocation: For SSL test, whether or not the test should fail on revoked certificate in stapled OCSP.
        :param 'SyntheticsTestOptionsListCiArgs' ci: CI/CD options for a Synthetic test.
        :param bool disable_cors: Disable Cross-Origin Resource Sharing for browser tests.
        :param bool disable_csp: Disable Content Security Policy for browser tests.
        :param bool follow_redirects: Determines whether or not the API HTTP test should follow redirects.
        :param str http_version: HTTP version to use for a Synthetics API test. Valid values are `http1`, `http2`, `any`.
        :param bool ignore_server_certificate_error: Ignore server certificate error for browser tests.
        :param int initial_navigation_timeout: Timeout before declaring the initial step as failed (in seconds) for browser tests.
        :param int min_failure_duration: Minimum amount of time in failure required to trigger an alert (in seconds). Default is `0`.
        :param int min_location_failed: Minimum number of locations in failure required to trigger an alert. Default is `1`.
        :param str monitor_name: The monitor name is used for the alert title as well as for all monitor dashboard widgets and SLOs.
        :param bool no_screenshot: Prevents saving screenshots of the steps.
        :param Sequence[str] restricted_roles: A list of role identifiers pulled from the Roles API to restrict read and write access.
        :param 'SyntheticsTestOptionsListRumSettingsArgs' rum_settings: The RUM data collection settings for the Synthetic browser test.
        :param 'SyntheticsTestOptionsListSchedulingArgs' scheduling: Object containing timeframes and timezone used for advanced scheduling.
        """
        SyntheticsTestOptionsList._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tick_every=tick_every,
            accept_self_signed=accept_self_signed,
            allow_insecure=allow_insecure,
            check_certificate_revocation=check_certificate_revocation,
            ci=ci,
            disable_cors=disable_cors,
            disable_csp=disable_csp,
            follow_redirects=follow_redirects,
            http_version=http_version,
            ignore_server_certificate_error=ignore_server_certificate_error,
            initial_navigation_timeout=initial_navigation_timeout,
            min_failure_duration=min_failure_duration,
            min_location_failed=min_location_failed,
            monitor_name=monitor_name,
            monitor_options=monitor_options,
            monitor_priority=monitor_priority,
            no_screenshot=no_screenshot,
            restricted_roles=restricted_roles,
            retry=retry,
            rum_settings=rum_settings,
            scheduling=scheduling,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tick_every: int,
             accept_self_signed: Optional[bool] = None,
             allow_insecure: Optional[bool] = None,
             check_certificate_revocation: Optional[bool] = None,
             ci: Optional['outputs.SyntheticsTestOptionsListCi'] = None,
             disable_cors: Optional[bool] = None,
             disable_csp: Optional[bool] = None,
             follow_redirects: Optional[bool] = None,
             http_version: Optional[str] = None,
             ignore_server_certificate_error: Optional[bool] = None,
             initial_navigation_timeout: Optional[int] = None,
             min_failure_duration: Optional[int] = None,
             min_location_failed: Optional[int] = None,
             monitor_name: Optional[str] = None,
             monitor_options: Optional['outputs.SyntheticsTestOptionsListMonitorOptions'] = None,
             monitor_priority: Optional[int] = None,
             no_screenshot: Optional[bool] = None,
             restricted_roles: Optional[Sequence[str]] = None,
             retry: Optional['outputs.SyntheticsTestOptionsListRetry'] = None,
             rum_settings: Optional['outputs.SyntheticsTestOptionsListRumSettings'] = None,
             scheduling: Optional['outputs.SyntheticsTestOptionsListScheduling'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("tick_every", tick_every)
        if accept_self_signed is not None:
            _setter("accept_self_signed", accept_self_signed)
        if allow_insecure is not None:
            _setter("allow_insecure", allow_insecure)
        if check_certificate_revocation is not None:
            _setter("check_certificate_revocation", check_certificate_revocation)
        if ci is not None:
            _setter("ci", ci)
        if disable_cors is not None:
            _setter("disable_cors", disable_cors)
        if disable_csp is not None:
            _setter("disable_csp", disable_csp)
        if follow_redirects is not None:
            _setter("follow_redirects", follow_redirects)
        if http_version is not None:
            _setter("http_version", http_version)
        if ignore_server_certificate_error is not None:
            _setter("ignore_server_certificate_error", ignore_server_certificate_error)
        if initial_navigation_timeout is not None:
            _setter("initial_navigation_timeout", initial_navigation_timeout)
        if min_failure_duration is not None:
            _setter("min_failure_duration", min_failure_duration)
        if min_location_failed is not None:
            _setter("min_location_failed", min_location_failed)
        if monitor_name is not None:
            _setter("monitor_name", monitor_name)
        if monitor_options is not None:
            _setter("monitor_options", monitor_options)
        if monitor_priority is not None:
            _setter("monitor_priority", monitor_priority)
        if no_screenshot is not None:
            _setter("no_screenshot", no_screenshot)
        if restricted_roles is not None:
            _setter("restricted_roles", restricted_roles)
        if retry is not None:
            _setter("retry", retry)
        if rum_settings is not None:
            _setter("rum_settings", rum_settings)
        if scheduling is not None:
            _setter("scheduling", scheduling)

    @property
    @pulumi.getter(name="tickEvery")
    def tick_every(self) -> int:
        """
        How often the test should run (in seconds).
        """
        return pulumi.get(self, "tick_every")

    @property
    @pulumi.getter(name="acceptSelfSigned")
    def accept_self_signed(self) -> Optional[bool]:
        """
        For SSL test, whether or not the test should allow self signed certificates.
        """
        return pulumi.get(self, "accept_self_signed")

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[bool]:
        """
        Allows loading insecure content for an HTTP request in an API test or in a multistep API test step.
        """
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter(name="checkCertificateRevocation")
    def check_certificate_revocation(self) -> Optional[bool]:
        """
        For SSL test, whether or not the test should fail on revoked certificate in stapled OCSP.
        """
        return pulumi.get(self, "check_certificate_revocation")

    @property
    @pulumi.getter
    def ci(self) -> Optional['outputs.SyntheticsTestOptionsListCi']:
        """
        CI/CD options for a Synthetic test.
        """
        return pulumi.get(self, "ci")

    @property
    @pulumi.getter(name="disableCors")
    def disable_cors(self) -> Optional[bool]:
        """
        Disable Cross-Origin Resource Sharing for browser tests.
        """
        return pulumi.get(self, "disable_cors")

    @property
    @pulumi.getter(name="disableCsp")
    def disable_csp(self) -> Optional[bool]:
        """
        Disable Content Security Policy for browser tests.
        """
        return pulumi.get(self, "disable_csp")

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[bool]:
        """
        Determines whether or not the API HTTP test should follow redirects.
        """
        return pulumi.get(self, "follow_redirects")

    @property
    @pulumi.getter(name="httpVersion")
    def http_version(self) -> Optional[str]:
        """
        HTTP version to use for a Synthetics API test. Valid values are `http1`, `http2`, `any`.
        """
        return pulumi.get(self, "http_version")

    @property
    @pulumi.getter(name="ignoreServerCertificateError")
    def ignore_server_certificate_error(self) -> Optional[bool]:
        """
        Ignore server certificate error for browser tests.
        """
        return pulumi.get(self, "ignore_server_certificate_error")

    @property
    @pulumi.getter(name="initialNavigationTimeout")
    def initial_navigation_timeout(self) -> Optional[int]:
        """
        Timeout before declaring the initial step as failed (in seconds) for browser tests.
        """
        return pulumi.get(self, "initial_navigation_timeout")

    @property
    @pulumi.getter(name="minFailureDuration")
    def min_failure_duration(self) -> Optional[int]:
        """
        Minimum amount of time in failure required to trigger an alert (in seconds). Default is `0`.
        """
        return pulumi.get(self, "min_failure_duration")

    @property
    @pulumi.getter(name="minLocationFailed")
    def min_location_failed(self) -> Optional[int]:
        """
        Minimum number of locations in failure required to trigger an alert. Default is `1`.
        """
        return pulumi.get(self, "min_location_failed")

    @property
    @pulumi.getter(name="monitorName")
    def monitor_name(self) -> Optional[str]:
        """
        The monitor name is used for the alert title as well as for all monitor dashboard widgets and SLOs.
        """
        return pulumi.get(self, "monitor_name")

    @property
    @pulumi.getter(name="monitorOptions")
    def monitor_options(self) -> Optional['outputs.SyntheticsTestOptionsListMonitorOptions']:
        return pulumi.get(self, "monitor_options")

    @property
    @pulumi.getter(name="monitorPriority")
    def monitor_priority(self) -> Optional[int]:
        return pulumi.get(self, "monitor_priority")

    @property
    @pulumi.getter(name="noScreenshot")
    def no_screenshot(self) -> Optional[bool]:
        """
        Prevents saving screenshots of the steps.
        """
        return pulumi.get(self, "no_screenshot")

    @property
    @pulumi.getter(name="restrictedRoles")
    def restricted_roles(self) -> Optional[Sequence[str]]:
        """
        A list of role identifiers pulled from the Roles API to restrict read and write access.
        """
        return pulumi.get(self, "restricted_roles")

    @property
    @pulumi.getter
    def retry(self) -> Optional['outputs.SyntheticsTestOptionsListRetry']:
        return pulumi.get(self, "retry")

    @property
    @pulumi.getter(name="rumSettings")
    def rum_settings(self) -> Optional['outputs.SyntheticsTestOptionsListRumSettings']:
        """
        The RUM data collection settings for the Synthetic browser test.
        """
        return pulumi.get(self, "rum_settings")

    @property
    @pulumi.getter
    def scheduling(self) -> Optional['outputs.SyntheticsTestOptionsListScheduling']:
        """
        Object containing timeframes and timezone used for advanced scheduling.
        """
        return pulumi.get(self, "scheduling")


@pulumi.output_type
class SyntheticsTestOptionsListCi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionRule":
            suggest = "execution_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestOptionsListCi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestOptionsListCi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestOptionsListCi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_rule: Optional[str] = None):
        """
        :param str execution_rule: Execution rule for a Synthetics test. Valid values are `blocking`, `non_blocking`, `skipped`.
        """
        SyntheticsTestOptionsListCi._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            execution_rule=execution_rule,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             execution_rule: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if execution_rule is not None:
            _setter("execution_rule", execution_rule)

    @property
    @pulumi.getter(name="executionRule")
    def execution_rule(self) -> Optional[str]:
        """
        Execution rule for a Synthetics test. Valid values are `blocking`, `non_blocking`, `skipped`.
        """
        return pulumi.get(self, "execution_rule")


@pulumi.output_type
class SyntheticsTestOptionsListMonitorOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renotifyInterval":
            suggest = "renotify_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestOptionsListMonitorOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestOptionsListMonitorOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestOptionsListMonitorOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 renotify_interval: Optional[int] = None):
        """
        :param int renotify_interval: Specify a renotification frequency in minutes. Values available by default are `0`, `10`, `20`, `30`, `40`, `50`, `60`, `90`, `120`, `180`, `240`, `300`, `360`, `720`, `1440`.
        """
        SyntheticsTestOptionsListMonitorOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            renotify_interval=renotify_interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             renotify_interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if renotify_interval is not None:
            _setter("renotify_interval", renotify_interval)

    @property
    @pulumi.getter(name="renotifyInterval")
    def renotify_interval(self) -> Optional[int]:
        """
        Specify a renotification frequency in minutes. Values available by default are `0`, `10`, `20`, `30`, `40`, `50`, `60`, `90`, `120`, `180`, `240`, `300`, `360`, `720`, `1440`.
        """
        return pulumi.get(self, "renotify_interval")


@pulumi.output_type
class SyntheticsTestOptionsListRetry(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 interval: Optional[int] = None):
        """
        :param int count: Number of retries needed to consider a location as failed before sending a notification alert.
        :param int interval: Interval between a failed test and the next retry in milliseconds.
        """
        SyntheticsTestOptionsListRetry._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            count=count,
            interval=interval,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             count: Optional[int] = None,
             interval: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if count is not None:
            _setter("count", count)
        if interval is not None:
            _setter("interval", interval)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        Number of retries needed to consider a location as failed before sending a notification alert.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Interval between a failed test and the next retry in milliseconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class SyntheticsTestOptionsListRumSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "applicationId":
            suggest = "application_id"
        elif key == "clientTokenId":
            suggest = "client_token_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestOptionsListRumSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestOptionsListRumSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestOptionsListRumSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: bool,
                 application_id: Optional[str] = None,
                 client_token_id: Optional[int] = None):
        """
        :param bool is_enabled: Determines whether RUM data is collected during test runs.
        :param str application_id: RUM application ID used to collect RUM data for the browser test.
        :param int client_token_id: RUM application API key ID used to collect RUM data for the browser test.
        """
        SyntheticsTestOptionsListRumSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_enabled=is_enabled,
            application_id=application_id,
            client_token_id=client_token_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_enabled: bool,
             application_id: Optional[str] = None,
             client_token_id: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_enabled", is_enabled)
        if application_id is not None:
            _setter("application_id", application_id)
        if client_token_id is not None:
            _setter("client_token_id", client_token_id)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Determines whether RUM data is collected during test runs.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        RUM application ID used to collect RUM data for the browser test.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="clientTokenId")
    def client_token_id(self) -> Optional[int]:
        """
        RUM application API key ID used to collect RUM data for the browser test.
        """
        return pulumi.get(self, "client_token_id")


@pulumi.output_type
class SyntheticsTestOptionsListScheduling(dict):
    def __init__(__self__, *,
                 timeframes: Sequence['outputs.SyntheticsTestOptionsListSchedulingTimeframe'],
                 timezone: str):
        """
        :param Sequence['SyntheticsTestOptionsListSchedulingTimeframeArgs'] timeframes: Array containing objects describing the scheduling pattern to apply to each day.
        :param str timezone: Timezone in which the timeframe is based.
        """
        SyntheticsTestOptionsListScheduling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            timeframes=timeframes,
            timezone=timezone,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             timeframes: Sequence['outputs.SyntheticsTestOptionsListSchedulingTimeframe'],
             timezone: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("timeframes", timeframes)
        _setter("timezone", timezone)

    @property
    @pulumi.getter
    def timeframes(self) -> Sequence['outputs.SyntheticsTestOptionsListSchedulingTimeframe']:
        """
        Array containing objects describing the scheduling pattern to apply to each day.
        """
        return pulumi.get(self, "timeframes")

    @property
    @pulumi.getter
    def timezone(self) -> str:
        """
        Timezone in which the timeframe is based.
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class SyntheticsTestOptionsListSchedulingTimeframe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestOptionsListSchedulingTimeframe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestOptionsListSchedulingTimeframe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestOptionsListSchedulingTimeframe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day: int,
                 from_: str,
                 to: str):
        """
        :param int day: Number representing the day of the week
        :param str from_: The hour of the day on which scheduling starts.
        :param str to: The hour of the day on which scheduling ends.
        """
        SyntheticsTestOptionsListSchedulingTimeframe._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            day=day,
            from_=from_,
            to=to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             day: int,
             from_: str,
             to: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("day", day)
        _setter("from_", from_)
        _setter("to", to)

    @property
    @pulumi.getter
    def day(self) -> int:
        """
        Number representing the day of the week
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter(name="from")
    def from_(self) -> str:
        """
        The hour of the day on which scheduling starts.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> str:
        """
        The hour of the day on which scheduling ends.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class SyntheticsTestRequestBasicauth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accessTokenUrl":
            suggest = "access_token_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "sessionToken":
            suggest = "session_token"
        elif key == "tokenApiAuthentication":
            suggest = "token_api_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestRequestBasicauth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestRequestBasicauth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestRequestBasicauth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 access_token_url: Optional[str] = None,
                 audience: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 domain: Optional[str] = None,
                 password: Optional[str] = None,
                 region: Optional[str] = None,
                 resource: Optional[str] = None,
                 scope: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 service_name: Optional[str] = None,
                 session_token: Optional[str] = None,
                 token_api_authentication: Optional[str] = None,
                 type: Optional[str] = None,
                 username: Optional[str] = None,
                 workstation: Optional[str] = None):
        """
        :param str access_key: Access key for `SIGV4` authentication.
        :param str access_token_url: Access token url for `oauth-client` or `oauth-rop` authentication.
        :param str audience: Audience for `oauth-client` or `oauth-rop` authentication.
        :param str client_id: Client ID for `oauth-client` or `oauth-rop` authentication.
        :param str client_secret: Client secret for `oauth-client` or `oauth-rop` authentication.
        :param str domain: Domain for `ntlm` authentication.
        :param str password: Password for authentication.
        :param str region: Region for `SIGV4` authentication.
        :param str resource: Resource for `oauth-client` or `oauth-rop` authentication.
        :param str scope: Scope for `oauth-client` or `oauth-rop` authentication.
        :param str secret_key: Secret key for `SIGV4` authentication.
        :param str service_name: Service name for `SIGV4` authentication.
        :param str session_token: Session token for `SIGV4` authentication.
        :param str token_api_authentication: Token API Authentication for `oauth-client` or `oauth-rop` authentication. Valid values are `header`, `body`.
        :param str type: Type of basic authentication to use when performing the test.
        :param str username: Username for authentication.
        :param str workstation: Workstation for `ntlm` authentication.
        """
        SyntheticsTestRequestBasicauth._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_key=access_key,
            access_token_url=access_token_url,
            audience=audience,
            client_id=client_id,
            client_secret=client_secret,
            domain=domain,
            password=password,
            region=region,
            resource=resource,
            scope=scope,
            secret_key=secret_key,
            service_name=service_name,
            session_token=session_token,
            token_api_authentication=token_api_authentication,
            type=type,
            username=username,
            workstation=workstation,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_key: Optional[str] = None,
             access_token_url: Optional[str] = None,
             audience: Optional[str] = None,
             client_id: Optional[str] = None,
             client_secret: Optional[str] = None,
             domain: Optional[str] = None,
             password: Optional[str] = None,
             region: Optional[str] = None,
             resource: Optional[str] = None,
             scope: Optional[str] = None,
             secret_key: Optional[str] = None,
             service_name: Optional[str] = None,
             session_token: Optional[str] = None,
             token_api_authentication: Optional[str] = None,
             type: Optional[str] = None,
             username: Optional[str] = None,
             workstation: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if access_key is not None:
            _setter("access_key", access_key)
        if access_token_url is not None:
            _setter("access_token_url", access_token_url)
        if audience is not None:
            _setter("audience", audience)
        if client_id is not None:
            _setter("client_id", client_id)
        if client_secret is not None:
            _setter("client_secret", client_secret)
        if domain is not None:
            _setter("domain", domain)
        if password is not None:
            _setter("password", password)
        if region is not None:
            _setter("region", region)
        if resource is not None:
            _setter("resource", resource)
        if scope is not None:
            _setter("scope", scope)
        if secret_key is not None:
            _setter("secret_key", secret_key)
        if service_name is not None:
            _setter("service_name", service_name)
        if session_token is not None:
            _setter("session_token", session_token)
        if token_api_authentication is not None:
            _setter("token_api_authentication", token_api_authentication)
        if type is not None:
            _setter("type", type)
        if username is not None:
            _setter("username", username)
        if workstation is not None:
            _setter("workstation", workstation)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Access key for `SIGV4` authentication.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accessTokenUrl")
    def access_token_url(self) -> Optional[str]:
        """
        Access token url for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "access_token_url")

    @property
    @pulumi.getter
    def audience(self) -> Optional[str]:
        """
        Audience for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Client ID for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        Client secret for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Domain for `ntlm` authentication.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region for `SIGV4` authentication.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        Resource for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        Scope for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Secret key for `SIGV4` authentication.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        Service name for `SIGV4` authentication.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[str]:
        """
        Session token for `SIGV4` authentication.
        """
        return pulumi.get(self, "session_token")

    @property
    @pulumi.getter(name="tokenApiAuthentication")
    def token_api_authentication(self) -> Optional[str]:
        """
        Token API Authentication for `oauth-client` or `oauth-rop` authentication. Valid values are `header`, `body`.
        """
        return pulumi.get(self, "token_api_authentication")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of basic authentication to use when performing the test.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def workstation(self) -> Optional[str]:
        """
        Workstation for `ntlm` authentication.
        """
        return pulumi.get(self, "workstation")


@pulumi.output_type
class SyntheticsTestRequestClientCertificate(dict):
    def __init__(__self__, *,
                 cert: 'outputs.SyntheticsTestRequestClientCertificateCert',
                 key: 'outputs.SyntheticsTestRequestClientCertificateKey'):
        SyntheticsTestRequestClientCertificate._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cert=cert,
            key=key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cert: 'outputs.SyntheticsTestRequestClientCertificateCert',
             key: 'outputs.SyntheticsTestRequestClientCertificateKey',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cert", cert)
        _setter("key", key)

    @property
    @pulumi.getter
    def cert(self) -> 'outputs.SyntheticsTestRequestClientCertificateCert':
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def key(self) -> 'outputs.SyntheticsTestRequestClientCertificateKey':
        return pulumi.get(self, "key")


@pulumi.output_type
class SyntheticsTestRequestClientCertificateCert(dict):
    def __init__(__self__, *,
                 content: str,
                 filename: Optional[str] = None):
        """
        :param str content: Content of the certificate.
        :param str filename: File name for the certificate.
        """
        SyntheticsTestRequestClientCertificateCert._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            filename=filename,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: str,
             filename: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("content", content)
        if filename is not None:
            _setter("filename", filename)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Content of the certificate.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        """
        File name for the certificate.
        """
        return pulumi.get(self, "filename")


@pulumi.output_type
class SyntheticsTestRequestClientCertificateKey(dict):
    def __init__(__self__, *,
                 content: str,
                 filename: Optional[str] = None):
        """
        :param str content: Content of the certificate.
        :param str filename: File name for the certificate.
        """
        SyntheticsTestRequestClientCertificateKey._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            content=content,
            filename=filename,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             content: str,
             filename: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("content", content)
        if filename is not None:
            _setter("filename", filename)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Content of the certificate.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        """
        File name for the certificate.
        """
        return pulumi.get(self, "filename")


@pulumi.output_type
class SyntheticsTestRequestDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodyType":
            suggest = "body_type"
        elif key == "callType":
            suggest = "call_type"
        elif key == "certificateDomains":
            suggest = "certificate_domains"
        elif key == "dnsServer":
            suggest = "dns_server"
        elif key == "dnsServerPort":
            suggest = "dns_server_port"
        elif key == "noSavingResponseBody":
            suggest = "no_saving_response_body"
        elif key == "numberOfPackets":
            suggest = "number_of_packets"
        elif key == "persistCookies":
            suggest = "persist_cookies"
        elif key == "shouldTrackHops":
            suggest = "should_track_hops"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestRequestDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestRequestDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestRequestDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: Optional[str] = None,
                 body_type: Optional[str] = None,
                 call_type: Optional[str] = None,
                 certificate_domains: Optional[Sequence[str]] = None,
                 dns_server: Optional[str] = None,
                 dns_server_port: Optional[int] = None,
                 host: Optional[str] = None,
                 message: Optional[str] = None,
                 method: Optional[str] = None,
                 no_saving_response_body: Optional[bool] = None,
                 number_of_packets: Optional[int] = None,
                 persist_cookies: Optional[bool] = None,
                 port: Optional[int] = None,
                 servername: Optional[str] = None,
                 service: Optional[str] = None,
                 should_track_hops: Optional[bool] = None,
                 timeout: Optional[int] = None,
                 url: Optional[str] = None):
        """
        :param str body: The request body.
        :param str body_type: Type of the request body. Valid values are `text/plain`, `application/json`, `text/xml`, `text/html`, `application/x-www-form-urlencoded`, `graphql`.
        :param str call_type: The type of gRPC call to perform. Valid values are `healthcheck`, `unary`.
        :param Sequence[str] certificate_domains: By default, the client certificate is applied on the domain of the starting URL for browser tests. If you want your client certificate to be applied on other domains instead, add them in `certificate_domains`.
        :param str dns_server: DNS server to use for DNS tests (`subtype = "dns"`).
        :param int dns_server_port: DNS server port to use for DNS tests.
        :param str host: Host name to perform the test with.
        :param str message: For UDP and websocket tests, message to send with the request.
        :param str method: Either the HTTP method/verb to use or a gRPC method available on the service set in the `service` field. Required if `subtype` is `HTTP` or if `subtype` is `grpc` and `callType` is `unary`.
        :param bool no_saving_response_body: Determines whether or not to save the response body.
        :param int number_of_packets: Number of pings to use per test for ICMP tests (`subtype = "icmp"`) between 0 and 10.
        :param bool persist_cookies: Persist cookies across redirects.
        :param int port: Port to use when performing the test.
        :param str servername: For SSL tests, it specifies on which server you want to initiate the TLS handshake, allowing the server to present one of multiple possible certificates on the same IP address and TCP port number.
        :param str service: The gRPC service on which you want to perform the gRPC call.
        :param bool should_track_hops: This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (`subtype = "icmp"`).
        :param int timeout: Timeout in seconds for the test. Defaults to `60`.
        :param str url: The URL to send the request to.
        """
        SyntheticsTestRequestDefinition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            body=body,
            body_type=body_type,
            call_type=call_type,
            certificate_domains=certificate_domains,
            dns_server=dns_server,
            dns_server_port=dns_server_port,
            host=host,
            message=message,
            method=method,
            no_saving_response_body=no_saving_response_body,
            number_of_packets=number_of_packets,
            persist_cookies=persist_cookies,
            port=port,
            servername=servername,
            service=service,
            should_track_hops=should_track_hops,
            timeout=timeout,
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             body: Optional[str] = None,
             body_type: Optional[str] = None,
             call_type: Optional[str] = None,
             certificate_domains: Optional[Sequence[str]] = None,
             dns_server: Optional[str] = None,
             dns_server_port: Optional[int] = None,
             host: Optional[str] = None,
             message: Optional[str] = None,
             method: Optional[str] = None,
             no_saving_response_body: Optional[bool] = None,
             number_of_packets: Optional[int] = None,
             persist_cookies: Optional[bool] = None,
             port: Optional[int] = None,
             servername: Optional[str] = None,
             service: Optional[str] = None,
             should_track_hops: Optional[bool] = None,
             timeout: Optional[int] = None,
             url: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if body is not None:
            _setter("body", body)
        if body_type is not None:
            _setter("body_type", body_type)
        if call_type is not None:
            _setter("call_type", call_type)
        if certificate_domains is not None:
            _setter("certificate_domains", certificate_domains)
        if dns_server is not None:
            _setter("dns_server", dns_server)
        if dns_server_port is not None:
            _setter("dns_server_port", dns_server_port)
        if host is not None:
            _setter("host", host)
        if message is not None:
            _setter("message", message)
        if method is not None:
            _setter("method", method)
        if no_saving_response_body is not None:
            _setter("no_saving_response_body", no_saving_response_body)
        if number_of_packets is not None:
            _setter("number_of_packets", number_of_packets)
        if persist_cookies is not None:
            _setter("persist_cookies", persist_cookies)
        if port is not None:
            _setter("port", port)
        if servername is not None:
            _setter("servername", servername)
        if service is not None:
            _setter("service", service)
        if should_track_hops is not None:
            _setter("should_track_hops", should_track_hops)
        if timeout is not None:
            _setter("timeout", timeout)
        if url is not None:
            _setter("url", url)

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        The request body.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="bodyType")
    def body_type(self) -> Optional[str]:
        """
        Type of the request body. Valid values are `text/plain`, `application/json`, `text/xml`, `text/html`, `application/x-www-form-urlencoded`, `graphql`.
        """
        return pulumi.get(self, "body_type")

    @property
    @pulumi.getter(name="callType")
    def call_type(self) -> Optional[str]:
        """
        The type of gRPC call to perform. Valid values are `healthcheck`, `unary`.
        """
        return pulumi.get(self, "call_type")

    @property
    @pulumi.getter(name="certificateDomains")
    def certificate_domains(self) -> Optional[Sequence[str]]:
        """
        By default, the client certificate is applied on the domain of the starting URL for browser tests. If you want your client certificate to be applied on other domains instead, add them in `certificate_domains`.
        """
        return pulumi.get(self, "certificate_domains")

    @property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> Optional[str]:
        """
        DNS server to use for DNS tests (`subtype = "dns"`).
        """
        return pulumi.get(self, "dns_server")

    @property
    @pulumi.getter(name="dnsServerPort")
    def dns_server_port(self) -> Optional[int]:
        """
        DNS server port to use for DNS tests.
        """
        return pulumi.get(self, "dns_server_port")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to perform the test with.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        For UDP and websocket tests, message to send with the request.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Either the HTTP method/verb to use or a gRPC method available on the service set in the `service` field. Required if `subtype` is `HTTP` or if `subtype` is `grpc` and `callType` is `unary`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="noSavingResponseBody")
    def no_saving_response_body(self) -> Optional[bool]:
        """
        Determines whether or not to save the response body.
        """
        return pulumi.get(self, "no_saving_response_body")

    @property
    @pulumi.getter(name="numberOfPackets")
    def number_of_packets(self) -> Optional[int]:
        """
        Number of pings to use per test for ICMP tests (`subtype = "icmp"`) between 0 and 10.
        """
        return pulumi.get(self, "number_of_packets")

    @property
    @pulumi.getter(name="persistCookies")
    def persist_cookies(self) -> Optional[bool]:
        """
        Persist cookies across redirects.
        """
        return pulumi.get(self, "persist_cookies")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port to use when performing the test.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def servername(self) -> Optional[str]:
        """
        For SSL tests, it specifies on which server you want to initiate the TLS handshake, allowing the server to present one of multiple possible certificates on the same IP address and TCP port number.
        """
        return pulumi.get(self, "servername")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        The gRPC service on which you want to perform the gRPC call.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="shouldTrackHops")
    def should_track_hops(self) -> Optional[bool]:
        """
        This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (`subtype = "icmp"`).
        """
        return pulumi.get(self, "should_track_hops")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        Timeout in seconds for the test. Defaults to `60`.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL to send the request to.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class SyntheticsTestRequestProxy(dict):
    def __init__(__self__, *,
                 url: str,
                 headers: Optional[Mapping[str, Any]] = None):
        """
        :param str url: URL of the proxy to perform the test.
        :param Mapping[str, Any] headers: Header name and value map.
        """
        SyntheticsTestRequestProxy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            url=url,
            headers=headers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             url: str,
             headers: Optional[Mapping[str, Any]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("url", url)
        if headers is not None:
            _setter("headers", headers)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL of the proxy to perform the test.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, Any]]:
        """
        Header name and value map.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class GetCloudWorkloadSecurityAgentRulesAgentRuleResult(dict):
    def __init__(__self__, *,
                 description: str,
                 enabled: bool,
                 expression: str,
                 id: str,
                 name: str):
        GetCloudWorkloadSecurityAgentRulesAgentRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            enabled=enabled,
            expression=expression,
            id=id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: str,
             enabled: bool,
             expression: str,
             id: str,
             name: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("description", description)
        _setter("enabled", enabled)
        _setter("expression", expression)
        _setter("id", id)
        _setter("name", name)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetHostsHostListResult(dict):
    def __init__(__self__, *,
                 aliases: Sequence[str],
                 apps: Sequence[str],
                 aws_name: str,
                 host_name: str,
                 id: int,
                 is_muted: bool,
                 last_reported_time: int,
                 meta: 'outputs.GetHostsHostListMetaResult',
                 metrics: 'outputs.GetHostsHostListMetricsResult',
                 mute_timeout: int,
                 name: str,
                 sources: Sequence[str],
                 up: bool):
        GetHostsHostListResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aliases=aliases,
            apps=apps,
            aws_name=aws_name,
            host_name=host_name,
            id=id,
            is_muted=is_muted,
            last_reported_time=last_reported_time,
            meta=meta,
            metrics=metrics,
            mute_timeout=mute_timeout,
            name=name,
            sources=sources,
            up=up,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aliases: Sequence[str],
             apps: Sequence[str],
             aws_name: str,
             host_name: str,
             id: int,
             is_muted: bool,
             last_reported_time: int,
             meta: 'outputs.GetHostsHostListMetaResult',
             metrics: 'outputs.GetHostsHostListMetricsResult',
             mute_timeout: int,
             name: str,
             sources: Sequence[str],
             up: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aliases", aliases)
        _setter("apps", apps)
        _setter("aws_name", aws_name)
        _setter("host_name", host_name)
        _setter("id", id)
        _setter("is_muted", is_muted)
        _setter("last_reported_time", last_reported_time)
        _setter("meta", meta)
        _setter("metrics", metrics)
        _setter("mute_timeout", mute_timeout)
        _setter("name", name)
        _setter("sources", sources)
        _setter("up", up)

    @property
    @pulumi.getter
    def aliases(self) -> Sequence[str]:
        return pulumi.get(self, "aliases")

    @property
    @pulumi.getter
    def apps(self) -> Sequence[str]:
        return pulumi.get(self, "apps")

    @property
    @pulumi.getter(name="awsName")
    def aws_name(self) -> str:
        return pulumi.get(self, "aws_name")

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> str:
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isMuted")
    def is_muted(self) -> bool:
        return pulumi.get(self, "is_muted")

    @property
    @pulumi.getter(name="lastReportedTime")
    def last_reported_time(self) -> int:
        return pulumi.get(self, "last_reported_time")

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.GetHostsHostListMetaResult':
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def metrics(self) -> 'outputs.GetHostsHostListMetricsResult':
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter(name="muteTimeout")
    def mute_timeout(self) -> int:
        return pulumi.get(self, "mute_timeout")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def up(self) -> bool:
        return pulumi.get(self, "up")


@pulumi.output_type
class GetHostsHostListMetaResult(dict):
    def __init__(__self__, *,
                 agent_version: str,
                 cpu_cores: int,
                 gohai: str,
                 machine: str,
                 platform: str,
                 processor: str,
                 python_version: str,
                 socket_fqdn: str,
                 socket_hostname: str):
        GetHostsHostListMetaResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            agent_version=agent_version,
            cpu_cores=cpu_cores,
            gohai=gohai,
            machine=machine,
            platform=platform,
            processor=processor,
            python_version=python_version,
            socket_fqdn=socket_fqdn,
            socket_hostname=socket_hostname,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             agent_version: str,
             cpu_cores: int,
             gohai: str,
             machine: str,
             platform: str,
             processor: str,
             python_version: str,
             socket_fqdn: str,
             socket_hostname: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("agent_version", agent_version)
        _setter("cpu_cores", cpu_cores)
        _setter("gohai", gohai)
        _setter("machine", machine)
        _setter("platform", platform)
        _setter("processor", processor)
        _setter("python_version", python_version)
        _setter("socket_fqdn", socket_fqdn)
        _setter("socket_hostname", socket_hostname)

    @property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> str:
        return pulumi.get(self, "agent_version")

    @property
    @pulumi.getter(name="cpuCores")
    def cpu_cores(self) -> int:
        return pulumi.get(self, "cpu_cores")

    @property
    @pulumi.getter
    def gohai(self) -> str:
        return pulumi.get(self, "gohai")

    @property
    @pulumi.getter
    def machine(self) -> str:
        return pulumi.get(self, "machine")

    @property
    @pulumi.getter
    def platform(self) -> str:
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def processor(self) -> str:
        return pulumi.get(self, "processor")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> str:
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="socketFqdn")
    def socket_fqdn(self) -> str:
        return pulumi.get(self, "socket_fqdn")

    @property
    @pulumi.getter(name="socketHostname")
    def socket_hostname(self) -> str:
        return pulumi.get(self, "socket_hostname")


@pulumi.output_type
class GetHostsHostListMetricsResult(dict):
    def __init__(__self__, *,
                 cpu: float,
                 iowait: float,
                 load: float):
        GetHostsHostListMetricsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cpu=cpu,
            iowait=iowait,
            load=load,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cpu: float,
             iowait: float,
             load: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cpu", cpu)
        _setter("iowait", iowait)
        _setter("load", load)

    @property
    @pulumi.getter
    def cpu(self) -> float:
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def iowait(self) -> float:
        return pulumi.get(self, "iowait")

    @property
    @pulumi.getter
    def load(self) -> float:
        return pulumi.get(self, "load")


@pulumi.output_type
class GetLogsIndexesLogsIndexResult(dict):
    def __init__(__self__, *,
                 daily_limit: int,
                 exclusion_filters: Sequence['outputs.GetLogsIndexesLogsIndexExclusionFilterResult'],
                 filters: Sequence['outputs.GetLogsIndexesLogsIndexFilterResult'],
                 name: str,
                 retention_days: int):
        GetLogsIndexesLogsIndexResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            daily_limit=daily_limit,
            exclusion_filters=exclusion_filters,
            filters=filters,
            name=name,
            retention_days=retention_days,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             daily_limit: int,
             exclusion_filters: Sequence['outputs.GetLogsIndexesLogsIndexExclusionFilterResult'],
             filters: Sequence['outputs.GetLogsIndexesLogsIndexFilterResult'],
             name: str,
             retention_days: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("daily_limit", daily_limit)
        _setter("exclusion_filters", exclusion_filters)
        _setter("filters", filters)
        _setter("name", name)
        _setter("retention_days", retention_days)

    @property
    @pulumi.getter(name="dailyLimit")
    def daily_limit(self) -> int:
        return pulumi.get(self, "daily_limit")

    @property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Sequence['outputs.GetLogsIndexesLogsIndexExclusionFilterResult']:
        return pulumi.get(self, "exclusion_filters")

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.GetLogsIndexesLogsIndexFilterResult']:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> int:
        return pulumi.get(self, "retention_days")


@pulumi.output_type
class GetLogsIndexesLogsIndexExclusionFilterResult(dict):
    def __init__(__self__, *,
                 is_enabled: bool,
                 name: str,
                 filters: Optional[Sequence['outputs.GetLogsIndexesLogsIndexExclusionFilterFilterResult']] = None):
        GetLogsIndexesLogsIndexExclusionFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_enabled=is_enabled,
            name=name,
            filters=filters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_enabled: bool,
             name: str,
             filters: Optional[Sequence['outputs.GetLogsIndexesLogsIndexExclusionFilterFilterResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_enabled", is_enabled)
        _setter("name", name)
        if filters is not None:
            _setter("filters", filters)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.GetLogsIndexesLogsIndexExclusionFilterFilterResult']]:
        return pulumi.get(self, "filters")


@pulumi.output_type
class GetLogsIndexesLogsIndexExclusionFilterFilterResult(dict):
    def __init__(__self__, *,
                 query: str,
                 sample_rate: float):
        GetLogsIndexesLogsIndexExclusionFilterFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
            sample_rate=sample_rate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             sample_rate: float,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)
        _setter("sample_rate", sample_rate)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> float:
        return pulumi.get(self, "sample_rate")


@pulumi.output_type
class GetLogsIndexesLogsIndexFilterResult(dict):
    def __init__(__self__, *,
                 query: str):
        GetLogsIndexesLogsIndexFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class GetLogsPipelinesLogsPipelineResult(dict):
    def __init__(__self__, *,
                 filters: Sequence['outputs.GetLogsPipelinesLogsPipelineFilterResult'],
                 id: str,
                 is_enabled: bool,
                 is_read_only: bool,
                 name: str,
                 type: str):
        GetLogsPipelinesLogsPipelineResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            filters=filters,
            id=id,
            is_enabled=is_enabled,
            is_read_only=is_read_only,
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             filters: Sequence['outputs.GetLogsPipelinesLogsPipelineFilterResult'],
             id: str,
             is_enabled: bool,
             is_read_only: bool,
             name: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("filters", filters)
        _setter("id", id)
        _setter("is_enabled", is_enabled)
        _setter("is_read_only", is_read_only)
        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.GetLogsPipelinesLogsPipelineFilterResult']:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReadOnly")
    def is_read_only(self) -> bool:
        return pulumi.get(self, "is_read_only")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLogsPipelinesLogsPipelineFilterResult(dict):
    def __init__(__self__, *,
                 query: str):
        GetLogsPipelinesLogsPipelineFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class GetMonitorConfigPoliciesMonitorConfigPolicyResult(dict):
    def __init__(__self__, *,
                 id: str,
                 policy_type: str,
                 tag_policy: 'outputs.GetMonitorConfigPoliciesMonitorConfigPolicyTagPolicyResult'):
        GetMonitorConfigPoliciesMonitorConfigPolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            policy_type=policy_type,
            tag_policy=tag_policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             policy_type: str,
             tag_policy: 'outputs.GetMonitorConfigPoliciesMonitorConfigPolicyTagPolicyResult',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("policy_type", policy_type)
        _setter("tag_policy", tag_policy)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> str:
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="tagPolicy")
    def tag_policy(self) -> 'outputs.GetMonitorConfigPoliciesMonitorConfigPolicyTagPolicyResult':
        return pulumi.get(self, "tag_policy")


@pulumi.output_type
class GetMonitorConfigPoliciesMonitorConfigPolicyTagPolicyResult(dict):
    def __init__(__self__, *,
                 tag_key: str,
                 tag_key_required: bool,
                 valid_tag_values: Sequence[str]):
        GetMonitorConfigPoliciesMonitorConfigPolicyTagPolicyResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            tag_key=tag_key,
            tag_key_required=tag_key_required,
            valid_tag_values=valid_tag_values,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             tag_key: str,
             tag_key_required: bool,
             valid_tag_values: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("tag_key", tag_key)
        _setter("tag_key_required", tag_key_required)
        _setter("valid_tag_values", valid_tag_values)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> str:
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter(name="tagKeyRequired")
    def tag_key_required(self) -> bool:
        return pulumi.get(self, "tag_key_required")

    @property
    @pulumi.getter(name="validTagValues")
    def valid_tag_values(self) -> Sequence[str]:
        return pulumi.get(self, "valid_tag_values")


@pulumi.output_type
class GetMonitorMonitorThresholdResult(dict):
    def __init__(__self__, *,
                 critical: str,
                 critical_recovery: str,
                 ok: str,
                 unknown: str,
                 warning: str,
                 warning_recovery: str):
        GetMonitorMonitorThresholdResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            critical=critical,
            critical_recovery=critical_recovery,
            ok=ok,
            unknown=unknown,
            warning=warning,
            warning_recovery=warning_recovery,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             critical: str,
             critical_recovery: str,
             ok: str,
             unknown: str,
             warning: str,
             warning_recovery: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("critical", critical)
        _setter("critical_recovery", critical_recovery)
        _setter("ok", ok)
        _setter("unknown", unknown)
        _setter("warning", warning)
        _setter("warning_recovery", warning_recovery)

    @property
    @pulumi.getter
    def critical(self) -> str:
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter(name="criticalRecovery")
    def critical_recovery(self) -> str:
        return pulumi.get(self, "critical_recovery")

    @property
    @pulumi.getter
    def ok(self) -> str:
        return pulumi.get(self, "ok")

    @property
    @pulumi.getter
    def unknown(self) -> str:
        return pulumi.get(self, "unknown")

    @property
    @pulumi.getter
    def warning(self) -> str:
        return pulumi.get(self, "warning")

    @property
    @pulumi.getter(name="warningRecovery")
    def warning_recovery(self) -> str:
        return pulumi.get(self, "warning_recovery")


@pulumi.output_type
class GetMonitorMonitorThresholdWindowResult(dict):
    def __init__(__self__, *,
                 recovery_window: str,
                 trigger_window: str):
        GetMonitorMonitorThresholdWindowResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            recovery_window=recovery_window,
            trigger_window=trigger_window,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             recovery_window: str,
             trigger_window: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("recovery_window", recovery_window)
        _setter("trigger_window", trigger_window)

    @property
    @pulumi.getter(name="recoveryWindow")
    def recovery_window(self) -> str:
        return pulumi.get(self, "recovery_window")

    @property
    @pulumi.getter(name="triggerWindow")
    def trigger_window(self) -> str:
        return pulumi.get(self, "trigger_window")


@pulumi.output_type
class GetMonitorSchedulingOptionResult(dict):
    def __init__(__self__, *,
                 evaluation_windows: Sequence['outputs.GetMonitorSchedulingOptionEvaluationWindowResult']):
        GetMonitorSchedulingOptionResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            evaluation_windows=evaluation_windows,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             evaluation_windows: Sequence['outputs.GetMonitorSchedulingOptionEvaluationWindowResult'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("evaluation_windows", evaluation_windows)

    @property
    @pulumi.getter(name="evaluationWindows")
    def evaluation_windows(self) -> Sequence['outputs.GetMonitorSchedulingOptionEvaluationWindowResult']:
        return pulumi.get(self, "evaluation_windows")


@pulumi.output_type
class GetMonitorSchedulingOptionEvaluationWindowResult(dict):
    def __init__(__self__, *,
                 day_starts: str,
                 hour_starts: int,
                 month_starts: int):
        GetMonitorSchedulingOptionEvaluationWindowResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            day_starts=day_starts,
            hour_starts=hour_starts,
            month_starts=month_starts,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             day_starts: str,
             hour_starts: int,
             month_starts: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("day_starts", day_starts)
        _setter("hour_starts", hour_starts)
        _setter("month_starts", month_starts)

    @property
    @pulumi.getter(name="dayStarts")
    def day_starts(self) -> str:
        return pulumi.get(self, "day_starts")

    @property
    @pulumi.getter(name="hourStarts")
    def hour_starts(self) -> int:
        return pulumi.get(self, "hour_starts")

    @property
    @pulumi.getter(name="monthStarts")
    def month_starts(self) -> int:
        return pulumi.get(self, "month_starts")


@pulumi.output_type
class GetMonitorsMonitorResult(dict):
    def __init__(__self__, *,
                 id: int,
                 name: str,
                 type: str):
        GetMonitorsMonitorResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: int,
             name: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRolesRoleResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 user_count: int):
        GetRolesRoleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            user_count=user_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             name: str,
             user_count: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("name", name)
        _setter("user_count", user_count)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="userCount")
    def user_count(self) -> int:
        return pulumi.get(self, "user_count")


@pulumi.output_type
class GetSecurityMonitoringFiltersFilterResult(dict):
    def __init__(__self__, *,
                 is_enabled: bool,
                 name: str,
                 query: str,
                 version: int,
                 exclusion_filters: Optional[Sequence['outputs.GetSecurityMonitoringFiltersFilterExclusionFilterResult']] = None,
                 filtered_data_type: Optional[str] = None):
        GetSecurityMonitoringFiltersFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            is_enabled=is_enabled,
            name=name,
            query=query,
            version=version,
            exclusion_filters=exclusion_filters,
            filtered_data_type=filtered_data_type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             is_enabled: bool,
             name: str,
             query: str,
             version: int,
             exclusion_filters: Optional[Sequence['outputs.GetSecurityMonitoringFiltersFilterExclusionFilterResult']] = None,
             filtered_data_type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("is_enabled", is_enabled)
        _setter("name", name)
        _setter("query", query)
        _setter("version", version)
        if exclusion_filters is not None:
            _setter("exclusion_filters", exclusion_filters)
        if filtered_data_type is not None:
            _setter("filtered_data_type", filtered_data_type)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def version(self) -> int:
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[Sequence['outputs.GetSecurityMonitoringFiltersFilterExclusionFilterResult']]:
        return pulumi.get(self, "exclusion_filters")

    @property
    @pulumi.getter(name="filteredDataType")
    def filtered_data_type(self) -> Optional[str]:
        return pulumi.get(self, "filtered_data_type")


@pulumi.output_type
class GetSecurityMonitoringFiltersFilterExclusionFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 query: str):
        GetSecurityMonitoringFiltersFilterExclusionFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: str,
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("query", query)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleResult(dict):
    def __init__(__self__, *,
                 cases: Sequence['outputs.GetSecurityMonitoringRulesRuleCaseResult'],
                 message: str,
                 name: str,
                 enabled: Optional[bool] = None,
                 filters: Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleFilterResult']] = None,
                 has_extended_title: Optional[bool] = None,
                 options: Optional['outputs.GetSecurityMonitoringRulesRuleOptionsResult'] = None,
                 queries: Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleQueryResult']] = None,
                 signal_queries: Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleSignalQueryResult']] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        GetSecurityMonitoringRulesRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            cases=cases,
            message=message,
            name=name,
            enabled=enabled,
            filters=filters,
            has_extended_title=has_extended_title,
            options=options,
            queries=queries,
            signal_queries=signal_queries,
            tags=tags,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             cases: Sequence['outputs.GetSecurityMonitoringRulesRuleCaseResult'],
             message: str,
             name: str,
             enabled: Optional[bool] = None,
             filters: Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleFilterResult']] = None,
             has_extended_title: Optional[bool] = None,
             options: Optional['outputs.GetSecurityMonitoringRulesRuleOptionsResult'] = None,
             queries: Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleQueryResult']] = None,
             signal_queries: Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleSignalQueryResult']] = None,
             tags: Optional[Sequence[str]] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("cases", cases)
        _setter("message", message)
        _setter("name", name)
        if enabled is not None:
            _setter("enabled", enabled)
        if filters is not None:
            _setter("filters", filters)
        if has_extended_title is not None:
            _setter("has_extended_title", has_extended_title)
        if options is not None:
            _setter("options", options)
        if queries is not None:
            _setter("queries", queries)
        if signal_queries is not None:
            _setter("signal_queries", signal_queries)
        if tags is not None:
            _setter("tags", tags)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def cases(self) -> Sequence['outputs.GetSecurityMonitoringRulesRuleCaseResult']:
        return pulumi.get(self, "cases")

    @property
    @pulumi.getter
    def message(self) -> str:
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleFilterResult']]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="hasExtendedTitle")
    def has_extended_title(self) -> Optional[bool]:
        return pulumi.get(self, "has_extended_title")

    @property
    @pulumi.getter
    def options(self) -> Optional['outputs.GetSecurityMonitoringRulesRuleOptionsResult']:
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleQueryResult']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="signalQueries")
    def signal_queries(self) -> Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleSignalQueryResult']]:
        return pulumi.get(self, "signal_queries")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleCaseResult(dict):
    def __init__(__self__, *,
                 status: str,
                 condition: Optional[str] = None,
                 name: Optional[str] = None,
                 notifications: Optional[Sequence[str]] = None):
        GetSecurityMonitoringRulesRuleCaseResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            status=status,
            condition=condition,
            name=name,
            notifications=notifications,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             status: str,
             condition: Optional[str] = None,
             name: Optional[str] = None,
             notifications: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("status", status)
        if condition is not None:
            _setter("condition", condition)
        if name is not None:
            _setter("name", name)
        if notifications is not None:
            _setter("notifications", notifications)

    @property
    @pulumi.getter
    def status(self) -> str:
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def notifications(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "notifications")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleFilterResult(dict):
    def __init__(__self__, *,
                 action: str,
                 query: str):
        GetSecurityMonitoringRulesRuleFilterResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            query=query,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: str,
             query: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("query", query)

    @property
    @pulumi.getter
    def action(self) -> str:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleOptionsResult(dict):
    def __init__(__self__, *,
                 keep_alive: int,
                 max_signal_duration: int,
                 decrease_criticality_based_on_env: Optional[bool] = None,
                 detection_method: Optional[str] = None,
                 evaluation_window: Optional[int] = None,
                 impossible_travel_options: Optional['outputs.GetSecurityMonitoringRulesRuleOptionsImpossibleTravelOptionsResult'] = None,
                 new_value_options: Optional['outputs.GetSecurityMonitoringRulesRuleOptionsNewValueOptionsResult'] = None):
        GetSecurityMonitoringRulesRuleOptionsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            keep_alive=keep_alive,
            max_signal_duration=max_signal_duration,
            decrease_criticality_based_on_env=decrease_criticality_based_on_env,
            detection_method=detection_method,
            evaluation_window=evaluation_window,
            impossible_travel_options=impossible_travel_options,
            new_value_options=new_value_options,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             keep_alive: int,
             max_signal_duration: int,
             decrease_criticality_based_on_env: Optional[bool] = None,
             detection_method: Optional[str] = None,
             evaluation_window: Optional[int] = None,
             impossible_travel_options: Optional['outputs.GetSecurityMonitoringRulesRuleOptionsImpossibleTravelOptionsResult'] = None,
             new_value_options: Optional['outputs.GetSecurityMonitoringRulesRuleOptionsNewValueOptionsResult'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("keep_alive", keep_alive)
        _setter("max_signal_duration", max_signal_duration)
        if decrease_criticality_based_on_env is not None:
            _setter("decrease_criticality_based_on_env", decrease_criticality_based_on_env)
        if detection_method is not None:
            _setter("detection_method", detection_method)
        if evaluation_window is not None:
            _setter("evaluation_window", evaluation_window)
        if impossible_travel_options is not None:
            _setter("impossible_travel_options", impossible_travel_options)
        if new_value_options is not None:
            _setter("new_value_options", new_value_options)

    @property
    @pulumi.getter(name="keepAlive")
    def keep_alive(self) -> int:
        return pulumi.get(self, "keep_alive")

    @property
    @pulumi.getter(name="maxSignalDuration")
    def max_signal_duration(self) -> int:
        return pulumi.get(self, "max_signal_duration")

    @property
    @pulumi.getter(name="decreaseCriticalityBasedOnEnv")
    def decrease_criticality_based_on_env(self) -> Optional[bool]:
        return pulumi.get(self, "decrease_criticality_based_on_env")

    @property
    @pulumi.getter(name="detectionMethod")
    def detection_method(self) -> Optional[str]:
        return pulumi.get(self, "detection_method")

    @property
    @pulumi.getter(name="evaluationWindow")
    def evaluation_window(self) -> Optional[int]:
        return pulumi.get(self, "evaluation_window")

    @property
    @pulumi.getter(name="impossibleTravelOptions")
    def impossible_travel_options(self) -> Optional['outputs.GetSecurityMonitoringRulesRuleOptionsImpossibleTravelOptionsResult']:
        return pulumi.get(self, "impossible_travel_options")

    @property
    @pulumi.getter(name="newValueOptions")
    def new_value_options(self) -> Optional['outputs.GetSecurityMonitoringRulesRuleOptionsNewValueOptionsResult']:
        return pulumi.get(self, "new_value_options")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleOptionsImpossibleTravelOptionsResult(dict):
    def __init__(__self__, *,
                 baseline_user_locations: Optional[bool] = None):
        GetSecurityMonitoringRulesRuleOptionsImpossibleTravelOptionsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            baseline_user_locations=baseline_user_locations,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             baseline_user_locations: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if baseline_user_locations is not None:
            _setter("baseline_user_locations", baseline_user_locations)

    @property
    @pulumi.getter(name="baselineUserLocations")
    def baseline_user_locations(self) -> Optional[bool]:
        return pulumi.get(self, "baseline_user_locations")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleOptionsNewValueOptionsResult(dict):
    def __init__(__self__, *,
                 forget_after: int,
                 learning_duration: Optional[int] = None,
                 learning_method: Optional[str] = None,
                 learning_threshold: Optional[int] = None):
        GetSecurityMonitoringRulesRuleOptionsNewValueOptionsResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            forget_after=forget_after,
            learning_duration=learning_duration,
            learning_method=learning_method,
            learning_threshold=learning_threshold,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             forget_after: int,
             learning_duration: Optional[int] = None,
             learning_method: Optional[str] = None,
             learning_threshold: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("forget_after", forget_after)
        if learning_duration is not None:
            _setter("learning_duration", learning_duration)
        if learning_method is not None:
            _setter("learning_method", learning_method)
        if learning_threshold is not None:
            _setter("learning_threshold", learning_threshold)

    @property
    @pulumi.getter(name="forgetAfter")
    def forget_after(self) -> int:
        return pulumi.get(self, "forget_after")

    @property
    @pulumi.getter(name="learningDuration")
    def learning_duration(self) -> Optional[int]:
        return pulumi.get(self, "learning_duration")

    @property
    @pulumi.getter(name="learningMethod")
    def learning_method(self) -> Optional[str]:
        return pulumi.get(self, "learning_method")

    @property
    @pulumi.getter(name="learningThreshold")
    def learning_threshold(self) -> Optional[int]:
        return pulumi.get(self, "learning_threshold")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleQueryResult(dict):
    def __init__(__self__, *,
                 metrics: Sequence[str],
                 query: str,
                 agent_rules: Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleQueryAgentRuleResult']] = None,
                 aggregation: Optional[str] = None,
                 distinct_fields: Optional[Sequence[str]] = None,
                 group_by_fields: Optional[Sequence[str]] = None,
                 metric: Optional[str] = None,
                 name: Optional[str] = None):
        GetSecurityMonitoringRulesRuleQueryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            metrics=metrics,
            query=query,
            agent_rules=agent_rules,
            aggregation=aggregation,
            distinct_fields=distinct_fields,
            group_by_fields=group_by_fields,
            metric=metric,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             metrics: Sequence[str],
             query: str,
             agent_rules: Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleQueryAgentRuleResult']] = None,
             aggregation: Optional[str] = None,
             distinct_fields: Optional[Sequence[str]] = None,
             group_by_fields: Optional[Sequence[str]] = None,
             metric: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("metrics", metrics)
        _setter("query", query)
        if agent_rules is not None:
            _setter("agent_rules", agent_rules)
        if aggregation is not None:
            _setter("aggregation", aggregation)
        if distinct_fields is not None:
            _setter("distinct_fields", distinct_fields)
        if group_by_fields is not None:
            _setter("group_by_fields", group_by_fields)
        if metric is not None:
            _setter("metric", metric)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter
    def metrics(self) -> Sequence[str]:
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="agentRules")
    def agent_rules(self) -> Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleQueryAgentRuleResult']]:
        warnings.warn("""`agent_rule` has been deprecated in favor of new Agent Rule resource.""", DeprecationWarning)
        pulumi.log.warn("""agent_rules is deprecated: `agent_rule` has been deprecated in favor of new Agent Rule resource.""")

        return pulumi.get(self, "agent_rules")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="distinctFields")
    def distinct_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "distinct_fields")

    @property
    @pulumi.getter(name="groupByFields")
    def group_by_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "group_by_fields")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        warnings.warn("""Configure `metrics` instead. This attribute will be removed in the next major version of the provider.""", DeprecationWarning)
        pulumi.log.warn("""metric is deprecated: Configure `metrics` instead. This attribute will be removed in the next major version of the provider.""")

        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleQueryAgentRuleResult(dict):
    def __init__(__self__, *,
                 agent_rule_id: str,
                 expression: str):
        GetSecurityMonitoringRulesRuleQueryAgentRuleResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            agent_rule_id=agent_rule_id,
            expression=expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             agent_rule_id: str,
             expression: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("agent_rule_id", agent_rule_id)
        _setter("expression", expression)

    @property
    @pulumi.getter(name="agentRuleId")
    def agent_rule_id(self) -> str:
        return pulumi.get(self, "agent_rule_id")

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleSignalQueryResult(dict):
    def __init__(__self__, *,
                 rule_id: str,
                 aggregation: Optional[str] = None,
                 correlated_by_fields: Optional[Sequence[str]] = None,
                 correlated_query_index: Optional[str] = None,
                 default_rule_id: Optional[str] = None,
                 name: Optional[str] = None):
        GetSecurityMonitoringRulesRuleSignalQueryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rule_id=rule_id,
            aggregation=aggregation,
            correlated_by_fields=correlated_by_fields,
            correlated_query_index=correlated_query_index,
            default_rule_id=default_rule_id,
            name=name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rule_id: str,
             aggregation: Optional[str] = None,
             correlated_by_fields: Optional[Sequence[str]] = None,
             correlated_query_index: Optional[str] = None,
             default_rule_id: Optional[str] = None,
             name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("rule_id", rule_id)
        if aggregation is not None:
            _setter("aggregation", aggregation)
        if correlated_by_fields is not None:
            _setter("correlated_by_fields", correlated_by_fields)
        if correlated_query_index is not None:
            _setter("correlated_query_index", correlated_query_index)
        if default_rule_id is not None:
            _setter("default_rule_id", default_rule_id)
        if name is not None:
            _setter("name", name)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> str:
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="correlatedByFields")
    def correlated_by_fields(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "correlated_by_fields")

    @property
    @pulumi.getter(name="correlatedQueryIndex")
    def correlated_query_index(self) -> Optional[str]:
        return pulumi.get(self, "correlated_query_index")

    @property
    @pulumi.getter(name="defaultRuleId")
    def default_rule_id(self) -> Optional[str]:
        return pulumi.get(self, "default_rule_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetServiceLevelObjectiveQueryResult(dict):
    def __init__(__self__, *,
                 denominator: str,
                 numerator: str):
        GetServiceLevelObjectiveQueryResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            denominator=denominator,
            numerator=numerator,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             denominator: str,
             numerator: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("denominator", denominator)
        _setter("numerator", numerator)

    @property
    @pulumi.getter
    def denominator(self) -> str:
        return pulumi.get(self, "denominator")

    @property
    @pulumi.getter
    def numerator(self) -> str:
        return pulumi.get(self, "numerator")


@pulumi.output_type
class GetServiceLevelObjectivesSloResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 type: str):
        GetServiceLevelObjectivesSloResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             name: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("name", name)
        _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetTeamMembershipsTeamMembershipResult(dict):
    def __init__(__self__, *,
                 id: str,
                 role: str,
                 team_id: str,
                 user_id: str):
        GetTeamMembershipsTeamMembershipResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            role=role,
            team_id=team_id,
            user_id=user_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             role: str,
             team_id: str,
             user_id: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("role", role)
        _setter("team_id", team_id)
        _setter("user_id", user_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def role(self) -> str:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        return pulumi.get(self, "user_id")



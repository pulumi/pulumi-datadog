# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'ApmRetentionFilterFilter',
    'ChildOrganizationApiKey',
    'ChildOrganizationApplicationKey',
    'ChildOrganizationSetting',
    'ChildOrganizationSettingSaml',
    'ChildOrganizationSettingSamlAutocreateUsersDomain',
    'ChildOrganizationSettingSamlIdpInitiatedLogin',
    'ChildOrganizationSettingSamlStrictMode',
    'ChildOrganizationUser',
    'CloudConfigurationRuleFilter',
    'DashboardListDashItem',
    'DashboardTemplateVariable',
    'DashboardTemplateVariablePreset',
    'DashboardTemplateVariablePresetTemplateVariable',
    'DashboardWidget',
    'DashboardWidgetAlertGraphDefinition',
    'DashboardWidgetAlertValueDefinition',
    'DashboardWidgetApmQuery',
    'DashboardWidgetApmQueryComputeQuery',
    'DashboardWidgetApmQueryGroupBy',
    'DashboardWidgetApmQueryGroupBySortQuery',
    'DashboardWidgetApmQueryMultiCompute',
    'DashboardWidgetChangeDefinition',
    'DashboardWidgetChangeDefinitionCustomLink',
    'DashboardWidgetChangeDefinitionRequest',
    'DashboardWidgetChangeDefinitionRequestFormula',
    'DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetChangeDefinitionRequestFormulaLimit',
    'DashboardWidgetChangeDefinitionRequestFormulaStyle',
    'DashboardWidgetChangeDefinitionRequestProcessQuery',
    'DashboardWidgetChangeDefinitionRequestQuery',
    'DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetChangeDefinitionRequestQueryCloudCostQuery',
    'DashboardWidgetChangeDefinitionRequestQueryEventQuery',
    'DashboardWidgetChangeDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetChangeDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetChangeDefinitionRequestQueryMetricQuery',
    'DashboardWidgetChangeDefinitionRequestQueryProcessQuery',
    'DashboardWidgetChangeDefinitionRequestQuerySloQuery',
    'DashboardWidgetCheckStatusDefinition',
    'DashboardWidgetDistributionDefinition',
    'DashboardWidgetDistributionDefinitionRequest',
    'DashboardWidgetDistributionDefinitionRequestApmStatsQuery',
    'DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn',
    'DashboardWidgetDistributionDefinitionRequestProcessQuery',
    'DashboardWidgetDistributionDefinitionRequestStyle',
    'DashboardWidgetDistributionDefinitionXaxis',
    'DashboardWidgetDistributionDefinitionYaxis',
    'DashboardWidgetEventStreamDefinition',
    'DashboardWidgetEventTimelineDefinition',
    'DashboardWidgetFreeTextDefinition',
    'DashboardWidgetGeomapDefinition',
    'DashboardWidgetGeomapDefinitionCustomLink',
    'DashboardWidgetGeomapDefinitionRequest',
    'DashboardWidgetGeomapDefinitionRequestFormula',
    'DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetGeomapDefinitionRequestFormulaLimit',
    'DashboardWidgetGeomapDefinitionRequestFormulaStyle',
    'DashboardWidgetGeomapDefinitionRequestQuery',
    'DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetGeomapDefinitionRequestQueryCloudCostQuery',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQuery',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetGeomapDefinitionRequestQueryMetricQuery',
    'DashboardWidgetGeomapDefinitionRequestQueryProcessQuery',
    'DashboardWidgetGeomapDefinitionRequestQuerySloQuery',
    'DashboardWidgetGeomapDefinitionStyle',
    'DashboardWidgetGeomapDefinitionView',
    'DashboardWidgetGroupDefinition',
    'DashboardWidgetGroupDefinitionWidget',
    'DashboardWidgetGroupDefinitionWidgetWidgetLayout',
    'DashboardWidgetHeatmapDefinition',
    'DashboardWidgetHeatmapDefinitionCustomLink',
    'DashboardWidgetHeatmapDefinitionEvent',
    'DashboardWidgetHeatmapDefinitionRequest',
    'DashboardWidgetHeatmapDefinitionRequestFormula',
    'DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetHeatmapDefinitionRequestFormulaLimit',
    'DashboardWidgetHeatmapDefinitionRequestFormulaStyle',
    'DashboardWidgetHeatmapDefinitionRequestProcessQuery',
    'DashboardWidgetHeatmapDefinitionRequestQuery',
    'DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQuery',
    'DashboardWidgetHeatmapDefinitionRequestQueryEventQuery',
    'DashboardWidgetHeatmapDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetHeatmapDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetHeatmapDefinitionRequestQueryMetricQuery',
    'DashboardWidgetHeatmapDefinitionRequestQueryProcessQuery',
    'DashboardWidgetHeatmapDefinitionRequestQuerySloQuery',
    'DashboardWidgetHeatmapDefinitionRequestStyle',
    'DashboardWidgetHeatmapDefinitionYaxis',
    'DashboardWidgetHostmapDefinition',
    'DashboardWidgetHostmapDefinitionCustomLink',
    'DashboardWidgetHostmapDefinitionRequest',
    'DashboardWidgetHostmapDefinitionRequestFill',
    'DashboardWidgetHostmapDefinitionRequestFillProcessQuery',
    'DashboardWidgetHostmapDefinitionRequestSize',
    'DashboardWidgetHostmapDefinitionRequestSizeProcessQuery',
    'DashboardWidgetHostmapDefinitionStyle',
    'DashboardWidgetIframeDefinition',
    'DashboardWidgetImageDefinition',
    'DashboardWidgetListStreamDefinition',
    'DashboardWidgetListStreamDefinitionRequest',
    'DashboardWidgetListStreamDefinitionRequestColumn',
    'DashboardWidgetListStreamDefinitionRequestQuery',
    'DashboardWidgetListStreamDefinitionRequestQuerySort',
    'DashboardWidgetLogQuery',
    'DashboardWidgetLogQueryComputeQuery',
    'DashboardWidgetLogQueryGroupBy',
    'DashboardWidgetLogQueryGroupBySortQuery',
    'DashboardWidgetLogQueryMultiCompute',
    'DashboardWidgetLogStreamDefinition',
    'DashboardWidgetLogStreamDefinitionSort',
    'DashboardWidgetManageStatusDefinition',
    'DashboardWidgetNoteDefinition',
    'DashboardWidgetPowerpackDefinition',
    'DashboardWidgetPowerpackDefinitionTemplateVariables',
    'DashboardWidgetPowerpackDefinitionTemplateVariablesControlledByPowerpack',
    'DashboardWidgetPowerpackDefinitionTemplateVariablesControlledExternally',
    'DashboardWidgetQueryTableDefinition',
    'DashboardWidgetQueryTableDefinitionCustomLink',
    'DashboardWidgetQueryTableDefinitionRequest',
    'DashboardWidgetQueryTableDefinitionRequestApmStatsQuery',
    'DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn',
    'DashboardWidgetQueryTableDefinitionRequestConditionalFormat',
    'DashboardWidgetQueryTableDefinitionRequestFormula',
    'DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetQueryTableDefinitionRequestFormulaLimit',
    'DashboardWidgetQueryTableDefinitionRequestFormulaStyle',
    'DashboardWidgetQueryTableDefinitionRequestProcessQuery',
    'DashboardWidgetQueryTableDefinitionRequestQuery',
    'DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQuery',
    'DashboardWidgetQueryTableDefinitionRequestQueryEventQuery',
    'DashboardWidgetQueryTableDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery',
    'DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery',
    'DashboardWidgetQueryTableDefinitionRequestQuerySloQuery',
    'DashboardWidgetQueryTableDefinitionRequestTextFormat',
    'DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormat',
    'DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormatMatch',
    'DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormatReplace',
    'DashboardWidgetQueryValueDefinition',
    'DashboardWidgetQueryValueDefinitionCustomLink',
    'DashboardWidgetQueryValueDefinitionRequest',
    'DashboardWidgetQueryValueDefinitionRequestAuditQuery',
    'DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQuery',
    'DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy',
    'DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery',
    'DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiCompute',
    'DashboardWidgetQueryValueDefinitionRequestConditionalFormat',
    'DashboardWidgetQueryValueDefinitionRequestFormula',
    'DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetQueryValueDefinitionRequestFormulaLimit',
    'DashboardWidgetQueryValueDefinitionRequestFormulaStyle',
    'DashboardWidgetQueryValueDefinitionRequestProcessQuery',
    'DashboardWidgetQueryValueDefinitionRequestQuery',
    'DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQuery',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQuery',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery',
    'DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery',
    'DashboardWidgetQueryValueDefinitionRequestQuerySloQuery',
    'DashboardWidgetQueryValueDefinitionTimeseriesBackground',
    'DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis',
    'DashboardWidgetRumQuery',
    'DashboardWidgetRumQueryComputeQuery',
    'DashboardWidgetRumQueryGroupBy',
    'DashboardWidgetRumQueryGroupBySortQuery',
    'DashboardWidgetRumQueryMultiCompute',
    'DashboardWidgetRunWorkflowDefinition',
    'DashboardWidgetRunWorkflowDefinitionCustomLink',
    'DashboardWidgetRunWorkflowDefinitionInput',
    'DashboardWidgetScatterplotDefinition',
    'DashboardWidgetScatterplotDefinitionCustomLink',
    'DashboardWidgetScatterplotDefinitionRequest',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTable',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery',
    'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery',
    'DashboardWidgetScatterplotDefinitionRequestX',
    'DashboardWidgetScatterplotDefinitionRequestXProcessQuery',
    'DashboardWidgetScatterplotDefinitionRequestY',
    'DashboardWidgetScatterplotDefinitionRequestYProcessQuery',
    'DashboardWidgetScatterplotDefinitionXaxis',
    'DashboardWidgetScatterplotDefinitionYaxis',
    'DashboardWidgetSecurityQuery',
    'DashboardWidgetSecurityQueryComputeQuery',
    'DashboardWidgetSecurityQueryGroupBy',
    'DashboardWidgetSecurityQueryGroupBySortQuery',
    'DashboardWidgetSecurityQueryMultiCompute',
    'DashboardWidgetServiceLevelObjectiveDefinition',
    'DashboardWidgetServicemapDefinition',
    'DashboardWidgetServicemapDefinitionCustomLink',
    'DashboardWidgetSloListDefinition',
    'DashboardWidgetSloListDefinitionRequest',
    'DashboardWidgetSloListDefinitionRequestQuery',
    'DashboardWidgetSloListDefinitionRequestQuerySort',
    'DashboardWidgetSplitGraphDefinition',
    'DashboardWidgetSplitGraphDefinitionSourceWidgetDefinition',
    'DashboardWidgetSplitGraphDefinitionSplitConfig',
    'DashboardWidgetSplitGraphDefinitionSplitConfigSort',
    'DashboardWidgetSplitGraphDefinitionSplitConfigSortCompute',
    'DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensions',
    'DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplit',
    'DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVector',
    'DashboardWidgetSunburstDefinition',
    'DashboardWidgetSunburstDefinitionCustomLink',
    'DashboardWidgetSunburstDefinitionLegendInline',
    'DashboardWidgetSunburstDefinitionLegendTable',
    'DashboardWidgetSunburstDefinitionRequest',
    'DashboardWidgetSunburstDefinitionRequestAuditQuery',
    'DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQuery',
    'DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy',
    'DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery',
    'DashboardWidgetSunburstDefinitionRequestAuditQueryMultiCompute',
    'DashboardWidgetSunburstDefinitionRequestFormula',
    'DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetSunburstDefinitionRequestFormulaLimit',
    'DashboardWidgetSunburstDefinitionRequestFormulaStyle',
    'DashboardWidgetSunburstDefinitionRequestNetworkQuery',
    'DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQuery',
    'DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy',
    'DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery',
    'DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiCompute',
    'DashboardWidgetSunburstDefinitionRequestProcessQuery',
    'DashboardWidgetSunburstDefinitionRequestQuery',
    'DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetSunburstDefinitionRequestQueryCloudCostQuery',
    'DashboardWidgetSunburstDefinitionRequestQueryEventQuery',
    'DashboardWidgetSunburstDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetSunburstDefinitionRequestQueryMetricQuery',
    'DashboardWidgetSunburstDefinitionRequestQueryProcessQuery',
    'DashboardWidgetSunburstDefinitionRequestQuerySloQuery',
    'DashboardWidgetSunburstDefinitionRequestStyle',
    'DashboardWidgetTimeseriesDefinition',
    'DashboardWidgetTimeseriesDefinitionCustomLink',
    'DashboardWidgetTimeseriesDefinitionEvent',
    'DashboardWidgetTimeseriesDefinitionMarker',
    'DashboardWidgetTimeseriesDefinitionRequest',
    'DashboardWidgetTimeseriesDefinitionRequestAuditQuery',
    'DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery',
    'DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery',
    'DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute',
    'DashboardWidgetTimeseriesDefinitionRequestFormula',
    'DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetTimeseriesDefinitionRequestFormulaLimit',
    'DashboardWidgetTimeseriesDefinitionRequestFormulaStyle',
    'DashboardWidgetTimeseriesDefinitionRequestMetadata',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQuery',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery',
    'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute',
    'DashboardWidgetTimeseriesDefinitionRequestProcessQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery',
    'DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery',
    'DashboardWidgetTimeseriesDefinitionRequestStyle',
    'DashboardWidgetTimeseriesDefinitionRightYaxis',
    'DashboardWidgetTimeseriesDefinitionYaxis',
    'DashboardWidgetToplistDefinition',
    'DashboardWidgetToplistDefinitionCustomLink',
    'DashboardWidgetToplistDefinitionRequest',
    'DashboardWidgetToplistDefinitionRequestAuditQuery',
    'DashboardWidgetToplistDefinitionRequestAuditQueryComputeQuery',
    'DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy',
    'DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery',
    'DashboardWidgetToplistDefinitionRequestAuditQueryMultiCompute',
    'DashboardWidgetToplistDefinitionRequestConditionalFormat',
    'DashboardWidgetToplistDefinitionRequestFormula',
    'DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetToplistDefinitionRequestFormulaLimit',
    'DashboardWidgetToplistDefinitionRequestFormulaStyle',
    'DashboardWidgetToplistDefinitionRequestProcessQuery',
    'DashboardWidgetToplistDefinitionRequestQuery',
    'DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetToplistDefinitionRequestQueryCloudCostQuery',
    'DashboardWidgetToplistDefinitionRequestQueryEventQuery',
    'DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetToplistDefinitionRequestQueryMetricQuery',
    'DashboardWidgetToplistDefinitionRequestQueryProcessQuery',
    'DashboardWidgetToplistDefinitionRequestQuerySloQuery',
    'DashboardWidgetToplistDefinitionRequestStyle',
    'DashboardWidgetToplistDefinitionStyle',
    'DashboardWidgetToplistDefinitionStyleDisplay',
    'DashboardWidgetTopologyMapDefinition',
    'DashboardWidgetTopologyMapDefinitionCustomLink',
    'DashboardWidgetTopologyMapDefinitionRequest',
    'DashboardWidgetTopologyMapDefinitionRequestQuery',
    'DashboardWidgetTraceServiceDefinition',
    'DashboardWidgetTreemapDefinition',
    'DashboardWidgetTreemapDefinitionRequest',
    'DashboardWidgetTreemapDefinitionRequestFormula',
    'DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat',
    'DashboardWidgetTreemapDefinitionRequestFormulaLimit',
    'DashboardWidgetTreemapDefinitionRequestFormulaStyle',
    'DashboardWidgetTreemapDefinitionRequestQuery',
    'DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery',
    'DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery',
    'DashboardWidgetTreemapDefinitionRequestQueryCloudCostQuery',
    'DashboardWidgetTreemapDefinitionRequestQueryEventQuery',
    'DashboardWidgetTreemapDefinitionRequestQueryEventQueryCompute',
    'DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBy',
    'DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort',
    'DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearch',
    'DashboardWidgetTreemapDefinitionRequestQueryMetricQuery',
    'DashboardWidgetTreemapDefinitionRequestQueryProcessQuery',
    'DashboardWidgetTreemapDefinitionRequestQuerySloQuery',
    'DashboardWidgetWidgetLayout',
    'DowntimeRecurrence',
    'DowntimeScheduleMonitorIdentifier',
    'DowntimeScheduleOneTimeSchedule',
    'DowntimeScheduleRecurringSchedule',
    'DowntimeScheduleRecurringScheduleRecurrence',
    'IpAllowlistEntry',
    'LogsArchiveAzureArchive',
    'LogsArchiveGcsArchive',
    'LogsArchiveS3Archive',
    'LogsCustomDestinationElasticsearchDestination',
    'LogsCustomDestinationElasticsearchDestinationBasicAuth',
    'LogsCustomDestinationHttpDestination',
    'LogsCustomDestinationHttpDestinationBasicAuth',
    'LogsCustomDestinationHttpDestinationCustomHeaderAuth',
    'LogsCustomDestinationSplunkDestination',
    'LogsCustomPipelineFilter',
    'LogsCustomPipelineProcessor',
    'LogsCustomPipelineProcessorArithmeticProcessor',
    'LogsCustomPipelineProcessorAttributeRemapper',
    'LogsCustomPipelineProcessorCategoryProcessor',
    'LogsCustomPipelineProcessorCategoryProcessorCategory',
    'LogsCustomPipelineProcessorCategoryProcessorCategoryFilter',
    'LogsCustomPipelineProcessorDateRemapper',
    'LogsCustomPipelineProcessorGeoIpParser',
    'LogsCustomPipelineProcessorGrokParser',
    'LogsCustomPipelineProcessorGrokParserGrok',
    'LogsCustomPipelineProcessorLookupProcessor',
    'LogsCustomPipelineProcessorMessageRemapper',
    'LogsCustomPipelineProcessorPipeline',
    'LogsCustomPipelineProcessorPipelineFilter',
    'LogsCustomPipelineProcessorPipelineProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory',
    'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter',
    'LogsCustomPipelineProcessorPipelineProcessorDateRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorGeoIpParser',
    'LogsCustomPipelineProcessorPipelineProcessorGrokParser',
    'LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok',
    'LogsCustomPipelineProcessorPipelineProcessorLookupProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorMessageRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorServiceRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorStatusRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor',
    'LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper',
    'LogsCustomPipelineProcessorPipelineProcessorUrlParser',
    'LogsCustomPipelineProcessorPipelineProcessorUserAgentParser',
    'LogsCustomPipelineProcessorReferenceTableLookupProcessor',
    'LogsCustomPipelineProcessorServiceRemapper',
    'LogsCustomPipelineProcessorStatusRemapper',
    'LogsCustomPipelineProcessorStringBuilderProcessor',
    'LogsCustomPipelineProcessorTraceIdRemapper',
    'LogsCustomPipelineProcessorUrlParser',
    'LogsCustomPipelineProcessorUserAgentParser',
    'LogsIndexDailyLimitReset',
    'LogsIndexExclusionFilter',
    'LogsIndexExclusionFilterFilter',
    'LogsIndexFilter',
    'LogsMetricCompute',
    'LogsMetricFilter',
    'LogsMetricGroupBy',
    'MetricTagConfigurationAggregation',
    'MonitorConfigPolicyTagPolicy',
    'MonitorMonitorThresholdWindows',
    'MonitorMonitorThresholds',
    'MonitorSchedulingOption',
    'MonitorSchedulingOptionCustomSchedule',
    'MonitorSchedulingOptionCustomScheduleRecurrence',
    'MonitorSchedulingOptionEvaluationWindow',
    'MonitorVariables',
    'MonitorVariablesEventQuery',
    'MonitorVariablesEventQueryCompute',
    'MonitorVariablesEventQueryGroupBy',
    'MonitorVariablesEventQueryGroupBySort',
    'MonitorVariablesEventQuerySearch',
    'OrganizationSettingsSettings',
    'OrganizationSettingsSettingsSaml',
    'OrganizationSettingsSettingsSamlAutocreateUsersDomains',
    'OrganizationSettingsSettingsSamlIdpInitiatedLogin',
    'OrganizationSettingsSettingsSamlStrictMode',
    'PowerpackLayout',
    'PowerpackTemplateVariable',
    'PowerpackWidget',
    'PowerpackWidgetAlertGraphDefinition',
    'PowerpackWidgetAlertValueDefinition',
    'PowerpackWidgetChangeDefinition',
    'PowerpackWidgetChangeDefinitionCustomLink',
    'PowerpackWidgetChangeDefinitionRequest',
    'PowerpackWidgetChangeDefinitionRequestApmQuery',
    'PowerpackWidgetChangeDefinitionRequestApmQueryComputeQuery',
    'PowerpackWidgetChangeDefinitionRequestApmQueryGroupBy',
    'PowerpackWidgetChangeDefinitionRequestApmQueryGroupBySortQuery',
    'PowerpackWidgetChangeDefinitionRequestApmQueryMultiCompute',
    'PowerpackWidgetChangeDefinitionRequestFormula',
    'PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormat',
    'PowerpackWidgetChangeDefinitionRequestFormulaLimit',
    'PowerpackWidgetChangeDefinitionRequestFormulaStyle',
    'PowerpackWidgetChangeDefinitionRequestLogQuery',
    'PowerpackWidgetChangeDefinitionRequestLogQueryComputeQuery',
    'PowerpackWidgetChangeDefinitionRequestLogQueryGroupBy',
    'PowerpackWidgetChangeDefinitionRequestLogQueryGroupBySortQuery',
    'PowerpackWidgetChangeDefinitionRequestLogQueryMultiCompute',
    'PowerpackWidgetChangeDefinitionRequestProcessQuery',
    'PowerpackWidgetChangeDefinitionRequestQuery',
    'PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery',
    'PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQuery',
    'PowerpackWidgetChangeDefinitionRequestQueryCloudCostQuery',
    'PowerpackWidgetChangeDefinitionRequestQueryEventQuery',
    'PowerpackWidgetChangeDefinitionRequestQueryEventQueryCompute',
    'PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBy',
    'PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBySort',
    'PowerpackWidgetChangeDefinitionRequestQueryEventQuerySearch',
    'PowerpackWidgetChangeDefinitionRequestQueryMetricQuery',
    'PowerpackWidgetChangeDefinitionRequestQueryProcessQuery',
    'PowerpackWidgetChangeDefinitionRequestQuerySloQuery',
    'PowerpackWidgetChangeDefinitionRequestRumQuery',
    'PowerpackWidgetChangeDefinitionRequestRumQueryComputeQuery',
    'PowerpackWidgetChangeDefinitionRequestRumQueryGroupBy',
    'PowerpackWidgetChangeDefinitionRequestRumQueryGroupBySortQuery',
    'PowerpackWidgetChangeDefinitionRequestRumQueryMultiCompute',
    'PowerpackWidgetChangeDefinitionRequestSecurityQuery',
    'PowerpackWidgetChangeDefinitionRequestSecurityQueryComputeQuery',
    'PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBy',
    'PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery',
    'PowerpackWidgetChangeDefinitionRequestSecurityQueryMultiCompute',
    'PowerpackWidgetCheckStatusDefinition',
    'PowerpackWidgetDistributionDefinition',
    'PowerpackWidgetDistributionDefinitionRequest',
    'PowerpackWidgetDistributionDefinitionRequestApmQuery',
    'PowerpackWidgetDistributionDefinitionRequestApmQueryComputeQuery',
    'PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBy',
    'PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery',
    'PowerpackWidgetDistributionDefinitionRequestApmQueryMultiCompute',
    'PowerpackWidgetDistributionDefinitionRequestApmStatsQuery',
    'PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumn',
    'PowerpackWidgetDistributionDefinitionRequestLogQuery',
    'PowerpackWidgetDistributionDefinitionRequestLogQueryComputeQuery',
    'PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBy',
    'PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery',
    'PowerpackWidgetDistributionDefinitionRequestLogQueryMultiCompute',
    'PowerpackWidgetDistributionDefinitionRequestProcessQuery',
    'PowerpackWidgetDistributionDefinitionRequestRumQuery',
    'PowerpackWidgetDistributionDefinitionRequestRumQueryComputeQuery',
    'PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBy',
    'PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery',
    'PowerpackWidgetDistributionDefinitionRequestRumQueryMultiCompute',
    'PowerpackWidgetDistributionDefinitionRequestSecurityQuery',
    'PowerpackWidgetDistributionDefinitionRequestSecurityQueryComputeQuery',
    'PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBy',
    'PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery',
    'PowerpackWidgetDistributionDefinitionRequestSecurityQueryMultiCompute',
    'PowerpackWidgetDistributionDefinitionRequestStyle',
    'PowerpackWidgetDistributionDefinitionXaxis',
    'PowerpackWidgetDistributionDefinitionYaxis',
    'PowerpackWidgetEventStreamDefinition',
    'PowerpackWidgetEventTimelineDefinition',
    'PowerpackWidgetFreeTextDefinition',
    'PowerpackWidgetGeomapDefinition',
    'PowerpackWidgetGeomapDefinitionCustomLink',
    'PowerpackWidgetGeomapDefinitionRequest',
    'PowerpackWidgetGeomapDefinitionRequestFormula',
    'PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormat',
    'PowerpackWidgetGeomapDefinitionRequestFormulaLimit',
    'PowerpackWidgetGeomapDefinitionRequestFormulaStyle',
    'PowerpackWidgetGeomapDefinitionRequestLogQuery',
    'PowerpackWidgetGeomapDefinitionRequestLogQueryComputeQuery',
    'PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBy',
    'PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery',
    'PowerpackWidgetGeomapDefinitionRequestLogQueryMultiCompute',
    'PowerpackWidgetGeomapDefinitionRequestQuery',
    'PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery',
    'PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery',
    'PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQuery',
    'PowerpackWidgetGeomapDefinitionRequestQueryEventQuery',
    'PowerpackWidgetGeomapDefinitionRequestQueryEventQueryCompute',
    'PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBy',
    'PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort',
    'PowerpackWidgetGeomapDefinitionRequestQueryEventQuerySearch',
    'PowerpackWidgetGeomapDefinitionRequestQueryMetricQuery',
    'PowerpackWidgetGeomapDefinitionRequestQueryProcessQuery',
    'PowerpackWidgetGeomapDefinitionRequestQuerySloQuery',
    'PowerpackWidgetGeomapDefinitionRequestRumQuery',
    'PowerpackWidgetGeomapDefinitionRequestRumQueryComputeQuery',
    'PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBy',
    'PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery',
    'PowerpackWidgetGeomapDefinitionRequestRumQueryMultiCompute',
    'PowerpackWidgetGeomapDefinitionStyle',
    'PowerpackWidgetGeomapDefinitionView',
    'PowerpackWidgetHeatmapDefinition',
    'PowerpackWidgetHeatmapDefinitionCustomLink',
    'PowerpackWidgetHeatmapDefinitionEvent',
    'PowerpackWidgetHeatmapDefinitionRequest',
    'PowerpackWidgetHeatmapDefinitionRequestApmQuery',
    'PowerpackWidgetHeatmapDefinitionRequestApmQueryComputeQuery',
    'PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBy',
    'PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery',
    'PowerpackWidgetHeatmapDefinitionRequestApmQueryMultiCompute',
    'PowerpackWidgetHeatmapDefinitionRequestFormula',
    'PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormat',
    'PowerpackWidgetHeatmapDefinitionRequestFormulaLimit',
    'PowerpackWidgetHeatmapDefinitionRequestFormulaStyle',
    'PowerpackWidgetHeatmapDefinitionRequestLogQuery',
    'PowerpackWidgetHeatmapDefinitionRequestLogQueryComputeQuery',
    'PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBy',
    'PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery',
    'PowerpackWidgetHeatmapDefinitionRequestLogQueryMultiCompute',
    'PowerpackWidgetHeatmapDefinitionRequestProcessQuery',
    'PowerpackWidgetHeatmapDefinitionRequestQuery',
    'PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery',
    'PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery',
    'PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQuery',
    'PowerpackWidgetHeatmapDefinitionRequestQueryEventQuery',
    'PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryCompute',
    'PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy',
    'PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort',
    'PowerpackWidgetHeatmapDefinitionRequestQueryEventQuerySearch',
    'PowerpackWidgetHeatmapDefinitionRequestQueryMetricQuery',
    'PowerpackWidgetHeatmapDefinitionRequestQueryProcessQuery',
    'PowerpackWidgetHeatmapDefinitionRequestQuerySloQuery',
    'PowerpackWidgetHeatmapDefinitionRequestRumQuery',
    'PowerpackWidgetHeatmapDefinitionRequestRumQueryComputeQuery',
    'PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBy',
    'PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery',
    'PowerpackWidgetHeatmapDefinitionRequestRumQueryMultiCompute',
    'PowerpackWidgetHeatmapDefinitionRequestSecurityQuery',
    'PowerpackWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery',
    'PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBy',
    'PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery',
    'PowerpackWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute',
    'PowerpackWidgetHeatmapDefinitionRequestStyle',
    'PowerpackWidgetHeatmapDefinitionYaxis',
    'PowerpackWidgetHostmapDefinition',
    'PowerpackWidgetHostmapDefinitionCustomLink',
    'PowerpackWidgetHostmapDefinitionRequest',
    'PowerpackWidgetHostmapDefinitionRequestFill',
    'PowerpackWidgetHostmapDefinitionRequestFillApmQuery',
    'PowerpackWidgetHostmapDefinitionRequestFillApmQueryComputeQuery',
    'PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBy',
    'PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery',
    'PowerpackWidgetHostmapDefinitionRequestFillApmQueryMultiCompute',
    'PowerpackWidgetHostmapDefinitionRequestFillLogQuery',
    'PowerpackWidgetHostmapDefinitionRequestFillLogQueryComputeQuery',
    'PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBy',
    'PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery',
    'PowerpackWidgetHostmapDefinitionRequestFillLogQueryMultiCompute',
    'PowerpackWidgetHostmapDefinitionRequestFillProcessQuery',
    'PowerpackWidgetHostmapDefinitionRequestFillRumQuery',
    'PowerpackWidgetHostmapDefinitionRequestFillRumQueryComputeQuery',
    'PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBy',
    'PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery',
    'PowerpackWidgetHostmapDefinitionRequestFillRumQueryMultiCompute',
    'PowerpackWidgetHostmapDefinitionRequestFillSecurityQuery',
    'PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery',
    'PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy',
    'PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery',
    'PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute',
    'PowerpackWidgetHostmapDefinitionRequestSize',
    'PowerpackWidgetHostmapDefinitionRequestSizeApmQuery',
    'PowerpackWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery',
    'PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBy',
    'PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery',
    'PowerpackWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute',
    'PowerpackWidgetHostmapDefinitionRequestSizeLogQuery',
    'PowerpackWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery',
    'PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBy',
    'PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery',
    'PowerpackWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute',
    'PowerpackWidgetHostmapDefinitionRequestSizeProcessQuery',
    'PowerpackWidgetHostmapDefinitionRequestSizeRumQuery',
    'PowerpackWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery',
    'PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBy',
    'PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery',
    'PowerpackWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute',
    'PowerpackWidgetHostmapDefinitionRequestSizeSecurityQuery',
    'PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery',
    'PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy',
    'PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery',
    'PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute',
    'PowerpackWidgetHostmapDefinitionStyle',
    'PowerpackWidgetIframeDefinition',
    'PowerpackWidgetImageDefinition',
    'PowerpackWidgetListStreamDefinition',
    'PowerpackWidgetListStreamDefinitionRequest',
    'PowerpackWidgetListStreamDefinitionRequestColumn',
    'PowerpackWidgetListStreamDefinitionRequestQuery',
    'PowerpackWidgetListStreamDefinitionRequestQuerySort',
    'PowerpackWidgetLogStreamDefinition',
    'PowerpackWidgetLogStreamDefinitionSort',
    'PowerpackWidgetManageStatusDefinition',
    'PowerpackWidgetNoteDefinition',
    'PowerpackWidgetQueryTableDefinition',
    'PowerpackWidgetQueryTableDefinitionCustomLink',
    'PowerpackWidgetQueryTableDefinitionRequest',
    'PowerpackWidgetQueryTableDefinitionRequestApmQuery',
    'PowerpackWidgetQueryTableDefinitionRequestApmQueryComputeQuery',
    'PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBy',
    'PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery',
    'PowerpackWidgetQueryTableDefinitionRequestApmQueryMultiCompute',
    'PowerpackWidgetQueryTableDefinitionRequestApmStatsQuery',
    'PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumn',
    'PowerpackWidgetQueryTableDefinitionRequestConditionalFormat',
    'PowerpackWidgetQueryTableDefinitionRequestFormula',
    'PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormat',
    'PowerpackWidgetQueryTableDefinitionRequestFormulaLimit',
    'PowerpackWidgetQueryTableDefinitionRequestFormulaStyle',
    'PowerpackWidgetQueryTableDefinitionRequestLogQuery',
    'PowerpackWidgetQueryTableDefinitionRequestLogQueryComputeQuery',
    'PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBy',
    'PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery',
    'PowerpackWidgetQueryTableDefinitionRequestLogQueryMultiCompute',
    'PowerpackWidgetQueryTableDefinitionRequestProcessQuery',
    'PowerpackWidgetQueryTableDefinitionRequestQuery',
    'PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery',
    'PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery',
    'PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQuery',
    'PowerpackWidgetQueryTableDefinitionRequestQueryEventQuery',
    'PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryCompute',
    'PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy',
    'PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort',
    'PowerpackWidgetQueryTableDefinitionRequestQueryEventQuerySearch',
    'PowerpackWidgetQueryTableDefinitionRequestQueryMetricQuery',
    'PowerpackWidgetQueryTableDefinitionRequestQueryProcessQuery',
    'PowerpackWidgetQueryTableDefinitionRequestQuerySloQuery',
    'PowerpackWidgetQueryTableDefinitionRequestRumQuery',
    'PowerpackWidgetQueryTableDefinitionRequestRumQueryComputeQuery',
    'PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBy',
    'PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery',
    'PowerpackWidgetQueryTableDefinitionRequestRumQueryMultiCompute',
    'PowerpackWidgetQueryTableDefinitionRequestSecurityQuery',
    'PowerpackWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery',
    'PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBy',
    'PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery',
    'PowerpackWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute',
    'PowerpackWidgetQueryTableDefinitionRequestTextFormat',
    'PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormat',
    'PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormatMatch',
    'PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormatReplace',
    'PowerpackWidgetQueryValueDefinition',
    'PowerpackWidgetQueryValueDefinitionCustomLink',
    'PowerpackWidgetQueryValueDefinitionRequest',
    'PowerpackWidgetQueryValueDefinitionRequestApmQuery',
    'PowerpackWidgetQueryValueDefinitionRequestApmQueryComputeQuery',
    'PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBy',
    'PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery',
    'PowerpackWidgetQueryValueDefinitionRequestApmQueryMultiCompute',
    'PowerpackWidgetQueryValueDefinitionRequestAuditQuery',
    'PowerpackWidgetQueryValueDefinitionRequestAuditQueryComputeQuery',
    'PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBy',
    'PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery',
    'PowerpackWidgetQueryValueDefinitionRequestAuditQueryMultiCompute',
    'PowerpackWidgetQueryValueDefinitionRequestConditionalFormat',
    'PowerpackWidgetQueryValueDefinitionRequestFormula',
    'PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormat',
    'PowerpackWidgetQueryValueDefinitionRequestFormulaLimit',
    'PowerpackWidgetQueryValueDefinitionRequestFormulaStyle',
    'PowerpackWidgetQueryValueDefinitionRequestLogQuery',
    'PowerpackWidgetQueryValueDefinitionRequestLogQueryComputeQuery',
    'PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBy',
    'PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery',
    'PowerpackWidgetQueryValueDefinitionRequestLogQueryMultiCompute',
    'PowerpackWidgetQueryValueDefinitionRequestProcessQuery',
    'PowerpackWidgetQueryValueDefinitionRequestQuery',
    'PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery',
    'PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery',
    'PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQuery',
    'PowerpackWidgetQueryValueDefinitionRequestQueryEventQuery',
    'PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryCompute',
    'PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy',
    'PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort',
    'PowerpackWidgetQueryValueDefinitionRequestQueryEventQuerySearch',
    'PowerpackWidgetQueryValueDefinitionRequestQueryMetricQuery',
    'PowerpackWidgetQueryValueDefinitionRequestQueryProcessQuery',
    'PowerpackWidgetQueryValueDefinitionRequestQuerySloQuery',
    'PowerpackWidgetQueryValueDefinitionRequestRumQuery',
    'PowerpackWidgetQueryValueDefinitionRequestRumQueryComputeQuery',
    'PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBy',
    'PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery',
    'PowerpackWidgetQueryValueDefinitionRequestRumQueryMultiCompute',
    'PowerpackWidgetQueryValueDefinitionRequestSecurityQuery',
    'PowerpackWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery',
    'PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBy',
    'PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery',
    'PowerpackWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute',
    'PowerpackWidgetQueryValueDefinitionTimeseriesBackground',
    'PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxis',
    'PowerpackWidgetRunWorkflowDefinition',
    'PowerpackWidgetRunWorkflowDefinitionCustomLink',
    'PowerpackWidgetRunWorkflowDefinitionInput',
    'PowerpackWidgetScatterplotDefinition',
    'PowerpackWidgetScatterplotDefinitionCustomLink',
    'PowerpackWidgetScatterplotDefinitionRequest',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTable',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableFormula',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuery',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery',
    'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery',
    'PowerpackWidgetScatterplotDefinitionRequestX',
    'PowerpackWidgetScatterplotDefinitionRequestXApmQuery',
    'PowerpackWidgetScatterplotDefinitionRequestXApmQueryComputeQuery',
    'PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBy',
    'PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery',
    'PowerpackWidgetScatterplotDefinitionRequestXApmQueryMultiCompute',
    'PowerpackWidgetScatterplotDefinitionRequestXLogQuery',
    'PowerpackWidgetScatterplotDefinitionRequestXLogQueryComputeQuery',
    'PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBy',
    'PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery',
    'PowerpackWidgetScatterplotDefinitionRequestXLogQueryMultiCompute',
    'PowerpackWidgetScatterplotDefinitionRequestXProcessQuery',
    'PowerpackWidgetScatterplotDefinitionRequestXRumQuery',
    'PowerpackWidgetScatterplotDefinitionRequestXRumQueryComputeQuery',
    'PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBy',
    'PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery',
    'PowerpackWidgetScatterplotDefinitionRequestXRumQueryMultiCompute',
    'PowerpackWidgetScatterplotDefinitionRequestXSecurityQuery',
    'PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery',
    'PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy',
    'PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery',
    'PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute',
    'PowerpackWidgetScatterplotDefinitionRequestY',
    'PowerpackWidgetScatterplotDefinitionRequestYApmQuery',
    'PowerpackWidgetScatterplotDefinitionRequestYApmQueryComputeQuery',
    'PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBy',
    'PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery',
    'PowerpackWidgetScatterplotDefinitionRequestYApmQueryMultiCompute',
    'PowerpackWidgetScatterplotDefinitionRequestYLogQuery',
    'PowerpackWidgetScatterplotDefinitionRequestYLogQueryComputeQuery',
    'PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBy',
    'PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery',
    'PowerpackWidgetScatterplotDefinitionRequestYLogQueryMultiCompute',
    'PowerpackWidgetScatterplotDefinitionRequestYProcessQuery',
    'PowerpackWidgetScatterplotDefinitionRequestYRumQuery',
    'PowerpackWidgetScatterplotDefinitionRequestYRumQueryComputeQuery',
    'PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBy',
    'PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery',
    'PowerpackWidgetScatterplotDefinitionRequestYRumQueryMultiCompute',
    'PowerpackWidgetScatterplotDefinitionRequestYSecurityQuery',
    'PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery',
    'PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy',
    'PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery',
    'PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute',
    'PowerpackWidgetScatterplotDefinitionXaxis',
    'PowerpackWidgetScatterplotDefinitionYaxis',
    'PowerpackWidgetServiceLevelObjectiveDefinition',
    'PowerpackWidgetServicemapDefinition',
    'PowerpackWidgetServicemapDefinitionCustomLink',
    'PowerpackWidgetSloListDefinition',
    'PowerpackWidgetSloListDefinitionRequest',
    'PowerpackWidgetSloListDefinitionRequestQuery',
    'PowerpackWidgetSloListDefinitionRequestQuerySort',
    'PowerpackWidgetSunburstDefinition',
    'PowerpackWidgetSunburstDefinitionCustomLink',
    'PowerpackWidgetSunburstDefinitionLegendInline',
    'PowerpackWidgetSunburstDefinitionLegendTable',
    'PowerpackWidgetSunburstDefinitionRequest',
    'PowerpackWidgetSunburstDefinitionRequestApmQuery',
    'PowerpackWidgetSunburstDefinitionRequestApmQueryComputeQuery',
    'PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBy',
    'PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery',
    'PowerpackWidgetSunburstDefinitionRequestApmQueryMultiCompute',
    'PowerpackWidgetSunburstDefinitionRequestAuditQuery',
    'PowerpackWidgetSunburstDefinitionRequestAuditQueryComputeQuery',
    'PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBy',
    'PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery',
    'PowerpackWidgetSunburstDefinitionRequestAuditQueryMultiCompute',
    'PowerpackWidgetSunburstDefinitionRequestFormula',
    'PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormat',
    'PowerpackWidgetSunburstDefinitionRequestFormulaLimit',
    'PowerpackWidgetSunburstDefinitionRequestFormulaStyle',
    'PowerpackWidgetSunburstDefinitionRequestLogQuery',
    'PowerpackWidgetSunburstDefinitionRequestLogQueryComputeQuery',
    'PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBy',
    'PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery',
    'PowerpackWidgetSunburstDefinitionRequestLogQueryMultiCompute',
    'PowerpackWidgetSunburstDefinitionRequestNetworkQuery',
    'PowerpackWidgetSunburstDefinitionRequestNetworkQueryComputeQuery',
    'PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBy',
    'PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery',
    'PowerpackWidgetSunburstDefinitionRequestNetworkQueryMultiCompute',
    'PowerpackWidgetSunburstDefinitionRequestProcessQuery',
    'PowerpackWidgetSunburstDefinitionRequestQuery',
    'PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery',
    'PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery',
    'PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQuery',
    'PowerpackWidgetSunburstDefinitionRequestQueryEventQuery',
    'PowerpackWidgetSunburstDefinitionRequestQueryEventQueryCompute',
    'PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBy',
    'PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort',
    'PowerpackWidgetSunburstDefinitionRequestQueryEventQuerySearch',
    'PowerpackWidgetSunburstDefinitionRequestQueryMetricQuery',
    'PowerpackWidgetSunburstDefinitionRequestQueryProcessQuery',
    'PowerpackWidgetSunburstDefinitionRequestQuerySloQuery',
    'PowerpackWidgetSunburstDefinitionRequestRumQuery',
    'PowerpackWidgetSunburstDefinitionRequestRumQueryComputeQuery',
    'PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBy',
    'PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery',
    'PowerpackWidgetSunburstDefinitionRequestRumQueryMultiCompute',
    'PowerpackWidgetSunburstDefinitionRequestSecurityQuery',
    'PowerpackWidgetSunburstDefinitionRequestSecurityQueryComputeQuery',
    'PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBy',
    'PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery',
    'PowerpackWidgetSunburstDefinitionRequestSecurityQueryMultiCompute',
    'PowerpackWidgetSunburstDefinitionRequestStyle',
    'PowerpackWidgetTimeseriesDefinition',
    'PowerpackWidgetTimeseriesDefinitionCustomLink',
    'PowerpackWidgetTimeseriesDefinitionEvent',
    'PowerpackWidgetTimeseriesDefinitionMarker',
    'PowerpackWidgetTimeseriesDefinitionRequest',
    'PowerpackWidgetTimeseriesDefinitionRequestApmQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestApmQueryComputeQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBy',
    'PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestApmQueryMultiCompute',
    'PowerpackWidgetTimeseriesDefinitionRequestAuditQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBy',
    'PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute',
    'PowerpackWidgetTimeseriesDefinitionRequestFormula',
    'PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormat',
    'PowerpackWidgetTimeseriesDefinitionRequestFormulaLimit',
    'PowerpackWidgetTimeseriesDefinitionRequestFormulaStyle',
    'PowerpackWidgetTimeseriesDefinitionRequestLogQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestLogQueryComputeQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBy',
    'PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestLogQueryMultiCompute',
    'PowerpackWidgetTimeseriesDefinitionRequestMetadata',
    'PowerpackWidgetTimeseriesDefinitionRequestNetworkQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy',
    'PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute',
    'PowerpackWidgetTimeseriesDefinitionRequestProcessQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryCompute',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuerySearch',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestQuerySloQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestRumQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestRumQueryComputeQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBy',
    'PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestRumQueryMultiCompute',
    'PowerpackWidgetTimeseriesDefinitionRequestSecurityQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy',
    'PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery',
    'PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute',
    'PowerpackWidgetTimeseriesDefinitionRequestStyle',
    'PowerpackWidgetTimeseriesDefinitionRightYaxis',
    'PowerpackWidgetTimeseriesDefinitionYaxis',
    'PowerpackWidgetToplistDefinition',
    'PowerpackWidgetToplistDefinitionCustomLink',
    'PowerpackWidgetToplistDefinitionRequest',
    'PowerpackWidgetToplistDefinitionRequestApmQuery',
    'PowerpackWidgetToplistDefinitionRequestApmQueryComputeQuery',
    'PowerpackWidgetToplistDefinitionRequestApmQueryGroupBy',
    'PowerpackWidgetToplistDefinitionRequestApmQueryGroupBySortQuery',
    'PowerpackWidgetToplistDefinitionRequestApmQueryMultiCompute',
    'PowerpackWidgetToplistDefinitionRequestAuditQuery',
    'PowerpackWidgetToplistDefinitionRequestAuditQueryComputeQuery',
    'PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBy',
    'PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery',
    'PowerpackWidgetToplistDefinitionRequestAuditQueryMultiCompute',
    'PowerpackWidgetToplistDefinitionRequestConditionalFormat',
    'PowerpackWidgetToplistDefinitionRequestFormula',
    'PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormat',
    'PowerpackWidgetToplistDefinitionRequestFormulaLimit',
    'PowerpackWidgetToplistDefinitionRequestFormulaStyle',
    'PowerpackWidgetToplistDefinitionRequestLogQuery',
    'PowerpackWidgetToplistDefinitionRequestLogQueryComputeQuery',
    'PowerpackWidgetToplistDefinitionRequestLogQueryGroupBy',
    'PowerpackWidgetToplistDefinitionRequestLogQueryGroupBySortQuery',
    'PowerpackWidgetToplistDefinitionRequestLogQueryMultiCompute',
    'PowerpackWidgetToplistDefinitionRequestProcessQuery',
    'PowerpackWidgetToplistDefinitionRequestQuery',
    'PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery',
    'PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQuery',
    'PowerpackWidgetToplistDefinitionRequestQueryCloudCostQuery',
    'PowerpackWidgetToplistDefinitionRequestQueryEventQuery',
    'PowerpackWidgetToplistDefinitionRequestQueryEventQueryCompute',
    'PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBy',
    'PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBySort',
    'PowerpackWidgetToplistDefinitionRequestQueryEventQuerySearch',
    'PowerpackWidgetToplistDefinitionRequestQueryMetricQuery',
    'PowerpackWidgetToplistDefinitionRequestQueryProcessQuery',
    'PowerpackWidgetToplistDefinitionRequestQuerySloQuery',
    'PowerpackWidgetToplistDefinitionRequestRumQuery',
    'PowerpackWidgetToplistDefinitionRequestRumQueryComputeQuery',
    'PowerpackWidgetToplistDefinitionRequestRumQueryGroupBy',
    'PowerpackWidgetToplistDefinitionRequestRumQueryGroupBySortQuery',
    'PowerpackWidgetToplistDefinitionRequestRumQueryMultiCompute',
    'PowerpackWidgetToplistDefinitionRequestSecurityQuery',
    'PowerpackWidgetToplistDefinitionRequestSecurityQueryComputeQuery',
    'PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBy',
    'PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery',
    'PowerpackWidgetToplistDefinitionRequestSecurityQueryMultiCompute',
    'PowerpackWidgetToplistDefinitionRequestStyle',
    'PowerpackWidgetToplistDefinitionStyle',
    'PowerpackWidgetToplistDefinitionStyleDisplay',
    'PowerpackWidgetTopologyMapDefinition',
    'PowerpackWidgetTopologyMapDefinitionCustomLink',
    'PowerpackWidgetTopologyMapDefinitionRequest',
    'PowerpackWidgetTopologyMapDefinitionRequestQuery',
    'PowerpackWidgetTraceServiceDefinition',
    'PowerpackWidgetTreemapDefinition',
    'PowerpackWidgetTreemapDefinitionRequest',
    'PowerpackWidgetTreemapDefinitionRequestFormula',
    'PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormat',
    'PowerpackWidgetTreemapDefinitionRequestFormulaLimit',
    'PowerpackWidgetTreemapDefinitionRequestFormulaStyle',
    'PowerpackWidgetTreemapDefinitionRequestQuery',
    'PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery',
    'PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery',
    'PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQuery',
    'PowerpackWidgetTreemapDefinitionRequestQueryEventQuery',
    'PowerpackWidgetTreemapDefinitionRequestQueryEventQueryCompute',
    'PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBy',
    'PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort',
    'PowerpackWidgetTreemapDefinitionRequestQueryEventQuerySearch',
    'PowerpackWidgetTreemapDefinitionRequestQueryMetricQuery',
    'PowerpackWidgetTreemapDefinitionRequestQueryProcessQuery',
    'PowerpackWidgetTreemapDefinitionRequestQuerySloQuery',
    'PowerpackWidgetWidgetLayout',
    'RestrictionPolicyBinding',
    'RolePermission',
    'RumMetricCompute',
    'RumMetricFilter',
    'RumMetricGroupBy',
    'RumMetricUniqueness',
    'SecurityMonitoringDefaultRuleCase',
    'SecurityMonitoringDefaultRuleFilter',
    'SecurityMonitoringDefaultRuleOptions',
    'SecurityMonitoringFilterExclusionFilter',
    'SecurityMonitoringRuleCase',
    'SecurityMonitoringRuleFilter',
    'SecurityMonitoringRuleOptions',
    'SecurityMonitoringRuleOptionsImpossibleTravelOptions',
    'SecurityMonitoringRuleOptionsNewValueOptions',
    'SecurityMonitoringRuleOptionsThirdPartyRuleOptions',
    'SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQuery',
    'SecurityMonitoringRuleQuery',
    'SecurityMonitoringRuleQueryAgentRule',
    'SecurityMonitoringRuleReferenceTable',
    'SecurityMonitoringRuleSignalQuery',
    'SecurityMonitoringRuleThirdPartyCase',
    'SensitiveDataScannerGroupFilter',
    'SensitiveDataScannerRuleIncludedKeywordConfiguration',
    'SensitiveDataScannerRuleTextReplacement',
    'ServiceLevelObjectiveQuery',
    'ServiceLevelObjectiveSliSpecification',
    'ServiceLevelObjectiveSliSpecificationTimeSlice',
    'ServiceLevelObjectiveSliSpecificationTimeSliceQuery',
    'ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormula',
    'ServiceLevelObjectiveSliSpecificationTimeSliceQueryQuery',
    'ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQuery',
    'ServiceLevelObjectiveThreshold',
    'SpansMetricCompute',
    'SpansMetricFilter',
    'SpansMetricGroupBy',
    'SyntheticsGlobalVariableOptions',
    'SyntheticsGlobalVariableOptionsTotpParameters',
    'SyntheticsGlobalVariableParseTestOptions',
    'SyntheticsGlobalVariableParseTestOptionsParser',
    'SyntheticsPrivateLocationMetadata',
    'SyntheticsTestApiStep',
    'SyntheticsTestApiStepAssertion',
    'SyntheticsTestApiStepAssertionTargetjsonpath',
    'SyntheticsTestApiStepAssertionTargetjsonschema',
    'SyntheticsTestApiStepAssertionTargetxpath',
    'SyntheticsTestApiStepExtractedValue',
    'SyntheticsTestApiStepExtractedValueParser',
    'SyntheticsTestApiStepRequestBasicauth',
    'SyntheticsTestApiStepRequestClientCertificate',
    'SyntheticsTestApiStepRequestClientCertificateCert',
    'SyntheticsTestApiStepRequestClientCertificateKey',
    'SyntheticsTestApiStepRequestDefinition',
    'SyntheticsTestApiStepRequestFile',
    'SyntheticsTestApiStepRequestProxy',
    'SyntheticsTestApiStepRetry',
    'SyntheticsTestAssertion',
    'SyntheticsTestAssertionTargetjsonpath',
    'SyntheticsTestAssertionTargetjsonschema',
    'SyntheticsTestAssertionTargetxpath',
    'SyntheticsTestBrowserStep',
    'SyntheticsTestBrowserStepParams',
    'SyntheticsTestBrowserStepParamsElementUserLocator',
    'SyntheticsTestBrowserStepParamsElementUserLocatorValue',
    'SyntheticsTestBrowserStepParamsVariable',
    'SyntheticsTestBrowserVariable',
    'SyntheticsTestConfigVariable',
    'SyntheticsTestMobileOptionsList',
    'SyntheticsTestMobileOptionsListBinding',
    'SyntheticsTestMobileOptionsListCi',
    'SyntheticsTestMobileOptionsListMobileApplication',
    'SyntheticsTestMobileOptionsListMonitorOptions',
    'SyntheticsTestMobileOptionsListRetry',
    'SyntheticsTestMobileOptionsListScheduling',
    'SyntheticsTestMobileOptionsListSchedulingTimeframe',
    'SyntheticsTestMobileStep',
    'SyntheticsTestMobileStepParams',
    'SyntheticsTestMobileStepParamsElement',
    'SyntheticsTestMobileStepParamsElementRelativePosition',
    'SyntheticsTestMobileStepParamsElementUserLocator',
    'SyntheticsTestMobileStepParamsElementUserLocatorValue',
    'SyntheticsTestMobileStepParamsPosition',
    'SyntheticsTestMobileStepParamsVariable',
    'SyntheticsTestOptionsList',
    'SyntheticsTestOptionsListCi',
    'SyntheticsTestOptionsListMonitorOptions',
    'SyntheticsTestOptionsListRetry',
    'SyntheticsTestOptionsListRumSettings',
    'SyntheticsTestOptionsListScheduling',
    'SyntheticsTestOptionsListSchedulingTimeframe',
    'SyntheticsTestRequestBasicauth',
    'SyntheticsTestRequestClientCertificate',
    'SyntheticsTestRequestClientCertificateCert',
    'SyntheticsTestRequestClientCertificateKey',
    'SyntheticsTestRequestDefinition',
    'SyntheticsTestRequestFile',
    'SyntheticsTestRequestProxy',
    'GetCloudWorkloadSecurityAgentRulesAgentRuleResult',
    'GetCsmThreatsAgentRulesAgentRuleResult',
    'GetHostsHostListResult',
    'GetHostsHostListMetaResult',
    'GetHostsHostListMetricsResult',
    'GetLogsIndexesLogsIndexResult',
    'GetLogsIndexesLogsIndexDailyLimitResetResult',
    'GetLogsIndexesLogsIndexExclusionFilterResult',
    'GetLogsIndexesLogsIndexExclusionFilterFilterResult',
    'GetLogsIndexesLogsIndexFilterResult',
    'GetLogsPipelinesLogsPipelineResult',
    'GetLogsPipelinesLogsPipelineFilterResult',
    'GetMonitorConfigPoliciesMonitorConfigPolicyResult',
    'GetMonitorConfigPoliciesMonitorConfigPolicyTagPolicyResult',
    'GetMonitorMonitorThresholdResult',
    'GetMonitorMonitorThresholdWindowResult',
    'GetMonitorSchedulingOptionResult',
    'GetMonitorSchedulingOptionCustomScheduleResult',
    'GetMonitorSchedulingOptionCustomScheduleRecurrenceResult',
    'GetMonitorSchedulingOptionEvaluationWindowResult',
    'GetMonitorsMonitorResult',
    'GetRoleUsersRoleUserResult',
    'GetRolesRoleResult',
    'GetSecurityMonitoringFiltersFilterResult',
    'GetSecurityMonitoringFiltersFilterExclusionFilterResult',
    'GetSecurityMonitoringRulesRuleResult',
    'GetSecurityMonitoringRulesRuleCaseResult',
    'GetSecurityMonitoringRulesRuleFilterResult',
    'GetSecurityMonitoringRulesRuleOptionsResult',
    'GetSecurityMonitoringRulesRuleOptionsImpossibleTravelOptionsResult',
    'GetSecurityMonitoringRulesRuleOptionsNewValueOptionsResult',
    'GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptionsResult',
    'GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptionsRootQueryResult',
    'GetSecurityMonitoringRulesRuleQueryResult',
    'GetSecurityMonitoringRulesRuleQueryAgentRuleResult',
    'GetSecurityMonitoringRulesRuleReferenceTableResult',
    'GetSecurityMonitoringRulesRuleSignalQueryResult',
    'GetSecurityMonitoringRulesRuleThirdPartyCaseResult',
    'GetSecurityMonitoringSuppressionsSuppressionResult',
    'GetServiceLevelObjectiveQueryResult',
    'GetServiceLevelObjectivesSloResult',
    'GetTeamMembershipsTeamMembershipResult',
    'GetUsersUserResult',
]

@pulumi.output_type
class ApmRetentionFilterFilter(dict):
    def __init__(__self__, *,
                 query: Optional[str] = None):
        """
        :param str query: The search query - follow the span search syntax, use `AND` between tags and `\\` to escape special characters, use nanosecond for duration. Defaults to `"*"`.
        """
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        The search query - follow the span search syntax, use `AND` between tags and `\\` to escape special characters, use nanosecond for duration. Defaults to `"*"`.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class ChildOrganizationApiKey(dict):
    def __init__(__self__, *,
                 key: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str key: API key.
        :param str name: Name of your API key.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        API key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of your API key.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ChildOrganizationApplicationKey(dict):
    def __init__(__self__, *,
                 hash: Optional[str] = None,
                 name: Optional[str] = None,
                 owner: Optional[str] = None):
        """
        :param str hash: Hash of an application key.
        :param str name: Name of an application key.
        :param str owner: Owner of an application key.
        """
        if hash is not None:
            pulumi.set(__self__, "hash", hash)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if owner is not None:
            pulumi.set(__self__, "owner", owner)

    @property
    @pulumi.getter
    def hash(self) -> Optional[str]:
        """
        Hash of an application key.
        """
        return pulumi.get(self, "hash")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of an application key.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def owner(self) -> Optional[str]:
        """
        Owner of an application key.
        """
        return pulumi.get(self, "owner")


@pulumi.output_type
class ChildOrganizationSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateWidgetShare":
            suggest = "private_widget_share"
        elif key == "samlAutocreateAccessRole":
            suggest = "saml_autocreate_access_role"
        elif key == "samlAutocreateUsersDomains":
            suggest = "saml_autocreate_users_domains"
        elif key == "samlCanBeEnabled":
            suggest = "saml_can_be_enabled"
        elif key == "samlIdpEndpoint":
            suggest = "saml_idp_endpoint"
        elif key == "samlIdpInitiatedLogins":
            suggest = "saml_idp_initiated_logins"
        elif key == "samlIdpMetadataUploaded":
            suggest = "saml_idp_metadata_uploaded"
        elif key == "samlLoginUrl":
            suggest = "saml_login_url"
        elif key == "samlStrictModes":
            suggest = "saml_strict_modes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChildOrganizationSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChildOrganizationSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChildOrganizationSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_widget_share: Optional[bool] = None,
                 saml_autocreate_access_role: Optional[str] = None,
                 saml_autocreate_users_domains: Optional[Sequence['outputs.ChildOrganizationSettingSamlAutocreateUsersDomain']] = None,
                 saml_can_be_enabled: Optional[bool] = None,
                 saml_idp_endpoint: Optional[str] = None,
                 saml_idp_initiated_logins: Optional[Sequence['outputs.ChildOrganizationSettingSamlIdpInitiatedLogin']] = None,
                 saml_idp_metadata_uploaded: Optional[bool] = None,
                 saml_login_url: Optional[str] = None,
                 saml_strict_modes: Optional[Sequence['outputs.ChildOrganizationSettingSamlStrictMode']] = None,
                 samls: Optional[Sequence['outputs.ChildOrganizationSettingSaml']] = None):
        """
        :param bool private_widget_share: Whether or not the organization users can share widgets outside of Datadog.
        :param str saml_autocreate_access_role: The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm` , `ro`, `ERROR`
        :param Sequence['ChildOrganizationSettingSamlAutocreateUsersDomainArgs'] saml_autocreate_users_domains: List of domains where the SAML automated user creation is enabled.
        :param bool saml_can_be_enabled: Whether or not SAML can be enabled for this organization.
        :param str saml_idp_endpoint: Identity provider endpoint for SAML authentication.
        :param Sequence['ChildOrganizationSettingSamlIdpInitiatedLoginArgs'] saml_idp_initiated_logins: Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        :param bool saml_idp_metadata_uploaded: Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        :param str saml_login_url: URL for SAML logging.
        :param Sequence['ChildOrganizationSettingSamlStrictModeArgs'] saml_strict_modes: Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
        :param Sequence['ChildOrganizationSettingSamlArgs'] samls: SAML properties
        """
        if private_widget_share is not None:
            pulumi.set(__self__, "private_widget_share", private_widget_share)
        if saml_autocreate_access_role is not None:
            pulumi.set(__self__, "saml_autocreate_access_role", saml_autocreate_access_role)
        if saml_autocreate_users_domains is not None:
            pulumi.set(__self__, "saml_autocreate_users_domains", saml_autocreate_users_domains)
        if saml_can_be_enabled is not None:
            pulumi.set(__self__, "saml_can_be_enabled", saml_can_be_enabled)
        if saml_idp_endpoint is not None:
            pulumi.set(__self__, "saml_idp_endpoint", saml_idp_endpoint)
        if saml_idp_initiated_logins is not None:
            pulumi.set(__self__, "saml_idp_initiated_logins", saml_idp_initiated_logins)
        if saml_idp_metadata_uploaded is not None:
            pulumi.set(__self__, "saml_idp_metadata_uploaded", saml_idp_metadata_uploaded)
        if saml_login_url is not None:
            pulumi.set(__self__, "saml_login_url", saml_login_url)
        if saml_strict_modes is not None:
            pulumi.set(__self__, "saml_strict_modes", saml_strict_modes)
        if samls is not None:
            pulumi.set(__self__, "samls", samls)

    @property
    @pulumi.getter(name="privateWidgetShare")
    def private_widget_share(self) -> Optional[bool]:
        """
        Whether or not the organization users can share widgets outside of Datadog.
        """
        return pulumi.get(self, "private_widget_share")

    @property
    @pulumi.getter(name="samlAutocreateAccessRole")
    def saml_autocreate_access_role(self) -> Optional[str]:
        """
        The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm` , `ro`, `ERROR`
        """
        return pulumi.get(self, "saml_autocreate_access_role")

    @property
    @pulumi.getter(name="samlAutocreateUsersDomains")
    def saml_autocreate_users_domains(self) -> Optional[Sequence['outputs.ChildOrganizationSettingSamlAutocreateUsersDomain']]:
        """
        List of domains where the SAML automated user creation is enabled.
        """
        return pulumi.get(self, "saml_autocreate_users_domains")

    @property
    @pulumi.getter(name="samlCanBeEnabled")
    def saml_can_be_enabled(self) -> Optional[bool]:
        """
        Whether or not SAML can be enabled for this organization.
        """
        return pulumi.get(self, "saml_can_be_enabled")

    @property
    @pulumi.getter(name="samlIdpEndpoint")
    def saml_idp_endpoint(self) -> Optional[str]:
        """
        Identity provider endpoint for SAML authentication.
        """
        return pulumi.get(self, "saml_idp_endpoint")

    @property
    @pulumi.getter(name="samlIdpInitiatedLogins")
    def saml_idp_initiated_logins(self) -> Optional[Sequence['outputs.ChildOrganizationSettingSamlIdpInitiatedLogin']]:
        """
        Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        """
        return pulumi.get(self, "saml_idp_initiated_logins")

    @property
    @pulumi.getter(name="samlIdpMetadataUploaded")
    def saml_idp_metadata_uploaded(self) -> Optional[bool]:
        """
        Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        """
        return pulumi.get(self, "saml_idp_metadata_uploaded")

    @property
    @pulumi.getter(name="samlLoginUrl")
    def saml_login_url(self) -> Optional[str]:
        """
        URL for SAML logging.
        """
        return pulumi.get(self, "saml_login_url")

    @property
    @pulumi.getter(name="samlStrictModes")
    def saml_strict_modes(self) -> Optional[Sequence['outputs.ChildOrganizationSettingSamlStrictMode']]:
        """
        Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
        """
        return pulumi.get(self, "saml_strict_modes")

    @property
    @pulumi.getter
    def samls(self) -> Optional[Sequence['outputs.ChildOrganizationSettingSaml']]:
        """
        SAML properties
        """
        return pulumi.get(self, "samls")


@pulumi.output_type
class ChildOrganizationSettingSaml(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Whether or not SAML is enabled for this organization.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not SAML is enabled for this organization.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ChildOrganizationSettingSamlAutocreateUsersDomain(dict):
    def __init__(__self__, *,
                 domains: Optional[Sequence[str]] = None,
                 enabled: Optional[bool] = None):
        """
        :param Sequence[str] domains: List of domains where the SAML automated user creation is enabled.
        :param bool enabled: Whether or not the automated user creation based on SAML domain is enabled.
        """
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def domains(self) -> Optional[Sequence[str]]:
        """
        List of domains where the SAML automated user creation is enabled.
        """
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not the automated user creation based on SAML domain is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ChildOrganizationSettingSamlIdpInitiatedLogin(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ChildOrganizationSettingSamlStrictMode(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class ChildOrganizationUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessRole":
            suggest = "access_role"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChildOrganizationUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChildOrganizationUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChildOrganizationUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_role: Optional[str] = None,
                 email: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str access_role: The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm`, `ro`, `ERROR`
        :param str email: The new email of the user.
        :param str name: The name of the user.
        """
        if access_role is not None:
            pulumi.set(__self__, "access_role", access_role)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="accessRole")
    def access_role(self) -> Optional[str]:
        """
        The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm`, `ro`, `ERROR`
        """
        return pulumi.get(self, "access_role")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        The new email of the user.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the user.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CloudConfigurationRuleFilter(dict):
    def __init__(__self__, *,
                 action: str,
                 query: str):
        """
        :param str action: The type of filtering action. Valid values are `require`, `suppress`.
        :param str query: Query for selecting logs to apply the filtering action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The type of filtering action. Valid values are `require`, `suppress`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for selecting logs to apply the filtering action.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardListDashItem(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dashId":
            suggest = "dash_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardListDashItem. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardListDashItem.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardListDashItem.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dash_id: str,
                 type: str):
        """
        :param str dash_id: The ID of the dashboard to add
        :param str type: The type of this dashboard. Valid values are `custom_timeboard`, `custom_screenboard`, `integration_screenboard`, `integration_timeboard`, `host_timeboard`.
        """
        pulumi.set(__self__, "dash_id", dash_id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dashId")
    def dash_id(self) -> str:
        """
        The ID of the dashboard to add
        """
        return pulumi.get(self, "dash_id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of this dashboard. Valid values are `custom_timeboard`, `custom_screenboard`, `integration_screenboard`, `integration_timeboard`, `host_timeboard`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DashboardTemplateVariable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "availableValues":
            suggest = "available_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTemplateVariable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTemplateVariable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTemplateVariable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 available_values: Optional[Sequence[str]] = None,
                 default: Optional[str] = None,
                 defaults: Optional[Sequence[str]] = None,
                 prefix: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param Sequence[str] available_values: The list of values that the template variable drop-down is be limited to
        :param str default: The default value for the template variable on dashboard load. Cannot be used in conjunction with `defaults`. **Deprecated.** Use `defaults` instead.
        :param Sequence[str] defaults: One or many default values for template variables on load. If more than one default is specified, they will be unioned together with `OR`. Cannot be used in conjunction with `default`.
        :param str prefix: The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
        """
        pulumi.set(__self__, "name", name)
        if available_values is not None:
            pulumi.set(__self__, "available_values", available_values)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defaults is not None:
            pulumi.set(__self__, "defaults", defaults)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="availableValues")
    def available_values(self) -> Optional[Sequence[str]]:
        """
        The list of values that the template variable drop-down is be limited to
        """
        return pulumi.get(self, "available_values")

    @property
    @pulumi.getter
    @_utilities.deprecated("""Use `defaults` instead.""")
    def default(self) -> Optional[str]:
        """
        The default value for the template variable on dashboard load. Cannot be used in conjunction with `defaults`. **Deprecated.** Use `defaults` instead.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def defaults(self) -> Optional[Sequence[str]]:
        """
        One or many default values for template variables on load. If more than one default is specified, they will be unioned together with `OR`. Cannot be used in conjunction with `default`.
        """
        return pulumi.get(self, "defaults")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class DashboardTemplateVariablePreset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "templateVariables":
            suggest = "template_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTemplateVariablePreset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTemplateVariablePreset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTemplateVariablePreset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 template_variables: Optional[Sequence['outputs.DashboardTemplateVariablePresetTemplateVariable']] = None):
        """
        :param str name: The name of the preset.
        :param Sequence['DashboardTemplateVariablePresetTemplateVariableArgs'] template_variables: The template variable names and assumed values under the given preset
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if template_variables is not None:
            pulumi.set(__self__, "template_variables", template_variables)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the preset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="templateVariables")
    def template_variables(self) -> Optional[Sequence['outputs.DashboardTemplateVariablePresetTemplateVariable']]:
        """
        The template variable names and assumed values under the given preset
        """
        return pulumi.get(self, "template_variables")


@pulumi.output_type
class DashboardTemplateVariablePresetTemplateVariable(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None,
                 values: Optional[Sequence[str]] = None):
        """
        :param str name: The name of the template variable
        :param str value: The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        :param Sequence[str] values: One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified. Cannot be used in conjunction with `value`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the template variable
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    @_utilities.deprecated("""Use `values` instead.""")
    def value(self) -> Optional[str]:
        """
        The value that should be assumed by the template variable in this preset. Cannot be used in conjunction with `values`. **Deprecated.** Use `values` instead.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[str]]:
        """
        One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified. Cannot be used in conjunction with `value`.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardWidget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertGraphDefinition":
            suggest = "alert_graph_definition"
        elif key == "alertValueDefinition":
            suggest = "alert_value_definition"
        elif key == "changeDefinition":
            suggest = "change_definition"
        elif key == "checkStatusDefinition":
            suggest = "check_status_definition"
        elif key == "distributionDefinition":
            suggest = "distribution_definition"
        elif key == "eventStreamDefinition":
            suggest = "event_stream_definition"
        elif key == "eventTimelineDefinition":
            suggest = "event_timeline_definition"
        elif key == "freeTextDefinition":
            suggest = "free_text_definition"
        elif key == "geomapDefinition":
            suggest = "geomap_definition"
        elif key == "groupDefinition":
            suggest = "group_definition"
        elif key == "heatmapDefinition":
            suggest = "heatmap_definition"
        elif key == "hostmapDefinition":
            suggest = "hostmap_definition"
        elif key == "iframeDefinition":
            suggest = "iframe_definition"
        elif key == "imageDefinition":
            suggest = "image_definition"
        elif key == "listStreamDefinition":
            suggest = "list_stream_definition"
        elif key == "logStreamDefinition":
            suggest = "log_stream_definition"
        elif key == "manageStatusDefinition":
            suggest = "manage_status_definition"
        elif key == "noteDefinition":
            suggest = "note_definition"
        elif key == "powerpackDefinition":
            suggest = "powerpack_definition"
        elif key == "queryTableDefinition":
            suggest = "query_table_definition"
        elif key == "queryValueDefinition":
            suggest = "query_value_definition"
        elif key == "runWorkflowDefinition":
            suggest = "run_workflow_definition"
        elif key == "scatterplotDefinition":
            suggest = "scatterplot_definition"
        elif key == "serviceLevelObjectiveDefinition":
            suggest = "service_level_objective_definition"
        elif key == "servicemapDefinition":
            suggest = "servicemap_definition"
        elif key == "sloListDefinition":
            suggest = "slo_list_definition"
        elif key == "splitGraphDefinition":
            suggest = "split_graph_definition"
        elif key == "sunburstDefinition":
            suggest = "sunburst_definition"
        elif key == "timeseriesDefinition":
            suggest = "timeseries_definition"
        elif key == "toplistDefinition":
            suggest = "toplist_definition"
        elif key == "topologyMapDefinition":
            suggest = "topology_map_definition"
        elif key == "traceServiceDefinition":
            suggest = "trace_service_definition"
        elif key == "treemapDefinition":
            suggest = "treemap_definition"
        elif key == "widgetLayout":
            suggest = "widget_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_graph_definition: Optional['outputs.DashboardWidgetAlertGraphDefinition'] = None,
                 alert_value_definition: Optional['outputs.DashboardWidgetAlertValueDefinition'] = None,
                 change_definition: Optional['outputs.DashboardWidgetChangeDefinition'] = None,
                 check_status_definition: Optional['outputs.DashboardWidgetCheckStatusDefinition'] = None,
                 distribution_definition: Optional['outputs.DashboardWidgetDistributionDefinition'] = None,
                 event_stream_definition: Optional['outputs.DashboardWidgetEventStreamDefinition'] = None,
                 event_timeline_definition: Optional['outputs.DashboardWidgetEventTimelineDefinition'] = None,
                 free_text_definition: Optional['outputs.DashboardWidgetFreeTextDefinition'] = None,
                 geomap_definition: Optional['outputs.DashboardWidgetGeomapDefinition'] = None,
                 group_definition: Optional['outputs.DashboardWidgetGroupDefinition'] = None,
                 heatmap_definition: Optional['outputs.DashboardWidgetHeatmapDefinition'] = None,
                 hostmap_definition: Optional['outputs.DashboardWidgetHostmapDefinition'] = None,
                 id: Optional[int] = None,
                 iframe_definition: Optional['outputs.DashboardWidgetIframeDefinition'] = None,
                 image_definition: Optional['outputs.DashboardWidgetImageDefinition'] = None,
                 list_stream_definition: Optional['outputs.DashboardWidgetListStreamDefinition'] = None,
                 log_stream_definition: Optional['outputs.DashboardWidgetLogStreamDefinition'] = None,
                 manage_status_definition: Optional['outputs.DashboardWidgetManageStatusDefinition'] = None,
                 note_definition: Optional['outputs.DashboardWidgetNoteDefinition'] = None,
                 powerpack_definition: Optional['outputs.DashboardWidgetPowerpackDefinition'] = None,
                 query_table_definition: Optional['outputs.DashboardWidgetQueryTableDefinition'] = None,
                 query_value_definition: Optional['outputs.DashboardWidgetQueryValueDefinition'] = None,
                 run_workflow_definition: Optional['outputs.DashboardWidgetRunWorkflowDefinition'] = None,
                 scatterplot_definition: Optional['outputs.DashboardWidgetScatterplotDefinition'] = None,
                 service_level_objective_definition: Optional['outputs.DashboardWidgetServiceLevelObjectiveDefinition'] = None,
                 servicemap_definition: Optional['outputs.DashboardWidgetServicemapDefinition'] = None,
                 slo_list_definition: Optional['outputs.DashboardWidgetSloListDefinition'] = None,
                 split_graph_definition: Optional['outputs.DashboardWidgetSplitGraphDefinition'] = None,
                 sunburst_definition: Optional['outputs.DashboardWidgetSunburstDefinition'] = None,
                 timeseries_definition: Optional['outputs.DashboardWidgetTimeseriesDefinition'] = None,
                 toplist_definition: Optional['outputs.DashboardWidgetToplistDefinition'] = None,
                 topology_map_definition: Optional['outputs.DashboardWidgetTopologyMapDefinition'] = None,
                 trace_service_definition: Optional['outputs.DashboardWidgetTraceServiceDefinition'] = None,
                 treemap_definition: Optional['outputs.DashboardWidgetTreemapDefinition'] = None,
                 widget_layout: Optional['outputs.DashboardWidgetWidgetLayout'] = None):
        """
        :param 'DashboardWidgetAlertGraphDefinitionArgs' alert_graph_definition: The definition for a Alert Graph widget.
        :param 'DashboardWidgetAlertValueDefinitionArgs' alert_value_definition: The definition for a Alert Value widget.
        :param 'DashboardWidgetChangeDefinitionArgs' change_definition: The definition for a Change widget.
        :param 'DashboardWidgetCheckStatusDefinitionArgs' check_status_definition: The definition for a Check Status widget.
        :param 'DashboardWidgetDistributionDefinitionArgs' distribution_definition: The definition for a Distribution widget.
        :param 'DashboardWidgetEventStreamDefinitionArgs' event_stream_definition: The definition for a Event Stream widget.
        :param 'DashboardWidgetEventTimelineDefinitionArgs' event_timeline_definition: The definition for a Event Timeline widget.
        :param 'DashboardWidgetFreeTextDefinitionArgs' free_text_definition: The definition for a Free Text widget.
        :param 'DashboardWidgetGeomapDefinitionArgs' geomap_definition: The definition for a Geomap widget.
        :param 'DashboardWidgetGroupDefinitionArgs' group_definition: The definition for a Group widget.
        :param 'DashboardWidgetHeatmapDefinitionArgs' heatmap_definition: The definition for a Heatmap widget.
        :param 'DashboardWidgetHostmapDefinitionArgs' hostmap_definition: The definition for a Hostmap widget.
        :param int id: The ID of the widget.
        :param 'DashboardWidgetIframeDefinitionArgs' iframe_definition: The definition for an Iframe widget.
        :param 'DashboardWidgetImageDefinitionArgs' image_definition: The definition for an Image widget
        :param 'DashboardWidgetListStreamDefinitionArgs' list_stream_definition: The definition for a List Stream widget.
        :param 'DashboardWidgetLogStreamDefinitionArgs' log_stream_definition: The definition for an Log Stream widget.
        :param 'DashboardWidgetManageStatusDefinitionArgs' manage_status_definition: The definition for an Manage Status widget.
        :param 'DashboardWidgetNoteDefinitionArgs' note_definition: The definition for a Note widget.
        :param 'DashboardWidgetPowerpackDefinitionArgs' powerpack_definition: The definition for a Powerpack widget.
        :param 'DashboardWidgetQueryTableDefinitionArgs' query_table_definition: The definition for a Query Table widget.
        :param 'DashboardWidgetQueryValueDefinitionArgs' query_value_definition: The definition for a Query Value widget.
        :param 'DashboardWidgetRunWorkflowDefinitionArgs' run_workflow_definition: The definition for a Run Workflow widget.
        :param 'DashboardWidgetScatterplotDefinitionArgs' scatterplot_definition: The definition for a Scatterplot widget.
        :param 'DashboardWidgetServiceLevelObjectiveDefinitionArgs' service_level_objective_definition: The definition for a Service Level Objective widget.
        :param 'DashboardWidgetServicemapDefinitionArgs' servicemap_definition: The definition for a Service Map widget.
        :param 'DashboardWidgetSloListDefinitionArgs' slo_list_definition: The definition for an SLO (Service Level Objective) List widget.
        :param 'DashboardWidgetSplitGraphDefinitionArgs' split_graph_definition: The definition for a Split Graph widget.
        :param 'DashboardWidgetSunburstDefinitionArgs' sunburst_definition: The definition for a Sunburst widget.
        :param 'DashboardWidgetTimeseriesDefinitionArgs' timeseries_definition: The definition for a Timeseries widget.
        :param 'DashboardWidgetToplistDefinitionArgs' toplist_definition: The definition for a Toplist widget.
        :param 'DashboardWidgetTopologyMapDefinitionArgs' topology_map_definition: The definition for a Topology Map widget.
        :param 'DashboardWidgetTraceServiceDefinitionArgs' trace_service_definition: The definition for a Trace Service widget.
        :param 'DashboardWidgetTreemapDefinitionArgs' treemap_definition: The definition for a Treemap widget.
        :param 'DashboardWidgetWidgetLayoutArgs' widget_layout: The layout of the widget on a 'free' dashboard.
        """
        if alert_graph_definition is not None:
            pulumi.set(__self__, "alert_graph_definition", alert_graph_definition)
        if alert_value_definition is not None:
            pulumi.set(__self__, "alert_value_definition", alert_value_definition)
        if change_definition is not None:
            pulumi.set(__self__, "change_definition", change_definition)
        if check_status_definition is not None:
            pulumi.set(__self__, "check_status_definition", check_status_definition)
        if distribution_definition is not None:
            pulumi.set(__self__, "distribution_definition", distribution_definition)
        if event_stream_definition is not None:
            pulumi.set(__self__, "event_stream_definition", event_stream_definition)
        if event_timeline_definition is not None:
            pulumi.set(__self__, "event_timeline_definition", event_timeline_definition)
        if free_text_definition is not None:
            pulumi.set(__self__, "free_text_definition", free_text_definition)
        if geomap_definition is not None:
            pulumi.set(__self__, "geomap_definition", geomap_definition)
        if group_definition is not None:
            pulumi.set(__self__, "group_definition", group_definition)
        if heatmap_definition is not None:
            pulumi.set(__self__, "heatmap_definition", heatmap_definition)
        if hostmap_definition is not None:
            pulumi.set(__self__, "hostmap_definition", hostmap_definition)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if iframe_definition is not None:
            pulumi.set(__self__, "iframe_definition", iframe_definition)
        if image_definition is not None:
            pulumi.set(__self__, "image_definition", image_definition)
        if list_stream_definition is not None:
            pulumi.set(__self__, "list_stream_definition", list_stream_definition)
        if log_stream_definition is not None:
            pulumi.set(__self__, "log_stream_definition", log_stream_definition)
        if manage_status_definition is not None:
            pulumi.set(__self__, "manage_status_definition", manage_status_definition)
        if note_definition is not None:
            pulumi.set(__self__, "note_definition", note_definition)
        if powerpack_definition is not None:
            pulumi.set(__self__, "powerpack_definition", powerpack_definition)
        if query_table_definition is not None:
            pulumi.set(__self__, "query_table_definition", query_table_definition)
        if query_value_definition is not None:
            pulumi.set(__self__, "query_value_definition", query_value_definition)
        if run_workflow_definition is not None:
            pulumi.set(__self__, "run_workflow_definition", run_workflow_definition)
        if scatterplot_definition is not None:
            pulumi.set(__self__, "scatterplot_definition", scatterplot_definition)
        if service_level_objective_definition is not None:
            pulumi.set(__self__, "service_level_objective_definition", service_level_objective_definition)
        if servicemap_definition is not None:
            pulumi.set(__self__, "servicemap_definition", servicemap_definition)
        if slo_list_definition is not None:
            pulumi.set(__self__, "slo_list_definition", slo_list_definition)
        if split_graph_definition is not None:
            pulumi.set(__self__, "split_graph_definition", split_graph_definition)
        if sunburst_definition is not None:
            pulumi.set(__self__, "sunburst_definition", sunburst_definition)
        if timeseries_definition is not None:
            pulumi.set(__self__, "timeseries_definition", timeseries_definition)
        if toplist_definition is not None:
            pulumi.set(__self__, "toplist_definition", toplist_definition)
        if topology_map_definition is not None:
            pulumi.set(__self__, "topology_map_definition", topology_map_definition)
        if trace_service_definition is not None:
            pulumi.set(__self__, "trace_service_definition", trace_service_definition)
        if treemap_definition is not None:
            pulumi.set(__self__, "treemap_definition", treemap_definition)
        if widget_layout is not None:
            pulumi.set(__self__, "widget_layout", widget_layout)

    @property
    @pulumi.getter(name="alertGraphDefinition")
    def alert_graph_definition(self) -> Optional['outputs.DashboardWidgetAlertGraphDefinition']:
        """
        The definition for a Alert Graph widget.
        """
        return pulumi.get(self, "alert_graph_definition")

    @property
    @pulumi.getter(name="alertValueDefinition")
    def alert_value_definition(self) -> Optional['outputs.DashboardWidgetAlertValueDefinition']:
        """
        The definition for a Alert Value widget.
        """
        return pulumi.get(self, "alert_value_definition")

    @property
    @pulumi.getter(name="changeDefinition")
    def change_definition(self) -> Optional['outputs.DashboardWidgetChangeDefinition']:
        """
        The definition for a Change widget.
        """
        return pulumi.get(self, "change_definition")

    @property
    @pulumi.getter(name="checkStatusDefinition")
    def check_status_definition(self) -> Optional['outputs.DashboardWidgetCheckStatusDefinition']:
        """
        The definition for a Check Status widget.
        """
        return pulumi.get(self, "check_status_definition")

    @property
    @pulumi.getter(name="distributionDefinition")
    def distribution_definition(self) -> Optional['outputs.DashboardWidgetDistributionDefinition']:
        """
        The definition for a Distribution widget.
        """
        return pulumi.get(self, "distribution_definition")

    @property
    @pulumi.getter(name="eventStreamDefinition")
    def event_stream_definition(self) -> Optional['outputs.DashboardWidgetEventStreamDefinition']:
        """
        The definition for a Event Stream widget.
        """
        return pulumi.get(self, "event_stream_definition")

    @property
    @pulumi.getter(name="eventTimelineDefinition")
    def event_timeline_definition(self) -> Optional['outputs.DashboardWidgetEventTimelineDefinition']:
        """
        The definition for a Event Timeline widget.
        """
        return pulumi.get(self, "event_timeline_definition")

    @property
    @pulumi.getter(name="freeTextDefinition")
    def free_text_definition(self) -> Optional['outputs.DashboardWidgetFreeTextDefinition']:
        """
        The definition for a Free Text widget.
        """
        return pulumi.get(self, "free_text_definition")

    @property
    @pulumi.getter(name="geomapDefinition")
    def geomap_definition(self) -> Optional['outputs.DashboardWidgetGeomapDefinition']:
        """
        The definition for a Geomap widget.
        """
        return pulumi.get(self, "geomap_definition")

    @property
    @pulumi.getter(name="groupDefinition")
    def group_definition(self) -> Optional['outputs.DashboardWidgetGroupDefinition']:
        """
        The definition for a Group widget.
        """
        return pulumi.get(self, "group_definition")

    @property
    @pulumi.getter(name="heatmapDefinition")
    def heatmap_definition(self) -> Optional['outputs.DashboardWidgetHeatmapDefinition']:
        """
        The definition for a Heatmap widget.
        """
        return pulumi.get(self, "heatmap_definition")

    @property
    @pulumi.getter(name="hostmapDefinition")
    def hostmap_definition(self) -> Optional['outputs.DashboardWidgetHostmapDefinition']:
        """
        The definition for a Hostmap widget.
        """
        return pulumi.get(self, "hostmap_definition")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        The ID of the widget.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="iframeDefinition")
    def iframe_definition(self) -> Optional['outputs.DashboardWidgetIframeDefinition']:
        """
        The definition for an Iframe widget.
        """
        return pulumi.get(self, "iframe_definition")

    @property
    @pulumi.getter(name="imageDefinition")
    def image_definition(self) -> Optional['outputs.DashboardWidgetImageDefinition']:
        """
        The definition for an Image widget
        """
        return pulumi.get(self, "image_definition")

    @property
    @pulumi.getter(name="listStreamDefinition")
    def list_stream_definition(self) -> Optional['outputs.DashboardWidgetListStreamDefinition']:
        """
        The definition for a List Stream widget.
        """
        return pulumi.get(self, "list_stream_definition")

    @property
    @pulumi.getter(name="logStreamDefinition")
    def log_stream_definition(self) -> Optional['outputs.DashboardWidgetLogStreamDefinition']:
        """
        The definition for an Log Stream widget.
        """
        return pulumi.get(self, "log_stream_definition")

    @property
    @pulumi.getter(name="manageStatusDefinition")
    def manage_status_definition(self) -> Optional['outputs.DashboardWidgetManageStatusDefinition']:
        """
        The definition for an Manage Status widget.
        """
        return pulumi.get(self, "manage_status_definition")

    @property
    @pulumi.getter(name="noteDefinition")
    def note_definition(self) -> Optional['outputs.DashboardWidgetNoteDefinition']:
        """
        The definition for a Note widget.
        """
        return pulumi.get(self, "note_definition")

    @property
    @pulumi.getter(name="powerpackDefinition")
    def powerpack_definition(self) -> Optional['outputs.DashboardWidgetPowerpackDefinition']:
        """
        The definition for a Powerpack widget.
        """
        return pulumi.get(self, "powerpack_definition")

    @property
    @pulumi.getter(name="queryTableDefinition")
    def query_table_definition(self) -> Optional['outputs.DashboardWidgetQueryTableDefinition']:
        """
        The definition for a Query Table widget.
        """
        return pulumi.get(self, "query_table_definition")

    @property
    @pulumi.getter(name="queryValueDefinition")
    def query_value_definition(self) -> Optional['outputs.DashboardWidgetQueryValueDefinition']:
        """
        The definition for a Query Value widget.
        """
        return pulumi.get(self, "query_value_definition")

    @property
    @pulumi.getter(name="runWorkflowDefinition")
    def run_workflow_definition(self) -> Optional['outputs.DashboardWidgetRunWorkflowDefinition']:
        """
        The definition for a Run Workflow widget.
        """
        return pulumi.get(self, "run_workflow_definition")

    @property
    @pulumi.getter(name="scatterplotDefinition")
    def scatterplot_definition(self) -> Optional['outputs.DashboardWidgetScatterplotDefinition']:
        """
        The definition for a Scatterplot widget.
        """
        return pulumi.get(self, "scatterplot_definition")

    @property
    @pulumi.getter(name="serviceLevelObjectiveDefinition")
    def service_level_objective_definition(self) -> Optional['outputs.DashboardWidgetServiceLevelObjectiveDefinition']:
        """
        The definition for a Service Level Objective widget.
        """
        return pulumi.get(self, "service_level_objective_definition")

    @property
    @pulumi.getter(name="servicemapDefinition")
    def servicemap_definition(self) -> Optional['outputs.DashboardWidgetServicemapDefinition']:
        """
        The definition for a Service Map widget.
        """
        return pulumi.get(self, "servicemap_definition")

    @property
    @pulumi.getter(name="sloListDefinition")
    def slo_list_definition(self) -> Optional['outputs.DashboardWidgetSloListDefinition']:
        """
        The definition for an SLO (Service Level Objective) List widget.
        """
        return pulumi.get(self, "slo_list_definition")

    @property
    @pulumi.getter(name="splitGraphDefinition")
    def split_graph_definition(self) -> Optional['outputs.DashboardWidgetSplitGraphDefinition']:
        """
        The definition for a Split Graph widget.
        """
        return pulumi.get(self, "split_graph_definition")

    @property
    @pulumi.getter(name="sunburstDefinition")
    def sunburst_definition(self) -> Optional['outputs.DashboardWidgetSunburstDefinition']:
        """
        The definition for a Sunburst widget.
        """
        return pulumi.get(self, "sunburst_definition")

    @property
    @pulumi.getter(name="timeseriesDefinition")
    def timeseries_definition(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinition']:
        """
        The definition for a Timeseries widget.
        """
        return pulumi.get(self, "timeseries_definition")

    @property
    @pulumi.getter(name="toplistDefinition")
    def toplist_definition(self) -> Optional['outputs.DashboardWidgetToplistDefinition']:
        """
        The definition for a Toplist widget.
        """
        return pulumi.get(self, "toplist_definition")

    @property
    @pulumi.getter(name="topologyMapDefinition")
    def topology_map_definition(self) -> Optional['outputs.DashboardWidgetTopologyMapDefinition']:
        """
        The definition for a Topology Map widget.
        """
        return pulumi.get(self, "topology_map_definition")

    @property
    @pulumi.getter(name="traceServiceDefinition")
    def trace_service_definition(self) -> Optional['outputs.DashboardWidgetTraceServiceDefinition']:
        """
        The definition for a Trace Service widget.
        """
        return pulumi.get(self, "trace_service_definition")

    @property
    @pulumi.getter(name="treemapDefinition")
    def treemap_definition(self) -> Optional['outputs.DashboardWidgetTreemapDefinition']:
        """
        The definition for a Treemap widget.
        """
        return pulumi.get(self, "treemap_definition")

    @property
    @pulumi.getter(name="widgetLayout")
    def widget_layout(self) -> Optional['outputs.DashboardWidgetWidgetLayout']:
        """
        The layout of the widget on a 'free' dashboard.
        """
        return pulumi.get(self, "widget_layout")


@pulumi.output_type
class DashboardWidgetAlertGraphDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertId":
            suggest = "alert_id"
        elif key == "vizType":
            suggest = "viz_type"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetAlertGraphDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetAlertGraphDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetAlertGraphDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_id: str,
                 viz_type: str,
                 live_span: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str alert_id: The ID of the monitor used by the widget.
        :param str viz_type: Type of visualization to use when displaying the widget. Valid values are `timeseries`, `toplist`.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "alert_id", alert_id)
        pulumi.set(__self__, "viz_type", viz_type)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        """
        The ID of the monitor used by the widget.
        """
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter(name="vizType")
    def viz_type(self) -> str:
        """
        Type of visualization to use when displaying the widget. Valid values are `timeseries`, `toplist`.
        """
        return pulumi.get(self, "viz_type")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetAlertValueDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertId":
            suggest = "alert_id"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetAlertValueDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetAlertValueDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetAlertValueDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_id: str,
                 precision: Optional[int] = None,
                 text_align: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 unit: Optional[str] = None):
        """
        :param str alert_id: The ID of the monitor used by the widget.
        :param int precision: The precision to use when displaying the value. Use `*` for maximum precision.
        :param str text_align: The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param str unit: The unit for the value displayed in the widget.
        """
        pulumi.set(__self__, "alert_id", alert_id)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        """
        The ID of the monitor used by the widget.
        """
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter
    def precision(self) -> Optional[int]:
        """
        The precision to use when displaying the value. Use `*` for maximum precision.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class DashboardWidgetApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetChangeDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetChangeDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence['DashboardWidgetChangeDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetChangeDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "changeType":
            suggest = "change_type"
        elif key == "compareTo":
            suggest = "compare_to"
        elif key == "increaseGood":
            suggest = "increase_good"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "orderBy":
            suggest = "order_by"
        elif key == "orderDir":
            suggest = "order_dir"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"
        elif key == "showPresent":
            suggest = "show_present"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetApmQuery'] = None,
                 change_type: Optional[str] = None,
                 compare_to: Optional[str] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestFormula']] = None,
                 increase_good: Optional[bool] = None,
                 log_query: Optional['outputs.DashboardWidgetLogQuery'] = None,
                 order_by: Optional[str] = None,
                 order_dir: Optional[str] = None,
                 process_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetSecurityQuery'] = None,
                 show_present: Optional[bool] = None):
        """
        :param 'DashboardWidgetApmQueryArgs' apm_query: The query to use for this widget.
        :param str change_type: Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
        :param str compare_to: Choose from when to compare current data to. Valid values are `hour_before`, `day_before`, `week_before`, `month_before`.
        :param bool increase_good: A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
        :param 'DashboardWidgetLogQueryArgs' log_query: The query to use for this widget.
        :param str order_by: What to order by. Valid values are `change`, `name`, `present`, `past`.
        :param str order_dir: Widget sorting method. Valid values are `asc`, `desc`.
        :param 'DashboardWidgetChangeDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetSecurityQueryArgs' security_query: The query to use for this widget.
        :param bool show_present: If set to `true`, displays the current value.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if compare_to is not None:
            pulumi.set(__self__, "compare_to", compare_to)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if increase_good is not None:
            pulumi.set(__self__, "increase_good", increase_good)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)
        if order_dir is not None:
            pulumi.set(__self__, "order_dir", order_dir)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if show_present is not None:
            pulumi.set(__self__, "show_present", show_present)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[str]:
        """
        Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
        """
        return pulumi.get(self, "change_type")

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[str]:
        """
        Choose from when to compare current data to. Valid values are `hour_before`, `day_before`, `week_before`, `month_before`.
        """
        return pulumi.get(self, "compare_to")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[bool]:
        """
        A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
        """
        return pulumi.get(self, "increase_good")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[str]:
        """
        What to order by. Valid values are `change`, `name`, `present`, `past`.
        """
        return pulumi.get(self, "order_by")

    @property
    @pulumi.getter(name="orderDir")
    def order_dir(self) -> Optional[str]:
        """
        Widget sorting method. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order_dir")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter(name="showPresent")
    def show_present(self) -> Optional[bool]:
        """
        If set to `true`, displays the current value.
        """
        return pulumi.get(self, "show_present")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetChangeDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetChangeDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetChangeDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetChangeDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'DashboardWidgetChangeDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetChangeDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetChangeDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'DashboardWidgetChangeDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetChangeDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetChangeDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'DashboardWidgetChangeDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetChangeDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetChangeDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetChangeDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetChangeDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetChangeDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetChangeDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetCheckStatusDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBies":
            suggest = "group_bies"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetCheckStatusDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetCheckStatusDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetCheckStatusDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check: str,
                 grouping: str,
                 group: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 live_span: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str check: The check to use in the widget.
        :param str grouping: The kind of grouping to use. Valid values are `check`, `cluster`.
        :param str group: The check group to use in the widget.
        :param Sequence[str] group_bies: When `grouping = "cluster"`, indicates a list of tags to use for grouping.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence[str] tags: A list of tags to use in the widget.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "check", check)
        pulumi.set(__self__, "grouping", grouping)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def check(self) -> str:
        """
        The check to use in the widget.
        """
        return pulumi.get(self, "check")

    @property
    @pulumi.getter
    def grouping(self) -> str:
        """
        The kind of grouping to use. Valid values are `check`, `cluster`.
        """
        return pulumi.get(self, "grouping")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        When `grouping = "cluster"`, indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        A list of tags to use in the widget.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetDistributionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 xaxis: Optional['outputs.DashboardWidgetDistributionDefinitionXaxis'] = None,
                 yaxis: Optional['outputs.DashboardWidgetDistributionDefinitionYaxis'] = None):
        """
        :param str legend_size: The size of the legend displayed in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence['DashboardWidgetDistributionDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param bool show_legend: Whether or not to show the legend on this widget.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param 'DashboardWidgetDistributionDefinitionXaxisArgs' xaxis: A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
        :param 'DashboardWidgetDistributionDefinitionYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if xaxis is not None:
            pulumi.set(__self__, "xaxis", xaxis)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def xaxis(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionXaxis']:
        """
        A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "xaxis")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionYaxis']:
        """
        A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "apmStatsQuery":
            suggest = "apm_stats_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetApmQuery'] = None,
                 apm_stats_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmStatsQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetDistributionDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetDistributionDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetDistributionDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'DashboardWidgetDistributionDefinitionRequestStyleArgs' style: The style of the widget graph. One nested block is allowed using the structure below.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if apm_stats_query is not None:
            pulumi.set(__self__, "apm_stats_query", apm_stats_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="apmStatsQuery")
    def apm_stats_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestApmStatsQuery']:
        return pulumi.get(self, "apm_stats_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetDistributionDefinitionRequestStyle']:
        """
        The style of the widget graph. One nested block is allowed using the structure below.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryTag":
            suggest = "primary_tag"
        elif key == "rowType":
            suggest = "row_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestApmStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env: str,
                 name: str,
                 primary_tag: str,
                 row_type: str,
                 service: str,
                 columns: Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn']] = None,
                 resource: Optional[str] = None):
        """
        :param str env: The environment name.
        :param str name: The operation name associated with the service.
        :param str primary_tag: The organization's host group name and value.
        :param str row_type: The level of detail for the request. Valid values are `service`, `resource`, `span`.
        :param str service: The service name.
        :param Sequence['DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumnArgs'] columns: Column properties used by the front end for display.
        :param str resource: The resource name.
        """
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary_tag", primary_tag)
        pulumi.set(__self__, "row_type", row_type)
        pulumi.set(__self__, "service", service)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        The environment name.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The operation name associated with the service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryTag")
    def primary_tag(self) -> str:
        """
        The organization's host group name and value.
        """
        return pulumi.get(self, "primary_tag")

    @property
    @pulumi.getter(name="rowType")
    def row_type(self) -> str:
        """
        The level of detail for the request. Valid values are `service`, `resource`, `span`.
        """
        return pulumi.get(self, "row_type")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The service name.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn']]:
        """
        Column properties used by the front end for display.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        The resource name.
        """
        return pulumi.get(self, "resource")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellDisplayMode":
            suggest = "cell_display_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str name: The column name.
        :param str alias: A user-assigned alias for the column.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The column name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        A user-assigned alias for the column.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionXaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionXaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionXaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionXaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetDistributionDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetDistributionDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetDistributionDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetDistributionDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetEventStreamDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventSize":
            suggest = "event_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "tagsExecution":
            suggest = "tags_execution"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetEventStreamDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetEventStreamDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetEventStreamDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 event_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 tags_execution: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str query: The query to use in the widget.
        :param str event_size: The size to use to display an event. Valid values are `s`, `l`.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param str tags_execution: The execution method for multi-value filters, options: `and` or `or`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "query", query)
        if event_size is not None:
            pulumi.set(__self__, "event_size", event_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[str]:
        """
        The size to use to display an event. Valid values are `s`, `l`.
        """
        return pulumi.get(self, "event_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        """
        The execution method for multi-value filters, options: `and` or `or`.
        """
        return pulumi.get(self, "tags_execution")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetEventTimelineDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"
        elif key == "tagsExecution":
            suggest = "tags_execution"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetEventTimelineDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetEventTimelineDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetEventTimelineDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 live_span: Optional[str] = None,
                 tags_execution: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str query: The query to use in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param str tags_execution: The execution method for multi-value filters, options: `and` or `or`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "query", query)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        """
        The execution method for multi-value filters, options: `and` or `or`.
        """
        return pulumi.get(self, "tags_execution")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetFreeTextDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontSize":
            suggest = "font_size"
        elif key == "textAlign":
            suggest = "text_align"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetFreeTextDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetFreeTextDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetFreeTextDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text: str,
                 color: Optional[str] = None,
                 font_size: Optional[str] = None,
                 text_align: Optional[str] = None):
        """
        :param str text: The text to display in the widget.
        :param str color: The color of the text in the widget.
        :param str font_size: The size of the text in the widget.
        :param str text_align: The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        pulumi.set(__self__, "text", text)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The text to display in the widget.
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        The color of the text in the widget.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")


@pulumi.output_type
class DashboardWidgetGeomapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 view: 'outputs.DashboardWidgetGeomapDefinitionView',
                 custom_links: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequest']] = None,
                 style: Optional['outputs.DashboardWidgetGeomapDefinitionStyle'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param 'DashboardWidgetGeomapDefinitionViewArgs' view: The view of the world that the map should render.
        :param Sequence['DashboardWidgetGeomapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence['DashboardWidgetGeomapDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
        :param 'DashboardWidgetGeomapDefinitionStyleArgs' style: The style of the widget graph. One nested block is allowed using the structure below.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "view", view)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def view(self) -> 'outputs.DashboardWidgetGeomapDefinitionView':
        """
        The view of the world that the map should render.
        """
        return pulumi.get(self, "view")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionStyle']:
        """
        The style of the widget graph. One nested block is allowed using the structure below.
        """
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logQuery":
            suggest = "log_query"
        elif key == "rumQuery":
            suggest = "rum_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formulas: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetLogQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetRumQuery'] = None):
        """
        :param 'DashboardWidgetLogQueryArgs' log_query: The query to use for this widget.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetRumQueryArgs' rum_query: The query to use for this widget.
        """
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetGeomapDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetGeomapDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetGeomapDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'DashboardWidgetGeomapDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetGeomapDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'DashboardWidgetGeomapDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetGeomapDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetGeomapDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'DashboardWidgetGeomapDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetGeomapDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteFlip":
            suggest = "palette_flip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGeomapDefinitionStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGeomapDefinitionStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGeomapDefinitionStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: str,
                 palette_flip: bool):
        """
        :param str palette: The color palette to apply to the widget.
        :param bool palette_flip: A Boolean indicating whether to flip the palette tones.
        """
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "palette_flip", palette_flip)

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply to the widget.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> bool:
        """
        A Boolean indicating whether to flip the palette tones.
        """
        return pulumi.get(self, "palette_flip")


@pulumi.output_type
class DashboardWidgetGeomapDefinitionView(dict):
    def __init__(__self__, *,
                 focus: str):
        """
        :param str focus: The two-letter ISO code of a country to focus the map on (or `WORLD`).
        """
        pulumi.set(__self__, "focus", focus)

    @property
    @pulumi.getter
    def focus(self) -> str:
        """
        The two-letter ISO code of a country to focus the map on (or `WORLD`).
        """
        return pulumi.get(self, "focus")


@pulumi.output_type
class DashboardWidgetGroupDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layoutType":
            suggest = "layout_type"
        elif key == "backgroundColor":
            suggest = "background_color"
        elif key == "bannerImg":
            suggest = "banner_img"
        elif key == "showTitle":
            suggest = "show_title"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layout_type: str,
                 background_color: Optional[str] = None,
                 banner_img: Optional[str] = None,
                 show_title: Optional[bool] = None,
                 title: Optional[str] = None,
                 widgets: Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidget']] = None):
        """
        :param str layout_type: The layout type of the group. Valid values are `ordered`.
        :param str background_color: The background color of the group title, options: `vivid_blue`, `vivid_purple`, `vivid_pink`, `vivid_orange`, `vivid_yellow`, `vivid_green`, `blue`, `purple`, `pink`, `orange`, `yellow`, `green`, `gray` or `white`
        :param str banner_img: The image URL to display as a banner for the group.
        :param bool show_title: Whether to show the title or not. Defaults to `true`.
        :param str title: The title of the group.
        :param Sequence['DashboardWidgetGroupDefinitionWidgetArgs'] widgets: The list of widgets in this group.
        """
        pulumi.set(__self__, "layout_type", layout_type)
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if banner_img is not None:
            pulumi.set(__self__, "banner_img", banner_img)
        if show_title is not None:
            pulumi.set(__self__, "show_title", show_title)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if widgets is not None:
            pulumi.set(__self__, "widgets", widgets)

    @property
    @pulumi.getter(name="layoutType")
    def layout_type(self) -> str:
        """
        The layout type of the group. Valid values are `ordered`.
        """
        return pulumi.get(self, "layout_type")

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        """
        The background color of the group title, options: `vivid_blue`, `vivid_purple`, `vivid_pink`, `vivid_orange`, `vivid_yellow`, `vivid_green`, `blue`, `purple`, `pink`, `orange`, `yellow`, `green`, `gray` or `white`
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="bannerImg")
    def banner_img(self) -> Optional[str]:
        """
        The image URL to display as a banner for the group.
        """
        return pulumi.get(self, "banner_img")

    @property
    @pulumi.getter(name="showTitle")
    def show_title(self) -> Optional[bool]:
        """
        Whether to show the title or not. Defaults to `true`.
        """
        return pulumi.get(self, "show_title")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the group.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter
    def widgets(self) -> Optional[Sequence['outputs.DashboardWidgetGroupDefinitionWidget']]:
        """
        The list of widgets in this group.
        """
        return pulumi.get(self, "widgets")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertGraphDefinition":
            suggest = "alert_graph_definition"
        elif key == "alertValueDefinition":
            suggest = "alert_value_definition"
        elif key == "changeDefinition":
            suggest = "change_definition"
        elif key == "checkStatusDefinition":
            suggest = "check_status_definition"
        elif key == "distributionDefinition":
            suggest = "distribution_definition"
        elif key == "eventStreamDefinition":
            suggest = "event_stream_definition"
        elif key == "eventTimelineDefinition":
            suggest = "event_timeline_definition"
        elif key == "freeTextDefinition":
            suggest = "free_text_definition"
        elif key == "geomapDefinition":
            suggest = "geomap_definition"
        elif key == "heatmapDefinition":
            suggest = "heatmap_definition"
        elif key == "hostmapDefinition":
            suggest = "hostmap_definition"
        elif key == "iframeDefinition":
            suggest = "iframe_definition"
        elif key == "imageDefinition":
            suggest = "image_definition"
        elif key == "listStreamDefinition":
            suggest = "list_stream_definition"
        elif key == "logStreamDefinition":
            suggest = "log_stream_definition"
        elif key == "manageStatusDefinition":
            suggest = "manage_status_definition"
        elif key == "noteDefinition":
            suggest = "note_definition"
        elif key == "powerpackDefinition":
            suggest = "powerpack_definition"
        elif key == "queryTableDefinition":
            suggest = "query_table_definition"
        elif key == "queryValueDefinition":
            suggest = "query_value_definition"
        elif key == "runWorkflowDefinition":
            suggest = "run_workflow_definition"
        elif key == "scatterplotDefinition":
            suggest = "scatterplot_definition"
        elif key == "serviceLevelObjectiveDefinition":
            suggest = "service_level_objective_definition"
        elif key == "servicemapDefinition":
            suggest = "servicemap_definition"
        elif key == "sloListDefinition":
            suggest = "slo_list_definition"
        elif key == "splitGraphDefinition":
            suggest = "split_graph_definition"
        elif key == "sunburstDefinition":
            suggest = "sunburst_definition"
        elif key == "timeseriesDefinition":
            suggest = "timeseries_definition"
        elif key == "toplistDefinition":
            suggest = "toplist_definition"
        elif key == "topologyMapDefinition":
            suggest = "topology_map_definition"
        elif key == "traceServiceDefinition":
            suggest = "trace_service_definition"
        elif key == "treemapDefinition":
            suggest = "treemap_definition"
        elif key == "widgetLayout":
            suggest = "widget_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_graph_definition: Optional['outputs.DashboardWidgetAlertGraphDefinition'] = None,
                 alert_value_definition: Optional['outputs.DashboardWidgetAlertValueDefinition'] = None,
                 change_definition: Optional['outputs.DashboardWidgetChangeDefinition'] = None,
                 check_status_definition: Optional['outputs.DashboardWidgetCheckStatusDefinition'] = None,
                 distribution_definition: Optional['outputs.DashboardWidgetDistributionDefinition'] = None,
                 event_stream_definition: Optional['outputs.DashboardWidgetEventStreamDefinition'] = None,
                 event_timeline_definition: Optional['outputs.DashboardWidgetEventTimelineDefinition'] = None,
                 free_text_definition: Optional['outputs.DashboardWidgetFreeTextDefinition'] = None,
                 geomap_definition: Optional['outputs.DashboardWidgetGeomapDefinition'] = None,
                 heatmap_definition: Optional['outputs.DashboardWidgetHeatmapDefinition'] = None,
                 hostmap_definition: Optional['outputs.DashboardWidgetHostmapDefinition'] = None,
                 id: Optional[int] = None,
                 iframe_definition: Optional['outputs.DashboardWidgetIframeDefinition'] = None,
                 image_definition: Optional['outputs.DashboardWidgetImageDefinition'] = None,
                 list_stream_definition: Optional['outputs.DashboardWidgetListStreamDefinition'] = None,
                 log_stream_definition: Optional['outputs.DashboardWidgetLogStreamDefinition'] = None,
                 manage_status_definition: Optional['outputs.DashboardWidgetManageStatusDefinition'] = None,
                 note_definition: Optional['outputs.DashboardWidgetNoteDefinition'] = None,
                 powerpack_definition: Optional['outputs.DashboardWidgetPowerpackDefinition'] = None,
                 query_table_definition: Optional['outputs.DashboardWidgetQueryTableDefinition'] = None,
                 query_value_definition: Optional['outputs.DashboardWidgetQueryValueDefinition'] = None,
                 run_workflow_definition: Optional['outputs.DashboardWidgetRunWorkflowDefinition'] = None,
                 scatterplot_definition: Optional['outputs.DashboardWidgetScatterplotDefinition'] = None,
                 service_level_objective_definition: Optional['outputs.DashboardWidgetServiceLevelObjectiveDefinition'] = None,
                 servicemap_definition: Optional['outputs.DashboardWidgetServicemapDefinition'] = None,
                 slo_list_definition: Optional['outputs.DashboardWidgetSloListDefinition'] = None,
                 split_graph_definition: Optional['outputs.DashboardWidgetSplitGraphDefinition'] = None,
                 sunburst_definition: Optional['outputs.DashboardWidgetSunburstDefinition'] = None,
                 timeseries_definition: Optional['outputs.DashboardWidgetTimeseriesDefinition'] = None,
                 toplist_definition: Optional['outputs.DashboardWidgetToplistDefinition'] = None,
                 topology_map_definition: Optional['outputs.DashboardWidgetTopologyMapDefinition'] = None,
                 trace_service_definition: Optional['outputs.DashboardWidgetTraceServiceDefinition'] = None,
                 treemap_definition: Optional['outputs.DashboardWidgetTreemapDefinition'] = None,
                 widget_layout: Optional['outputs.DashboardWidgetGroupDefinitionWidgetWidgetLayout'] = None):
        """
        :param 'DashboardWidgetAlertGraphDefinitionArgs' alert_graph_definition: The definition for a Alert Graph widget.
        :param 'DashboardWidgetAlertValueDefinitionArgs' alert_value_definition: The definition for a Alert Value widget.
        :param 'DashboardWidgetChangeDefinitionArgs' change_definition: The definition for a Change widget.
        :param 'DashboardWidgetCheckStatusDefinitionArgs' check_status_definition: The definition for a Check Status widget.
        :param 'DashboardWidgetDistributionDefinitionArgs' distribution_definition: The definition for a Distribution widget.
        :param 'DashboardWidgetEventStreamDefinitionArgs' event_stream_definition: The definition for a Event Stream widget.
        :param 'DashboardWidgetEventTimelineDefinitionArgs' event_timeline_definition: The definition for a Event Timeline widget.
        :param 'DashboardWidgetFreeTextDefinitionArgs' free_text_definition: The definition for a Free Text widget.
        :param 'DashboardWidgetGeomapDefinitionArgs' geomap_definition: The definition for a Geomap widget.
        :param 'DashboardWidgetHeatmapDefinitionArgs' heatmap_definition: The definition for a Heatmap widget.
        :param 'DashboardWidgetHostmapDefinitionArgs' hostmap_definition: The definition for a Hostmap widget.
        :param int id: The ID of the widget.
        :param 'DashboardWidgetIframeDefinitionArgs' iframe_definition: The definition for an Iframe widget.
        :param 'DashboardWidgetImageDefinitionArgs' image_definition: The definition for an Image widget
        :param 'DashboardWidgetListStreamDefinitionArgs' list_stream_definition: The definition for a List Stream widget.
        :param 'DashboardWidgetLogStreamDefinitionArgs' log_stream_definition: The definition for an Log Stream widget.
        :param 'DashboardWidgetManageStatusDefinitionArgs' manage_status_definition: The definition for an Manage Status widget.
        :param 'DashboardWidgetNoteDefinitionArgs' note_definition: The definition for a Note widget.
        :param 'DashboardWidgetPowerpackDefinitionArgs' powerpack_definition: The definition for a Powerpack widget.
        :param 'DashboardWidgetQueryTableDefinitionArgs' query_table_definition: The definition for a Query Table widget.
        :param 'DashboardWidgetQueryValueDefinitionArgs' query_value_definition: The definition for a Query Value widget.
        :param 'DashboardWidgetRunWorkflowDefinitionArgs' run_workflow_definition: The definition for a Run Workflow widget.
        :param 'DashboardWidgetScatterplotDefinitionArgs' scatterplot_definition: The definition for a Scatterplot widget.
        :param 'DashboardWidgetServiceLevelObjectiveDefinitionArgs' service_level_objective_definition: The definition for a Service Level Objective widget.
        :param 'DashboardWidgetServicemapDefinitionArgs' servicemap_definition: The definition for a Service Map widget.
        :param 'DashboardWidgetSloListDefinitionArgs' slo_list_definition: The definition for an SLO (Service Level Objective) List widget.
        :param 'DashboardWidgetSplitGraphDefinitionArgs' split_graph_definition: The definition for a Split Graph widget.
        :param 'DashboardWidgetSunburstDefinitionArgs' sunburst_definition: The definition for a Sunburst widget.
        :param 'DashboardWidgetTimeseriesDefinitionArgs' timeseries_definition: The definition for a Timeseries widget.
        :param 'DashboardWidgetToplistDefinitionArgs' toplist_definition: The definition for a Toplist widget.
        :param 'DashboardWidgetTopologyMapDefinitionArgs' topology_map_definition: The definition for a Topology Map widget.
        :param 'DashboardWidgetTraceServiceDefinitionArgs' trace_service_definition: The definition for a Trace Service widget.
        :param 'DashboardWidgetTreemapDefinitionArgs' treemap_definition: The definition for a Treemap widget.
        :param 'DashboardWidgetGroupDefinitionWidgetWidgetLayoutArgs' widget_layout: The layout of the widget on a 'free' dashboard.
        """
        if alert_graph_definition is not None:
            pulumi.set(__self__, "alert_graph_definition", alert_graph_definition)
        if alert_value_definition is not None:
            pulumi.set(__self__, "alert_value_definition", alert_value_definition)
        if change_definition is not None:
            pulumi.set(__self__, "change_definition", change_definition)
        if check_status_definition is not None:
            pulumi.set(__self__, "check_status_definition", check_status_definition)
        if distribution_definition is not None:
            pulumi.set(__self__, "distribution_definition", distribution_definition)
        if event_stream_definition is not None:
            pulumi.set(__self__, "event_stream_definition", event_stream_definition)
        if event_timeline_definition is not None:
            pulumi.set(__self__, "event_timeline_definition", event_timeline_definition)
        if free_text_definition is not None:
            pulumi.set(__self__, "free_text_definition", free_text_definition)
        if geomap_definition is not None:
            pulumi.set(__self__, "geomap_definition", geomap_definition)
        if heatmap_definition is not None:
            pulumi.set(__self__, "heatmap_definition", heatmap_definition)
        if hostmap_definition is not None:
            pulumi.set(__self__, "hostmap_definition", hostmap_definition)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if iframe_definition is not None:
            pulumi.set(__self__, "iframe_definition", iframe_definition)
        if image_definition is not None:
            pulumi.set(__self__, "image_definition", image_definition)
        if list_stream_definition is not None:
            pulumi.set(__self__, "list_stream_definition", list_stream_definition)
        if log_stream_definition is not None:
            pulumi.set(__self__, "log_stream_definition", log_stream_definition)
        if manage_status_definition is not None:
            pulumi.set(__self__, "manage_status_definition", manage_status_definition)
        if note_definition is not None:
            pulumi.set(__self__, "note_definition", note_definition)
        if powerpack_definition is not None:
            pulumi.set(__self__, "powerpack_definition", powerpack_definition)
        if query_table_definition is not None:
            pulumi.set(__self__, "query_table_definition", query_table_definition)
        if query_value_definition is not None:
            pulumi.set(__self__, "query_value_definition", query_value_definition)
        if run_workflow_definition is not None:
            pulumi.set(__self__, "run_workflow_definition", run_workflow_definition)
        if scatterplot_definition is not None:
            pulumi.set(__self__, "scatterplot_definition", scatterplot_definition)
        if service_level_objective_definition is not None:
            pulumi.set(__self__, "service_level_objective_definition", service_level_objective_definition)
        if servicemap_definition is not None:
            pulumi.set(__self__, "servicemap_definition", servicemap_definition)
        if slo_list_definition is not None:
            pulumi.set(__self__, "slo_list_definition", slo_list_definition)
        if split_graph_definition is not None:
            pulumi.set(__self__, "split_graph_definition", split_graph_definition)
        if sunburst_definition is not None:
            pulumi.set(__self__, "sunburst_definition", sunburst_definition)
        if timeseries_definition is not None:
            pulumi.set(__self__, "timeseries_definition", timeseries_definition)
        if toplist_definition is not None:
            pulumi.set(__self__, "toplist_definition", toplist_definition)
        if topology_map_definition is not None:
            pulumi.set(__self__, "topology_map_definition", topology_map_definition)
        if trace_service_definition is not None:
            pulumi.set(__self__, "trace_service_definition", trace_service_definition)
        if treemap_definition is not None:
            pulumi.set(__self__, "treemap_definition", treemap_definition)
        if widget_layout is not None:
            pulumi.set(__self__, "widget_layout", widget_layout)

    @property
    @pulumi.getter(name="alertGraphDefinition")
    def alert_graph_definition(self) -> Optional['outputs.DashboardWidgetAlertGraphDefinition']:
        """
        The definition for a Alert Graph widget.
        """
        return pulumi.get(self, "alert_graph_definition")

    @property
    @pulumi.getter(name="alertValueDefinition")
    def alert_value_definition(self) -> Optional['outputs.DashboardWidgetAlertValueDefinition']:
        """
        The definition for a Alert Value widget.
        """
        return pulumi.get(self, "alert_value_definition")

    @property
    @pulumi.getter(name="changeDefinition")
    def change_definition(self) -> Optional['outputs.DashboardWidgetChangeDefinition']:
        """
        The definition for a Change widget.
        """
        return pulumi.get(self, "change_definition")

    @property
    @pulumi.getter(name="checkStatusDefinition")
    def check_status_definition(self) -> Optional['outputs.DashboardWidgetCheckStatusDefinition']:
        """
        The definition for a Check Status widget.
        """
        return pulumi.get(self, "check_status_definition")

    @property
    @pulumi.getter(name="distributionDefinition")
    def distribution_definition(self) -> Optional['outputs.DashboardWidgetDistributionDefinition']:
        """
        The definition for a Distribution widget.
        """
        return pulumi.get(self, "distribution_definition")

    @property
    @pulumi.getter(name="eventStreamDefinition")
    def event_stream_definition(self) -> Optional['outputs.DashboardWidgetEventStreamDefinition']:
        """
        The definition for a Event Stream widget.
        """
        return pulumi.get(self, "event_stream_definition")

    @property
    @pulumi.getter(name="eventTimelineDefinition")
    def event_timeline_definition(self) -> Optional['outputs.DashboardWidgetEventTimelineDefinition']:
        """
        The definition for a Event Timeline widget.
        """
        return pulumi.get(self, "event_timeline_definition")

    @property
    @pulumi.getter(name="freeTextDefinition")
    def free_text_definition(self) -> Optional['outputs.DashboardWidgetFreeTextDefinition']:
        """
        The definition for a Free Text widget.
        """
        return pulumi.get(self, "free_text_definition")

    @property
    @pulumi.getter(name="geomapDefinition")
    def geomap_definition(self) -> Optional['outputs.DashboardWidgetGeomapDefinition']:
        """
        The definition for a Geomap widget.
        """
        return pulumi.get(self, "geomap_definition")

    @property
    @pulumi.getter(name="heatmapDefinition")
    def heatmap_definition(self) -> Optional['outputs.DashboardWidgetHeatmapDefinition']:
        """
        The definition for a Heatmap widget.
        """
        return pulumi.get(self, "heatmap_definition")

    @property
    @pulumi.getter(name="hostmapDefinition")
    def hostmap_definition(self) -> Optional['outputs.DashboardWidgetHostmapDefinition']:
        """
        The definition for a Hostmap widget.
        """
        return pulumi.get(self, "hostmap_definition")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        The ID of the widget.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="iframeDefinition")
    def iframe_definition(self) -> Optional['outputs.DashboardWidgetIframeDefinition']:
        """
        The definition for an Iframe widget.
        """
        return pulumi.get(self, "iframe_definition")

    @property
    @pulumi.getter(name="imageDefinition")
    def image_definition(self) -> Optional['outputs.DashboardWidgetImageDefinition']:
        """
        The definition for an Image widget
        """
        return pulumi.get(self, "image_definition")

    @property
    @pulumi.getter(name="listStreamDefinition")
    def list_stream_definition(self) -> Optional['outputs.DashboardWidgetListStreamDefinition']:
        """
        The definition for a List Stream widget.
        """
        return pulumi.get(self, "list_stream_definition")

    @property
    @pulumi.getter(name="logStreamDefinition")
    def log_stream_definition(self) -> Optional['outputs.DashboardWidgetLogStreamDefinition']:
        """
        The definition for an Log Stream widget.
        """
        return pulumi.get(self, "log_stream_definition")

    @property
    @pulumi.getter(name="manageStatusDefinition")
    def manage_status_definition(self) -> Optional['outputs.DashboardWidgetManageStatusDefinition']:
        """
        The definition for an Manage Status widget.
        """
        return pulumi.get(self, "manage_status_definition")

    @property
    @pulumi.getter(name="noteDefinition")
    def note_definition(self) -> Optional['outputs.DashboardWidgetNoteDefinition']:
        """
        The definition for a Note widget.
        """
        return pulumi.get(self, "note_definition")

    @property
    @pulumi.getter(name="powerpackDefinition")
    def powerpack_definition(self) -> Optional['outputs.DashboardWidgetPowerpackDefinition']:
        """
        The definition for a Powerpack widget.
        """
        return pulumi.get(self, "powerpack_definition")

    @property
    @pulumi.getter(name="queryTableDefinition")
    def query_table_definition(self) -> Optional['outputs.DashboardWidgetQueryTableDefinition']:
        """
        The definition for a Query Table widget.
        """
        return pulumi.get(self, "query_table_definition")

    @property
    @pulumi.getter(name="queryValueDefinition")
    def query_value_definition(self) -> Optional['outputs.DashboardWidgetQueryValueDefinition']:
        """
        The definition for a Query Value widget.
        """
        return pulumi.get(self, "query_value_definition")

    @property
    @pulumi.getter(name="runWorkflowDefinition")
    def run_workflow_definition(self) -> Optional['outputs.DashboardWidgetRunWorkflowDefinition']:
        """
        The definition for a Run Workflow widget.
        """
        return pulumi.get(self, "run_workflow_definition")

    @property
    @pulumi.getter(name="scatterplotDefinition")
    def scatterplot_definition(self) -> Optional['outputs.DashboardWidgetScatterplotDefinition']:
        """
        The definition for a Scatterplot widget.
        """
        return pulumi.get(self, "scatterplot_definition")

    @property
    @pulumi.getter(name="serviceLevelObjectiveDefinition")
    def service_level_objective_definition(self) -> Optional['outputs.DashboardWidgetServiceLevelObjectiveDefinition']:
        """
        The definition for a Service Level Objective widget.
        """
        return pulumi.get(self, "service_level_objective_definition")

    @property
    @pulumi.getter(name="servicemapDefinition")
    def servicemap_definition(self) -> Optional['outputs.DashboardWidgetServicemapDefinition']:
        """
        The definition for a Service Map widget.
        """
        return pulumi.get(self, "servicemap_definition")

    @property
    @pulumi.getter(name="sloListDefinition")
    def slo_list_definition(self) -> Optional['outputs.DashboardWidgetSloListDefinition']:
        """
        The definition for an SLO (Service Level Objective) List widget.
        """
        return pulumi.get(self, "slo_list_definition")

    @property
    @pulumi.getter(name="splitGraphDefinition")
    def split_graph_definition(self) -> Optional['outputs.DashboardWidgetSplitGraphDefinition']:
        """
        The definition for a Split Graph widget.
        """
        return pulumi.get(self, "split_graph_definition")

    @property
    @pulumi.getter(name="sunburstDefinition")
    def sunburst_definition(self) -> Optional['outputs.DashboardWidgetSunburstDefinition']:
        """
        The definition for a Sunburst widget.
        """
        return pulumi.get(self, "sunburst_definition")

    @property
    @pulumi.getter(name="timeseriesDefinition")
    def timeseries_definition(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinition']:
        """
        The definition for a Timeseries widget.
        """
        return pulumi.get(self, "timeseries_definition")

    @property
    @pulumi.getter(name="toplistDefinition")
    def toplist_definition(self) -> Optional['outputs.DashboardWidgetToplistDefinition']:
        """
        The definition for a Toplist widget.
        """
        return pulumi.get(self, "toplist_definition")

    @property
    @pulumi.getter(name="topologyMapDefinition")
    def topology_map_definition(self) -> Optional['outputs.DashboardWidgetTopologyMapDefinition']:
        """
        The definition for a Topology Map widget.
        """
        return pulumi.get(self, "topology_map_definition")

    @property
    @pulumi.getter(name="traceServiceDefinition")
    def trace_service_definition(self) -> Optional['outputs.DashboardWidgetTraceServiceDefinition']:
        """
        The definition for a Trace Service widget.
        """
        return pulumi.get(self, "trace_service_definition")

    @property
    @pulumi.getter(name="treemapDefinition")
    def treemap_definition(self) -> Optional['outputs.DashboardWidgetTreemapDefinition']:
        """
        The definition for a Treemap widget.
        """
        return pulumi.get(self, "treemap_definition")

    @property
    @pulumi.getter(name="widgetLayout")
    def widget_layout(self) -> Optional['outputs.DashboardWidgetGroupDefinitionWidgetWidgetLayout']:
        """
        The layout of the widget on a 'free' dashboard.
        """
        return pulumi.get(self, "widget_layout")


@pulumi.output_type
class DashboardWidgetGroupDefinitionWidgetWidgetLayout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isColumnBreak":
            suggest = "is_column_break"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetGroupDefinitionWidgetWidgetLayout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetGroupDefinitionWidgetWidgetLayout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetGroupDefinitionWidgetWidgetLayout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 height: int,
                 width: int,
                 x: int,
                 y: int,
                 is_column_break: Optional[bool] = None):
        """
        :param int height: The height of the widget.
        :param int width: The width of the widget.
        :param int x: The position of the widget on the x (horizontal) axis. Must be greater than or equal to 0.
        :param int y: The position of the widget on the y (vertical) axis. Must be greater than or equal to 0.
        :param bool is_column_break: Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
        """
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "width", width)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)
        if is_column_break is not None:
            pulumi.set(__self__, "is_column_break", is_column_break)

    @property
    @pulumi.getter
    def height(self) -> int:
        """
        The height of the widget.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> int:
        """
        The width of the widget.
        """
        return pulumi.get(self, "width")

    @property
    @pulumi.getter
    def x(self) -> int:
        """
        The position of the widget on the x (horizontal) axis. Must be greater than or equal to 0.
        """
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> int:
        """
        The position of the widget on the y (vertical) axis. Must be greater than or equal to 0.
        """
        return pulumi.get(self, "y")

    @property
    @pulumi.getter(name="isColumnBreak")
    def is_column_break(self) -> Optional[bool]:
        """
        Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
        """
        return pulumi.get(self, "is_column_break")


@pulumi.output_type
class DashboardWidgetHeatmapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionCustomLink']] = None,
                 events: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionEvent']] = None,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 yaxis: Optional['outputs.DashboardWidgetHeatmapDefinitionYaxis'] = None):
        """
        :param Sequence['DashboardWidgetHeatmapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetHeatmapDefinitionEventArgs'] events: The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        :param str legend_size: The size of the legend displayed in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence['DashboardWidgetHeatmapDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param bool show_legend: Whether or not to show the legend on this widget.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param 'DashboardWidgetHeatmapDefinitionYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionEvent']]:
        """
        The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionYaxis']:
        """
        A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagsExecution":
            suggest = "tags_execution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 q: str,
                 tags_execution: Optional[str] = None):
        """
        :param str q: The event query to use in the widget.
        :param str tags_execution: The execution method for multi-value filters.
        """
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> str:
        """
        The event query to use in the widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        """
        The execution method for multi-value filters.
        """
        return pulumi.get(self, "tags_execution")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetApmQuery'] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetHeatmapDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'DashboardWidgetHeatmapDefinitionRequestStyleArgs' style: The style of the widget graph. One nested block is allowed using the structure below.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestStyle']:
        """
        The style of the widget graph. One nested block is allowed using the structure below.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetHeatmapDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'DashboardWidgetHeatmapDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'DashboardWidgetHeatmapDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetHeatmapDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetHeatmapDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'DashboardWidgetHeatmapDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetHeatmapDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetHeatmapDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHeatmapDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHeatmapDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHeatmapDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetHostmapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "noGroupHosts":
            suggest = "no_group_hosts"
        elif key == "noMetricHosts":
            suggest = "no_metric_hosts"
        elif key == "nodeType":
            suggest = "node_type"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionCustomLink']] = None,
                 groups: Optional[Sequence[str]] = None,
                 no_group_hosts: Optional[bool] = None,
                 no_metric_hosts: Optional[bool] = None,
                 node_type: Optional[str] = None,
                 request: Optional['outputs.DashboardWidgetHostmapDefinitionRequest'] = None,
                 scopes: Optional[Sequence[str]] = None,
                 style: Optional['outputs.DashboardWidgetHostmapDefinitionStyle'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetHostmapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence[str] groups: The list of tags to group nodes by.
        :param bool no_group_hosts: A Boolean indicating whether to show ungrouped nodes.
        :param bool no_metric_hosts: A Boolean indicating whether to show nodes with no metrics.
        :param str node_type: The type of node used. Valid values are `host`, `container`.
        :param 'DashboardWidgetHostmapDefinitionRequestArgs' request: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below.
        :param Sequence[str] scopes: The list of tags to filter nodes by.
        :param 'DashboardWidgetHostmapDefinitionStyleArgs' style: The style of the widget graph. One nested block is allowed using the structure below.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if no_group_hosts is not None:
            pulumi.set(__self__, "no_group_hosts", no_group_hosts)
        if no_metric_hosts is not None:
            pulumi.set(__self__, "no_metric_hosts", no_metric_hosts)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        """
        The list of tags to group nodes by.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="noGroupHosts")
    def no_group_hosts(self) -> Optional[bool]:
        """
        A Boolean indicating whether to show ungrouped nodes.
        """
        return pulumi.get(self, "no_group_hosts")

    @property
    @pulumi.getter(name="noMetricHosts")
    def no_metric_hosts(self) -> Optional[bool]:
        """
        A Boolean indicating whether to show nodes with no metrics.
        """
        return pulumi.get(self, "no_metric_hosts")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[str]:
        """
        The type of node used. Valid values are `host`, `container`.
        """
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequest']:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        The list of tags to filter nodes by.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionStyle']:
        """
        The style of the widget graph. One nested block is allowed using the structure below.
        """
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequest(dict):
    def __init__(__self__, *,
                 fills: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFill']] = None,
                 sizes: Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSize']] = None):
        """
        :param Sequence['DashboardWidgetHostmapDefinitionRequestFillArgs'] fills: The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param Sequence['DashboardWidgetHostmapDefinitionRequestSizeArgs'] sizes: The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        if fills is not None:
            pulumi.set(__self__, "fills", fills)
        if sizes is not None:
            pulumi.set(__self__, "sizes", sizes)

    @property
    @pulumi.getter
    def fills(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestFill']]:
        """
        The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "fills")

    @property
    @pulumi.getter
    def sizes(self) -> Optional[Sequence['outputs.DashboardWidgetHostmapDefinitionRequestSize']]:
        """
        The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "sizes")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFill(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFill. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFill.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFill.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetSecurityQuery'] = None):
        """
        :param 'DashboardWidgetApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetHostmapDefinitionRequestFillProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetSecurityQueryArgs' security_query: The query to use for this widget.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestFillProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestFillProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestFillProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestFillProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSize(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSize. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSize.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSize.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetSecurityQuery'] = None):
        """
        :param 'DashboardWidgetApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetHostmapDefinitionRequestSizeProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetSecurityQueryArgs' security_query: The query to use for this widget.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetHostmapDefinitionRequestSizeProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionRequestSizeProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionRequestSizeProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionRequestSizeProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetHostmapDefinitionStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fillMax":
            suggest = "fill_max"
        elif key == "fillMin":
            suggest = "fill_min"
        elif key == "paletteFlip":
            suggest = "palette_flip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetHostmapDefinitionStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetHostmapDefinitionStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetHostmapDefinitionStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fill_max: Optional[str] = None,
                 fill_min: Optional[str] = None,
                 palette: Optional[str] = None,
                 palette_flip: Optional[bool] = None):
        """
        :param str fill_max: The max value to use to color the map.
        :param str fill_min: The min value to use to color the map.
        :param str palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        :param bool palette_flip: A Boolean indicating whether to flip the palette tones.
        """
        if fill_max is not None:
            pulumi.set(__self__, "fill_max", fill_max)
        if fill_min is not None:
            pulumi.set(__self__, "fill_min", fill_min)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_flip is not None:
            pulumi.set(__self__, "palette_flip", palette_flip)

    @property
    @pulumi.getter(name="fillMax")
    def fill_max(self) -> Optional[str]:
        """
        The max value to use to color the map.
        """
        return pulumi.get(self, "fill_max")

    @property
    @pulumi.getter(name="fillMin")
    def fill_min(self) -> Optional[str]:
        """
        The min value to use to color the map.
        """
        return pulumi.get(self, "fill_min")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> Optional[bool]:
        """
        A Boolean indicating whether to flip the palette tones.
        """
        return pulumi.get(self, "palette_flip")


@pulumi.output_type
class DashboardWidgetIframeDefinition(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: The URL to use as a data source for the widget.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL to use as a data source for the widget.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class DashboardWidgetImageDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hasBackground":
            suggest = "has_background"
        elif key == "hasBorder":
            suggest = "has_border"
        elif key == "horizontalAlign":
            suggest = "horizontal_align"
        elif key == "urlDarkTheme":
            suggest = "url_dark_theme"
        elif key == "verticalAlign":
            suggest = "vertical_align"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetImageDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetImageDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetImageDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 has_background: Optional[bool] = None,
                 has_border: Optional[bool] = None,
                 horizontal_align: Optional[str] = None,
                 margin: Optional[str] = None,
                 sizing: Optional[str] = None,
                 url_dark_theme: Optional[str] = None,
                 vertical_align: Optional[str] = None):
        """
        :param str url: The URL to use as a data source for the widget.
        :param bool has_background: Whether to display a background or not. Defaults to `true`.
        :param bool has_border: Whether to display a border or not. Defaults to `true`.
        :param str horizontal_align: The horizontal alignment for the widget. Valid values are `center`, `left`, `right`.
        :param str margin: The margins to use around the image. Note: `small` and `large` values are deprecated. Valid values are `sm`, `md`, `lg`, `small`, `large`.
        :param str sizing: The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated. Valid values are `fill`, `contain`, `cover`, `none`, `scale-down`, `zoom`, `fit`, `center`.
        :param str url_dark_theme: The URL in dark mode to use as a data source for the widget.
        :param str vertical_align: The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        pulumi.set(__self__, "url", url)
        if has_background is not None:
            pulumi.set(__self__, "has_background", has_background)
        if has_border is not None:
            pulumi.set(__self__, "has_border", has_border)
        if horizontal_align is not None:
            pulumi.set(__self__, "horizontal_align", horizontal_align)
        if margin is not None:
            pulumi.set(__self__, "margin", margin)
        if sizing is not None:
            pulumi.set(__self__, "sizing", sizing)
        if url_dark_theme is not None:
            pulumi.set(__self__, "url_dark_theme", url_dark_theme)
        if vertical_align is not None:
            pulumi.set(__self__, "vertical_align", vertical_align)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL to use as a data source for the widget.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="hasBackground")
    def has_background(self) -> Optional[bool]:
        """
        Whether to display a background or not. Defaults to `true`.
        """
        return pulumi.get(self, "has_background")

    @property
    @pulumi.getter(name="hasBorder")
    def has_border(self) -> Optional[bool]:
        """
        Whether to display a border or not. Defaults to `true`.
        """
        return pulumi.get(self, "has_border")

    @property
    @pulumi.getter(name="horizontalAlign")
    def horizontal_align(self) -> Optional[str]:
        """
        The horizontal alignment for the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "horizontal_align")

    @property
    @pulumi.getter
    def margin(self) -> Optional[str]:
        """
        The margins to use around the image. Note: `small` and `large` values are deprecated. Valid values are `sm`, `md`, `lg`, `small`, `large`.
        """
        return pulumi.get(self, "margin")

    @property
    @pulumi.getter
    def sizing(self) -> Optional[str]:
        """
        The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated. Valid values are `fill`, `contain`, `cover`, `none`, `scale-down`, `zoom`, `fit`, `center`.
        """
        return pulumi.get(self, "sizing")

    @property
    @pulumi.getter(name="urlDarkTheme")
    def url_dark_theme(self) -> Optional[str]:
        """
        The URL in dark mode to use as a data source for the widget.
        """
        return pulumi.get(self, "url_dark_theme")

    @property
    @pulumi.getter(name="verticalAlign")
    def vertical_align(self) -> Optional[str]:
        """
        The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        return pulumi.get(self, "vertical_align")


@pulumi.output_type
class DashboardWidgetListStreamDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetListStreamDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetListStreamDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetListStreamDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 requests: Sequence['outputs.DashboardWidgetListStreamDefinitionRequest'],
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetListStreamDefinitionRequestArgs'] requests: Nested block describing the requests to use when displaying the widget. Multiple `request` blocks are allowed with the structure below.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title. Default is 16.
        """
        pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> Sequence['outputs.DashboardWidgetListStreamDefinitionRequest']:
        """
        Nested block describing the requests to use when displaying the widget. Multiple `request` blocks are allowed with the structure below.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title. Default is 16.
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetListStreamDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseFormat":
            suggest = "response_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetListStreamDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetListStreamDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetListStreamDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Sequence['outputs.DashboardWidgetListStreamDefinitionRequestColumn'],
                 query: 'outputs.DashboardWidgetListStreamDefinitionRequestQuery',
                 response_format: str):
        """
        :param Sequence['DashboardWidgetListStreamDefinitionRequestColumnArgs'] columns: Widget columns.
        :param 'DashboardWidgetListStreamDefinitionRequestQueryArgs' query: Updated list stream widget.
        :param str response_format: Widget response format. Valid values are `event_list`.
        """
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "response_format", response_format)

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.DashboardWidgetListStreamDefinitionRequestColumn']:
        """
        Widget columns.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def query(self) -> 'outputs.DashboardWidgetListStreamDefinitionRequestQuery':
        """
        Updated list stream widget.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="responseFormat")
    def response_format(self) -> str:
        """
        Widget response format. Valid values are `event_list`.
        """
        return pulumi.get(self, "response_format")


@pulumi.output_type
class DashboardWidgetListStreamDefinitionRequestColumn(dict):
    def __init__(__self__, *,
                 field: str,
                 width: str):
        """
        :param str field: Widget column field.
        :param str width: Widget column width. Valid values are `auto`, `compact`, `full`.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Widget column field.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def width(self) -> str:
        """
        Widget column width. Valid values are `auto`, `compact`, `full`.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class DashboardWidgetListStreamDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "eventSize":
            suggest = "event_size"
        elif key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetListStreamDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetListStreamDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetListStreamDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 event_size: Optional[str] = None,
                 indexes: Optional[Sequence[str]] = None,
                 query_string: Optional[str] = None,
                 sort: Optional['outputs.DashboardWidgetListStreamDefinitionRequestQuerySort'] = None,
                 storage: Optional[str] = None):
        """
        :param str data_source: Source from which to query items to display in the stream. Valid values are `logs_stream`, `audit_stream`, `ci_pipeline_stream`, `ci_test_stream`, `rum_issue_stream`, `apm_issue_stream`, `trace_stream`, `logs_issue_stream`, `logs_pattern_stream`, `logs_transaction_stream`, `event_stream`, `rum_stream`, `llm_observability_stream`.
        :param str event_size: Size of events displayed in widget. Required if `data_source` is `event_stream`. Valid values are `s`, `l`.
        :param Sequence[str] indexes: List of indexes.
        :param str query_string: Widget query.
        :param 'DashboardWidgetListStreamDefinitionRequestQuerySortArgs' sort: The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "data_source", data_source)
        if event_size is not None:
            pulumi.set(__self__, "event_size", event_size)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        Source from which to query items to display in the stream. Valid values are `logs_stream`, `audit_stream`, `ci_pipeline_stream`, `ci_test_stream`, `rum_issue_stream`, `apm_issue_stream`, `trace_stream`, `logs_issue_stream`, `logs_pattern_stream`, `logs_transaction_stream`, `event_stream`, `rum_stream`, `llm_observability_stream`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[str]:
        """
        Size of events displayed in widget. Required if `data_source` is `event_stream`. Valid values are `s`, `l`.
        """
        return pulumi.get(self, "event_size")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        List of indexes.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[str]:
        """
        Widget query.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetListStreamDefinitionRequestQuerySort']:
        """
        The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetListStreamDefinitionRequestQuerySort(dict):
    def __init__(__self__, *,
                 column: str,
                 order: str):
        """
        :param str column: The facet path for the column.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetLogStreamDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"
        elif key == "messageDisplay":
            suggest = "message_display"
        elif key == "showDateColumn":
            suggest = "show_date_column"
        elif key == "showMessageColumn":
            suggest = "show_message_column"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetLogStreamDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetLogStreamDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetLogStreamDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Optional[Sequence[str]] = None,
                 indexes: Optional[Sequence[str]] = None,
                 live_span: Optional[str] = None,
                 message_display: Optional[str] = None,
                 query: Optional[str] = None,
                 show_date_column: Optional[bool] = None,
                 show_message_column: Optional[bool] = None,
                 sort: Optional['outputs.DashboardWidgetLogStreamDefinitionSort'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence[str] columns: Stringified list of columns to use, for example: `["column1","column2","column3"]`.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param str message_display: The number of log lines to display. Valid values are `inline`, `expanded-md`, `expanded-lg`.
        :param str query: The query to use in the widget.
        :param bool show_date_column: If the date column should be displayed.
        :param bool show_message_column: If the message column should be displayed.
        :param 'DashboardWidgetLogStreamDefinitionSortArgs' sort: The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if message_display is not None:
            pulumi.set(__self__, "message_display", message_display)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if show_date_column is not None:
            pulumi.set(__self__, "show_date_column", show_date_column)
        if show_message_column is not None:
            pulumi.set(__self__, "show_message_column", show_message_column)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence[str]]:
        """
        Stringified list of columns to use, for example: `["column1","column2","column3"]`.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="messageDisplay")
    def message_display(self) -> Optional[str]:
        """
        The number of log lines to display. Valid values are `inline`, `expanded-md`, `expanded-lg`.
        """
        return pulumi.get(self, "message_display")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="showDateColumn")
    def show_date_column(self) -> Optional[bool]:
        """
        If the date column should be displayed.
        """
        return pulumi.get(self, "show_date_column")

    @property
    @pulumi.getter(name="showMessageColumn")
    def show_message_column(self) -> Optional[bool]:
        """
        If the message column should be displayed.
        """
        return pulumi.get(self, "show_message_column")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetLogStreamDefinitionSort']:
        """
        The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetLogStreamDefinitionSort(dict):
    def __init__(__self__, *,
                 column: str,
                 order: str):
        """
        :param str column: The facet path for the column.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetManageStatusDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorPreference":
            suggest = "color_preference"
        elif key == "displayFormat":
            suggest = "display_format"
        elif key == "hideZeroCounts":
            suggest = "hide_zero_counts"
        elif key == "showLastTriggered":
            suggest = "show_last_triggered"
        elif key == "showPriority":
            suggest = "show_priority"
        elif key == "summaryType":
            suggest = "summary_type"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetManageStatusDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetManageStatusDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetManageStatusDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 color_preference: Optional[str] = None,
                 display_format: Optional[str] = None,
                 hide_zero_counts: Optional[bool] = None,
                 show_last_triggered: Optional[bool] = None,
                 show_priority: Optional[bool] = None,
                 sort: Optional[str] = None,
                 summary_type: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str query: The query to use in the widget.
        :param str color_preference: Whether to colorize text or background. Valid values are `background`, `text`.
        :param str display_format: The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
        :param bool hide_zero_counts: A Boolean indicating whether to hide empty categories.
        :param bool show_last_triggered: A Boolean indicating whether to show when monitors/groups last triggered.
        :param bool show_priority: Whether to show the priorities column.
        :param str sort: The method to sort the monitors. Valid values are `name`, `group`, `status`, `tags`, `triggered`, `group,asc`, `group,desc`, `name,asc`, `name,desc`, `status,asc`, `status,desc`, `tags,asc`, `tags,desc`, `triggered,asc`, `triggered,desc`, `priority,asc`, `priority,desc`.
        :param str summary_type: The summary type to use. Valid values are `monitors`, `groups`, `combined`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "query", query)
        if color_preference is not None:
            pulumi.set(__self__, "color_preference", color_preference)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if hide_zero_counts is not None:
            pulumi.set(__self__, "hide_zero_counts", hide_zero_counts)
        if show_last_triggered is not None:
            pulumi.set(__self__, "show_last_triggered", show_last_triggered)
        if show_priority is not None:
            pulumi.set(__self__, "show_priority", show_priority)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if summary_type is not None:
            pulumi.set(__self__, "summary_type", summary_type)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="colorPreference")
    def color_preference(self) -> Optional[str]:
        """
        Whether to colorize text or background. Valid values are `background`, `text`.
        """
        return pulumi.get(self, "color_preference")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        """
        The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
        """
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter(name="hideZeroCounts")
    def hide_zero_counts(self) -> Optional[bool]:
        """
        A Boolean indicating whether to hide empty categories.
        """
        return pulumi.get(self, "hide_zero_counts")

    @property
    @pulumi.getter(name="showLastTriggered")
    def show_last_triggered(self) -> Optional[bool]:
        """
        A Boolean indicating whether to show when monitors/groups last triggered.
        """
        return pulumi.get(self, "show_last_triggered")

    @property
    @pulumi.getter(name="showPriority")
    def show_priority(self) -> Optional[bool]:
        """
        Whether to show the priorities column.
        """
        return pulumi.get(self, "show_priority")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The method to sort the monitors. Valid values are `name`, `group`, `status`, `tags`, `triggered`, `group,asc`, `group,desc`, `name,asc`, `name,desc`, `status,asc`, `status,desc`, `tags,asc`, `tags,desc`, `triggered,asc`, `triggered,desc`, `priority,asc`, `priority,desc`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="summaryType")
    def summary_type(self) -> Optional[str]:
        """
        The summary type to use. Valid values are `monitors`, `groups`, `combined`.
        """
        return pulumi.get(self, "summary_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetNoteDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "hasPadding":
            suggest = "has_padding"
        elif key == "showTick":
            suggest = "show_tick"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "tickEdge":
            suggest = "tick_edge"
        elif key == "tickPos":
            suggest = "tick_pos"
        elif key == "verticalAlign":
            suggest = "vertical_align"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetNoteDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetNoteDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetNoteDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: str,
                 background_color: Optional[str] = None,
                 font_size: Optional[str] = None,
                 has_padding: Optional[bool] = None,
                 show_tick: Optional[bool] = None,
                 text_align: Optional[str] = None,
                 tick_edge: Optional[str] = None,
                 tick_pos: Optional[str] = None,
                 vertical_align: Optional[str] = None):
        """
        :param str content: The content of the note.
        :param str background_color: The background color of the note.
        :param str font_size: The size of the text.
        :param bool has_padding: Whether to add padding or not. Defaults to `true`.
        :param bool show_tick: Whether to show a tick or not.
        :param str text_align: The alignment of the widget's text. Valid values are `center`, `left`, `right`.
        :param str tick_edge: When `tick = true`, a string indicating on which side of the widget the tick should be displayed. Valid values are `bottom`, `left`, `right`, `top`.
        :param str tick_pos: When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tick_pos = "50%"` is centered alignment.
        :param str vertical_align: The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        pulumi.set(__self__, "content", content)
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if has_padding is not None:
            pulumi.set(__self__, "has_padding", has_padding)
        if show_tick is not None:
            pulumi.set(__self__, "show_tick", show_tick)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if tick_edge is not None:
            pulumi.set(__self__, "tick_edge", tick_edge)
        if tick_pos is not None:
            pulumi.set(__self__, "tick_pos", tick_pos)
        if vertical_align is not None:
            pulumi.set(__self__, "vertical_align", vertical_align)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The content of the note.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        """
        The background color of the note.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        """
        The size of the text.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="hasPadding")
    def has_padding(self) -> Optional[bool]:
        """
        Whether to add padding or not. Defaults to `true`.
        """
        return pulumi.get(self, "has_padding")

    @property
    @pulumi.getter(name="showTick")
    def show_tick(self) -> Optional[bool]:
        """
        Whether to show a tick or not.
        """
        return pulumi.get(self, "show_tick")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the widget's text. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter(name="tickEdge")
    def tick_edge(self) -> Optional[str]:
        """
        When `tick = true`, a string indicating on which side of the widget the tick should be displayed. Valid values are `bottom`, `left`, `right`, `top`.
        """
        return pulumi.get(self, "tick_edge")

    @property
    @pulumi.getter(name="tickPos")
    def tick_pos(self) -> Optional[str]:
        """
        When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tick_pos = "50%"` is centered alignment.
        """
        return pulumi.get(self, "tick_pos")

    @property
    @pulumi.getter(name="verticalAlign")
    def vertical_align(self) -> Optional[str]:
        """
        The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        return pulumi.get(self, "vertical_align")


@pulumi.output_type
class DashboardWidgetPowerpackDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "powerpackId":
            suggest = "powerpack_id"
        elif key == "backgroundColor":
            suggest = "background_color"
        elif key == "bannerImg":
            suggest = "banner_img"
        elif key == "showTitle":
            suggest = "show_title"
        elif key == "templateVariables":
            suggest = "template_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetPowerpackDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetPowerpackDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetPowerpackDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 powerpack_id: str,
                 background_color: Optional[str] = None,
                 banner_img: Optional[str] = None,
                 show_title: Optional[bool] = None,
                 template_variables: Optional['outputs.DashboardWidgetPowerpackDefinitionTemplateVariables'] = None,
                 title: Optional[str] = None):
        """
        :param str powerpack_id: UUID of the associated powerpack.
        :param str background_color: The background color of the powerpack title.
        :param str banner_img: URL of image to display as a banner for the powerpack.
        :param bool show_title: Whether to show the title of the powerpack.
        :param 'DashboardWidgetPowerpackDefinitionTemplateVariablesArgs' template_variables: The list of template variables for this powerpack.
        :param str title: Title of the powerpack.
        """
        pulumi.set(__self__, "powerpack_id", powerpack_id)
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if banner_img is not None:
            pulumi.set(__self__, "banner_img", banner_img)
        if show_title is not None:
            pulumi.set(__self__, "show_title", show_title)
        if template_variables is not None:
            pulumi.set(__self__, "template_variables", template_variables)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter(name="powerpackId")
    def powerpack_id(self) -> str:
        """
        UUID of the associated powerpack.
        """
        return pulumi.get(self, "powerpack_id")

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        """
        The background color of the powerpack title.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="bannerImg")
    def banner_img(self) -> Optional[str]:
        """
        URL of image to display as a banner for the powerpack.
        """
        return pulumi.get(self, "banner_img")

    @property
    @pulumi.getter(name="showTitle")
    def show_title(self) -> Optional[bool]:
        """
        Whether to show the title of the powerpack.
        """
        return pulumi.get(self, "show_title")

    @property
    @pulumi.getter(name="templateVariables")
    def template_variables(self) -> Optional['outputs.DashboardWidgetPowerpackDefinitionTemplateVariables']:
        """
        The list of template variables for this powerpack.
        """
        return pulumi.get(self, "template_variables")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the powerpack.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardWidgetPowerpackDefinitionTemplateVariables(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlledByPowerpacks":
            suggest = "controlled_by_powerpacks"
        elif key == "controlledExternallies":
            suggest = "controlled_externallies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetPowerpackDefinitionTemplateVariables. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetPowerpackDefinitionTemplateVariables.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetPowerpackDefinitionTemplateVariables.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 controlled_by_powerpacks: Optional[Sequence['outputs.DashboardWidgetPowerpackDefinitionTemplateVariablesControlledByPowerpack']] = None,
                 controlled_externallies: Optional[Sequence['outputs.DashboardWidgetPowerpackDefinitionTemplateVariablesControlledExternally']] = None):
        """
        :param Sequence['DashboardWidgetPowerpackDefinitionTemplateVariablesControlledByPowerpackArgs'] controlled_by_powerpacks: Template variables controlled at the powerpack level.
        :param Sequence['DashboardWidgetPowerpackDefinitionTemplateVariablesControlledExternallyArgs'] controlled_externallies: Template variables controlled by the external resource, such as the dashboard this powerpack is on.
        """
        if controlled_by_powerpacks is not None:
            pulumi.set(__self__, "controlled_by_powerpacks", controlled_by_powerpacks)
        if controlled_externallies is not None:
            pulumi.set(__self__, "controlled_externallies", controlled_externallies)

    @property
    @pulumi.getter(name="controlledByPowerpacks")
    def controlled_by_powerpacks(self) -> Optional[Sequence['outputs.DashboardWidgetPowerpackDefinitionTemplateVariablesControlledByPowerpack']]:
        """
        Template variables controlled at the powerpack level.
        """
        return pulumi.get(self, "controlled_by_powerpacks")

    @property
    @pulumi.getter(name="controlledExternallies")
    def controlled_externallies(self) -> Optional[Sequence['outputs.DashboardWidgetPowerpackDefinitionTemplateVariablesControlledExternally']]:
        """
        Template variables controlled by the external resource, such as the dashboard this powerpack is on.
        """
        return pulumi.get(self, "controlled_externallies")


@pulumi.output_type
class DashboardWidgetPowerpackDefinitionTemplateVariablesControlledByPowerpack(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 prefix: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param Sequence[str] values: One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified.
        :param str prefix: The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified.
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class DashboardWidgetPowerpackDefinitionTemplateVariablesControlledExternally(dict):
    def __init__(__self__, *,
                 name: str,
                 values: Sequence[str],
                 prefix: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param Sequence[str] values: One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified.
        :param str prefix: The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        One or many template variable values within the saved view, which will be unioned together using `OR` if more than one is specified.
        """
        return pulumi.get(self, "values")

    @property
    @pulumi.getter
    def prefix(self) -> Optional[str]:
        """
        The tag prefix associated with the variable. Only tags with this prefix appear in the variable dropdown.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class DashboardWidgetQueryTableDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "hasSearchBar":
            suggest = "has_search_bar"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionCustomLink']] = None,
                 has_search_bar: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetQueryTableDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str has_search_bar: Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the `request` block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if has_search_bar is not None:
            pulumi.set(__self__, "has_search_bar", has_search_bar)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="hasSearchBar")
    def has_search_bar(self) -> Optional[str]:
        """
        Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
        """
        return pulumi.get(self, "has_search_bar")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "apmStatsQuery":
            suggest = "apm_stats_query"
        elif key == "cellDisplayModes":
            suggest = "cell_display_modes"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"
        elif key == "textFormats":
            suggest = "text_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 alias: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetApmQuery'] = None,
                 apm_stats_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQuery'] = None,
                 cell_display_modes: Optional[Sequence[str]] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestConditionalFormat']] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestFormula']] = None,
                 limit: Optional[int] = None,
                 log_query: Optional['outputs.DashboardWidgetLogQuery'] = None,
                 order: Optional[str] = None,
                 process_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetSecurityQuery'] = None,
                 text_formats: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestTextFormat']] = None):
        """
        :param str aggregator: The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str alias: The alias for the column name (defaults to metric name).
        :param 'DashboardWidgetApmQueryArgs' apm_query: The query to use for this widget.
        :param Sequence[str] cell_display_modes: A list of display modes for each table cell. List items one of `number`, `bar`. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param int limit: The number of lines to show in the table.
        :param 'DashboardWidgetLogQueryArgs' log_query: The query to use for this widget.
        :param str order: The sort order for the rows. Valid values are `asc`, `desc`.
        :param 'DashboardWidgetQueryTableDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetSecurityQueryArgs' security_query: The query to use for this widget.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestTextFormatArgs'] text_formats: Text formats define how to format text in table widget content. Multiple `text_formats` blocks are allowed using the structure below. This resource is in beta and is subject to change.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if apm_stats_query is not None:
            pulumi.set(__self__, "apm_stats_query", apm_stats_query)
        if cell_display_modes is not None:
            pulumi.set(__self__, "cell_display_modes", cell_display_modes)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if text_formats is not None:
            pulumi.set(__self__, "text_formats", text_formats)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        The alias for the column name (defaults to metric name).
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="apmStatsQuery")
    def apm_stats_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQuery']:
        return pulumi.get(self, "apm_stats_query")

    @property
    @pulumi.getter(name="cellDisplayModes")
    def cell_display_modes(self) -> Optional[Sequence[str]]:
        """
        A list of display modes for each table cell. List items one of `number`, `bar`. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_modes")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The sort order for the rows. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter(name="textFormats")
    def text_formats(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestTextFormat']]:
        """
        Text formats define how to format text in table widget content. Multiple `text_formats` blocks are allowed using the structure below. This resource is in beta and is subject to change.
        """
        return pulumi.get(self, "text_formats")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryTag":
            suggest = "primary_tag"
        elif key == "rowType":
            suggest = "row_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestApmStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env: str,
                 name: str,
                 primary_tag: str,
                 row_type: str,
                 service: str,
                 columns: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn']] = None,
                 resource: Optional[str] = None):
        """
        :param str env: The environment name.
        :param str name: The operation name associated with the service.
        :param str primary_tag: The organization's host group name and value.
        :param str row_type: The level of detail for the request. Valid values are `service`, `resource`, `span`.
        :param str service: The service name.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumnArgs'] columns: Column properties used by the front end for display.
        :param str resource: The resource name.
        """
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary_tag", primary_tag)
        pulumi.set(__self__, "row_type", row_type)
        pulumi.set(__self__, "service", service)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        The environment name.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The operation name associated with the service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryTag")
    def primary_tag(self) -> str:
        """
        The organization's host group name and value.
        """
        return pulumi.get(self, "primary_tag")

    @property
    @pulumi.getter(name="rowType")
    def row_type(self) -> str:
        """
        The level of detail for the request. Valid values are `service`, `resource`, `span`.
        """
        return pulumi.get(self, "row_type")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The service name.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn']]:
        """
        Column properties used by the front end for display.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        The resource name.
        """
        return pulumi.get(self, "resource")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellDisplayMode":
            suggest = "cell_display_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str name: The column name.
        :param str alias: A user-assigned alias for the column.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The column name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        A user-assigned alias for the column.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetQueryTableDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'DashboardWidgetQueryTableDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'DashboardWidgetQueryTableDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetQueryTableDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetQueryTableDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'DashboardWidgetQueryTableDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestTextFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textFormats":
            suggest = "text_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestTextFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestTextFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestTextFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_formats: Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormat']] = None):
        """
        :param Sequence['DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormatArgs'] text_formats: The text format to apply to the items in a table widget column.
        """
        if text_formats is not None:
            pulumi.set(__self__, "text_formats", text_formats)

    @property
    @pulumi.getter(name="textFormats")
    def text_formats(self) -> Optional[Sequence['outputs.DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormat']]:
        """
        The text format to apply to the items in a table widget column.
        """
        return pulumi.get(self, "text_formats")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match: 'outputs.DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormatMatch',
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 palette: Optional[str] = None,
                 replace: Optional['outputs.DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormatReplace'] = None):
        """
        :param 'DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormatMatchArgs' match: Match rule for the table widget text format.
        :param str custom_bg_color: The custom color palette to apply to the background.
        :param str custom_fg_color: The custom color palette to apply to the foreground text.
        :param str palette: The color palette to apply. Valid values are `white_on_red`, `white_on_yellow`, `white_on_green`, `black_on_light_red`, `black_on_light_yellow`, `black_on_light_green`, `red_on_white`, `yellow_on_white`, `green_on_white`, `custom_bg`, `custom_text`.
        :param 'DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormatReplaceArgs' replace: Match rule for the table widget text format.
        """
        pulumi.set(__self__, "match", match)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter
    def match(self) -> 'outputs.DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormatMatch':
        """
        Match rule for the table widget text format.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The custom color palette to apply to the background.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The custom color palette to apply to the foreground text.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `white_on_red`, `white_on_yellow`, `white_on_green`, `black_on_light_red`, `black_on_light_yellow`, `black_on_light_green`, `red_on_white`, `yellow_on_white`, `green_on_white`, `custom_bg`, `custom_text`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def replace(self) -> Optional['outputs.DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormatReplace']:
        """
        Match rule for the table widget text format.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormatMatch(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Match or compare option. Valid values are `is`, `is_not`, `contains`, `does_not_contain`, `starts_with`, `ends_with`.
        :param str value: Table Widget Match String.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Match or compare option. Valid values are `is`, `is_not`, `contains`, `does_not_contain`, `starts_with`, `ends_with`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Table Widget Match String.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormatReplace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "with":
            suggest = "with_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormatReplace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormatReplace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryTableDefinitionRequestTextFormatTextFormatReplace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 with_: str,
                 substring: Optional[str] = None):
        """
        :param str type: Table widget text format replace all type.
        :param str with_: Table Widget Match String.
        :param str substring: Text that will be replaced. Must be used with type `substring`.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "with_", with_)
        if substring is not None:
            pulumi.set(__self__, "substring", substring)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Table widget text format replace all type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="with")
    def with_(self) -> str:
        """
        Table Widget Match String.
        """
        return pulumi.get(self, "with_")

    @property
    @pulumi.getter
    def substring(self) -> Optional[str]:
        """
        Text that will be replaced. Must be used with type `substring`.
        """
        return pulumi.get(self, "substring")


@pulumi.output_type
class DashboardWidgetQueryValueDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "customUnit":
            suggest = "custom_unit"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "timeseriesBackground":
            suggest = "timeseries_background"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscale: Optional[bool] = None,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionCustomLink']] = None,
                 custom_unit: Optional[str] = None,
                 live_span: Optional[str] = None,
                 precision: Optional[int] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequest']] = None,
                 text_align: Optional[str] = None,
                 timeseries_background: Optional['outputs.DashboardWidgetQueryValueDefinitionTimeseriesBackground'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param bool autoscale: A Boolean indicating whether to automatically scale the tile.
        :param Sequence['DashboardWidgetQueryValueDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str custom_unit: The unit for the value displayed in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param int precision: The precision to use when displaying the tile.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
        :param str text_align: The alignment of the widget's text. Valid values are `center`, `left`, `right`.
        :param 'DashboardWidgetQueryValueDefinitionTimeseriesBackgroundArgs' timeseries_background: Set a timeseries on the widget background.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if custom_unit is not None:
            pulumi.set(__self__, "custom_unit", custom_unit)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if timeseries_background is not None:
            pulumi.set(__self__, "timeseries_background", timeseries_background)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[bool]:
        """
        A Boolean indicating whether to automatically scale the tile.
        """
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[str]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "custom_unit")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def precision(self) -> Optional[int]:
        """
        The precision to use when displaying the tile.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the widget's text. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter(name="timeseriesBackground")
    def timeseries_background(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionTimeseriesBackground']:
        """
        Set a timeseries on the widget background.
        """
        return pulumi.get(self, "timeseries_background")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "auditQuery":
            suggest = "audit_query"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetApmQuery'] = None,
                 audit_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQuery'] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestConditionalFormat']] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetSecurityQuery'] = None):
        """
        :param str aggregator: The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param 'DashboardWidgetApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetQueryValueDefinitionRequestAuditQueryArgs' audit_query: The query to use for this widget.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetQueryValueDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetSecurityQueryArgs' security_query: The query to use for this widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if audit_query is not None:
            pulumi.set(__self__, "audit_query", audit_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestAuditQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestAuditQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestAuditQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestAuditQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestAuditQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestAuditQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetQueryValueDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'DashboardWidgetQueryValueDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'DashboardWidgetQueryValueDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetQueryValueDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetQueryValueDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'DashboardWidgetQueryValueDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionTimeseriesBackground(dict):
    def __init__(__self__, *,
                 type: str,
                 yaxis: Optional['outputs.DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis'] = None):
        """
        :param str type: Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        :param 'DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        pulumi.set(__self__, "type", type)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis']:
        """
        A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetQueryValueDefinitionTimeseriesBackgroundYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetRunWorkflowDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workflowId":
            suggest = "workflow_id"
        elif key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetRunWorkflowDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetRunWorkflowDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetRunWorkflowDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workflow_id: str,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetRunWorkflowDefinitionCustomLink']] = None,
                 inputs: Optional[Sequence['outputs.DashboardWidgetRunWorkflowDefinitionInput']] = None,
                 live_span: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str workflow_id: Workflow ID
        :param Sequence['DashboardWidgetRunWorkflowDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetRunWorkflowDefinitionInputArgs'] inputs: Array of workflow inputs to map to dashboard template variables.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "workflow_id", workflow_id)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> str:
        """
        Workflow ID
        """
        return pulumi.get(self, "workflow_id")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetRunWorkflowDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def inputs(self) -> Optional[Sequence['outputs.DashboardWidgetRunWorkflowDefinitionInput']]:
        """
        Array of workflow inputs to map to dashboard template variables.
        """
        return pulumi.get(self, "inputs")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetRunWorkflowDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetRunWorkflowDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetRunWorkflowDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetRunWorkflowDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetRunWorkflowDefinitionInput(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the workflow input.
        :param str value: Dashboard template variable. Can be suffixed with `.value` or `.key`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the workflow input.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Dashboard template variable. Can be suffixed with `.value` or `.key`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardWidgetScatterplotDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorByGroups":
            suggest = "color_by_groups"
        elif key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_by_groups: Optional[Sequence[str]] = None,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 request: Optional['outputs.DashboardWidgetScatterplotDefinitionRequest'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 xaxis: Optional['outputs.DashboardWidgetScatterplotDefinitionXaxis'] = None,
                 yaxis: Optional['outputs.DashboardWidgetScatterplotDefinitionYaxis'] = None):
        """
        :param Sequence[str] color_by_groups: List of groups used for colors.
        :param Sequence['DashboardWidgetScatterplotDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param 'DashboardWidgetScatterplotDefinitionRequestArgs' request: A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed using the structure below.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param 'DashboardWidgetScatterplotDefinitionXaxisArgs' xaxis: A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
        :param 'DashboardWidgetScatterplotDefinitionYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        if color_by_groups is not None:
            pulumi.set(__self__, "color_by_groups", color_by_groups)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if xaxis is not None:
            pulumi.set(__self__, "xaxis", xaxis)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="colorByGroups")
    def color_by_groups(self) -> Optional[Sequence[str]]:
        """
        List of groups used for colors.
        """
        return pulumi.get(self, "color_by_groups")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequest']:
        """
        A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed using the structure below.
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def xaxis(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionXaxis']:
        """
        A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "xaxis")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionYaxis']:
        """
        A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scatterplotTables":
            suggest = "scatterplot_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scatterplot_tables: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTable']] = None,
                 xes: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestX']] = None,
                 ys: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestY']] = None):
        """
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestScatterplotTableArgs'] scatterplot_tables: Scatterplot request containing formulas and functions.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestXArgs'] xes: The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestYArgs'] ys: The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        if scatterplot_tables is not None:
            pulumi.set(__self__, "scatterplot_tables", scatterplot_tables)
        if xes is not None:
            pulumi.set(__self__, "xes", xes)
        if ys is not None:
            pulumi.set(__self__, "ys", ys)

    @property
    @pulumi.getter(name="scatterplotTables")
    def scatterplot_tables(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTable']]:
        """
        Scatterplot request containing formulas and functions.
        """
        return pulumi.get(self, "scatterplot_tables")

    @property
    @pulumi.getter
    def xes(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestX']]:
        """
        The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        return pulumi.get(self, "xes")

    @property
    @pulumi.getter
    def ys(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestY']]:
        """
        The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        return pulumi.get(self, "ys")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTable(dict):
    def __init__(__self__, *,
                 formulas: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula']] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery']] = None):
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery']]:
        return pulumi.get(self, "queries")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension: str,
                 formula_expression: str,
                 alias: Optional[str] = None):
        """
        :param str dimension: Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        """
        pulumi.set(__self__, "dimension", dimension)
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)

    @property
    @pulumi.getter
    def dimension(self) -> str:
        """
        Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestX(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestX. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestX.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestX.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetSecurityQuery'] = None):
        """
        :param str aggregator: Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param 'DashboardWidgetApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetScatterplotDefinitionRequestXProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetSecurityQueryArgs' security_query: The query to use for this widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestXProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestXProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestXProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestXProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestY(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestY. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestY.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestY.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.DashboardWidgetApmQuery'] = None,
                 log_query: Optional['outputs.DashboardWidgetLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.DashboardWidgetRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetSecurityQuery'] = None):
        """
        :param str aggregator: Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param 'DashboardWidgetApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetScatterplotDefinitionRequestYProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetSecurityQueryArgs' security_query: The query to use for this widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetScatterplotDefinitionRequestYProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionRequestYProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionRequestYProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionRequestYProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionXaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionXaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionXaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionXaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetScatterplotDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetScatterplotDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetScatterplotDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetScatterplotDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetServiceLevelObjectiveDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sloId":
            suggest = "slo_id"
        elif key == "timeWindows":
            suggest = "time_windows"
        elif key == "viewMode":
            suggest = "view_mode"
        elif key == "viewType":
            suggest = "view_type"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "globalTimeTarget":
            suggest = "global_time_target"
        elif key == "showErrorBudget":
            suggest = "show_error_budget"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetServiceLevelObjectiveDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetServiceLevelObjectiveDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetServiceLevelObjectiveDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slo_id: str,
                 time_windows: Sequence[str],
                 view_mode: str,
                 view_type: str,
                 additional_query_filters: Optional[str] = None,
                 global_time_target: Optional[str] = None,
                 show_error_budget: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str slo_id: The ID of the service level objective used by the widget.
        :param Sequence[str] time_windows: A list of time windows to display in the widget. Valid values are `7d`, `30d`, `90d`, `week_to_date`, `previous_week`, `month_to_date`, `previous_month`, `global_time`.
        :param str view_mode: The view mode for the widget. Valid values are `overall`, `component`, `both`.
        :param str view_type: The type of view to use when displaying the widget. Only `detail` is supported.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str global_time_target: The global time target of the widget.
        :param bool show_error_budget: Whether to show the error budget or not.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "slo_id", slo_id)
        pulumi.set(__self__, "time_windows", time_windows)
        pulumi.set(__self__, "view_mode", view_mode)
        pulumi.set(__self__, "view_type", view_type)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if global_time_target is not None:
            pulumi.set(__self__, "global_time_target", global_time_target)
        if show_error_budget is not None:
            pulumi.set(__self__, "show_error_budget", show_error_budget)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        The ID of the service level objective used by the widget.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Sequence[str]:
        """
        A list of time windows to display in the widget. Valid values are `7d`, `30d`, `90d`, `week_to_date`, `previous_week`, `month_to_date`, `previous_month`, `global_time`.
        """
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter(name="viewMode")
    def view_mode(self) -> str:
        """
        The view mode for the widget. Valid values are `overall`, `component`, `both`.
        """
        return pulumi.get(self, "view_mode")

    @property
    @pulumi.getter(name="viewType")
    def view_type(self) -> str:
        """
        The type of view to use when displaying the widget. Only `detail` is supported.
        """
        return pulumi.get(self, "view_type")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="globalTimeTarget")
    def global_time_target(self) -> Optional[str]:
        """
        The global time target of the widget.
        """
        return pulumi.get(self, "global_time_target")

    @property
    @pulumi.getter(name="showErrorBudget")
    def show_error_budget(self) -> Optional[bool]:
        """
        Whether to show the error budget or not.
        """
        return pulumi.get(self, "show_error_budget")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetServicemapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetServicemapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetServicemapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetServicemapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Sequence[str],
                 service: str,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetServicemapDefinitionCustomLink']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence[str] filters: Your environment and primary tag (or `*` if enabled for your account).
        :param str service: The ID of the service to map.
        :param Sequence['DashboardWidgetServicemapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "service", service)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def filters(self) -> Sequence[str]:
        """
        Your environment and primary tag (or `*` if enabled for your account).
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The ID of the service to map.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetServicemapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetServicemapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetServicemapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetServicemapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetServicemapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetSloListDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSloListDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSloListDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSloListDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request: 'outputs.DashboardWidgetSloListDefinitionRequest',
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param 'DashboardWidgetSloListDefinitionRequestArgs' request: A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "request", request)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def request(self) -> 'outputs.DashboardWidgetSloListDefinitionRequest':
        """
        A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed.
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetSloListDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestType":
            suggest = "request_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSloListDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSloListDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSloListDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: 'outputs.DashboardWidgetSloListDefinitionRequestQuery',
                 request_type: str):
        """
        :param 'DashboardWidgetSloListDefinitionRequestQueryArgs' query: Updated SLO List widget.
        :param str request_type: The request type for the SLO List request. Valid values are `slo_list`.
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "request_type", request_type)

    @property
    @pulumi.getter
    def query(self) -> 'outputs.DashboardWidgetSloListDefinitionRequestQuery':
        """
        Updated SLO List widget.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> str:
        """
        The request type for the SLO List request. Valid values are `slo_list`.
        """
        return pulumi.get(self, "request_type")


@pulumi.output_type
class DashboardWidgetSloListDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSloListDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSloListDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSloListDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_string: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetSloListDefinitionRequestQuerySort'] = None):
        """
        :param str query_string: Widget query.
        :param int limit: Maximum number of results to display in the table. Defaults to `100`.
        :param 'DashboardWidgetSloListDefinitionRequestQuerySortArgs' sort: The facet and order to sort the data, for example: `{"column": "status.sli", "order": "desc"}`.
        """
        pulumi.set(__self__, "query_string", query_string)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> str:
        """
        Widget query.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        Maximum number of results to display in the table. Defaults to `100`.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetSloListDefinitionRequestQuerySort']:
        """
        The facet and order to sort the data, for example: `{"column": "status.sli", "order": "desc"}`.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetSloListDefinitionRequestQuerySort(dict):
    def __init__(__self__, *,
                 column: str,
                 order: str):
        """
        :param str column: The facet path for the column.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetSplitGraphDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceWidgetDefinition":
            suggest = "source_widget_definition"
        elif key == "splitConfig":
            suggest = "split_config"
        elif key == "hasUniformYAxes":
            suggest = "has_uniform_y_axes"
        elif key == "liveSpan":
            suggest = "live_span"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSplitGraphDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSplitGraphDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSplitGraphDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 size: str,
                 source_widget_definition: 'outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinition',
                 split_config: 'outputs.DashboardWidgetSplitGraphDefinitionSplitConfig',
                 has_uniform_y_axes: Optional[bool] = None,
                 live_span: Optional[str] = None,
                 title: Optional[str] = None):
        """
        :param str size: Size of the individual graphs in the split.
        :param 'DashboardWidgetSplitGraphDefinitionSourceWidgetDefinitionArgs' source_widget_definition: The original widget we are splitting on.
        :param 'DashboardWidgetSplitGraphDefinitionSplitConfigArgs' split_config: Encapsulates all user choices about how to split a graph.
        :param bool has_uniform_y_axes: Normalize y axes across graphs.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param str title: The title of the widget.
        """
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "source_widget_definition", source_widget_definition)
        pulumi.set(__self__, "split_config", split_config)
        if has_uniform_y_axes is not None:
            pulumi.set(__self__, "has_uniform_y_axes", has_uniform_y_axes)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def size(self) -> str:
        """
        Size of the individual graphs in the split.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter(name="sourceWidgetDefinition")
    def source_widget_definition(self) -> 'outputs.DashboardWidgetSplitGraphDefinitionSourceWidgetDefinition':
        """
        The original widget we are splitting on.
        """
        return pulumi.get(self, "source_widget_definition")

    @property
    @pulumi.getter(name="splitConfig")
    def split_config(self) -> 'outputs.DashboardWidgetSplitGraphDefinitionSplitConfig':
        """
        Encapsulates all user choices about how to split a graph.
        """
        return pulumi.get(self, "split_config")

    @property
    @pulumi.getter(name="hasUniformYAxes")
    def has_uniform_y_axes(self) -> Optional[bool]:
        """
        Normalize y axes across graphs.
        """
        return pulumi.get(self, "has_uniform_y_axes")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardWidgetSplitGraphDefinitionSourceWidgetDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "changeDefinition":
            suggest = "change_definition"
        elif key == "geomapDefinition":
            suggest = "geomap_definition"
        elif key == "queryTableDefinition":
            suggest = "query_table_definition"
        elif key == "queryValueDefinition":
            suggest = "query_value_definition"
        elif key == "scatterplotDefinition":
            suggest = "scatterplot_definition"
        elif key == "sunburstDefinition":
            suggest = "sunburst_definition"
        elif key == "timeseriesDefinition":
            suggest = "timeseries_definition"
        elif key == "toplistDefinition":
            suggest = "toplist_definition"
        elif key == "treemapDefinition":
            suggest = "treemap_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSplitGraphDefinitionSourceWidgetDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSplitGraphDefinitionSourceWidgetDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSplitGraphDefinitionSourceWidgetDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 change_definition: Optional['outputs.DashboardWidgetChangeDefinition'] = None,
                 geomap_definition: Optional['outputs.DashboardWidgetGeomapDefinition'] = None,
                 query_table_definition: Optional['outputs.DashboardWidgetQueryTableDefinition'] = None,
                 query_value_definition: Optional['outputs.DashboardWidgetQueryValueDefinition'] = None,
                 scatterplot_definition: Optional['outputs.DashboardWidgetScatterplotDefinition'] = None,
                 sunburst_definition: Optional['outputs.DashboardWidgetSunburstDefinition'] = None,
                 timeseries_definition: Optional['outputs.DashboardWidgetTimeseriesDefinition'] = None,
                 toplist_definition: Optional['outputs.DashboardWidgetToplistDefinition'] = None,
                 treemap_definition: Optional['outputs.DashboardWidgetTreemapDefinition'] = None):
        """
        :param 'DashboardWidgetChangeDefinitionArgs' change_definition: The definition for a Change widget.
        :param 'DashboardWidgetGeomapDefinitionArgs' geomap_definition: The definition for a Geomap widget.
        :param 'DashboardWidgetQueryTableDefinitionArgs' query_table_definition: The definition for a Query Table widget.
        :param 'DashboardWidgetQueryValueDefinitionArgs' query_value_definition: The definition for a Query Value widget.
        :param 'DashboardWidgetScatterplotDefinitionArgs' scatterplot_definition: The definition for a Scatterplot widget.
        :param 'DashboardWidgetSunburstDefinitionArgs' sunburst_definition: The definition for a Sunburst widget.
        :param 'DashboardWidgetTimeseriesDefinitionArgs' timeseries_definition: The definition for a Timeseries widget.
        :param 'DashboardWidgetToplistDefinitionArgs' toplist_definition: The definition for a Toplist widget.
        :param 'DashboardWidgetTreemapDefinitionArgs' treemap_definition: The definition for a Treemap widget.
        """
        if change_definition is not None:
            pulumi.set(__self__, "change_definition", change_definition)
        if geomap_definition is not None:
            pulumi.set(__self__, "geomap_definition", geomap_definition)
        if query_table_definition is not None:
            pulumi.set(__self__, "query_table_definition", query_table_definition)
        if query_value_definition is not None:
            pulumi.set(__self__, "query_value_definition", query_value_definition)
        if scatterplot_definition is not None:
            pulumi.set(__self__, "scatterplot_definition", scatterplot_definition)
        if sunburst_definition is not None:
            pulumi.set(__self__, "sunburst_definition", sunburst_definition)
        if timeseries_definition is not None:
            pulumi.set(__self__, "timeseries_definition", timeseries_definition)
        if toplist_definition is not None:
            pulumi.set(__self__, "toplist_definition", toplist_definition)
        if treemap_definition is not None:
            pulumi.set(__self__, "treemap_definition", treemap_definition)

    @property
    @pulumi.getter(name="changeDefinition")
    def change_definition(self) -> Optional['outputs.DashboardWidgetChangeDefinition']:
        """
        The definition for a Change widget.
        """
        return pulumi.get(self, "change_definition")

    @property
    @pulumi.getter(name="geomapDefinition")
    def geomap_definition(self) -> Optional['outputs.DashboardWidgetGeomapDefinition']:
        """
        The definition for a Geomap widget.
        """
        return pulumi.get(self, "geomap_definition")

    @property
    @pulumi.getter(name="queryTableDefinition")
    def query_table_definition(self) -> Optional['outputs.DashboardWidgetQueryTableDefinition']:
        """
        The definition for a Query Table widget.
        """
        return pulumi.get(self, "query_table_definition")

    @property
    @pulumi.getter(name="queryValueDefinition")
    def query_value_definition(self) -> Optional['outputs.DashboardWidgetQueryValueDefinition']:
        """
        The definition for a Query Value widget.
        """
        return pulumi.get(self, "query_value_definition")

    @property
    @pulumi.getter(name="scatterplotDefinition")
    def scatterplot_definition(self) -> Optional['outputs.DashboardWidgetScatterplotDefinition']:
        """
        The definition for a Scatterplot widget.
        """
        return pulumi.get(self, "scatterplot_definition")

    @property
    @pulumi.getter(name="sunburstDefinition")
    def sunburst_definition(self) -> Optional['outputs.DashboardWidgetSunburstDefinition']:
        """
        The definition for a Sunburst widget.
        """
        return pulumi.get(self, "sunburst_definition")

    @property
    @pulumi.getter(name="timeseriesDefinition")
    def timeseries_definition(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinition']:
        """
        The definition for a Timeseries widget.
        """
        return pulumi.get(self, "timeseries_definition")

    @property
    @pulumi.getter(name="toplistDefinition")
    def toplist_definition(self) -> Optional['outputs.DashboardWidgetToplistDefinition']:
        """
        The definition for a Toplist widget.
        """
        return pulumi.get(self, "toplist_definition")

    @property
    @pulumi.getter(name="treemapDefinition")
    def treemap_definition(self) -> Optional['outputs.DashboardWidgetTreemapDefinition']:
        """
        The definition for a Treemap widget.
        """
        return pulumi.get(self, "treemap_definition")


@pulumi.output_type
class DashboardWidgetSplitGraphDefinitionSplitConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "splitDimensions":
            suggest = "split_dimensions"
        elif key == "staticSplits":
            suggest = "static_splits"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSplitGraphDefinitionSplitConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSplitGraphDefinitionSplitConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSplitGraphDefinitionSplitConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sort: 'outputs.DashboardWidgetSplitGraphDefinitionSplitConfigSort',
                 split_dimensions: 'outputs.DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensions',
                 limit: Optional[int] = None,
                 static_splits: Optional[Sequence['outputs.DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplit']] = None):
        """
        :param 'DashboardWidgetSplitGraphDefinitionSplitConfigSortArgs' sort: Controls the order in which graphs appear in the split.
        :param 'DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensionsArgs' split_dimensions: The property by which the graph splits
        :param int limit: Maximum number of graphs to display in the widget.
        :param Sequence['DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitArgs'] static_splits: The property by which the graph splits
        """
        pulumi.set(__self__, "sort", sort)
        pulumi.set(__self__, "split_dimensions", split_dimensions)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if static_splits is not None:
            pulumi.set(__self__, "static_splits", static_splits)

    @property
    @pulumi.getter
    def sort(self) -> 'outputs.DashboardWidgetSplitGraphDefinitionSplitConfigSort':
        """
        Controls the order in which graphs appear in the split.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="splitDimensions")
    def split_dimensions(self) -> 'outputs.DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensions':
        """
        The property by which the graph splits
        """
        return pulumi.get(self, "split_dimensions")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        Maximum number of graphs to display in the widget.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="staticSplits")
    def static_splits(self) -> Optional[Sequence['outputs.DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplit']]:
        """
        The property by which the graph splits
        """
        return pulumi.get(self, "static_splits")


@pulumi.output_type
class DashboardWidgetSplitGraphDefinitionSplitConfigSort(dict):
    def __init__(__self__, *,
                 order: str,
                 compute: Optional['outputs.DashboardWidgetSplitGraphDefinitionSplitConfigSortCompute'] = None):
        """
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param 'DashboardWidgetSplitGraphDefinitionSplitConfigSortComputeArgs' compute: Defines the metric and aggregation used as the sort value
        """
        pulumi.set(__self__, "order", order)
        if compute is not None:
            pulumi.set(__self__, "compute", compute)

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def compute(self) -> Optional['outputs.DashboardWidgetSplitGraphDefinitionSplitConfigSortCompute']:
        """
        Defines the metric and aggregation used as the sort value
        """
        return pulumi.get(self, "compute")


@pulumi.output_type
class DashboardWidgetSplitGraphDefinitionSplitConfigSortCompute(dict):
    def __init__(__self__, *,
                 metric: str,
                 aggregation: Optional[str] = None):
        """
        :param str metric: The metric to use for sorting graphs.
        :param str aggregation: How to aggregate the sort metric for the purposes of ordering.
        """
        pulumi.set(__self__, "metric", metric)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The metric to use for sorting graphs.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        How to aggregate the sort metric for the purposes of ordering.
        """
        return pulumi.get(self, "aggregation")


@pulumi.output_type
class DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oneGraphPer":
            suggest = "one_graph_per"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSplitGraphDefinitionSplitConfigSplitDimensions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 one_graph_per: str):
        """
        :param str one_graph_per: The system interprets this attribute differently depending on the data source of the query being split. For metrics, it's a tag. For the events platform, it's an attribute or tag.
        """
        pulumi.set(__self__, "one_graph_per", one_graph_per)

    @property
    @pulumi.getter(name="oneGraphPer")
    def one_graph_per(self) -> str:
        """
        The system interprets this attribute differently depending on the data source of the query being split. For metrics, it's a tag. For the events platform, it's an attribute or tag.
        """
        return pulumi.get(self, "one_graph_per")


@pulumi.output_type
class DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "splitVectors":
            suggest = "split_vectors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 split_vectors: Sequence['outputs.DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVector']):
        """
        :param Sequence['DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVectorArgs'] split_vectors: The split graph list contains a graph for each value of the split dimension.
        """
        pulumi.set(__self__, "split_vectors", split_vectors)

    @property
    @pulumi.getter(name="splitVectors")
    def split_vectors(self) -> Sequence['outputs.DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVector']:
        """
        The split graph list contains a graph for each value of the split dimension.
        """
        return pulumi.get(self, "split_vectors")


@pulumi.output_type
class DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"
        elif key == "tagValues":
            suggest = "tag_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSplitGraphDefinitionSplitConfigStaticSplitSplitVector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_key: str,
                 tag_values: Sequence[str]):
        pulumi.set(__self__, "tag_key", tag_key)
        pulumi.set(__self__, "tag_values", tag_values)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> str:
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter(name="tagValues")
    def tag_values(self) -> Sequence[str]:
        return pulumi.get(self, "tag_values")


@pulumi.output_type
class DashboardWidgetSunburstDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "hideTotal":
            suggest = "hide_total"
        elif key == "legendInline":
            suggest = "legend_inline"
        elif key == "legendTable":
            suggest = "legend_table"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionCustomLink']] = None,
                 hide_total: Optional[bool] = None,
                 legend_inline: Optional['outputs.DashboardWidgetSunburstDefinitionLegendInline'] = None,
                 legend_table: Optional['outputs.DashboardWidgetSunburstDefinitionLegendTable'] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetSunburstDefinitionCustomLinkArgs'] custom_links: Nested block describing a custom link. Multiple `custom_link` blocks are allowed with the structure below.
        :param bool hide_total: Whether or not to show the total value in the widget.
        :param 'DashboardWidgetSunburstDefinitionLegendInlineArgs' legend_inline: Used to configure the inline legend. Cannot be used in conjunction with legend*table.
        :param 'DashboardWidgetSunburstDefinitionLegendTableArgs' legend_table: Used to configure the table legend. Cannot be used in conjunction with legend*inline.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestArgs'] requests: Nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed with the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. One of `left`, `center`, or `right`. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title. Default is 16.
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if hide_total is not None:
            pulumi.set(__self__, "hide_total", hide_total)
        if legend_inline is not None:
            pulumi.set(__self__, "legend_inline", legend_inline)
        if legend_table is not None:
            pulumi.set(__self__, "legend_table", legend_table)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionCustomLink']]:
        """
        Nested block describing a custom link. Multiple `custom_link` blocks are allowed with the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="hideTotal")
    def hide_total(self) -> Optional[bool]:
        """
        Whether or not to show the total value in the widget.
        """
        return pulumi.get(self, "hide_total")

    @property
    @pulumi.getter(name="legendInline")
    def legend_inline(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionLegendInline']:
        """
        Used to configure the inline legend. Cannot be used in conjunction with legend*table.
        """
        return pulumi.get(self, "legend_inline")

    @property
    @pulumi.getter(name="legendTable")
    def legend_table(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionLegendTable']:
        """
        Used to configure the table legend. Cannot be used in conjunction with legend*inline.
        """
        return pulumi.get(self, "legend_table")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequest']]:
        """
        Nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed with the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. One of `left`, `center`, or `right`. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title. Default is 16.
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionLegendInline(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hidePercent":
            suggest = "hide_percent"
        elif key == "hideValue":
            suggest = "hide_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionLegendInline. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionLegendInline.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionLegendInline.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 hide_percent: Optional[bool] = None,
                 hide_value: Optional[bool] = None):
        """
        :param str type: The type of legend (inline or automatic). Valid values are `inline`, `automatic`.
        :param bool hide_percent: Whether to hide the percentages of the groups.
        :param bool hide_value: Whether to hide the values of the groups.
        """
        pulumi.set(__self__, "type", type)
        if hide_percent is not None:
            pulumi.set(__self__, "hide_percent", hide_percent)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of legend (inline or automatic). Valid values are `inline`, `automatic`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="hidePercent")
    def hide_percent(self) -> Optional[bool]:
        """
        Whether to hide the percentages of the groups.
        """
        return pulumi.get(self, "hide_percent")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Whether to hide the values of the groups.
        """
        return pulumi.get(self, "hide_value")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionLegendTable(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: The type of legend (table or none). Valid values are `table`, `none`.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of legend (table or none). Valid values are `table`, `none`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "auditQuery":
            suggest = "audit_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "networkQuery":
            suggest = "network_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetApmQuery'] = None,
                 audit_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestAuditQuery'] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetLogQuery'] = None,
                 network_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetSunburstDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetSunburstDefinitionRequestAuditQueryArgs' audit_query: The query to use for this widget.
        :param 'DashboardWidgetLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetSunburstDefinitionRequestNetworkQueryArgs' network_query: The query to use for this widget.
        :param 'DashboardWidgetSunburstDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'DashboardWidgetSunburstDefinitionRequestStyleArgs' style: Define style for the widget's request.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if audit_query is not None:
            pulumi.set(__self__, "audit_query", audit_query)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if network_query is not None:
            pulumi.set(__self__, "network_query", network_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestAuditQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "network_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestStyle']:
        """
        Define style for the widget's request.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestAuditQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestAuditQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestAuditQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestAuditQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestAuditQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestAuditQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestAuditQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestAuditQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetSunburstDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetSunburstDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetSunburstDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'DashboardWidgetSunburstDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestNetworkQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestNetworkQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestNetworkQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestNetworkQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestNetworkQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestNetworkQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetSunburstDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'DashboardWidgetSunburstDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetSunburstDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetSunburstDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'DashboardWidgetSunburstDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetSunburstDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetSunburstDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetSunburstDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetSunburstDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetSunburstDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "legendColumns":
            suggest = "legend_columns"
        elif key == "legendLayout":
            suggest = "legend_layout"
        elif key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "rightYaxis":
            suggest = "right_yaxis"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionCustomLink']] = None,
                 events: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionEvent']] = None,
                 legend_columns: Optional[Sequence[str]] = None,
                 legend_layout: Optional[str] = None,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 markers: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionMarker']] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequest']] = None,
                 right_yaxis: Optional['outputs.DashboardWidgetTimeseriesDefinitionRightYaxis'] = None,
                 show_legend: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 yaxis: Optional['outputs.DashboardWidgetTimeseriesDefinitionYaxis'] = None):
        """
        :param Sequence['DashboardWidgetTimeseriesDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionEventArgs'] events: The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        :param Sequence[str] legend_columns: A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
        :param str legend_layout: The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
        :param str legend_size: The size of the legend displayed in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence['DashboardWidgetTimeseriesDefinitionMarkerArgs'] markers: A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tile_def` block.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `network_query`, `security_query` or `process_query` is required within the `request` block).
        :param 'DashboardWidgetTimeseriesDefinitionRightYaxisArgs' right_yaxis: A nested block describing the right Y-Axis Controls. See the `on_right_yaxis` property for which request will use this axis. The structure of this block is described below.
        :param bool show_legend: Whether or not to show the legend on this widget.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param 'DashboardWidgetTimeseriesDefinitionYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_columns is not None:
            pulumi.set(__self__, "legend_columns", legend_columns)
        if legend_layout is not None:
            pulumi.set(__self__, "legend_layout", legend_layout)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if markers is not None:
            pulumi.set(__self__, "markers", markers)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if right_yaxis is not None:
            pulumi.set(__self__, "right_yaxis", right_yaxis)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionEvent']]:
        """
        The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="legendColumns")
    def legend_columns(self) -> Optional[Sequence[str]]:
        """
        A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
        """
        return pulumi.get(self, "legend_columns")

    @property
    @pulumi.getter(name="legendLayout")
    def legend_layout(self) -> Optional[str]:
        """
        The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
        """
        return pulumi.get(self, "legend_layout")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def markers(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionMarker']]:
        """
        A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tile_def` block.
        """
        return pulumi.get(self, "markers")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `network_query`, `security_query` or `process_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="rightYaxis")
    def right_yaxis(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRightYaxis']:
        """
        A nested block describing the right Y-Axis Controls. See the `on_right_yaxis` property for which request will use this axis. The structure of this block is described below.
        """
        return pulumi.get(self, "right_yaxis")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionYaxis']:
        """
        A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagsExecution":
            suggest = "tags_execution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 q: str,
                 tags_execution: Optional[str] = None):
        """
        :param str q: The event query to use in the widget.
        :param str tags_execution: The execution method for multi-value filters.
        """
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> str:
        """
        The event query to use in the widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        """
        The execution method for multi-value filters.
        """
        return pulumi.get(self, "tags_execution")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionMarker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayType":
            suggest = "display_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionMarker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionMarker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionMarker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: str,
                 display_type: Optional[str] = None,
                 label: Optional[str] = None):
        """
        :param str value: A mathematical expression describing the marker, for example: `y > 1`, `-5 < y < 0`, `y = 19`.
        :param str display_type: How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
        :param str label: A label for the line or range.
        """
        pulumi.set(__self__, "value", value)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        A mathematical expression describing the marker, for example: `y > 1`, `-5 < y < 0`, `y = 19`.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[str]:
        """
        How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
        """
        return pulumi.get(self, "display_type")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        A label for the line or range.
        """
        return pulumi.get(self, "label")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "auditQuery":
            suggest = "audit_query"
        elif key == "displayType":
            suggest = "display_type"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "networkQuery":
            suggest = "network_query"
        elif key == "onRightYaxis":
            suggest = "on_right_yaxis"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetApmQuery'] = None,
                 audit_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQuery'] = None,
                 display_type: Optional[str] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetLogQuery'] = None,
                 metadatas: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestMetadata']] = None,
                 network_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQuery'] = None,
                 on_right_yaxis: Optional[bool] = None,
                 process_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetTimeseriesDefinitionRequestAuditQueryArgs' audit_query: The query to use for this widget.
        :param str display_type: How to display the marker lines. Valid values are `area`, `bars`, `line`, `overlay`.
        :param 'DashboardWidgetLogQueryArgs' log_query: The query to use for this widget.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestMetadataArgs'] metadatas: Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
        :param 'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryArgs' network_query: The query to use for this widget.
        :param bool on_right_yaxis: A Boolean indicating whether the request uses the right or left Y-Axis.
        :param 'DashboardWidgetTimeseriesDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'DashboardWidgetTimeseriesDefinitionRequestStyleArgs' style: The style of the widget graph. Exactly one `style` block is allowed using the structure below.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if audit_query is not None:
            pulumi.set(__self__, "audit_query", audit_query)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if network_query is not None:
            pulumi.set(__self__, "network_query", network_query)
        if on_right_yaxis is not None:
            pulumi.set(__self__, "on_right_yaxis", on_right_yaxis)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[str]:
        """
        How to display the marker lines. Valid values are `area`, `bars`, `line`, `overlay`.
        """
        return pulumi.get(self, "display_type")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestMetadata']]:
        """
        Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "network_query")

    @property
    @pulumi.getter(name="onRightYaxis")
    def on_right_yaxis(self) -> Optional[bool]:
        """
        A Boolean indicating whether the request uses the right or left Y-Axis.
        """
        return pulumi.get(self, "on_right_yaxis")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestStyle']:
        """
        The style of the widget graph. Exactly one `style` block is allowed using the structure below.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestAuditQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestAuditQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestAuditQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestAuditQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetTimeseriesDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'DashboardWidgetTimeseriesDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasName":
            suggest = "alias_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 alias_name: Optional[str] = None):
        """
        :param str expression: The expression name.
        :param str alias_name: The expression alias.
        """
        pulumi.set(__self__, "expression", expression)
        if alias_name is not None:
            pulumi.set(__self__, "alias_name", alias_name)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The expression name.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="aliasName")
    def alias_name(self) -> Optional[str]:
        """
        The expression alias.
        """
        return pulumi.get(self, "alias_name")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestNetworkQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestNetworkQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestNetworkQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetTimeseriesDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetTimeseriesDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'DashboardWidgetTimeseriesDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRequestStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineType":
            suggest = "line_type"
        elif key == "lineWidth":
            suggest = "line_width"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRequestStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRequestStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 line_type: Optional[str] = None,
                 line_width: Optional[str] = None,
                 palette: Optional[str] = None):
        """
        :param str line_type: The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
        :param str line_width: The width of line displayed. Valid values are `normal`, `thick`, `thin`.
        :param str palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if line_type is not None:
            pulumi.set(__self__, "line_type", line_type)
        if line_width is not None:
            pulumi.set(__self__, "line_width", line_width)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter(name="lineType")
    def line_type(self) -> Optional[str]:
        """
        The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
        """
        return pulumi.get(self, "line_type")

    @property
    @pulumi.getter(name="lineWidth")
    def line_width(self) -> Optional[str]:
        """
        The width of line displayed. Valid values are `normal`, `thick`, `thin`.
        """
        return pulumi.get(self, "line_width")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionRightYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionRightYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionRightYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionRightYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetTimeseriesDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTimeseriesDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTimeseriesDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTimeseriesDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class DashboardWidgetToplistDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequest']] = None,
                 styles: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionStyle']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetToplistDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence['DashboardWidgetToplistDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
        :param Sequence['DashboardWidgetToplistDefinitionStyleArgs'] styles: The style of the widget
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if styles is not None:
            pulumi.set(__self__, "styles", styles)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def styles(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionStyle']]:
        """
        The style of the widget
        """
        return pulumi.get(self, "styles")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetToplistDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "auditQuery":
            suggest = "audit_query"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.DashboardWidgetApmQuery'] = None,
                 audit_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestAuditQuery'] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestConditionalFormat']] = None,
                 formulas: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.DashboardWidgetLogQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.DashboardWidgetRumQuery'] = None,
                 security_query: Optional['outputs.DashboardWidgetSecurityQuery'] = None,
                 style: Optional['outputs.DashboardWidgetToplistDefinitionRequestStyle'] = None):
        """
        :param 'DashboardWidgetApmQueryArgs' apm_query: The query to use for this widget.
        :param 'DashboardWidgetToplistDefinitionRequestAuditQueryArgs' audit_query: The query to use for this widget.
        :param Sequence['DashboardWidgetToplistDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetLogQueryArgs' log_query: The query to use for this widget.
        :param 'DashboardWidgetToplistDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'DashboardWidgetRumQueryArgs' rum_query: The query to use for this widget.
        :param 'DashboardWidgetSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'DashboardWidgetToplistDefinitionRequestStyleArgs' style: Define request for the widget's style.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if audit_query is not None:
            pulumi.set(__self__, "audit_query", audit_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.DashboardWidgetApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestAuditQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.DashboardWidgetLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.DashboardWidgetRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.DashboardWidgetSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestStyle']:
        """
        Define request for the widget's style.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestAuditQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestAuditQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestAuditQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestAuditQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'DashboardWidgetToplistDefinitionRequestAuditQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['DashboardWidgetToplistDefinitionRequestAuditQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetToplistDefinitionRequestAuditQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestAuditQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestAuditQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetToplistDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetToplistDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetToplistDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetToplistDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'DashboardWidgetToplistDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetToplistDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetToplistDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'DashboardWidgetToplistDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetToplistDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetToplistDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'DashboardWidgetToplistDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetToplistDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetToplistDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetToplistDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetToplistDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetToplistDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetToplistDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetToplistDefinitionStyle(dict):
    def __init__(__self__, *,
                 displays: Optional[Sequence['outputs.DashboardWidgetToplistDefinitionStyleDisplay']] = None,
                 palette: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetToplistDefinitionStyleDisplayArgs'] displays: The display mode for the widget.
        :param str palette: The color palette for the widget.
        """
        if displays is not None:
            pulumi.set(__self__, "displays", displays)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def displays(self) -> Optional[Sequence['outputs.DashboardWidgetToplistDefinitionStyleDisplay']]:
        """
        The display mode for the widget.
        """
        return pulumi.get(self, "displays")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette for the widget.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class DashboardWidgetToplistDefinitionStyleDisplay(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: The display type for the widget.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The display type for the widget.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class DashboardWidgetTopologyMapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTopologyMapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTopologyMapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTopologyMapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.DashboardWidgetTopologyMapDefinitionCustomLink']] = None,
                 requests: Optional[Sequence['outputs.DashboardWidgetTopologyMapDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetTopologyMapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence['DashboardWidgetTopologyMapDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (`query` and `request_type` are required within the request).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.DashboardWidgetTopologyMapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetTopologyMapDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (`query` and `request_type` are required within the request).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetTopologyMapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTopologyMapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTopologyMapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTopologyMapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class DashboardWidgetTopologyMapDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestType":
            suggest = "request_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTopologyMapDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTopologyMapDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTopologyMapDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queries: Sequence['outputs.DashboardWidgetTopologyMapDefinitionRequestQuery'],
                 request_type: str):
        """
        :param Sequence['DashboardWidgetTopologyMapDefinitionRequestQueryArgs'] queries: The query for a Topology request.
        :param str request_type: The request type for the Topology request ('topology'). Valid values are `topology`.
        """
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "request_type", request_type)

    @property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.DashboardWidgetTopologyMapDefinitionRequestQuery']:
        """
        The query for a Topology request.
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> str:
        """
        The request type for the Topology request ('topology'). Valid values are `topology`.
        """
        return pulumi.get(self, "request_type")


@pulumi.output_type
class DashboardWidgetTopologyMapDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTopologyMapDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTopologyMapDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTopologyMapDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 filters: Sequence[str],
                 service: str):
        """
        :param str data_source: The data source for the Topology request ('service*map' or 'data*streams'). Valid values are `data_streams`, `service_map`.
        :param Sequence[str] filters: Your environment and primary tag (or `*` if enabled for your account).
        :param str service: The ID of the service to map.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for the Topology request ('service*map' or 'data*streams'). Valid values are `data_streams`, `service_map`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def filters(self) -> Sequence[str]:
        """
        Your environment and primary tag (or `*` if enabled for your account).
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The ID of the service to map.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class DashboardWidgetTraceServiceDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spanName":
            suggest = "span_name"
        elif key == "displayFormat":
            suggest = "display_format"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showBreakdown":
            suggest = "show_breakdown"
        elif key == "showDistribution":
            suggest = "show_distribution"
        elif key == "showErrors":
            suggest = "show_errors"
        elif key == "showHits":
            suggest = "show_hits"
        elif key == "showLatency":
            suggest = "show_latency"
        elif key == "showResourceList":
            suggest = "show_resource_list"
        elif key == "sizeFormat":
            suggest = "size_format"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTraceServiceDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTraceServiceDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTraceServiceDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env: str,
                 service: str,
                 span_name: str,
                 display_format: Optional[str] = None,
                 live_span: Optional[str] = None,
                 show_breakdown: Optional[bool] = None,
                 show_distribution: Optional[bool] = None,
                 show_errors: Optional[bool] = None,
                 show_hits: Optional[bool] = None,
                 show_latency: Optional[bool] = None,
                 show_resource_list: Optional[bool] = None,
                 size_format: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str env: APM environment.
        :param str service: APM service.
        :param str span_name: APM span name
        :param str display_format: The number of columns to display. Valid values are `one_column`, `two_column`, `three_column`.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param bool show_breakdown: Whether to show the latency breakdown or not.
        :param bool show_distribution: Whether to show the latency distribution or not.
        :param bool show_errors: Whether to show the error metrics or not.
        :param bool show_hits: Whether to show the hits metrics or not
        :param bool show_latency: Whether to show the latency metrics or not.
        :param bool show_resource_list: Whether to show the resource list or not.
        :param str size_format: The size of the widget. Valid values are `small`, `medium`, `large`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "span_name", span_name)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if show_breakdown is not None:
            pulumi.set(__self__, "show_breakdown", show_breakdown)
        if show_distribution is not None:
            pulumi.set(__self__, "show_distribution", show_distribution)
        if show_errors is not None:
            pulumi.set(__self__, "show_errors", show_errors)
        if show_hits is not None:
            pulumi.set(__self__, "show_hits", show_hits)
        if show_latency is not None:
            pulumi.set(__self__, "show_latency", show_latency)
        if show_resource_list is not None:
            pulumi.set(__self__, "show_resource_list", show_resource_list)
        if size_format is not None:
            pulumi.set(__self__, "size_format", size_format)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="spanName")
    def span_name(self) -> str:
        """
        APM span name
        """
        return pulumi.get(self, "span_name")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        """
        The number of columns to display. Valid values are `one_column`, `two_column`, `three_column`.
        """
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="showBreakdown")
    def show_breakdown(self) -> Optional[bool]:
        """
        Whether to show the latency breakdown or not.
        """
        return pulumi.get(self, "show_breakdown")

    @property
    @pulumi.getter(name="showDistribution")
    def show_distribution(self) -> Optional[bool]:
        """
        Whether to show the latency distribution or not.
        """
        return pulumi.get(self, "show_distribution")

    @property
    @pulumi.getter(name="showErrors")
    def show_errors(self) -> Optional[bool]:
        """
        Whether to show the error metrics or not.
        """
        return pulumi.get(self, "show_errors")

    @property
    @pulumi.getter(name="showHits")
    def show_hits(self) -> Optional[bool]:
        """
        Whether to show the hits metrics or not
        """
        return pulumi.get(self, "show_hits")

    @property
    @pulumi.getter(name="showLatency")
    def show_latency(self) -> Optional[bool]:
        """
        Whether to show the latency metrics or not.
        """
        return pulumi.get(self, "show_latency")

    @property
    @pulumi.getter(name="showResourceList")
    def show_resource_list(self) -> Optional[bool]:
        """
        Whether to show the resource list or not.
        """
        return pulumi.get(self, "show_resource_list")

    @property
    @pulumi.getter(name="sizeFormat")
    def size_format(self) -> Optional[str]:
        """
        The size of the widget. Valid values are `small`, `medium`, `large`.
        """
        return pulumi.get(self, "size_format")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class DashboardWidgetTreemapDefinition(dict):
    def __init__(__self__, *,
                 requests: Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequest']] = None,
                 title: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetTreemapDefinitionRequestArgs'] requests: Nested block describing the request to use when displaying the widget.
        :param str title: The title of the widget.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequest']]:
        """
        Nested block describing the request to use when displaying the widget.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequest(dict):
    def __init__(__self__, *,
                 formulas: Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestFormula']] = None,
                 queries: Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestQuery']] = None):
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.DashboardWidgetTreemapDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.DashboardWidgetTreemapDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'DashboardWidgetTreemapDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'DashboardWidgetTreemapDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'DashboardWidgetTreemapDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'DashboardWidgetTreemapDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'DashboardWidgetTreemapDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'DashboardWidgetTreemapDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'DashboardWidgetTreemapDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['DashboardWidgetTreemapDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class DashboardWidgetTreemapDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetTreemapDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetTreemapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetTreemapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class DashboardWidgetWidgetLayout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isColumnBreak":
            suggest = "is_column_break"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardWidgetWidgetLayout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardWidgetWidgetLayout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardWidgetWidgetLayout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 height: int,
                 width: int,
                 x: int,
                 y: int,
                 is_column_break: Optional[bool] = None):
        """
        :param int height: The height of the widget.
        :param int width: The width of the widget.
        :param int x: The position of the widget on the x (horizontal) axis. Must be greater than or equal to 0.
        :param int y: The position of the widget on the y (vertical) axis. Must be greater than or equal to 0.
        :param bool is_column_break: Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
        """
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "width", width)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)
        if is_column_break is not None:
            pulumi.set(__self__, "is_column_break", is_column_break)

    @property
    @pulumi.getter
    def height(self) -> int:
        """
        The height of the widget.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> int:
        """
        The width of the widget.
        """
        return pulumi.get(self, "width")

    @property
    @pulumi.getter
    def x(self) -> int:
        """
        The position of the widget on the x (horizontal) axis. Must be greater than or equal to 0.
        """
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> int:
        """
        The position of the widget on the y (vertical) axis. Must be greater than or equal to 0.
        """
        return pulumi.get(self, "y")

    @property
    @pulumi.getter(name="isColumnBreak")
    def is_column_break(self) -> Optional[bool]:
        """
        Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
        """
        return pulumi.get(self, "is_column_break")


@pulumi.output_type
class DowntimeRecurrence(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "untilDate":
            suggest = "until_date"
        elif key == "untilOccurrences":
            suggest = "until_occurrences"
        elif key == "weekDays":
            suggest = "week_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DowntimeRecurrence. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DowntimeRecurrence.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DowntimeRecurrence.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 period: Optional[int] = None,
                 rrule: Optional[str] = None,
                 until_date: Optional[int] = None,
                 until_occurrences: Optional[int] = None,
                 week_days: Optional[Sequence[str]] = None):
        """
        :param str type: One of `days`, `weeks`, `months`, `years`, or `rrule`.
        :param int period: How often to repeat as an integer. For example to repeat every 3 days, select a `type` of `days` and a `period` of `3`.
        :param str rrule: The RRULE standard for defining recurring events. For example, to have a recurring event on the first day of each month, use `FREQ=MONTHLY;INTERVAL=1`. Most common rrule options from the iCalendar Spec are supported. Attributes specifying the duration in RRULE are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). Only applicable when `type` is `rrule`.
        :param int until_date: The date at which the recurrence should end as a POSIX timestamp. `until_occurrences` and `until_date` are mutually exclusive.
        :param int until_occurrences: How many times the downtime will be rescheduled. `until_occurrences` and `until_date` are mutually exclusive.
        :param Sequence[str] week_days: A list of week days to repeat on. Choose from: `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`. Only applicable when `type` is `weeks`. First letter must be capitalized.
        """
        pulumi.set(__self__, "type", type)
        if period is not None:
            pulumi.set(__self__, "period", period)
        if rrule is not None:
            pulumi.set(__self__, "rrule", rrule)
        if until_date is not None:
            pulumi.set(__self__, "until_date", until_date)
        if until_occurrences is not None:
            pulumi.set(__self__, "until_occurrences", until_occurrences)
        if week_days is not None:
            pulumi.set(__self__, "week_days", week_days)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        One of `days`, `weeks`, `months`, `years`, or `rrule`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def period(self) -> Optional[int]:
        """
        How often to repeat as an integer. For example to repeat every 3 days, select a `type` of `days` and a `period` of `3`.
        """
        return pulumi.get(self, "period")

    @property
    @pulumi.getter
    def rrule(self) -> Optional[str]:
        """
        The RRULE standard for defining recurring events. For example, to have a recurring event on the first day of each month, use `FREQ=MONTHLY;INTERVAL=1`. Most common rrule options from the iCalendar Spec are supported. Attributes specifying the duration in RRULE are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). Only applicable when `type` is `rrule`.
        """
        return pulumi.get(self, "rrule")

    @property
    @pulumi.getter(name="untilDate")
    def until_date(self) -> Optional[int]:
        """
        The date at which the recurrence should end as a POSIX timestamp. `until_occurrences` and `until_date` are mutually exclusive.
        """
        return pulumi.get(self, "until_date")

    @property
    @pulumi.getter(name="untilOccurrences")
    def until_occurrences(self) -> Optional[int]:
        """
        How many times the downtime will be rescheduled. `until_occurrences` and `until_date` are mutually exclusive.
        """
        return pulumi.get(self, "until_occurrences")

    @property
    @pulumi.getter(name="weekDays")
    def week_days(self) -> Optional[Sequence[str]]:
        """
        A list of week days to repeat on. Choose from: `Mon`, `Tue`, `Wed`, `Thu`, `Fri`, `Sat` or `Sun`. Only applicable when `type` is `weeks`. First letter must be capitalized.
        """
        return pulumi.get(self, "week_days")


@pulumi.output_type
class DowntimeScheduleMonitorIdentifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitorId":
            suggest = "monitor_id"
        elif key == "monitorTags":
            suggest = "monitor_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DowntimeScheduleMonitorIdentifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DowntimeScheduleMonitorIdentifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DowntimeScheduleMonitorIdentifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitor_id: Optional[int] = None,
                 monitor_tags: Optional[Sequence[str]] = None):
        """
        :param int monitor_id: ID of the monitor to prevent notifications.
        :param Sequence[str] monitor_tags: A list of monitor tags. For example, tags that are applied directly to monitors, not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies. The resulting downtime applies to monitors that match **all** provided monitor tags. Setting `monitor_tags` to `[*]` configures the downtime to mute all monitors for the given scope.
        """
        if monitor_id is not None:
            pulumi.set(__self__, "monitor_id", monitor_id)
        if monitor_tags is not None:
            pulumi.set(__self__, "monitor_tags", monitor_tags)

    @property
    @pulumi.getter(name="monitorId")
    def monitor_id(self) -> Optional[int]:
        """
        ID of the monitor to prevent notifications.
        """
        return pulumi.get(self, "monitor_id")

    @property
    @pulumi.getter(name="monitorTags")
    def monitor_tags(self) -> Optional[Sequence[str]]:
        """
        A list of monitor tags. For example, tags that are applied directly to monitors, not tags that are used in monitor queries (which are filtered by the scope parameter), to which the downtime applies. The resulting downtime applies to monitors that match **all** provided monitor tags. Setting `monitor_tags` to `[*]` configures the downtime to mute all monitors for the given scope.
        """
        return pulumi.get(self, "monitor_tags")


@pulumi.output_type
class DowntimeScheduleOneTimeSchedule(dict):
    def __init__(__self__, *,
                 end: Optional[str] = None,
                 start: Optional[str] = None):
        """
        :param str end: ISO-8601 Datetime to end the downtime. Must include a UTC offset of zero. If not provided, the downtime never ends.
        :param str start: ISO-8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
        """
        if end is not None:
            pulumi.set(__self__, "end", end)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> Optional[str]:
        """
        ISO-8601 Datetime to end the downtime. Must include a UTC offset of zero. If not provided, the downtime never ends.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def start(self) -> Optional[str]:
        """
        ISO-8601 Datetime to start the downtime. Must include a UTC offset of zero. If not provided, the downtime starts the moment it is created.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class DowntimeScheduleRecurringSchedule(dict):
    def __init__(__self__, *,
                 recurrences: Optional[Sequence['outputs.DowntimeScheduleRecurringScheduleRecurrence']] = None,
                 timezone: Optional[str] = None):
        """
        :param str timezone: The timezone in which to schedule the downtime.
        """
        if recurrences is not None:
            pulumi.set(__self__, "recurrences", recurrences)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter
    def recurrences(self) -> Optional[Sequence['outputs.DowntimeScheduleRecurringScheduleRecurrence']]:
        return pulumi.get(self, "recurrences")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        The timezone in which to schedule the downtime.
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class DowntimeScheduleRecurringScheduleRecurrence(dict):
    def __init__(__self__, *,
                 duration: str,
                 rrule: str,
                 start: Optional[str] = None):
        """
        :param str duration: The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
        :param str rrule: The `RRULE` standard for defining recurring events. For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`. Most common `rrule` options from the [iCalendar Spec](https://tools.ietf.org/html/rfc5545) are supported.  **Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api).
        :param str start: ISO-8601 Datetime to start the downtime. Must not include a UTC offset. If not provided, the downtime starts the moment it is created.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "rrule", rrule)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def duration(self) -> str:
        """
        The length of the downtime. Must begin with an integer and end with one of 'm', 'h', d', or 'w'.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def rrule(self) -> str:
        """
        The `RRULE` standard for defining recurring events. For example, to have a recurring event on the first day of each month, set the type to `rrule` and set the `FREQ` to `MONTHLY` and `BYMONTHDAY` to `1`. Most common `rrule` options from the [iCalendar Spec](https://tools.ietf.org/html/rfc5545) are supported.  **Note**: Attributes specifying the duration in `RRULE` are not supported (for example, `DTSTART`, `DTEND`, `DURATION`). More examples available in this [downtime guide](https://docs.datadoghq.com/monitors/guide/suppress-alert-with-downtimes/?tab=api).
        """
        return pulumi.get(self, "rrule")

    @property
    @pulumi.getter
    def start(self) -> Optional[str]:
        """
        ISO-8601 Datetime to start the downtime. Must not include a UTC offset. If not provided, the downtime starts the moment it is created.
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class IpAllowlistEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cidrBlock":
            suggest = "cidr_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IpAllowlistEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IpAllowlistEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IpAllowlistEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cidr_block: str,
                 note: Optional[str] = None):
        """
        :param str cidr_block: IP address or range of addresses.
        :param str note: Note accompanying IP address.
        """
        pulumi.set(__self__, "cidr_block", cidr_block)
        if note is not None:
            pulumi.set(__self__, "note", note)

    @property
    @pulumi.getter(name="cidrBlock")
    def cidr_block(self) -> str:
        """
        IP address or range of addresses.
        """
        return pulumi.get(self, "cidr_block")

    @property
    @pulumi.getter
    def note(self) -> Optional[str]:
        """
        Note accompanying IP address.
        """
        return pulumi.get(self, "note")


@pulumi.output_type
class LogsArchiveAzureArchive(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "storageAccount":
            suggest = "storage_account"
        elif key == "tenantId":
            suggest = "tenant_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsArchiveAzureArchive. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsArchiveAzureArchive.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsArchiveAzureArchive.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: str,
                 container: str,
                 storage_account: str,
                 tenant_id: str,
                 path: Optional[str] = None):
        """
        :param str client_id: Your client id.
        :param str container: The container where the archive is stored.
        :param str storage_account: The associated storage account.
        :param str tenant_id: Your tenant id.
        :param str path: The path where the archive is stored.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "storage_account", storage_account)
        pulumi.set(__self__, "tenant_id", tenant_id)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> str:
        """
        Your client id.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter
    def container(self) -> str:
        """
        The container where the archive is stored.
        """
        return pulumi.get(self, "container")

    @property
    @pulumi.getter(name="storageAccount")
    def storage_account(self) -> str:
        """
        The associated storage account.
        """
        return pulumi.get(self, "storage_account")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> str:
        """
        Your tenant id.
        """
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path where the archive is stored.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class LogsArchiveGcsArchive(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientEmail":
            suggest = "client_email"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsArchiveGcsArchive. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsArchiveGcsArchive.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsArchiveGcsArchive.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: str,
                 client_email: str,
                 path: Optional[str] = None,
                 project_id: Optional[str] = None):
        """
        :param str bucket: Name of your GCS bucket.
        :param str client_email: Your client email.
        :param str path: Path where the archive is stored.
        :param str project_id: Your project id.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "client_email", client_email)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of your GCS bucket.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> str:
        """
        Your client email.
        """
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path where the archive is stored.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        Your project id.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class LogsArchiveS3Archive(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountId":
            suggest = "account_id"
        elif key == "roleName":
            suggest = "role_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsArchiveS3Archive. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsArchiveS3Archive.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsArchiveS3Archive.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_id: str,
                 bucket: str,
                 role_name: str,
                 path: Optional[str] = None):
        """
        :param str account_id: Your AWS account id.
        :param str bucket: Name of your s3 bucket.
        :param str role_name: Your AWS role name
        :param str path: Path where the archive is stored.
        """
        pulumi.set(__self__, "account_id", account_id)
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "role_name", role_name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="accountId")
    def account_id(self) -> str:
        """
        Your AWS account id.
        """
        return pulumi.get(self, "account_id")

    @property
    @pulumi.getter
    def bucket(self) -> str:
        """
        Name of your s3 bucket.
        """
        return pulumi.get(self, "bucket")

    @property
    @pulumi.getter(name="roleName")
    def role_name(self) -> str:
        """
        Your AWS role name
        """
        return pulumi.get(self, "role_name")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path where the archive is stored.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class LogsCustomDestinationElasticsearchDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"
        elif key == "indexName":
            suggest = "index_name"
        elif key == "indexRotation":
            suggest = "index_rotation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomDestinationElasticsearchDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomDestinationElasticsearchDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomDestinationElasticsearchDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 basic_auth: 'outputs.LogsCustomDestinationElasticsearchDestinationBasicAuth',
                 endpoint: str,
                 index_name: str,
                 index_rotation: Optional[str] = None):
        """
        :param 'LogsCustomDestinationElasticsearchDestinationBasicAuthArgs' basic_auth: Basic access authentication.
        :param str endpoint: The destination for which logs will be forwarded to. Must have HTTPS scheme. Forwarding back to Datadog is not allowed.
        :param str index_name: Name of the Elasticsearch index (must follow [Elasticsearch's criteria](https://www.elastic.co/guide/en/elasticsearch/reference/8.11/indices-create-index.html#indices-create-api-path-params)).
        :param str index_rotation: Date pattern with US locale and UTC timezone to be appended to the index name after adding '-'
               						(that is, '${index_name}-${indexPattern}').
               						You can customize the index rotation naming pattern by choosing one of these options:
               						- Hourly: 'yyyy-MM-dd-HH' (as an example, it would render: '2022-10-19-09')
               						- Daily: 'yyyy-MM-dd' (as an example, it would render: '2022-10-19')
               						- Weekly: 'yyyy-'W'ww' (as an example, it would render: '2022-W42')
               						- Monthly: 'yyyy-MM' (as an example, it would render: '2022-10')
               						If this field is missing or is blank, it means that the index name will always be the same
               						(that is, no rotation).
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "index_name", index_name)
        if index_rotation is not None:
            pulumi.set(__self__, "index_rotation", index_rotation)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> 'outputs.LogsCustomDestinationElasticsearchDestinationBasicAuth':
        """
        Basic access authentication.
        """
        return pulumi.get(self, "basic_auth")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The destination for which logs will be forwarded to. Must have HTTPS scheme. Forwarding back to Datadog is not allowed.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> str:
        """
        Name of the Elasticsearch index (must follow [Elasticsearch's criteria](https://www.elastic.co/guide/en/elasticsearch/reference/8.11/indices-create-index.html#indices-create-api-path-params)).
        """
        return pulumi.get(self, "index_name")

    @property
    @pulumi.getter(name="indexRotation")
    def index_rotation(self) -> Optional[str]:
        """
        Date pattern with US locale and UTC timezone to be appended to the index name after adding '-'
        						(that is, '${index_name}-${indexPattern}').
        						You can customize the index rotation naming pattern by choosing one of these options:
        						- Hourly: 'yyyy-MM-dd-HH' (as an example, it would render: '2022-10-19-09')
        						- Daily: 'yyyy-MM-dd' (as an example, it would render: '2022-10-19')
        						- Weekly: 'yyyy-'W'ww' (as an example, it would render: '2022-W42')
        						- Monthly: 'yyyy-MM' (as an example, it would render: '2022-10')
        						If this field is missing or is blank, it means that the index name will always be the same
        						(that is, no rotation).
        """
        return pulumi.get(self, "index_rotation")


@pulumi.output_type
class LogsCustomDestinationElasticsearchDestinationBasicAuth(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password of the authentication. This field is not returned by the API.
        :param str username: The username of the authentication. This field is not returned by the API.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password of the authentication. This field is not returned by the API.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username of the authentication. This field is not returned by the API.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class LogsCustomDestinationHttpDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"
        elif key == "customHeaderAuth":
            suggest = "custom_header_auth"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomDestinationHttpDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomDestinationHttpDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomDestinationHttpDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 endpoint: str,
                 basic_auth: Optional['outputs.LogsCustomDestinationHttpDestinationBasicAuth'] = None,
                 custom_header_auth: Optional['outputs.LogsCustomDestinationHttpDestinationCustomHeaderAuth'] = None):
        """
        :param str endpoint: The destination for which logs will be forwarded to. Must have HTTPS scheme. Forwarding back to Datadog is not allowed.
        :param 'LogsCustomDestinationHttpDestinationBasicAuthArgs' basic_auth: Basic access authentication.
        :param 'LogsCustomDestinationHttpDestinationCustomHeaderAuthArgs' custom_header_auth: Custom header access authentication.
        """
        pulumi.set(__self__, "endpoint", endpoint)
        if basic_auth is not None:
            pulumi.set(__self__, "basic_auth", basic_auth)
        if custom_header_auth is not None:
            pulumi.set(__self__, "custom_header_auth", custom_header_auth)

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The destination for which logs will be forwarded to. Must have HTTPS scheme. Forwarding back to Datadog is not allowed.
        """
        return pulumi.get(self, "endpoint")

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> Optional['outputs.LogsCustomDestinationHttpDestinationBasicAuth']:
        """
        Basic access authentication.
        """
        return pulumi.get(self, "basic_auth")

    @property
    @pulumi.getter(name="customHeaderAuth")
    def custom_header_auth(self) -> Optional['outputs.LogsCustomDestinationHttpDestinationCustomHeaderAuth']:
        """
        Custom header access authentication.
        """
        return pulumi.get(self, "custom_header_auth")


@pulumi.output_type
class LogsCustomDestinationHttpDestinationBasicAuth(dict):
    def __init__(__self__, *,
                 password: str,
                 username: str):
        """
        :param str password: The password of the authentication. This field is not returned by the API.
        :param str username: The username of the authentication. This field is not returned by the API.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> str:
        """
        The password of the authentication. This field is not returned by the API.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The username of the authentication. This field is not returned by the API.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class LogsCustomDestinationHttpDestinationCustomHeaderAuth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerName":
            suggest = "header_name"
        elif key == "headerValue":
            suggest = "header_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomDestinationHttpDestinationCustomHeaderAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomDestinationHttpDestinationCustomHeaderAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomDestinationHttpDestinationCustomHeaderAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_name: str,
                 header_value: str):
        """
        :param str header_name: The header name of the authentication.
        :param str header_value: The header value of the authentication. This field is not returned by the API.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "header_value", header_value)

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        The header name of the authentication.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> str:
        """
        The header value of the authentication. This field is not returned by the API.
        """
        return pulumi.get(self, "header_value")


@pulumi.output_type
class LogsCustomDestinationSplunkDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessToken":
            suggest = "access_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomDestinationSplunkDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomDestinationSplunkDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomDestinationSplunkDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_token: str,
                 endpoint: str):
        """
        :param str access_token: Access token of the Splunk HTTP Event Collector. This field is not returned by the API.
        :param str endpoint: The destination for which logs will be forwarded to. Must have HTTPS scheme. Forwarding back to Datadog is not allowed.
        """
        pulumi.set(__self__, "access_token", access_token)
        pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> str:
        """
        Access token of the Splunk HTTP Event Collector. This field is not returned by the API.
        """
        return pulumi.get(self, "access_token")

    @property
    @pulumi.getter
    def endpoint(self) -> str:
        """
        The destination for which logs will be forwarded to. Must have HTTPS scheme. Forwarding back to Datadog is not allowed.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class LogsCustomPipelineFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Filter criteria of the category.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Filter criteria of the category.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsCustomPipelineProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arithmeticProcessor":
            suggest = "arithmetic_processor"
        elif key == "attributeRemapper":
            suggest = "attribute_remapper"
        elif key == "categoryProcessor":
            suggest = "category_processor"
        elif key == "dateRemapper":
            suggest = "date_remapper"
        elif key == "geoIpParser":
            suggest = "geo_ip_parser"
        elif key == "grokParser":
            suggest = "grok_parser"
        elif key == "lookupProcessor":
            suggest = "lookup_processor"
        elif key == "messageRemapper":
            suggest = "message_remapper"
        elif key == "referenceTableLookupProcessor":
            suggest = "reference_table_lookup_processor"
        elif key == "serviceRemapper":
            suggest = "service_remapper"
        elif key == "statusRemapper":
            suggest = "status_remapper"
        elif key == "stringBuilderProcessor":
            suggest = "string_builder_processor"
        elif key == "traceIdRemapper":
            suggest = "trace_id_remapper"
        elif key == "urlParser":
            suggest = "url_parser"
        elif key == "userAgentParser":
            suggest = "user_agent_parser"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arithmetic_processor: Optional['outputs.LogsCustomPipelineProcessorArithmeticProcessor'] = None,
                 attribute_remapper: Optional['outputs.LogsCustomPipelineProcessorAttributeRemapper'] = None,
                 category_processor: Optional['outputs.LogsCustomPipelineProcessorCategoryProcessor'] = None,
                 date_remapper: Optional['outputs.LogsCustomPipelineProcessorDateRemapper'] = None,
                 geo_ip_parser: Optional['outputs.LogsCustomPipelineProcessorGeoIpParser'] = None,
                 grok_parser: Optional['outputs.LogsCustomPipelineProcessorGrokParser'] = None,
                 lookup_processor: Optional['outputs.LogsCustomPipelineProcessorLookupProcessor'] = None,
                 message_remapper: Optional['outputs.LogsCustomPipelineProcessorMessageRemapper'] = None,
                 pipeline: Optional['outputs.LogsCustomPipelineProcessorPipeline'] = None,
                 reference_table_lookup_processor: Optional['outputs.LogsCustomPipelineProcessorReferenceTableLookupProcessor'] = None,
                 service_remapper: Optional['outputs.LogsCustomPipelineProcessorServiceRemapper'] = None,
                 status_remapper: Optional['outputs.LogsCustomPipelineProcessorStatusRemapper'] = None,
                 string_builder_processor: Optional['outputs.LogsCustomPipelineProcessorStringBuilderProcessor'] = None,
                 trace_id_remapper: Optional['outputs.LogsCustomPipelineProcessorTraceIdRemapper'] = None,
                 url_parser: Optional['outputs.LogsCustomPipelineProcessorUrlParser'] = None,
                 user_agent_parser: Optional['outputs.LogsCustomPipelineProcessorUserAgentParser'] = None):
        """
        :param 'LogsCustomPipelineProcessorArithmeticProcessorArgs' arithmetic_processor: Arithmetic Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#arithmetic-processor)
        :param 'LogsCustomPipelineProcessorAttributeRemapperArgs' attribute_remapper: Attribute Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#remapper)
        :param 'LogsCustomPipelineProcessorCategoryProcessorArgs' category_processor: Category Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#category-processor)
        :param 'LogsCustomPipelineProcessorDateRemapperArgs' date_remapper: Date Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-date-remapper)
        :param 'LogsCustomPipelineProcessorGeoIpParserArgs' geo_ip_parser: Date GeoIP Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#geoip-parser)
        :param 'LogsCustomPipelineProcessorGrokParserArgs' grok_parser: Grok Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#grok-parser)
        :param 'LogsCustomPipelineProcessorLookupProcessorArgs' lookup_processor: Lookup Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        :param 'LogsCustomPipelineProcessorMessageRemapperArgs' message_remapper: Message Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-message-remapper)
        :param 'LogsCustomPipelineProcessorReferenceTableLookupProcessorArgs' reference_table_lookup_processor: Reference Table Lookup Processor. Reference Tables are in public beta. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        :param 'LogsCustomPipelineProcessorServiceRemapperArgs' service_remapper: Service Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#service-remapper)
        :param 'LogsCustomPipelineProcessorStatusRemapperArgs' status_remapper: Status Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-status-remapper)
        :param 'LogsCustomPipelineProcessorStringBuilderProcessorArgs' string_builder_processor: String Builder Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#string-builder-processor)
        :param 'LogsCustomPipelineProcessorTraceIdRemapperArgs' trace_id_remapper: Trace ID Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#trace-remapper)
        :param 'LogsCustomPipelineProcessorUrlParserArgs' url_parser: URL Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#url-parser)
        :param 'LogsCustomPipelineProcessorUserAgentParserArgs' user_agent_parser: User-Agent Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#user-agent-parser)
        """
        if arithmetic_processor is not None:
            pulumi.set(__self__, "arithmetic_processor", arithmetic_processor)
        if attribute_remapper is not None:
            pulumi.set(__self__, "attribute_remapper", attribute_remapper)
        if category_processor is not None:
            pulumi.set(__self__, "category_processor", category_processor)
        if date_remapper is not None:
            pulumi.set(__self__, "date_remapper", date_remapper)
        if geo_ip_parser is not None:
            pulumi.set(__self__, "geo_ip_parser", geo_ip_parser)
        if grok_parser is not None:
            pulumi.set(__self__, "grok_parser", grok_parser)
        if lookup_processor is not None:
            pulumi.set(__self__, "lookup_processor", lookup_processor)
        if message_remapper is not None:
            pulumi.set(__self__, "message_remapper", message_remapper)
        if pipeline is not None:
            pulumi.set(__self__, "pipeline", pipeline)
        if reference_table_lookup_processor is not None:
            pulumi.set(__self__, "reference_table_lookup_processor", reference_table_lookup_processor)
        if service_remapper is not None:
            pulumi.set(__self__, "service_remapper", service_remapper)
        if status_remapper is not None:
            pulumi.set(__self__, "status_remapper", status_remapper)
        if string_builder_processor is not None:
            pulumi.set(__self__, "string_builder_processor", string_builder_processor)
        if trace_id_remapper is not None:
            pulumi.set(__self__, "trace_id_remapper", trace_id_remapper)
        if url_parser is not None:
            pulumi.set(__self__, "url_parser", url_parser)
        if user_agent_parser is not None:
            pulumi.set(__self__, "user_agent_parser", user_agent_parser)

    @property
    @pulumi.getter(name="arithmeticProcessor")
    def arithmetic_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorArithmeticProcessor']:
        """
        Arithmetic Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#arithmetic-processor)
        """
        return pulumi.get(self, "arithmetic_processor")

    @property
    @pulumi.getter(name="attributeRemapper")
    def attribute_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorAttributeRemapper']:
        """
        Attribute Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#remapper)
        """
        return pulumi.get(self, "attribute_remapper")

    @property
    @pulumi.getter(name="categoryProcessor")
    def category_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorCategoryProcessor']:
        """
        Category Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#category-processor)
        """
        return pulumi.get(self, "category_processor")

    @property
    @pulumi.getter(name="dateRemapper")
    def date_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorDateRemapper']:
        """
        Date Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-date-remapper)
        """
        return pulumi.get(self, "date_remapper")

    @property
    @pulumi.getter(name="geoIpParser")
    def geo_ip_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorGeoIpParser']:
        """
        Date GeoIP Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#geoip-parser)
        """
        return pulumi.get(self, "geo_ip_parser")

    @property
    @pulumi.getter(name="grokParser")
    def grok_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorGrokParser']:
        """
        Grok Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#grok-parser)
        """
        return pulumi.get(self, "grok_parser")

    @property
    @pulumi.getter(name="lookupProcessor")
    def lookup_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorLookupProcessor']:
        """
        Lookup Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        """
        return pulumi.get(self, "lookup_processor")

    @property
    @pulumi.getter(name="messageRemapper")
    def message_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorMessageRemapper']:
        """
        Message Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-message-remapper)
        """
        return pulumi.get(self, "message_remapper")

    @property
    @pulumi.getter
    def pipeline(self) -> Optional['outputs.LogsCustomPipelineProcessorPipeline']:
        return pulumi.get(self, "pipeline")

    @property
    @pulumi.getter(name="referenceTableLookupProcessor")
    def reference_table_lookup_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorReferenceTableLookupProcessor']:
        """
        Reference Table Lookup Processor. Reference Tables are in public beta. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        """
        return pulumi.get(self, "reference_table_lookup_processor")

    @property
    @pulumi.getter(name="serviceRemapper")
    def service_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorServiceRemapper']:
        """
        Service Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#service-remapper)
        """
        return pulumi.get(self, "service_remapper")

    @property
    @pulumi.getter(name="statusRemapper")
    def status_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorStatusRemapper']:
        """
        Status Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-status-remapper)
        """
        return pulumi.get(self, "status_remapper")

    @property
    @pulumi.getter(name="stringBuilderProcessor")
    def string_builder_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorStringBuilderProcessor']:
        """
        String Builder Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#string-builder-processor)
        """
        return pulumi.get(self, "string_builder_processor")

    @property
    @pulumi.getter(name="traceIdRemapper")
    def trace_id_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorTraceIdRemapper']:
        """
        Trace ID Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#trace-remapper)
        """
        return pulumi.get(self, "trace_id_remapper")

    @property
    @pulumi.getter(name="urlParser")
    def url_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorUrlParser']:
        """
        URL Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#url-parser)
        """
        return pulumi.get(self, "url_parser")

    @property
    @pulumi.getter(name="userAgentParser")
    def user_agent_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorUserAgentParser']:
        """
        User-Agent Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#user-agent-parser)
        """
        return pulumi.get(self, "user_agent_parser")


@pulumi.output_type
class LogsCustomPipelineProcessorArithmeticProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isReplaceMissing":
            suggest = "is_replace_missing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorArithmeticProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorArithmeticProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorArithmeticProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 target: str,
                 is_enabled: Optional[bool] = None,
                 is_replace_missing: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str expression: Arithmetic operation between one or more log attributes.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param bool is_replace_missing: If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
        :param str name: Your pipeline name.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Arithmetic operation between one or more log attributes.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[bool]:
        """
        If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
        """
        return pulumi.get(self, "is_replace_missing")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorAttributeRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"
        elif key == "targetType":
            suggest = "target_type"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "overrideOnConflict":
            suggest = "override_on_conflict"
        elif key == "preserveSource":
            suggest = "preserve_source"
        elif key == "targetFormat":
            suggest = "target_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorAttributeRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorAttributeRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorAttributeRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 sources: Sequence[str],
                 target: str,
                 target_type: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 override_on_conflict: Optional[bool] = None,
                 preserve_source: Optional[bool] = None,
                 target_format: Optional[str] = None):
        """
        :param str source_type: Defines where the sources are from (log `attribute` or `tag`).
        :param Sequence[str] sources: List of source attributes or tags.
        :param str target: Final attribute or tag name to remap the sources.
        :param str target_type: Defines if the target is a log `attribute` or `tag`.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        :param bool override_on_conflict: Override the target element if already set.
        :param bool preserve_source: Remove or preserve the remapped source element.
        :param str target_format: If the `target_type` of the remapper is `attribute`, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. `string`, `integer`, or `double` are the possible types. If the `target_type` is `tag`, this parameter may not be specified.
        """
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "target_type", target_type)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_on_conflict is not None:
            pulumi.set(__self__, "override_on_conflict", override_on_conflict)
        if preserve_source is not None:
            pulumi.set(__self__, "preserve_source", preserve_source)
        if target_format is not None:
            pulumi.set(__self__, "target_format", target_format)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Defines where the sources are from (log `attribute` or `tag`).
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Final attribute or tag name to remap the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> str:
        """
        Defines if the target is a log `attribute` or `tag`.
        """
        return pulumi.get(self, "target_type")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideOnConflict")
    def override_on_conflict(self) -> Optional[bool]:
        """
        Override the target element if already set.
        """
        return pulumi.get(self, "override_on_conflict")

    @property
    @pulumi.getter(name="preserveSource")
    def preserve_source(self) -> Optional[bool]:
        """
        Remove or preserve the remapped source element.
        """
        return pulumi.get(self, "preserve_source")

    @property
    @pulumi.getter(name="targetFormat")
    def target_format(self) -> Optional[str]:
        """
        If the `target_type` of the remapper is `attribute`, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. `string`, `integer`, or `double` are the possible types. If the `target_type` is `tag`, this parameter may not be specified.
        """
        return pulumi.get(self, "target_format")


@pulumi.output_type
class LogsCustomPipelineProcessorCategoryProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorCategoryProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorCategoryProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorCategoryProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 categories: Sequence['outputs.LogsCustomPipelineProcessorCategoryProcessorCategory'],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence['LogsCustomPipelineProcessorCategoryProcessorCategoryArgs'] categories: List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        :param str target: Name of the target attribute whose value is defined by the matching category.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the category
        """
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def categories(self) -> Sequence['outputs.LogsCustomPipelineProcessorCategoryProcessorCategory']:
        """
        List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        """
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the target attribute whose value is defined by the matching category.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the category
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorCategoryProcessorCategory(dict):
    def __init__(__self__, *,
                 filter: 'outputs.LogsCustomPipelineProcessorCategoryProcessorCategoryFilter',
                 name: str):
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.LogsCustomPipelineProcessorCategoryProcessorCategoryFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorCategoryProcessorCategoryFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Filter criteria of the category.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Filter criteria of the category.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsCustomPipelineProcessorDateRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorDateRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorDateRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorDateRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorGeoIpParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorGeoIpParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorGeoIpParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorGeoIpParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorGrokParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorGrokParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorGrokParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorGrokParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grok: 'outputs.LogsCustomPipelineProcessorGrokParserGrok',
                 source: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 samples: Optional[Sequence[str]] = None):
        """
        :param str source: Name of the log attribute to parse.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        :param Sequence[str] samples: List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        pulumi.set(__self__, "grok", grok)
        pulumi.set(__self__, "source", source)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if samples is not None:
            pulumi.set(__self__, "samples", samples)

    @property
    @pulumi.getter
    def grok(self) -> 'outputs.LogsCustomPipelineProcessorGrokParserGrok':
        return pulumi.get(self, "grok")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Name of the log attribute to parse.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def samples(self) -> Optional[Sequence[str]]:
        """
        List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        return pulumi.get(self, "samples")


@pulumi.output_type
class LogsCustomPipelineProcessorGrokParserGrok(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchRules":
            suggest = "match_rules"
        elif key == "supportRules":
            suggest = "support_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorGrokParserGrok. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorGrokParserGrok.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorGrokParserGrok.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_rules: str,
                 support_rules: str):
        """
        :param str match_rules: Match rules for your grok parser.
        :param str support_rules: Support rules for your grok parser.
        """
        pulumi.set(__self__, "match_rules", match_rules)
        pulumi.set(__self__, "support_rules", support_rules)

    @property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> str:
        """
        Match rules for your grok parser.
        """
        return pulumi.get(self, "match_rules")

    @property
    @pulumi.getter(name="supportRules")
    def support_rules(self) -> str:
        """
        Support rules for your grok parser.
        """
        return pulumi.get(self, "support_rules")


@pulumi.output_type
class LogsCustomPipelineProcessorLookupProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lookupTables":
            suggest = "lookup_tables"
        elif key == "defaultLookup":
            suggest = "default_lookup"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorLookupProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorLookupProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorLookupProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lookup_tables: Sequence[str],
                 source: str,
                 target: str,
                 default_lookup: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] lookup_tables: List of entries of the lookup table using `key,value` format.
        :param str source: Name of the source attribute used to do the lookup.
        :param str target: Name of the attribute that contains the result of the lookup.
        :param str default_lookup: Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "lookup_tables", lookup_tables)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if default_lookup is not None:
            pulumi.set(__self__, "default_lookup", default_lookup)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lookupTables")
    def lookup_tables(self) -> Sequence[str]:
        """
        List of entries of the lookup table using `key,value` format.
        """
        return pulumi.get(self, "lookup_tables")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Name of the source attribute used to do the lookup.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the lookup.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="defaultLookup")
    def default_lookup(self) -> Optional[str]:
        """
        Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        """
        return pulumi.get(self, "default_lookup")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorMessageRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorMessageRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorMessageRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorMessageRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipeline(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipeline. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipeline.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipeline.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Sequence['outputs.LogsCustomPipelineProcessorPipelineFilter'],
                 name: str,
                 is_enabled: Optional[bool] = None,
                 processors: Optional[Sequence['outputs.LogsCustomPipelineProcessorPipelineProcessor']] = None):
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "name", name)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if processors is not None:
            pulumi.set(__self__, "processors", processors)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.LogsCustomPipelineProcessorPipelineFilter']:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def processors(self) -> Optional[Sequence['outputs.LogsCustomPipelineProcessorPipelineProcessor']]:
        return pulumi.get(self, "processors")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Filter criteria of the category.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Filter criteria of the category.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "arithmeticProcessor":
            suggest = "arithmetic_processor"
        elif key == "attributeRemapper":
            suggest = "attribute_remapper"
        elif key == "categoryProcessor":
            suggest = "category_processor"
        elif key == "dateRemapper":
            suggest = "date_remapper"
        elif key == "geoIpParser":
            suggest = "geo_ip_parser"
        elif key == "grokParser":
            suggest = "grok_parser"
        elif key == "lookupProcessor":
            suggest = "lookup_processor"
        elif key == "messageRemapper":
            suggest = "message_remapper"
        elif key == "referenceTableLookupProcessor":
            suggest = "reference_table_lookup_processor"
        elif key == "serviceRemapper":
            suggest = "service_remapper"
        elif key == "statusRemapper":
            suggest = "status_remapper"
        elif key == "stringBuilderProcessor":
            suggest = "string_builder_processor"
        elif key == "traceIdRemapper":
            suggest = "trace_id_remapper"
        elif key == "urlParser":
            suggest = "url_parser"
        elif key == "userAgentParser":
            suggest = "user_agent_parser"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arithmetic_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor'] = None,
                 attribute_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper'] = None,
                 category_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor'] = None,
                 date_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorDateRemapper'] = None,
                 geo_ip_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGeoIpParser'] = None,
                 grok_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParser'] = None,
                 lookup_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorLookupProcessor'] = None,
                 message_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorMessageRemapper'] = None,
                 reference_table_lookup_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor'] = None,
                 service_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorServiceRemapper'] = None,
                 status_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStatusRemapper'] = None,
                 string_builder_processor: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor'] = None,
                 trace_id_remapper: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper'] = None,
                 url_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUrlParser'] = None,
                 user_agent_parser: Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUserAgentParser'] = None):
        """
        :param 'LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessorArgs' arithmetic_processor: Arithmetic Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#arithmetic-processor)
        :param 'LogsCustomPipelineProcessorPipelineProcessorAttributeRemapperArgs' attribute_remapper: Attribute Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#remapper)
        :param 'LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorArgs' category_processor: Category Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#category-processor)
        :param 'LogsCustomPipelineProcessorPipelineProcessorDateRemapperArgs' date_remapper: Date Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-date-remapper)
        :param 'LogsCustomPipelineProcessorPipelineProcessorGeoIpParserArgs' geo_ip_parser: Date GeoIP Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#geoip-parser)
        :param 'LogsCustomPipelineProcessorPipelineProcessorGrokParserArgs' grok_parser: Grok Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#grok-parser)
        :param 'LogsCustomPipelineProcessorPipelineProcessorLookupProcessorArgs' lookup_processor: Lookup Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        :param 'LogsCustomPipelineProcessorPipelineProcessorMessageRemapperArgs' message_remapper: Message Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-message-remapper)
        :param 'LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessorArgs' reference_table_lookup_processor: Reference Table Lookup Processor. Reference Tables are in public beta. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        :param 'LogsCustomPipelineProcessorPipelineProcessorServiceRemapperArgs' service_remapper: Service Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#service-remapper)
        :param 'LogsCustomPipelineProcessorPipelineProcessorStatusRemapperArgs' status_remapper: Status Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-status-remapper)
        :param 'LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessorArgs' string_builder_processor: String Builder Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#string-builder-processor)
        :param 'LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapperArgs' trace_id_remapper: Trace ID Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#trace-remapper)
        :param 'LogsCustomPipelineProcessorPipelineProcessorUrlParserArgs' url_parser: URL Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#url-parser)
        :param 'LogsCustomPipelineProcessorPipelineProcessorUserAgentParserArgs' user_agent_parser: User-Agent Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#user-agent-parser)
        """
        if arithmetic_processor is not None:
            pulumi.set(__self__, "arithmetic_processor", arithmetic_processor)
        if attribute_remapper is not None:
            pulumi.set(__self__, "attribute_remapper", attribute_remapper)
        if category_processor is not None:
            pulumi.set(__self__, "category_processor", category_processor)
        if date_remapper is not None:
            pulumi.set(__self__, "date_remapper", date_remapper)
        if geo_ip_parser is not None:
            pulumi.set(__self__, "geo_ip_parser", geo_ip_parser)
        if grok_parser is not None:
            pulumi.set(__self__, "grok_parser", grok_parser)
        if lookup_processor is not None:
            pulumi.set(__self__, "lookup_processor", lookup_processor)
        if message_remapper is not None:
            pulumi.set(__self__, "message_remapper", message_remapper)
        if reference_table_lookup_processor is not None:
            pulumi.set(__self__, "reference_table_lookup_processor", reference_table_lookup_processor)
        if service_remapper is not None:
            pulumi.set(__self__, "service_remapper", service_remapper)
        if status_remapper is not None:
            pulumi.set(__self__, "status_remapper", status_remapper)
        if string_builder_processor is not None:
            pulumi.set(__self__, "string_builder_processor", string_builder_processor)
        if trace_id_remapper is not None:
            pulumi.set(__self__, "trace_id_remapper", trace_id_remapper)
        if url_parser is not None:
            pulumi.set(__self__, "url_parser", url_parser)
        if user_agent_parser is not None:
            pulumi.set(__self__, "user_agent_parser", user_agent_parser)

    @property
    @pulumi.getter(name="arithmeticProcessor")
    def arithmetic_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor']:
        """
        Arithmetic Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#arithmetic-processor)
        """
        return pulumi.get(self, "arithmetic_processor")

    @property
    @pulumi.getter(name="attributeRemapper")
    def attribute_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper']:
        """
        Attribute Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#remapper)
        """
        return pulumi.get(self, "attribute_remapper")

    @property
    @pulumi.getter(name="categoryProcessor")
    def category_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor']:
        """
        Category Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#category-processor)
        """
        return pulumi.get(self, "category_processor")

    @property
    @pulumi.getter(name="dateRemapper")
    def date_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorDateRemapper']:
        """
        Date Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-date-remapper)
        """
        return pulumi.get(self, "date_remapper")

    @property
    @pulumi.getter(name="geoIpParser")
    def geo_ip_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGeoIpParser']:
        """
        Date GeoIP Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#geoip-parser)
        """
        return pulumi.get(self, "geo_ip_parser")

    @property
    @pulumi.getter(name="grokParser")
    def grok_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParser']:
        """
        Grok Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#grok-parser)
        """
        return pulumi.get(self, "grok_parser")

    @property
    @pulumi.getter(name="lookupProcessor")
    def lookup_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorLookupProcessor']:
        """
        Lookup Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        """
        return pulumi.get(self, "lookup_processor")

    @property
    @pulumi.getter(name="messageRemapper")
    def message_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorMessageRemapper']:
        """
        Message Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-message-remapper)
        """
        return pulumi.get(self, "message_remapper")

    @property
    @pulumi.getter(name="referenceTableLookupProcessor")
    def reference_table_lookup_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor']:
        """
        Reference Table Lookup Processor. Reference Tables are in public beta. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#lookup-processor)
        """
        return pulumi.get(self, "reference_table_lookup_processor")

    @property
    @pulumi.getter(name="serviceRemapper")
    def service_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorServiceRemapper']:
        """
        Service Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#service-remapper)
        """
        return pulumi.get(self, "service_remapper")

    @property
    @pulumi.getter(name="statusRemapper")
    def status_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStatusRemapper']:
        """
        Status Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#log-status-remapper)
        """
        return pulumi.get(self, "status_remapper")

    @property
    @pulumi.getter(name="stringBuilderProcessor")
    def string_builder_processor(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor']:
        """
        String Builder Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#string-builder-processor)
        """
        return pulumi.get(self, "string_builder_processor")

    @property
    @pulumi.getter(name="traceIdRemapper")
    def trace_id_remapper(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper']:
        """
        Trace ID Remapper Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#trace-remapper)
        """
        return pulumi.get(self, "trace_id_remapper")

    @property
    @pulumi.getter(name="urlParser")
    def url_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUrlParser']:
        """
        URL Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#url-parser)
        """
        return pulumi.get(self, "url_parser")

    @property
    @pulumi.getter(name="userAgentParser")
    def user_agent_parser(self) -> Optional['outputs.LogsCustomPipelineProcessorPipelineProcessorUserAgentParser']:
        """
        User-Agent Parser Processor. More information can be found in the [official docs](https://docs.datadoghq.com/logs/processing/processors/?tab=ui#user-agent-parser)
        """
        return pulumi.get(self, "user_agent_parser")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isReplaceMissing":
            suggest = "is_replace_missing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorArithmeticProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 target: str,
                 is_enabled: Optional[bool] = None,
                 is_replace_missing: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str expression: Arithmetic operation between one or more log attributes.
        :param str target: Name of the attribute that contains the result of the arithmetic operation.
        :param bool is_enabled: Boolean value to enable your pipeline.
        :param bool is_replace_missing: If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
        :param str name: Your pipeline name.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        Arithmetic operation between one or more log attributes.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the arithmetic operation.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        Boolean value to enable your pipeline.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[bool]:
        """
        If true, it replaces all missing attributes of expression by 0, false skips the operation if an attribute is missing.
        """
        return pulumi.get(self, "is_replace_missing")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Your pipeline name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceType":
            suggest = "source_type"
        elif key == "targetType":
            suggest = "target_type"
        elif key == "isEnabled":
            suggest = "is_enabled"
        elif key == "overrideOnConflict":
            suggest = "override_on_conflict"
        elif key == "preserveSource":
            suggest = "preserve_source"
        elif key == "targetFormat":
            suggest = "target_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorAttributeRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_type: str,
                 sources: Sequence[str],
                 target: str,
                 target_type: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 override_on_conflict: Optional[bool] = None,
                 preserve_source: Optional[bool] = None,
                 target_format: Optional[str] = None):
        """
        :param str source_type: Defines where the sources are from (log `attribute` or `tag`).
        :param Sequence[str] sources: List of source attributes or tags.
        :param str target: Final attribute or tag name to remap the sources.
        :param str target_type: Defines if the target is a log `attribute` or `tag`.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        :param bool override_on_conflict: Override the target element if already set.
        :param bool preserve_source: Remove or preserve the remapped source element.
        :param str target_format: If the `target_type` of the remapper is `attribute`, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. `string`, `integer`, or `double` are the possible types. If the `target_type` is `tag`, this parameter may not be specified.
        """
        pulumi.set(__self__, "source_type", source_type)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "target_type", target_type)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if override_on_conflict is not None:
            pulumi.set(__self__, "override_on_conflict", override_on_conflict)
        if preserve_source is not None:
            pulumi.set(__self__, "preserve_source", preserve_source)
        if target_format is not None:
            pulumi.set(__self__, "target_format", target_format)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Defines where the sources are from (log `attribute` or `tag`).
        """
        return pulumi.get(self, "source_type")

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes or tags.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Final attribute or tag name to remap the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="targetType")
    def target_type(self) -> str:
        """
        Defines if the target is a log `attribute` or `tag`.
        """
        return pulumi.get(self, "target_type")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="overrideOnConflict")
    def override_on_conflict(self) -> Optional[bool]:
        """
        Override the target element if already set.
        """
        return pulumi.get(self, "override_on_conflict")

    @property
    @pulumi.getter(name="preserveSource")
    def preserve_source(self) -> Optional[bool]:
        """
        Remove or preserve the remapped source element.
        """
        return pulumi.get(self, "preserve_source")

    @property
    @pulumi.getter(name="targetFormat")
    def target_format(self) -> Optional[str]:
        """
        If the `target_type` of the remapper is `attribute`, try to cast the value to a new specific type. If the cast is not possible, the original type is kept. `string`, `integer`, or `double` are the possible types. If the `target_type` is `tag`, this parameter may not be specified.
        """
        return pulumi.get(self, "target_format")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorCategoryProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 categories: Sequence['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory'],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence['LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryArgs'] categories: List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        :param str target: Name of the target attribute whose value is defined by the matching category.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the category
        """
        pulumi.set(__self__, "categories", categories)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def categories(self) -> Sequence['outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory']:
        """
        List of filters to match or exclude a log with their corresponding name to assign a custom value to the log.
        """
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the target attribute whose value is defined by the matching category.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the category
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategory(dict):
    def __init__(__self__, *,
                 filter: 'outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter',
                 name: str):
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def filter(self) -> 'outputs.LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter':
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorCategoryProcessorCategoryFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Filter criteria of the category.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Filter criteria of the category.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorDateRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorDateRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorDateRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorDateRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorGeoIpParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorGeoIpParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGeoIpParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGeoIpParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorGrokParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorGrokParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGrokParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGrokParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grok: 'outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok',
                 source: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 samples: Optional[Sequence[str]] = None):
        """
        :param str source: Name of the log attribute to parse.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        :param Sequence[str] samples: List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        pulumi.set(__self__, "grok", grok)
        pulumi.set(__self__, "source", source)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if samples is not None:
            pulumi.set(__self__, "samples", samples)

    @property
    @pulumi.getter
    def grok(self) -> 'outputs.LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok':
        return pulumi.get(self, "grok")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Name of the log attribute to parse.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def samples(self) -> Optional[Sequence[str]]:
        """
        List of sample logs for this parser. It can save up to 5 samples. Each sample takes up to 5000 characters.
        """
        return pulumi.get(self, "samples")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchRules":
            suggest = "match_rules"
        elif key == "supportRules":
            suggest = "support_rules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorGrokParserGrok.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_rules: str,
                 support_rules: str):
        """
        :param str match_rules: Match rules for your grok parser.
        :param str support_rules: Support rules for your grok parser.
        """
        pulumi.set(__self__, "match_rules", match_rules)
        pulumi.set(__self__, "support_rules", support_rules)

    @property
    @pulumi.getter(name="matchRules")
    def match_rules(self) -> str:
        """
        Match rules for your grok parser.
        """
        return pulumi.get(self, "match_rules")

    @property
    @pulumi.getter(name="supportRules")
    def support_rules(self) -> str:
        """
        Support rules for your grok parser.
        """
        return pulumi.get(self, "support_rules")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorLookupProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lookupTables":
            suggest = "lookup_tables"
        elif key == "defaultLookup":
            suggest = "default_lookup"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorLookupProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorLookupProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorLookupProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lookup_tables: Sequence[str],
                 source: str,
                 target: str,
                 default_lookup: Optional[str] = None,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] lookup_tables: List of entries of the lookup table using `key,value` format.
        :param str source: Name of the source attribute used to do the lookup.
        :param str target: Name of the attribute that contains the result of the lookup.
        :param str default_lookup: Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "lookup_tables", lookup_tables)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if default_lookup is not None:
            pulumi.set(__self__, "default_lookup", default_lookup)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lookupTables")
    def lookup_tables(self) -> Sequence[str]:
        """
        List of entries of the lookup table using `key,value` format.
        """
        return pulumi.get(self, "lookup_tables")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Name of the source attribute used to do the lookup.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the lookup.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="defaultLookup")
    def default_lookup(self) -> Optional[str]:
        """
        Default lookup value to use if there is no entry in the lookup table for the value of the source attribute.
        """
        return pulumi.get(self, "default_lookup")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorMessageRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorMessageRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorMessageRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorMessageRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lookupEnrichmentTable":
            suggest = "lookup_enrichment_table"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorReferenceTableLookupProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lookup_enrichment_table: str,
                 source: str,
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str lookup_enrichment_table: Name of the Reference Table for the source attribute and their associated target attribute values.
        :param str source: Name of the source attribute used to do the lookup.
        :param str target: Name of the attribute that contains the result of the lookup.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "lookup_enrichment_table", lookup_enrichment_table)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lookupEnrichmentTable")
    def lookup_enrichment_table(self) -> str:
        """
        Name of the Reference Table for the source attribute and their associated target attribute values.
        """
        return pulumi.get(self, "lookup_enrichment_table")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Name of the source attribute used to do the lookup.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the lookup.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorServiceRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorServiceRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorServiceRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorServiceRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorStatusRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorStatusRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorStatusRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorStatusRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isReplaceMissing":
            suggest = "is_replace_missing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorStringBuilderProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: str,
                 template: str,
                 is_enabled: Optional[bool] = None,
                 is_replace_missing: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str target: The name of the attribute that contains the result of the template.
        :param str template: The formula with one or more attributes and raw text.
        :param bool is_enabled: If the processor is enabled or not.
        :param bool is_replace_missing: If it replaces all missing attributes of template by an empty string.
        :param str name: The name of the processor.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "template", template)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The name of the attribute that contains the result of the template.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def template(self) -> str:
        """
        The formula with one or more attributes and raw text.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[bool]:
        """
        If it replaces all missing attributes of template by an empty string.
        """
        return pulumi.get(self, "is_replace_missing")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the processor.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorTraceIdRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorUrlParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "normalizeEndingSlashes":
            suggest = "normalize_ending_slashes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorUrlParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorUrlParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorUrlParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 normalize_ending_slashes: Optional[bool] = None):
        """
        :param Sequence[str] sources: List of source attributes.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        :param bool normalize_ending_slashes: Normalize the ending slashes or not.
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if normalize_ending_slashes is not None:
            pulumi.set(__self__, "normalize_ending_slashes", normalize_ending_slashes)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="normalizeEndingSlashes")
    def normalize_ending_slashes(self) -> Optional[bool]:
        """
        Normalize the ending slashes or not.
        """
        return pulumi.get(self, "normalize_ending_slashes")


@pulumi.output_type
class LogsCustomPipelineProcessorPipelineProcessorUserAgentParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isEncoded":
            suggest = "is_encoded"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorPipelineProcessorUserAgentParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorUserAgentParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorPipelineProcessorUserAgentParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 is_encoded: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param bool is_enabled: If the processor is enabled or not.
        :param bool is_encoded: If the source attribute is URL encoded or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_encoded is not None:
            pulumi.set(__self__, "is_encoded", is_encoded)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isEncoded")
    def is_encoded(self) -> Optional[bool]:
        """
        If the source attribute is URL encoded or not.
        """
        return pulumi.get(self, "is_encoded")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorReferenceTableLookupProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lookupEnrichmentTable":
            suggest = "lookup_enrichment_table"
        elif key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorReferenceTableLookupProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorReferenceTableLookupProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorReferenceTableLookupProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lookup_enrichment_table: str,
                 source: str,
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str lookup_enrichment_table: Name of the Reference Table for the source attribute and their associated target attribute values.
        :param str source: Name of the source attribute used to do the lookup.
        :param str target: Name of the attribute that contains the result of the lookup.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "lookup_enrichment_table", lookup_enrichment_table)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="lookupEnrichmentTable")
    def lookup_enrichment_table(self) -> str:
        """
        Name of the Reference Table for the source attribute and their associated target attribute values.
        """
        return pulumi.get(self, "lookup_enrichment_table")

    @property
    @pulumi.getter
    def source(self) -> str:
        """
        Name of the source attribute used to do the lookup.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the attribute that contains the result of the lookup.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorServiceRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorServiceRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorServiceRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorServiceRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorStatusRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorStatusRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorStatusRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorStatusRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorStringBuilderProcessor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isReplaceMissing":
            suggest = "is_replace_missing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorStringBuilderProcessor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorStringBuilderProcessor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorStringBuilderProcessor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: str,
                 template: str,
                 is_enabled: Optional[bool] = None,
                 is_replace_missing: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param str target: The name of the attribute that contains the result of the template.
        :param str template: The formula with one or more attributes and raw text.
        :param bool is_enabled: If the processor is enabled or not.
        :param bool is_replace_missing: If it replaces all missing attributes of template by an empty string.
        :param str name: The name of the processor.
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "template", template)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_replace_missing is not None:
            pulumi.set(__self__, "is_replace_missing", is_replace_missing)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The name of the attribute that contains the result of the template.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def template(self) -> str:
        """
        The formula with one or more attributes and raw text.
        """
        return pulumi.get(self, "template")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReplaceMissing")
    def is_replace_missing(self) -> Optional[bool]:
        """
        If it replaces all missing attributes of template by an empty string.
        """
        return pulumi.get(self, "is_replace_missing")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the processor.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorTraceIdRemapper(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorTraceIdRemapper. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorTraceIdRemapper.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorTraceIdRemapper.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor.
        """
        pulumi.set(__self__, "sources", sources)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsCustomPipelineProcessorUrlParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "normalizeEndingSlashes":
            suggest = "normalize_ending_slashes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorUrlParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorUrlParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorUrlParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None,
                 normalize_ending_slashes: Optional[bool] = None):
        """
        :param Sequence[str] sources: List of source attributes.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param bool is_enabled: If the processor is enabled or not.
        :param str name: Name of the processor
        :param bool normalize_ending_slashes: Normalize the ending slashes or not.
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if normalize_ending_slashes is not None:
            pulumi.set(__self__, "normalize_ending_slashes", normalize_ending_slashes)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="normalizeEndingSlashes")
    def normalize_ending_slashes(self) -> Optional[bool]:
        """
        Normalize the ending slashes or not.
        """
        return pulumi.get(self, "normalize_ending_slashes")


@pulumi.output_type
class LogsCustomPipelineProcessorUserAgentParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "isEncoded":
            suggest = "is_encoded"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsCustomPipelineProcessorUserAgentParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsCustomPipelineProcessorUserAgentParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsCustomPipelineProcessorUserAgentParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sources: Sequence[str],
                 target: str,
                 is_enabled: Optional[bool] = None,
                 is_encoded: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] sources: List of source attributes.
        :param str target: Name of the parent attribute that contains all the extracted details from the sources.
        :param bool is_enabled: If the processor is enabled or not.
        :param bool is_encoded: If the source attribute is URL encoded or not.
        :param str name: Name of the processor
        """
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "target", target)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if is_encoded is not None:
            pulumi.set(__self__, "is_encoded", is_encoded)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        """
        List of source attributes.
        """
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        Name of the parent attribute that contains all the extracted details from the sources.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        If the processor is enabled or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isEncoded")
    def is_encoded(self) -> Optional[bool]:
        """
        If the source attribute is URL encoded or not.
        """
        return pulumi.get(self, "is_encoded")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the processor
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsIndexDailyLimitReset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resetTime":
            suggest = "reset_time"
        elif key == "resetUtcOffset":
            suggest = "reset_utc_offset"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsIndexDailyLimitReset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsIndexDailyLimitReset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsIndexDailyLimitReset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reset_time: str,
                 reset_utc_offset: str):
        """
        :param str reset_time: String in `HH:00` format representing the time of day the daily limit should be reset. The hours must be between 00 and 23 (inclusive).
        :param str reset_utc_offset: String in `(-|+)HH:00` format representing the UTC offset to apply to the given reset time. The hours must be between -12 and +14 (inclusive).
        """
        pulumi.set(__self__, "reset_time", reset_time)
        pulumi.set(__self__, "reset_utc_offset", reset_utc_offset)

    @property
    @pulumi.getter(name="resetTime")
    def reset_time(self) -> str:
        """
        String in `HH:00` format representing the time of day the daily limit should be reset. The hours must be between 00 and 23 (inclusive).
        """
        return pulumi.get(self, "reset_time")

    @property
    @pulumi.getter(name="resetUtcOffset")
    def reset_utc_offset(self) -> str:
        """
        String in `(-|+)HH:00` format representing the UTC offset to apply to the given reset time. The hours must be between -12 and +14 (inclusive).
        """
        return pulumi.get(self, "reset_utc_offset")


@pulumi.output_type
class LogsIndexExclusionFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsIndexExclusionFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsIndexExclusionFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsIndexExclusionFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Optional[Sequence['outputs.LogsIndexExclusionFilterFilter']] = None,
                 is_enabled: Optional[bool] = None,
                 name: Optional[str] = None):
        """
        :param bool is_enabled: A boolean stating if the exclusion is active or not.
        :param str name: The name of the exclusion filter.
        """
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.LogsIndexExclusionFilterFilter']]:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[bool]:
        """
        A boolean stating if the exclusion is active or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the exclusion filter.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LogsIndexExclusionFilterFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sampleRate":
            suggest = "sample_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsIndexExclusionFilterFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsIndexExclusionFilterFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsIndexExclusionFilterFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: Optional[str] = None,
                 sample_rate: Optional[float] = None):
        """
        :param str query: Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.
        :param float sample_rate: The fraction of logs excluded by the exclusion filter, when active.
        """
        if query is not None:
            pulumi.set(__self__, "query", query)
        if sample_rate is not None:
            pulumi.set(__self__, "sample_rate", sample_rate)

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> Optional[float]:
        """
        The fraction of logs excluded by the exclusion filter, when active.
        """
        return pulumi.get(self, "sample_rate")


@pulumi.output_type
class LogsIndexFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Logs filter criteria. Only logs matching this filter criteria are considered for this index.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Logs filter criteria. Only logs matching this filter criteria are considered for this index.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsMetricCompute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"
        elif key == "includePercentiles":
            suggest = "include_percentiles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsMetricCompute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsMetricCompute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsMetricCompute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_type: str,
                 include_percentiles: Optional[bool] = None,
                 path: Optional[str] = None):
        """
        :param str aggregation_type: The type of aggregation to use. This field can't be updated after creation. Valid values are `count`, `distribution`.
        :param bool include_percentiles: Toggle to include/exclude percentiles for a distribution metric. Defaults to false. Can only be applied to metrics that have an `aggregation_type` of distribution.
        :param str path: The path to the value the log-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
        """
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        if include_percentiles is not None:
            pulumi.set(__self__, "include_percentiles", include_percentiles)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> str:
        """
        The type of aggregation to use. This field can't be updated after creation. Valid values are `count`, `distribution`.
        """
        return pulumi.get(self, "aggregation_type")

    @property
    @pulumi.getter(name="includePercentiles")
    def include_percentiles(self) -> Optional[bool]:
        """
        Toggle to include/exclude percentiles for a distribution metric. Defaults to false. Can only be applied to metrics that have an `aggregation_type` of distribution.
        """
        return pulumi.get(self, "include_percentiles")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to the value the log-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class LogsMetricFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The search query - following the log search syntax.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The search query - following the log search syntax.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class LogsMetricGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagName":
            suggest = "tag_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogsMetricGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogsMetricGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogsMetricGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 tag_name: str):
        """
        :param str path: The path to the value the log-based metric will be aggregated over.
        :param str tag_name: Name of the tag that gets created.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "tag_name", tag_name)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path to the value the log-based metric will be aggregated over.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> str:
        """
        Name of the tag that gets created.
        """
        return pulumi.get(self, "tag_name")


@pulumi.output_type
class MetricTagConfigurationAggregation(dict):
    def __init__(__self__, *,
                 space: str,
                 time: str):
        """
        :param str space: A space aggregation for use in query. Valid values are `avg`, `max`, `min`, `sum`.
        :param str time: A time aggregation for use in query. Valid values are `avg`, `count`, `max`, `min`, `sum`.
        """
        pulumi.set(__self__, "space", space)
        pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def space(self) -> str:
        """
        A space aggregation for use in query. Valid values are `avg`, `max`, `min`, `sum`.
        """
        return pulumi.get(self, "space")

    @property
    @pulumi.getter
    def time(self) -> str:
        """
        A time aggregation for use in query. Valid values are `avg`, `count`, `max`, `min`, `sum`.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class MonitorConfigPolicyTagPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagKey":
            suggest = "tag_key"
        elif key == "tagKeyRequired":
            suggest = "tag_key_required"
        elif key == "validTagValues":
            suggest = "valid_tag_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorConfigPolicyTagPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorConfigPolicyTagPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorConfigPolicyTagPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_key: str,
                 tag_key_required: bool,
                 valid_tag_values: Sequence[str]):
        """
        :param str tag_key: The key of the tag
        :param bool tag_key_required: If a tag key is required for monitor creation
        :param Sequence[str] valid_tag_values: Valid values for the tag
        """
        pulumi.set(__self__, "tag_key", tag_key)
        pulumi.set(__self__, "tag_key_required", tag_key_required)
        pulumi.set(__self__, "valid_tag_values", valid_tag_values)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> str:
        """
        The key of the tag
        """
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter(name="tagKeyRequired")
    def tag_key_required(self) -> bool:
        """
        If a tag key is required for monitor creation
        """
        return pulumi.get(self, "tag_key_required")

    @property
    @pulumi.getter(name="validTagValues")
    def valid_tag_values(self) -> Sequence[str]:
        """
        Valid values for the tag
        """
        return pulumi.get(self, "valid_tag_values")


@pulumi.output_type
class MonitorMonitorThresholdWindows(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recoveryWindow":
            suggest = "recovery_window"
        elif key == "triggerWindow":
            suggest = "trigger_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorMonitorThresholdWindows. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorMonitorThresholdWindows.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorMonitorThresholdWindows.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 recovery_window: Optional[str] = None,
                 trigger_window: Optional[str] = None):
        """
        :param str recovery_window: Describes how long an anomalous metric must be normal before the alert recovers.
        :param str trigger_window: Describes how long a metric must be anomalous before an alert triggers.
        """
        if recovery_window is not None:
            pulumi.set(__self__, "recovery_window", recovery_window)
        if trigger_window is not None:
            pulumi.set(__self__, "trigger_window", trigger_window)

    @property
    @pulumi.getter(name="recoveryWindow")
    def recovery_window(self) -> Optional[str]:
        """
        Describes how long an anomalous metric must be normal before the alert recovers.
        """
        return pulumi.get(self, "recovery_window")

    @property
    @pulumi.getter(name="triggerWindow")
    def trigger_window(self) -> Optional[str]:
        """
        Describes how long a metric must be anomalous before an alert triggers.
        """
        return pulumi.get(self, "trigger_window")


@pulumi.output_type
class MonitorMonitorThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "criticalRecovery":
            suggest = "critical_recovery"
        elif key == "warningRecovery":
            suggest = "warning_recovery"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorMonitorThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorMonitorThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorMonitorThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 critical: Optional[str] = None,
                 critical_recovery: Optional[str] = None,
                 ok: Optional[str] = None,
                 unknown: Optional[str] = None,
                 warning: Optional[str] = None,
                 warning_recovery: Optional[str] = None):
        """
        :param str critical: The monitor `CRITICAL` threshold. Must be a number.
        :param str critical_recovery: The monitor `CRITICAL` recovery threshold. Must be a number.
        :param str ok: The monitor `OK` threshold. Only supported in monitor type `service check`. Must be a number.
        :param str unknown: The monitor `UNKNOWN` threshold. Only supported in monitor type `service check`. Must be a number.
        :param str warning: The monitor `WARNING` threshold. Must be a number.
        :param str warning_recovery: The monitor `WARNING` recovery threshold. Must be a number.
        """
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if critical_recovery is not None:
            pulumi.set(__self__, "critical_recovery", critical_recovery)
        if ok is not None:
            pulumi.set(__self__, "ok", ok)
        if unknown is not None:
            pulumi.set(__self__, "unknown", unknown)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)
        if warning_recovery is not None:
            pulumi.set(__self__, "warning_recovery", warning_recovery)

    @property
    @pulumi.getter
    def critical(self) -> Optional[str]:
        """
        The monitor `CRITICAL` threshold. Must be a number.
        """
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter(name="criticalRecovery")
    def critical_recovery(self) -> Optional[str]:
        """
        The monitor `CRITICAL` recovery threshold. Must be a number.
        """
        return pulumi.get(self, "critical_recovery")

    @property
    @pulumi.getter
    def ok(self) -> Optional[str]:
        """
        The monitor `OK` threshold. Only supported in monitor type `service check`. Must be a number.
        """
        return pulumi.get(self, "ok")

    @property
    @pulumi.getter
    def unknown(self) -> Optional[str]:
        """
        The monitor `UNKNOWN` threshold. Only supported in monitor type `service check`. Must be a number.
        """
        return pulumi.get(self, "unknown")

    @property
    @pulumi.getter
    def warning(self) -> Optional[str]:
        """
        The monitor `WARNING` threshold. Must be a number.
        """
        return pulumi.get(self, "warning")

    @property
    @pulumi.getter(name="warningRecovery")
    def warning_recovery(self) -> Optional[str]:
        """
        The monitor `WARNING` recovery threshold. Must be a number.
        """
        return pulumi.get(self, "warning_recovery")


@pulumi.output_type
class MonitorSchedulingOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customSchedules":
            suggest = "custom_schedules"
        elif key == "evaluationWindows":
            suggest = "evaluation_windows"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorSchedulingOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorSchedulingOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorSchedulingOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_schedules: Optional[Sequence['outputs.MonitorSchedulingOptionCustomSchedule']] = None,
                 evaluation_windows: Optional[Sequence['outputs.MonitorSchedulingOptionEvaluationWindow']] = None):
        """
        :param Sequence['MonitorSchedulingOptionCustomScheduleArgs'] custom_schedules: Configuration options for the custom schedules. If `start` is omitted, the monitor creation time will be used.
        :param Sequence['MonitorSchedulingOptionEvaluationWindowArgs'] evaluation_windows: Configuration options for the evaluation window. If `hour_starts` is set, no other fields may be set. Otherwise, `day_starts` and `month_starts` must be set together.
        """
        if custom_schedules is not None:
            pulumi.set(__self__, "custom_schedules", custom_schedules)
        if evaluation_windows is not None:
            pulumi.set(__self__, "evaluation_windows", evaluation_windows)

    @property
    @pulumi.getter(name="customSchedules")
    def custom_schedules(self) -> Optional[Sequence['outputs.MonitorSchedulingOptionCustomSchedule']]:
        """
        Configuration options for the custom schedules. If `start` is omitted, the monitor creation time will be used.
        """
        return pulumi.get(self, "custom_schedules")

    @property
    @pulumi.getter(name="evaluationWindows")
    def evaluation_windows(self) -> Optional[Sequence['outputs.MonitorSchedulingOptionEvaluationWindow']]:
        """
        Configuration options for the evaluation window. If `hour_starts` is set, no other fields may be set. Otherwise, `day_starts` and `month_starts` must be set together.
        """
        return pulumi.get(self, "evaluation_windows")


@pulumi.output_type
class MonitorSchedulingOptionCustomSchedule(dict):
    def __init__(__self__, *,
                 recurrence: 'outputs.MonitorSchedulingOptionCustomScheduleRecurrence'):
        """
        :param 'MonitorSchedulingOptionCustomScheduleRecurrenceArgs' recurrence: A list of recurrence definitions. Length must be 1.
        """
        pulumi.set(__self__, "recurrence", recurrence)

    @property
    @pulumi.getter
    def recurrence(self) -> 'outputs.MonitorSchedulingOptionCustomScheduleRecurrence':
        """
        A list of recurrence definitions. Length must be 1.
        """
        return pulumi.get(self, "recurrence")


@pulumi.output_type
class MonitorSchedulingOptionCustomScheduleRecurrence(dict):
    def __init__(__self__, *,
                 rrule: str,
                 timezone: str,
                 start: Optional[str] = None):
        """
        :param str rrule: Must be a valid `rrule`. See API docs for supported fields
        :param str timezone: 'tz database' format. Example: `America/New_York` or `UTC`
        :param str start: Time to start recurrence cycle. Similar to DTSTART. Expected format 'YYYY-MM-DDThh:mm:ss'
        """
        pulumi.set(__self__, "rrule", rrule)
        pulumi.set(__self__, "timezone", timezone)
        if start is not None:
            pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def rrule(self) -> str:
        """
        Must be a valid `rrule`. See API docs for supported fields
        """
        return pulumi.get(self, "rrule")

    @property
    @pulumi.getter
    def timezone(self) -> str:
        """
        'tz database' format. Example: `America/New_York` or `UTC`
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter
    def start(self) -> Optional[str]:
        """
        Time to start recurrence cycle. Similar to DTSTART. Expected format 'YYYY-MM-DDThh:mm:ss'
        """
        return pulumi.get(self, "start")


@pulumi.output_type
class MonitorSchedulingOptionEvaluationWindow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dayStarts":
            suggest = "day_starts"
        elif key == "hourStarts":
            suggest = "hour_starts"
        elif key == "monthStarts":
            suggest = "month_starts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorSchedulingOptionEvaluationWindow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorSchedulingOptionEvaluationWindow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorSchedulingOptionEvaluationWindow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day_starts: Optional[str] = None,
                 hour_starts: Optional[int] = None,
                 month_starts: Optional[int] = None):
        """
        :param str day_starts: The time of the day at which a one day cumulative evaluation window starts. Must be defined in UTC time in `HH:mm` format.
        :param int hour_starts: The minute of the hour at which a one hour cumulative evaluation window starts. Must be between 0 and 59.
        :param int month_starts: The day of the month at which a one month cumulative evaluation window starts. Must be a value of 1.
        """
        if day_starts is not None:
            pulumi.set(__self__, "day_starts", day_starts)
        if hour_starts is not None:
            pulumi.set(__self__, "hour_starts", hour_starts)
        if month_starts is not None:
            pulumi.set(__self__, "month_starts", month_starts)

    @property
    @pulumi.getter(name="dayStarts")
    def day_starts(self) -> Optional[str]:
        """
        The time of the day at which a one day cumulative evaluation window starts. Must be defined in UTC time in `HH:mm` format.
        """
        return pulumi.get(self, "day_starts")

    @property
    @pulumi.getter(name="hourStarts")
    def hour_starts(self) -> Optional[int]:
        """
        The minute of the hour at which a one hour cumulative evaluation window starts. Must be between 0 and 59.
        """
        return pulumi.get(self, "hour_starts")

    @property
    @pulumi.getter(name="monthStarts")
    def month_starts(self) -> Optional[int]:
        """
        The day of the month at which a one month cumulative evaluation window starts. Must be a value of 1.
        """
        return pulumi.get(self, "month_starts")


@pulumi.output_type
class MonitorVariables(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventQueries":
            suggest = "event_queries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorVariables. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorVariables.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorVariables.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_queries: Optional[Sequence['outputs.MonitorVariablesEventQuery']] = None):
        """
        :param Sequence['MonitorVariablesEventQueryArgs'] event_queries: A timeseries formula and functions events query.
        """
        if event_queries is not None:
            pulumi.set(__self__, "event_queries", event_queries)

    @property
    @pulumi.getter(name="eventQueries")
    def event_queries(self) -> Optional[Sequence['outputs.MonitorVariablesEventQuery']]:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_queries")


@pulumi.output_type
class MonitorVariablesEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorVariablesEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorVariablesEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorVariablesEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.MonitorVariablesEventQueryCompute'],
                 data_source: str,
                 name: str,
                 search: 'outputs.MonitorVariablesEventQuerySearch',
                 group_bies: Optional[Sequence['outputs.MonitorVariablesEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None):
        """
        :param Sequence['MonitorVariablesEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `rum`, `ci_pipelines`, `ci_tests`, `audit`, `events`, `logs`, `spans`, `database_queries`, `network`.
        :param str name: The name of query for use in formulas.
        :param 'MonitorVariablesEventQuerySearchArgs' search: The search options.
        :param Sequence['MonitorVariablesEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "search", search)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.MonitorVariablesEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `rum`, `ci_pipelines`, `ci_tests`, `audit`, `events`, `logs`, `spans`, `database_queries`, `network`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def search(self) -> 'outputs.MonitorVariablesEventQuerySearch':
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.MonitorVariablesEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")


@pulumi.output_type
class MonitorVariablesEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class MonitorVariablesEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.MonitorVariablesEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'MonitorVariablesEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.MonitorVariablesEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class MonitorVariablesEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class MonitorVariablesEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class OrganizationSettingsSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "samlAutocreateUsersDomains":
            suggest = "saml_autocreate_users_domains"
        elif key == "samlIdpInitiatedLogin":
            suggest = "saml_idp_initiated_login"
        elif key == "samlStrictMode":
            suggest = "saml_strict_mode"
        elif key == "privateWidgetShare":
            suggest = "private_widget_share"
        elif key == "samlAutocreateAccessRole":
            suggest = "saml_autocreate_access_role"
        elif key == "samlCanBeEnabled":
            suggest = "saml_can_be_enabled"
        elif key == "samlIdpEndpoint":
            suggest = "saml_idp_endpoint"
        elif key == "samlIdpMetadataUploaded":
            suggest = "saml_idp_metadata_uploaded"
        elif key == "samlLoginUrl":
            suggest = "saml_login_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in OrganizationSettingsSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        OrganizationSettingsSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        OrganizationSettingsSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 saml: 'outputs.OrganizationSettingsSettingsSaml',
                 saml_autocreate_users_domains: 'outputs.OrganizationSettingsSettingsSamlAutocreateUsersDomains',
                 saml_idp_initiated_login: 'outputs.OrganizationSettingsSettingsSamlIdpInitiatedLogin',
                 saml_strict_mode: 'outputs.OrganizationSettingsSettingsSamlStrictMode',
                 private_widget_share: Optional[bool] = None,
                 saml_autocreate_access_role: Optional[str] = None,
                 saml_can_be_enabled: Optional[bool] = None,
                 saml_idp_endpoint: Optional[str] = None,
                 saml_idp_metadata_uploaded: Optional[bool] = None,
                 saml_login_url: Optional[str] = None):
        """
        :param 'OrganizationSettingsSettingsSamlArgs' saml: SAML properties
        :param 'OrganizationSettingsSettingsSamlAutocreateUsersDomainsArgs' saml_autocreate_users_domains: List of domains where the SAML automated user creation is enabled.
        :param 'OrganizationSettingsSettingsSamlIdpInitiatedLoginArgs' saml_idp_initiated_login: Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        :param 'OrganizationSettingsSettingsSamlStrictModeArgs' saml_strict_mode: Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
        :param bool private_widget_share: Whether or not the organization users can share widgets outside of Datadog. Defaults to `false`.
        :param str saml_autocreate_access_role: The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm` , `ro`, `ERROR` Defaults to `"st"`.
        :param bool saml_can_be_enabled: Whether or not SAML can be enabled for this organization.
        :param str saml_idp_endpoint: Identity provider endpoint for SAML authentication.
        :param bool saml_idp_metadata_uploaded: Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        :param str saml_login_url: URL for SAML logging.
        """
        pulumi.set(__self__, "saml", saml)
        pulumi.set(__self__, "saml_autocreate_users_domains", saml_autocreate_users_domains)
        pulumi.set(__self__, "saml_idp_initiated_login", saml_idp_initiated_login)
        pulumi.set(__self__, "saml_strict_mode", saml_strict_mode)
        if private_widget_share is not None:
            pulumi.set(__self__, "private_widget_share", private_widget_share)
        if saml_autocreate_access_role is not None:
            pulumi.set(__self__, "saml_autocreate_access_role", saml_autocreate_access_role)
        if saml_can_be_enabled is not None:
            pulumi.set(__self__, "saml_can_be_enabled", saml_can_be_enabled)
        if saml_idp_endpoint is not None:
            pulumi.set(__self__, "saml_idp_endpoint", saml_idp_endpoint)
        if saml_idp_metadata_uploaded is not None:
            pulumi.set(__self__, "saml_idp_metadata_uploaded", saml_idp_metadata_uploaded)
        if saml_login_url is not None:
            pulumi.set(__self__, "saml_login_url", saml_login_url)

    @property
    @pulumi.getter
    def saml(self) -> 'outputs.OrganizationSettingsSettingsSaml':
        """
        SAML properties
        """
        return pulumi.get(self, "saml")

    @property
    @pulumi.getter(name="samlAutocreateUsersDomains")
    def saml_autocreate_users_domains(self) -> 'outputs.OrganizationSettingsSettingsSamlAutocreateUsersDomains':
        """
        List of domains where the SAML automated user creation is enabled.
        """
        return pulumi.get(self, "saml_autocreate_users_domains")

    @property
    @pulumi.getter(name="samlIdpInitiatedLogin")
    def saml_idp_initiated_login(self) -> 'outputs.OrganizationSettingsSettingsSamlIdpInitiatedLogin':
        """
        Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        """
        return pulumi.get(self, "saml_idp_initiated_login")

    @property
    @pulumi.getter(name="samlStrictMode")
    def saml_strict_mode(self) -> 'outputs.OrganizationSettingsSettingsSamlStrictMode':
        """
        Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML.
        """
        return pulumi.get(self, "saml_strict_mode")

    @property
    @pulumi.getter(name="privateWidgetShare")
    def private_widget_share(self) -> Optional[bool]:
        """
        Whether or not the organization users can share widgets outside of Datadog. Defaults to `false`.
        """
        return pulumi.get(self, "private_widget_share")

    @property
    @pulumi.getter(name="samlAutocreateAccessRole")
    def saml_autocreate_access_role(self) -> Optional[str]:
        """
        The access role of the user. Options are `st` (standard user), `adm` (admin user), or `ro` (read-only user). Allowed enum values: `st`, `adm` , `ro`, `ERROR` Defaults to `"st"`.
        """
        return pulumi.get(self, "saml_autocreate_access_role")

    @property
    @pulumi.getter(name="samlCanBeEnabled")
    def saml_can_be_enabled(self) -> Optional[bool]:
        """
        Whether or not SAML can be enabled for this organization.
        """
        return pulumi.get(self, "saml_can_be_enabled")

    @property
    @pulumi.getter(name="samlIdpEndpoint")
    def saml_idp_endpoint(self) -> Optional[str]:
        """
        Identity provider endpoint for SAML authentication.
        """
        return pulumi.get(self, "saml_idp_endpoint")

    @property
    @pulumi.getter(name="samlIdpMetadataUploaded")
    def saml_idp_metadata_uploaded(self) -> Optional[bool]:
        """
        Whether or not a SAML identity provider metadata file was provided to the Datadog organization.
        """
        return pulumi.get(self, "saml_idp_metadata_uploaded")

    @property
    @pulumi.getter(name="samlLoginUrl")
    def saml_login_url(self) -> Optional[str]:
        """
        URL for SAML logging.
        """
        return pulumi.get(self, "saml_login_url")


@pulumi.output_type
class OrganizationSettingsSettingsSaml(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Whether or not SAML is enabled for this organization. Defaults to `false`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not SAML is enabled for this organization. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class OrganizationSettingsSettingsSamlAutocreateUsersDomains(dict):
    def __init__(__self__, *,
                 domains: Optional[Sequence[str]] = None,
                 enabled: Optional[bool] = None):
        """
        :param Sequence[str] domains: List of domains where the SAML automated user creation is enabled.
        :param bool enabled: Whether or not the automated user creation based on SAML domain is enabled. Defaults to `false`.
        """
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def domains(self) -> Optional[Sequence[str]]:
        """
        List of domains where the SAML automated user creation is enabled.
        """
        return pulumi.get(self, "domains")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not the automated user creation based on SAML domain is enabled. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class OrganizationSettingsSettingsSamlIdpInitiatedLogin(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Whether or not a SAML identity provider metadata file was provided to the Datadog organization. Defaults to `false`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not a SAML identity provider metadata file was provided to the Datadog organization. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class OrganizationSettingsSettingsSamlStrictMode(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML. Defaults to `false`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether or not the SAML strict mode is enabled. If true, all users must log in with SAML. Defaults to `false`.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class PowerpackLayout(dict):
    def __init__(__self__, *,
                 height: Optional[int] = None,
                 width: Optional[int] = None,
                 x: Optional[int] = None,
                 y: Optional[int] = None):
        """
        :param int height: The height of the widget.
        :param int width: The width of the widget.
        :param int x: The position of the widget on the x (horizontal) axis. Should be greater than or equal to 0.
        :param int y: The position of the widget on the y (vertical) axis. Should be greater than or equal to 0.
        """
        if height is not None:
            pulumi.set(__self__, "height", height)
        if width is not None:
            pulumi.set(__self__, "width", width)
        if x is not None:
            pulumi.set(__self__, "x", x)
        if y is not None:
            pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def height(self) -> Optional[int]:
        """
        The height of the widget.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> Optional[int]:
        """
        The width of the widget.
        """
        return pulumi.get(self, "width")

    @property
    @pulumi.getter
    def x(self) -> Optional[int]:
        """
        The position of the widget on the x (horizontal) axis. Should be greater than or equal to 0.
        """
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> Optional[int]:
        """
        The position of the widget on the y (vertical) axis. Should be greater than or equal to 0.
        """
        return pulumi.get(self, "y")


@pulumi.output_type
class PowerpackTemplateVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 defaults: Optional[Sequence[str]] = None):
        """
        :param str name: The name of the powerpack template variable.
        :param Sequence[str] defaults: One or many default values for powerpack template variables on load. If more than one default is specified, they will be unioned together with `OR`.
        """
        pulumi.set(__self__, "name", name)
        if defaults is not None:
            pulumi.set(__self__, "defaults", defaults)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the powerpack template variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def defaults(self) -> Optional[Sequence[str]]:
        """
        One or many default values for powerpack template variables on load. If more than one default is specified, they will be unioned together with `OR`.
        """
        return pulumi.get(self, "defaults")


@pulumi.output_type
class PowerpackWidget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertGraphDefinition":
            suggest = "alert_graph_definition"
        elif key == "alertValueDefinition":
            suggest = "alert_value_definition"
        elif key == "changeDefinition":
            suggest = "change_definition"
        elif key == "checkStatusDefinition":
            suggest = "check_status_definition"
        elif key == "distributionDefinition":
            suggest = "distribution_definition"
        elif key == "eventStreamDefinition":
            suggest = "event_stream_definition"
        elif key == "eventTimelineDefinition":
            suggest = "event_timeline_definition"
        elif key == "freeTextDefinition":
            suggest = "free_text_definition"
        elif key == "geomapDefinition":
            suggest = "geomap_definition"
        elif key == "heatmapDefinition":
            suggest = "heatmap_definition"
        elif key == "hostmapDefinition":
            suggest = "hostmap_definition"
        elif key == "iframeDefinition":
            suggest = "iframe_definition"
        elif key == "imageDefinition":
            suggest = "image_definition"
        elif key == "listStreamDefinition":
            suggest = "list_stream_definition"
        elif key == "logStreamDefinition":
            suggest = "log_stream_definition"
        elif key == "manageStatusDefinition":
            suggest = "manage_status_definition"
        elif key == "noteDefinition":
            suggest = "note_definition"
        elif key == "queryTableDefinition":
            suggest = "query_table_definition"
        elif key == "queryValueDefinition":
            suggest = "query_value_definition"
        elif key == "runWorkflowDefinition":
            suggest = "run_workflow_definition"
        elif key == "scatterplotDefinition":
            suggest = "scatterplot_definition"
        elif key == "serviceLevelObjectiveDefinition":
            suggest = "service_level_objective_definition"
        elif key == "servicemapDefinition":
            suggest = "servicemap_definition"
        elif key == "sloListDefinition":
            suggest = "slo_list_definition"
        elif key == "sunburstDefinition":
            suggest = "sunburst_definition"
        elif key == "timeseriesDefinition":
            suggest = "timeseries_definition"
        elif key == "toplistDefinition":
            suggest = "toplist_definition"
        elif key == "topologyMapDefinition":
            suggest = "topology_map_definition"
        elif key == "traceServiceDefinition":
            suggest = "trace_service_definition"
        elif key == "treemapDefinition":
            suggest = "treemap_definition"
        elif key == "widgetLayout":
            suggest = "widget_layout"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_graph_definition: Optional['outputs.PowerpackWidgetAlertGraphDefinition'] = None,
                 alert_value_definition: Optional['outputs.PowerpackWidgetAlertValueDefinition'] = None,
                 change_definition: Optional['outputs.PowerpackWidgetChangeDefinition'] = None,
                 check_status_definition: Optional['outputs.PowerpackWidgetCheckStatusDefinition'] = None,
                 distribution_definition: Optional['outputs.PowerpackWidgetDistributionDefinition'] = None,
                 event_stream_definition: Optional['outputs.PowerpackWidgetEventStreamDefinition'] = None,
                 event_timeline_definition: Optional['outputs.PowerpackWidgetEventTimelineDefinition'] = None,
                 free_text_definition: Optional['outputs.PowerpackWidgetFreeTextDefinition'] = None,
                 geomap_definition: Optional['outputs.PowerpackWidgetGeomapDefinition'] = None,
                 heatmap_definition: Optional['outputs.PowerpackWidgetHeatmapDefinition'] = None,
                 hostmap_definition: Optional['outputs.PowerpackWidgetHostmapDefinition'] = None,
                 id: Optional[int] = None,
                 iframe_definition: Optional['outputs.PowerpackWidgetIframeDefinition'] = None,
                 image_definition: Optional['outputs.PowerpackWidgetImageDefinition'] = None,
                 list_stream_definition: Optional['outputs.PowerpackWidgetListStreamDefinition'] = None,
                 log_stream_definition: Optional['outputs.PowerpackWidgetLogStreamDefinition'] = None,
                 manage_status_definition: Optional['outputs.PowerpackWidgetManageStatusDefinition'] = None,
                 note_definition: Optional['outputs.PowerpackWidgetNoteDefinition'] = None,
                 query_table_definition: Optional['outputs.PowerpackWidgetQueryTableDefinition'] = None,
                 query_value_definition: Optional['outputs.PowerpackWidgetQueryValueDefinition'] = None,
                 run_workflow_definition: Optional['outputs.PowerpackWidgetRunWorkflowDefinition'] = None,
                 scatterplot_definition: Optional['outputs.PowerpackWidgetScatterplotDefinition'] = None,
                 service_level_objective_definition: Optional['outputs.PowerpackWidgetServiceLevelObjectiveDefinition'] = None,
                 servicemap_definition: Optional['outputs.PowerpackWidgetServicemapDefinition'] = None,
                 slo_list_definition: Optional['outputs.PowerpackWidgetSloListDefinition'] = None,
                 sunburst_definition: Optional['outputs.PowerpackWidgetSunburstDefinition'] = None,
                 timeseries_definition: Optional['outputs.PowerpackWidgetTimeseriesDefinition'] = None,
                 toplist_definition: Optional['outputs.PowerpackWidgetToplistDefinition'] = None,
                 topology_map_definition: Optional['outputs.PowerpackWidgetTopologyMapDefinition'] = None,
                 trace_service_definition: Optional['outputs.PowerpackWidgetTraceServiceDefinition'] = None,
                 treemap_definition: Optional['outputs.PowerpackWidgetTreemapDefinition'] = None,
                 widget_layout: Optional['outputs.PowerpackWidgetWidgetLayout'] = None):
        """
        :param 'PowerpackWidgetAlertGraphDefinitionArgs' alert_graph_definition: The definition for a Alert Graph widget.
        :param 'PowerpackWidgetAlertValueDefinitionArgs' alert_value_definition: The definition for a Alert Value widget.
        :param 'PowerpackWidgetChangeDefinitionArgs' change_definition: The definition for a Change widget.
        :param 'PowerpackWidgetCheckStatusDefinitionArgs' check_status_definition: The definition for a Check Status widget.
        :param 'PowerpackWidgetDistributionDefinitionArgs' distribution_definition: The definition for a Distribution widget.
        :param 'PowerpackWidgetEventStreamDefinitionArgs' event_stream_definition: The definition for a Event Stream widget.
        :param 'PowerpackWidgetEventTimelineDefinitionArgs' event_timeline_definition: The definition for a Event Timeline widget.
        :param 'PowerpackWidgetFreeTextDefinitionArgs' free_text_definition: The definition for a Free Text widget.
        :param 'PowerpackWidgetGeomapDefinitionArgs' geomap_definition: The definition for a Geomap widget.
        :param 'PowerpackWidgetHeatmapDefinitionArgs' heatmap_definition: The definition for a Heatmap widget.
        :param 'PowerpackWidgetHostmapDefinitionArgs' hostmap_definition: The definition for a Hostmap widget.
        :param int id: The ID of the widget.
        :param 'PowerpackWidgetIframeDefinitionArgs' iframe_definition: The definition for an Iframe widget.
        :param 'PowerpackWidgetImageDefinitionArgs' image_definition: The definition for an Image widget
        :param 'PowerpackWidgetListStreamDefinitionArgs' list_stream_definition: The definition for a List Stream widget.
        :param 'PowerpackWidgetLogStreamDefinitionArgs' log_stream_definition: The definition for an Log Stream widget.
        :param 'PowerpackWidgetManageStatusDefinitionArgs' manage_status_definition: The definition for an Manage Status widget.
        :param 'PowerpackWidgetNoteDefinitionArgs' note_definition: The definition for a Note widget.
        :param 'PowerpackWidgetQueryTableDefinitionArgs' query_table_definition: The definition for a Query Table widget.
        :param 'PowerpackWidgetQueryValueDefinitionArgs' query_value_definition: The definition for a Query Value widget.
        :param 'PowerpackWidgetRunWorkflowDefinitionArgs' run_workflow_definition: The definition for a Run Workflow widget.
        :param 'PowerpackWidgetScatterplotDefinitionArgs' scatterplot_definition: The definition for a Scatterplot widget.
        :param 'PowerpackWidgetServiceLevelObjectiveDefinitionArgs' service_level_objective_definition: The definition for a Service Level Objective widget.
        :param 'PowerpackWidgetServicemapDefinitionArgs' servicemap_definition: The definition for a Service Map widget.
        :param 'PowerpackWidgetSloListDefinitionArgs' slo_list_definition: The definition for an SLO (Service Level Objective) List widget.
        :param 'PowerpackWidgetSunburstDefinitionArgs' sunburst_definition: The definition for a Sunburst widget.
        :param 'PowerpackWidgetTimeseriesDefinitionArgs' timeseries_definition: The definition for a Timeseries widget.
        :param 'PowerpackWidgetToplistDefinitionArgs' toplist_definition: The definition for a Toplist widget.
        :param 'PowerpackWidgetTopologyMapDefinitionArgs' topology_map_definition: The definition for a Topology Map widget.
        :param 'PowerpackWidgetTraceServiceDefinitionArgs' trace_service_definition: The definition for a Trace Service widget.
        :param 'PowerpackWidgetTreemapDefinitionArgs' treemap_definition: The definition for a Treemap widget.
        :param 'PowerpackWidgetWidgetLayoutArgs' widget_layout: The layout of the widget on a 'free' dashboard.
        """
        if alert_graph_definition is not None:
            pulumi.set(__self__, "alert_graph_definition", alert_graph_definition)
        if alert_value_definition is not None:
            pulumi.set(__self__, "alert_value_definition", alert_value_definition)
        if change_definition is not None:
            pulumi.set(__self__, "change_definition", change_definition)
        if check_status_definition is not None:
            pulumi.set(__self__, "check_status_definition", check_status_definition)
        if distribution_definition is not None:
            pulumi.set(__self__, "distribution_definition", distribution_definition)
        if event_stream_definition is not None:
            pulumi.set(__self__, "event_stream_definition", event_stream_definition)
        if event_timeline_definition is not None:
            pulumi.set(__self__, "event_timeline_definition", event_timeline_definition)
        if free_text_definition is not None:
            pulumi.set(__self__, "free_text_definition", free_text_definition)
        if geomap_definition is not None:
            pulumi.set(__self__, "geomap_definition", geomap_definition)
        if heatmap_definition is not None:
            pulumi.set(__self__, "heatmap_definition", heatmap_definition)
        if hostmap_definition is not None:
            pulumi.set(__self__, "hostmap_definition", hostmap_definition)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if iframe_definition is not None:
            pulumi.set(__self__, "iframe_definition", iframe_definition)
        if image_definition is not None:
            pulumi.set(__self__, "image_definition", image_definition)
        if list_stream_definition is not None:
            pulumi.set(__self__, "list_stream_definition", list_stream_definition)
        if log_stream_definition is not None:
            pulumi.set(__self__, "log_stream_definition", log_stream_definition)
        if manage_status_definition is not None:
            pulumi.set(__self__, "manage_status_definition", manage_status_definition)
        if note_definition is not None:
            pulumi.set(__self__, "note_definition", note_definition)
        if query_table_definition is not None:
            pulumi.set(__self__, "query_table_definition", query_table_definition)
        if query_value_definition is not None:
            pulumi.set(__self__, "query_value_definition", query_value_definition)
        if run_workflow_definition is not None:
            pulumi.set(__self__, "run_workflow_definition", run_workflow_definition)
        if scatterplot_definition is not None:
            pulumi.set(__self__, "scatterplot_definition", scatterplot_definition)
        if service_level_objective_definition is not None:
            pulumi.set(__self__, "service_level_objective_definition", service_level_objective_definition)
        if servicemap_definition is not None:
            pulumi.set(__self__, "servicemap_definition", servicemap_definition)
        if slo_list_definition is not None:
            pulumi.set(__self__, "slo_list_definition", slo_list_definition)
        if sunburst_definition is not None:
            pulumi.set(__self__, "sunburst_definition", sunburst_definition)
        if timeseries_definition is not None:
            pulumi.set(__self__, "timeseries_definition", timeseries_definition)
        if toplist_definition is not None:
            pulumi.set(__self__, "toplist_definition", toplist_definition)
        if topology_map_definition is not None:
            pulumi.set(__self__, "topology_map_definition", topology_map_definition)
        if trace_service_definition is not None:
            pulumi.set(__self__, "trace_service_definition", trace_service_definition)
        if treemap_definition is not None:
            pulumi.set(__self__, "treemap_definition", treemap_definition)
        if widget_layout is not None:
            pulumi.set(__self__, "widget_layout", widget_layout)

    @property
    @pulumi.getter(name="alertGraphDefinition")
    def alert_graph_definition(self) -> Optional['outputs.PowerpackWidgetAlertGraphDefinition']:
        """
        The definition for a Alert Graph widget.
        """
        return pulumi.get(self, "alert_graph_definition")

    @property
    @pulumi.getter(name="alertValueDefinition")
    def alert_value_definition(self) -> Optional['outputs.PowerpackWidgetAlertValueDefinition']:
        """
        The definition for a Alert Value widget.
        """
        return pulumi.get(self, "alert_value_definition")

    @property
    @pulumi.getter(name="changeDefinition")
    def change_definition(self) -> Optional['outputs.PowerpackWidgetChangeDefinition']:
        """
        The definition for a Change widget.
        """
        return pulumi.get(self, "change_definition")

    @property
    @pulumi.getter(name="checkStatusDefinition")
    def check_status_definition(self) -> Optional['outputs.PowerpackWidgetCheckStatusDefinition']:
        """
        The definition for a Check Status widget.
        """
        return pulumi.get(self, "check_status_definition")

    @property
    @pulumi.getter(name="distributionDefinition")
    def distribution_definition(self) -> Optional['outputs.PowerpackWidgetDistributionDefinition']:
        """
        The definition for a Distribution widget.
        """
        return pulumi.get(self, "distribution_definition")

    @property
    @pulumi.getter(name="eventStreamDefinition")
    def event_stream_definition(self) -> Optional['outputs.PowerpackWidgetEventStreamDefinition']:
        """
        The definition for a Event Stream widget.
        """
        return pulumi.get(self, "event_stream_definition")

    @property
    @pulumi.getter(name="eventTimelineDefinition")
    def event_timeline_definition(self) -> Optional['outputs.PowerpackWidgetEventTimelineDefinition']:
        """
        The definition for a Event Timeline widget.
        """
        return pulumi.get(self, "event_timeline_definition")

    @property
    @pulumi.getter(name="freeTextDefinition")
    def free_text_definition(self) -> Optional['outputs.PowerpackWidgetFreeTextDefinition']:
        """
        The definition for a Free Text widget.
        """
        return pulumi.get(self, "free_text_definition")

    @property
    @pulumi.getter(name="geomapDefinition")
    def geomap_definition(self) -> Optional['outputs.PowerpackWidgetGeomapDefinition']:
        """
        The definition for a Geomap widget.
        """
        return pulumi.get(self, "geomap_definition")

    @property
    @pulumi.getter(name="heatmapDefinition")
    def heatmap_definition(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinition']:
        """
        The definition for a Heatmap widget.
        """
        return pulumi.get(self, "heatmap_definition")

    @property
    @pulumi.getter(name="hostmapDefinition")
    def hostmap_definition(self) -> Optional['outputs.PowerpackWidgetHostmapDefinition']:
        """
        The definition for a Hostmap widget.
        """
        return pulumi.get(self, "hostmap_definition")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        The ID of the widget.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="iframeDefinition")
    def iframe_definition(self) -> Optional['outputs.PowerpackWidgetIframeDefinition']:
        """
        The definition for an Iframe widget.
        """
        return pulumi.get(self, "iframe_definition")

    @property
    @pulumi.getter(name="imageDefinition")
    def image_definition(self) -> Optional['outputs.PowerpackWidgetImageDefinition']:
        """
        The definition for an Image widget
        """
        return pulumi.get(self, "image_definition")

    @property
    @pulumi.getter(name="listStreamDefinition")
    def list_stream_definition(self) -> Optional['outputs.PowerpackWidgetListStreamDefinition']:
        """
        The definition for a List Stream widget.
        """
        return pulumi.get(self, "list_stream_definition")

    @property
    @pulumi.getter(name="logStreamDefinition")
    def log_stream_definition(self) -> Optional['outputs.PowerpackWidgetLogStreamDefinition']:
        """
        The definition for an Log Stream widget.
        """
        return pulumi.get(self, "log_stream_definition")

    @property
    @pulumi.getter(name="manageStatusDefinition")
    def manage_status_definition(self) -> Optional['outputs.PowerpackWidgetManageStatusDefinition']:
        """
        The definition for an Manage Status widget.
        """
        return pulumi.get(self, "manage_status_definition")

    @property
    @pulumi.getter(name="noteDefinition")
    def note_definition(self) -> Optional['outputs.PowerpackWidgetNoteDefinition']:
        """
        The definition for a Note widget.
        """
        return pulumi.get(self, "note_definition")

    @property
    @pulumi.getter(name="queryTableDefinition")
    def query_table_definition(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinition']:
        """
        The definition for a Query Table widget.
        """
        return pulumi.get(self, "query_table_definition")

    @property
    @pulumi.getter(name="queryValueDefinition")
    def query_value_definition(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinition']:
        """
        The definition for a Query Value widget.
        """
        return pulumi.get(self, "query_value_definition")

    @property
    @pulumi.getter(name="runWorkflowDefinition")
    def run_workflow_definition(self) -> Optional['outputs.PowerpackWidgetRunWorkflowDefinition']:
        """
        The definition for a Run Workflow widget.
        """
        return pulumi.get(self, "run_workflow_definition")

    @property
    @pulumi.getter(name="scatterplotDefinition")
    def scatterplot_definition(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinition']:
        """
        The definition for a Scatterplot widget.
        """
        return pulumi.get(self, "scatterplot_definition")

    @property
    @pulumi.getter(name="serviceLevelObjectiveDefinition")
    def service_level_objective_definition(self) -> Optional['outputs.PowerpackWidgetServiceLevelObjectiveDefinition']:
        """
        The definition for a Service Level Objective widget.
        """
        return pulumi.get(self, "service_level_objective_definition")

    @property
    @pulumi.getter(name="servicemapDefinition")
    def servicemap_definition(self) -> Optional['outputs.PowerpackWidgetServicemapDefinition']:
        """
        The definition for a Service Map widget.
        """
        return pulumi.get(self, "servicemap_definition")

    @property
    @pulumi.getter(name="sloListDefinition")
    def slo_list_definition(self) -> Optional['outputs.PowerpackWidgetSloListDefinition']:
        """
        The definition for an SLO (Service Level Objective) List widget.
        """
        return pulumi.get(self, "slo_list_definition")

    @property
    @pulumi.getter(name="sunburstDefinition")
    def sunburst_definition(self) -> Optional['outputs.PowerpackWidgetSunburstDefinition']:
        """
        The definition for a Sunburst widget.
        """
        return pulumi.get(self, "sunburst_definition")

    @property
    @pulumi.getter(name="timeseriesDefinition")
    def timeseries_definition(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinition']:
        """
        The definition for a Timeseries widget.
        """
        return pulumi.get(self, "timeseries_definition")

    @property
    @pulumi.getter(name="toplistDefinition")
    def toplist_definition(self) -> Optional['outputs.PowerpackWidgetToplistDefinition']:
        """
        The definition for a Toplist widget.
        """
        return pulumi.get(self, "toplist_definition")

    @property
    @pulumi.getter(name="topologyMapDefinition")
    def topology_map_definition(self) -> Optional['outputs.PowerpackWidgetTopologyMapDefinition']:
        """
        The definition for a Topology Map widget.
        """
        return pulumi.get(self, "topology_map_definition")

    @property
    @pulumi.getter(name="traceServiceDefinition")
    def trace_service_definition(self) -> Optional['outputs.PowerpackWidgetTraceServiceDefinition']:
        """
        The definition for a Trace Service widget.
        """
        return pulumi.get(self, "trace_service_definition")

    @property
    @pulumi.getter(name="treemapDefinition")
    def treemap_definition(self) -> Optional['outputs.PowerpackWidgetTreemapDefinition']:
        """
        The definition for a Treemap widget.
        """
        return pulumi.get(self, "treemap_definition")

    @property
    @pulumi.getter(name="widgetLayout")
    def widget_layout(self) -> Optional['outputs.PowerpackWidgetWidgetLayout']:
        """
        The layout of the widget on a 'free' dashboard.
        """
        return pulumi.get(self, "widget_layout")


@pulumi.output_type
class PowerpackWidgetAlertGraphDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertId":
            suggest = "alert_id"
        elif key == "vizType":
            suggest = "viz_type"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetAlertGraphDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetAlertGraphDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetAlertGraphDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_id: str,
                 viz_type: str,
                 live_span: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str alert_id: The ID of the monitor used by the widget.
        :param str viz_type: Type of visualization to use when displaying the widget. Valid values are `timeseries`, `toplist`.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "alert_id", alert_id)
        pulumi.set(__self__, "viz_type", viz_type)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        """
        The ID of the monitor used by the widget.
        """
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter(name="vizType")
    def viz_type(self) -> str:
        """
        Type of visualization to use when displaying the widget. Valid values are `timeseries`, `toplist`.
        """
        return pulumi.get(self, "viz_type")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetAlertValueDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertId":
            suggest = "alert_id"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetAlertValueDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetAlertValueDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetAlertValueDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_id: str,
                 precision: Optional[int] = None,
                 text_align: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 unit: Optional[str] = None):
        """
        :param str alert_id: The ID of the monitor used by the widget.
        :param int precision: The precision to use when displaying the value. Use `*` for maximum precision.
        :param str text_align: The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param str unit: The unit for the value displayed in the widget.
        """
        pulumi.set(__self__, "alert_id", alert_id)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)

    @property
    @pulumi.getter(name="alertId")
    def alert_id(self) -> str:
        """
        The ID of the monitor used by the widget.
        """
        return pulumi.get(self, "alert_id")

    @property
    @pulumi.getter
    def precision(self) -> Optional[int]:
        """
        The precision to use when displaying the value. Use `*` for maximum precision.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "unit")


@pulumi.output_type
class PowerpackWidgetChangeDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetChangeDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence['PowerpackWidgetChangeDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "changeType":
            suggest = "change_type"
        elif key == "compareTo":
            suggest = "compare_to"
        elif key == "increaseGood":
            suggest = "increase_good"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "orderBy":
            suggest = "order_by"
        elif key == "orderDir":
            suggest = "order_dir"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"
        elif key == "showPresent":
            suggest = "show_present"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestApmQuery'] = None,
                 change_type: Optional[str] = None,
                 compare_to: Optional[str] = None,
                 formulas: Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestFormula']] = None,
                 increase_good: Optional[bool] = None,
                 log_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestLogQuery'] = None,
                 order_by: Optional[str] = None,
                 order_dir: Optional[str] = None,
                 process_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestSecurityQuery'] = None,
                 show_present: Optional[bool] = None):
        """
        :param 'PowerpackWidgetChangeDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param str change_type: Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
        :param str compare_to: Choose from when to compare current data to. Valid values are `hour_before`, `day_before`, `week_before`, `month_before`.
        :param bool increase_good: A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
        :param 'PowerpackWidgetChangeDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param str order_by: What to order by. Valid values are `change`, `name`, `present`, `past`.
        :param str order_dir: Widget sorting method. Valid values are `asc`, `desc`.
        :param 'PowerpackWidgetChangeDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'PowerpackWidgetChangeDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'PowerpackWidgetChangeDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param bool show_present: If set to `true`, displays the current value.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if change_type is not None:
            pulumi.set(__self__, "change_type", change_type)
        if compare_to is not None:
            pulumi.set(__self__, "compare_to", compare_to)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if increase_good is not None:
            pulumi.set(__self__, "increase_good", increase_good)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order_by is not None:
            pulumi.set(__self__, "order_by", order_by)
        if order_dir is not None:
            pulumi.set(__self__, "order_dir", order_dir)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if show_present is not None:
            pulumi.set(__self__, "show_present", show_present)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="changeType")
    def change_type(self) -> Optional[str]:
        """
        Whether to show absolute or relative change. Valid values are `absolute`, `relative`.
        """
        return pulumi.get(self, "change_type")

    @property
    @pulumi.getter(name="compareTo")
    def compare_to(self) -> Optional[str]:
        """
        Choose from when to compare current data to. Valid values are `hour_before`, `day_before`, `week_before`, `month_before`.
        """
        return pulumi.get(self, "compare_to")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="increaseGood")
    def increase_good(self) -> Optional[bool]:
        """
        A Boolean indicating whether an increase in the value is good (displayed in green) or not (displayed in red).
        """
        return pulumi.get(self, "increase_good")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="orderBy")
    def order_by(self) -> Optional[str]:
        """
        What to order by. Valid values are `change`, `name`, `present`, `past`.
        """
        return pulumi.get(self, "order_by")

    @property
    @pulumi.getter(name="orderDir")
    def order_dir(self) -> Optional[str]:
        """
        Widget sorting method. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order_dir")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter(name="showPresent")
    def show_present(self) -> Optional[bool]:
        """
        If set to `true`, displays the current value.
        """
        return pulumi.get(self, "show_present")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetChangeDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetChangeDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetChangeDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetChangeDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.PowerpackWidgetChangeDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.PowerpackWidgetChangeDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'PowerpackWidgetChangeDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'PowerpackWidgetChangeDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetChangeDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetChangeDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetChangeDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetChangeDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'PowerpackWidgetChangeDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'PowerpackWidgetChangeDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'PowerpackWidgetChangeDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'PowerpackWidgetChangeDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'PowerpackWidgetChangeDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetChangeDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'PowerpackWidgetChangeDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetChangeDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetChangeDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetChangeDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetChangeDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetChangeDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetChangeDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetChangeDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetChangeDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetCheckStatusDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupBies":
            suggest = "group_bies"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetCheckStatusDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetCheckStatusDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetCheckStatusDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check: str,
                 grouping: str,
                 group: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 live_span: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str check: The check to use in the widget.
        :param str grouping: The kind of grouping to use. Valid values are `check`, `cluster`.
        :param str group: The check group to use in the widget.
        :param Sequence[str] group_bies: When `grouping = "cluster"`, indicates a list of tags to use for grouping.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence[str] tags: A list of tags to use in the widget.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "check", check)
        pulumi.set(__self__, "grouping", grouping)
        if group is not None:
            pulumi.set(__self__, "group", group)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def check(self) -> str:
        """
        The check to use in the widget.
        """
        return pulumi.get(self, "check")

    @property
    @pulumi.getter
    def grouping(self) -> str:
        """
        The kind of grouping to use. Valid values are `check`, `cluster`.
        """
        return pulumi.get(self, "grouping")

    @property
    @pulumi.getter
    def group(self) -> Optional[str]:
        """
        The check group to use in the widget.
        """
        return pulumi.get(self, "group")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        When `grouping = "cluster"`, indicates a list of tags to use for grouping.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        A list of tags to use in the widget.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetDistributionDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetDistributionDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetDistributionDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetDistributionDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 xaxis: Optional['outputs.PowerpackWidgetDistributionDefinitionXaxis'] = None,
                 yaxis: Optional['outputs.PowerpackWidgetDistributionDefinitionYaxis'] = None):
        """
        :param str legend_size: The size of the legend displayed in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence['PowerpackWidgetDistributionDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param bool show_legend: Whether or not to show the legend on this widget.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param 'PowerpackWidgetDistributionDefinitionXaxisArgs' xaxis: A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
        :param 'PowerpackWidgetDistributionDefinitionYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if xaxis is not None:
            pulumi.set(__self__, "xaxis", xaxis)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def xaxis(self) -> Optional['outputs.PowerpackWidgetDistributionDefinitionXaxis']:
        """
        A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "xaxis")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.PowerpackWidgetDistributionDefinitionYaxis']:
        """
        A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "apmStatsQuery":
            suggest = "apm_stats_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetDistributionDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetDistributionDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetDistributionDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.PowerpackWidgetDistributionDefinitionRequestApmQuery'] = None,
                 apm_stats_query: Optional['outputs.PowerpackWidgetDistributionDefinitionRequestApmStatsQuery'] = None,
                 log_query: Optional['outputs.PowerpackWidgetDistributionDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetDistributionDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.PowerpackWidgetDistributionDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.PowerpackWidgetDistributionDefinitionRequestStyle'] = None):
        """
        :param 'PowerpackWidgetDistributionDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'PowerpackWidgetDistributionDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param 'PowerpackWidgetDistributionDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'PowerpackWidgetDistributionDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'PowerpackWidgetDistributionDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'PowerpackWidgetDistributionDefinitionRequestStyleArgs' style: The style of the widget graph. One nested block is allowed using the structure below.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if apm_stats_query is not None:
            pulumi.set(__self__, "apm_stats_query", apm_stats_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.PowerpackWidgetDistributionDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="apmStatsQuery")
    def apm_stats_query(self) -> Optional['outputs.PowerpackWidgetDistributionDefinitionRequestApmStatsQuery']:
        return pulumi.get(self, "apm_stats_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.PowerpackWidgetDistributionDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetDistributionDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.PowerpackWidgetDistributionDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.PowerpackWidgetDistributionDefinitionRequestStyle']:
        """
        The style of the widget graph. One nested block is allowed using the structure below.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetDistributionDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetDistributionDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetDistributionDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetDistributionDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetDistributionDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetDistributionDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetDistributionDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetDistributionDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestApmStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryTag":
            suggest = "primary_tag"
        elif key == "rowType":
            suggest = "row_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetDistributionDefinitionRequestApmStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetDistributionDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetDistributionDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env: str,
                 name: str,
                 primary_tag: str,
                 row_type: str,
                 service: str,
                 columns: Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumn']] = None,
                 resource: Optional[str] = None):
        """
        :param str env: The environment name.
        :param str name: The operation name associated with the service.
        :param str primary_tag: The organization's host group name and value.
        :param str row_type: The level of detail for the request. Valid values are `service`, `resource`, `span`.
        :param str service: The service name.
        :param Sequence['PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumnArgs'] columns: Column properties used by the front end for display.
        :param str resource: The resource name.
        """
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary_tag", primary_tag)
        pulumi.set(__self__, "row_type", row_type)
        pulumi.set(__self__, "service", service)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        The environment name.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The operation name associated with the service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryTag")
    def primary_tag(self) -> str:
        """
        The organization's host group name and value.
        """
        return pulumi.get(self, "primary_tag")

    @property
    @pulumi.getter(name="rowType")
    def row_type(self) -> str:
        """
        The level of detail for the request. Valid values are `service`, `resource`, `span`.
        """
        return pulumi.get(self, "row_type")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The service name.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumn']]:
        """
        Column properties used by the front end for display.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        The resource name.
        """
        return pulumi.get(self, "resource")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellDisplayMode":
            suggest = "cell_display_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetDistributionDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str name: The column name.
        :param str alias: A user-assigned alias for the column.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The column name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        A user-assigned alias for the column.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetDistributionDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetDistributionDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetDistributionDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetDistributionDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetDistributionDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetDistributionDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetDistributionDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetDistributionDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetDistributionDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetDistributionDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetDistributionDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetDistributionDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetDistributionDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetDistributionDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetDistributionDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetDistributionDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetDistributionDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetDistributionDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetDistributionDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetDistributionDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetDistributionDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetDistributionDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetDistributionDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetDistributionDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionXaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetDistributionDefinitionXaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetDistributionDefinitionXaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetDistributionDefinitionXaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class PowerpackWidgetDistributionDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetDistributionDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetDistributionDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetDistributionDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class PowerpackWidgetEventStreamDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventSize":
            suggest = "event_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "tagsExecution":
            suggest = "tags_execution"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetEventStreamDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetEventStreamDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetEventStreamDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 event_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 tags_execution: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str query: The query to use in the widget.
        :param str event_size: The size to use to display an event. Valid values are `s`, `l`.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param str tags_execution: The execution method for multi-value filters, options: `and` or `or`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "query", query)
        if event_size is not None:
            pulumi.set(__self__, "event_size", event_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[str]:
        """
        The size to use to display an event. Valid values are `s`, `l`.
        """
        return pulumi.get(self, "event_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        """
        The execution method for multi-value filters, options: `and` or `or`.
        """
        return pulumi.get(self, "tags_execution")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetEventTimelineDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"
        elif key == "tagsExecution":
            suggest = "tags_execution"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetEventTimelineDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetEventTimelineDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetEventTimelineDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 live_span: Optional[str] = None,
                 tags_execution: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str query: The query to use in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param str tags_execution: The execution method for multi-value filters, options: `and` or `or`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "query", query)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        """
        The execution method for multi-value filters, options: `and` or `or`.
        """
        return pulumi.get(self, "tags_execution")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetFreeTextDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fontSize":
            suggest = "font_size"
        elif key == "textAlign":
            suggest = "text_align"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetFreeTextDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetFreeTextDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetFreeTextDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text: str,
                 color: Optional[str] = None,
                 font_size: Optional[str] = None,
                 text_align: Optional[str] = None):
        """
        :param str text: The text to display in the widget.
        :param str color: The color of the text in the widget.
        :param str font_size: The size of the text in the widget.
        :param str text_align: The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        pulumi.set(__self__, "text", text)
        if color is not None:
            pulumi.set(__self__, "color", color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)

    @property
    @pulumi.getter
    def text(self) -> str:
        """
        The text to display in the widget.
        """
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def color(self) -> Optional[str]:
        """
        The color of the text in the widget.
        """
        return pulumi.get(self, "color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        """
        The size of the text in the widget.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the text in the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")


@pulumi.output_type
class PowerpackWidgetGeomapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 view: 'outputs.PowerpackWidgetGeomapDefinitionView',
                 custom_links: Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequest']] = None,
                 style: Optional['outputs.PowerpackWidgetGeomapDefinitionStyle'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param 'PowerpackWidgetGeomapDefinitionViewArgs' view: The view of the world that the map should render.
        :param Sequence['PowerpackWidgetGeomapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence['PowerpackWidgetGeomapDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
        :param 'PowerpackWidgetGeomapDefinitionStyleArgs' style: The style of the widget graph. One nested block is allowed using the structure below.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "view", view)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def view(self) -> 'outputs.PowerpackWidgetGeomapDefinitionView':
        """
        The view of the world that the map should render.
        """
        return pulumi.get(self, "view")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionStyle']:
        """
        The style of the widget graph. One nested block is allowed using the structure below.
        """
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logQuery":
            suggest = "log_query"
        elif key == "rumQuery":
            suggest = "rum_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formulas: Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.PowerpackWidgetGeomapDefinitionRequestLogQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.PowerpackWidgetGeomapDefinitionRequestRumQuery'] = None):
        """
        :param 'PowerpackWidgetGeomapDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param str q: The metric query to use for this widget.
        :param 'PowerpackWidgetGeomapDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        """
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.PowerpackWidgetGeomapDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.PowerpackWidgetGeomapDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'PowerpackWidgetGeomapDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'PowerpackWidgetGeomapDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetGeomapDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetGeomapDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetGeomapDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetGeomapDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'PowerpackWidgetGeomapDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'PowerpackWidgetGeomapDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'PowerpackWidgetGeomapDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'PowerpackWidgetGeomapDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'PowerpackWidgetGeomapDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetGeomapDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetGeomapDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetGeomapDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetGeomapDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetGeomapDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteFlip":
            suggest = "palette_flip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetGeomapDefinitionStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetGeomapDefinitionStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetGeomapDefinitionStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: str,
                 palette_flip: bool):
        """
        :param str palette: The color palette to apply to the widget.
        :param bool palette_flip: A Boolean indicating whether to flip the palette tones.
        """
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "palette_flip", palette_flip)

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply to the widget.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> bool:
        """
        A Boolean indicating whether to flip the palette tones.
        """
        return pulumi.get(self, "palette_flip")


@pulumi.output_type
class PowerpackWidgetGeomapDefinitionView(dict):
    def __init__(__self__, *,
                 focus: str):
        """
        :param str focus: The two-letter ISO code of a country to focus the map on (or `WORLD`).
        """
        pulumi.set(__self__, "focus", focus)

    @property
    @pulumi.getter
    def focus(self) -> str:
        """
        The two-letter ISO code of a country to focus the map on (or `WORLD`).
        """
        return pulumi.get(self, "focus")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionCustomLink']] = None,
                 events: Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionEvent']] = None,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequest']] = None,
                 show_legend: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 yaxis: Optional['outputs.PowerpackWidgetHeatmapDefinitionYaxis'] = None):
        """
        :param Sequence['PowerpackWidgetHeatmapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetHeatmapDefinitionEventArgs'] events: The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        :param str legend_size: The size of the legend displayed in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence['PowerpackWidgetHeatmapDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param bool show_legend: Whether or not to show the legend on this widget.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param 'PowerpackWidgetHeatmapDefinitionYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionEvent']]:
        """
        The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionYaxis']:
        """
        A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagsExecution":
            suggest = "tags_execution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 q: str,
                 tags_execution: Optional[str] = None):
        """
        :param str q: The event query to use in the widget.
        :param str tags_execution: The execution method for multi-value filters.
        """
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> str:
        """
        The event query to use in the widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        """
        The execution method for multi-value filters.
        """
        return pulumi.get(self, "tags_execution")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestApmQuery'] = None,
                 formulas: Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestStyle'] = None):
        """
        :param 'PowerpackWidgetHeatmapDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'PowerpackWidgetHeatmapDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param 'PowerpackWidgetHeatmapDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'PowerpackWidgetHeatmapDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'PowerpackWidgetHeatmapDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'PowerpackWidgetHeatmapDefinitionRequestStyleArgs' style: The style of the widget graph. One nested block is allowed using the structure below.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestStyle']:
        """
        The style of the widget graph. One nested block is allowed using the structure below.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetHeatmapDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetHeatmapDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'PowerpackWidgetHeatmapDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'PowerpackWidgetHeatmapDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetHeatmapDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetHeatmapDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'PowerpackWidgetHeatmapDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'PowerpackWidgetHeatmapDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'PowerpackWidgetHeatmapDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'PowerpackWidgetHeatmapDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetHeatmapDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetHeatmapDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetHeatmapDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetHeatmapDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class PowerpackWidgetHeatmapDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHeatmapDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHeatmapDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHeatmapDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class PowerpackWidgetHostmapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "noGroupHosts":
            suggest = "no_group_hosts"
        elif key == "noMetricHosts":
            suggest = "no_metric_hosts"
        elif key == "nodeType":
            suggest = "node_type"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionCustomLink']] = None,
                 groups: Optional[Sequence[str]] = None,
                 no_group_hosts: Optional[bool] = None,
                 no_metric_hosts: Optional[bool] = None,
                 node_type: Optional[str] = None,
                 request: Optional['outputs.PowerpackWidgetHostmapDefinitionRequest'] = None,
                 scopes: Optional[Sequence[str]] = None,
                 style: Optional['outputs.PowerpackWidgetHostmapDefinitionStyle'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetHostmapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence[str] groups: The list of tags to group nodes by.
        :param bool no_group_hosts: A Boolean indicating whether to show ungrouped nodes.
        :param bool no_metric_hosts: A Boolean indicating whether to show nodes with no metrics.
        :param str node_type: The type of node used. Valid values are `host`, `container`.
        :param 'PowerpackWidgetHostmapDefinitionRequestArgs' request: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below.
        :param Sequence[str] scopes: The list of tags to filter nodes by.
        :param 'PowerpackWidgetHostmapDefinitionStyleArgs' style: The style of the widget graph. One nested block is allowed using the structure below.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if no_group_hosts is not None:
            pulumi.set(__self__, "no_group_hosts", no_group_hosts)
        if no_metric_hosts is not None:
            pulumi.set(__self__, "no_metric_hosts", no_metric_hosts)
        if node_type is not None:
            pulumi.set(__self__, "node_type", node_type)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if style is not None:
            pulumi.set(__self__, "style", style)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence[str]]:
        """
        The list of tags to group nodes by.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter(name="noGroupHosts")
    def no_group_hosts(self) -> Optional[bool]:
        """
        A Boolean indicating whether to show ungrouped nodes.
        """
        return pulumi.get(self, "no_group_hosts")

    @property
    @pulumi.getter(name="noMetricHosts")
    def no_metric_hosts(self) -> Optional[bool]:
        """
        A Boolean indicating whether to show nodes with no metrics.
        """
        return pulumi.get(self, "no_metric_hosts")

    @property
    @pulumi.getter(name="nodeType")
    def node_type(self) -> Optional[str]:
        """
        The type of node used. Valid values are `host`, `container`.
        """
        return pulumi.get(self, "node_type")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequest']:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[str]]:
        """
        The list of tags to filter nodes by.
        """
        return pulumi.get(self, "scopes")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionStyle']:
        """
        The style of the widget graph. One nested block is allowed using the structure below.
        """
        return pulumi.get(self, "style")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequest(dict):
    def __init__(__self__, *,
                 fills: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFill']] = None,
                 sizes: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSize']] = None):
        """
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestFillArgs'] fills: The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestSizeArgs'] sizes: The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        if fills is not None:
            pulumi.set(__self__, "fills", fills)
        if sizes is not None:
            pulumi.set(__self__, "sizes", sizes)

    @property
    @pulumi.getter
    def fills(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFill']]:
        """
        The query used to fill the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "fills")

    @property
    @pulumi.getter
    def sizes(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSize']]:
        """
        The query used to size the map. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the request block).
        """
        return pulumi.get(self, "sizes")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFill(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestFill. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFill.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFill.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQuery'] = None,
                 log_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQuery'] = None,
                 security_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQuery'] = None):
        """
        :param 'PowerpackWidgetHostmapDefinitionRequestFillApmQueryArgs' apm_query: The query to use for this widget.
        :param 'PowerpackWidgetHostmapDefinitionRequestFillLogQueryArgs' log_query: The query to use for this widget.
        :param 'PowerpackWidgetHostmapDefinitionRequestFillProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'PowerpackWidgetHostmapDefinitionRequestFillRumQueryArgs' rum_query: The query to use for this widget.
        :param 'PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryArgs' security_query: The query to use for this widget.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestFillApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetHostmapDefinitionRequestFillApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestFillApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestFillLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetHostmapDefinitionRequestFillLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestFillLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestFillProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestFillRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetHostmapDefinitionRequestFillRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestFillRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestFillSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestFillSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSize(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestSize. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSize.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSize.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQuery'] = None,
                 log_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQuery'] = None,
                 security_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQuery'] = None):
        """
        :param 'PowerpackWidgetHostmapDefinitionRequestSizeApmQueryArgs' apm_query: The query to use for this widget.
        :param 'PowerpackWidgetHostmapDefinitionRequestSizeLogQueryArgs' log_query: The query to use for this widget.
        :param 'PowerpackWidgetHostmapDefinitionRequestSizeProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'PowerpackWidgetHostmapDefinitionRequestSizeRumQueryArgs' rum_query: The query to use for this widget.
        :param 'PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryArgs' security_query: The query to use for this widget.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestSizeApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetHostmapDefinitionRequestSizeApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestSizeApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestSizeLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetHostmapDefinitionRequestSizeLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestSizeLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestSizeProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestSizeRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetHostmapDefinitionRequestSizeRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestSizeRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestSizeSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionRequestSizeSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetHostmapDefinitionStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fillMax":
            suggest = "fill_max"
        elif key == "fillMin":
            suggest = "fill_min"
        elif key == "paletteFlip":
            suggest = "palette_flip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetHostmapDefinitionStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetHostmapDefinitionStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetHostmapDefinitionStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fill_max: Optional[str] = None,
                 fill_min: Optional[str] = None,
                 palette: Optional[str] = None,
                 palette_flip: Optional[bool] = None):
        """
        :param str fill_max: The max value to use to color the map.
        :param str fill_min: The min value to use to color the map.
        :param str palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        :param bool palette_flip: A Boolean indicating whether to flip the palette tones.
        """
        if fill_max is not None:
            pulumi.set(__self__, "fill_max", fill_max)
        if fill_min is not None:
            pulumi.set(__self__, "fill_min", fill_min)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_flip is not None:
            pulumi.set(__self__, "palette_flip", palette_flip)

    @property
    @pulumi.getter(name="fillMax")
    def fill_max(self) -> Optional[str]:
        """
        The max value to use to color the map.
        """
        return pulumi.get(self, "fill_max")

    @property
    @pulumi.getter(name="fillMin")
    def fill_min(self) -> Optional[str]:
        """
        The min value to use to color the map.
        """
        return pulumi.get(self, "fill_min")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteFlip")
    def palette_flip(self) -> Optional[bool]:
        """
        A Boolean indicating whether to flip the palette tones.
        """
        return pulumi.get(self, "palette_flip")


@pulumi.output_type
class PowerpackWidgetIframeDefinition(dict):
    def __init__(__self__, *,
                 url: str):
        """
        :param str url: The URL to use as a data source for the widget.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL to use as a data source for the widget.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class PowerpackWidgetImageDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hasBackground":
            suggest = "has_background"
        elif key == "hasBorder":
            suggest = "has_border"
        elif key == "horizontalAlign":
            suggest = "horizontal_align"
        elif key == "urlDarkTheme":
            suggest = "url_dark_theme"
        elif key == "verticalAlign":
            suggest = "vertical_align"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetImageDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetImageDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetImageDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 url: str,
                 has_background: Optional[bool] = None,
                 has_border: Optional[bool] = None,
                 horizontal_align: Optional[str] = None,
                 margin: Optional[str] = None,
                 sizing: Optional[str] = None,
                 url_dark_theme: Optional[str] = None,
                 vertical_align: Optional[str] = None):
        """
        :param str url: The URL to use as a data source for the widget.
        :param bool has_background: Whether to display a background or not. Defaults to `true`.
        :param bool has_border: Whether to display a border or not. Defaults to `true`.
        :param str horizontal_align: The horizontal alignment for the widget. Valid values are `center`, `left`, `right`.
        :param str margin: The margins to use around the image. Note: `small` and `large` values are deprecated. Valid values are `sm`, `md`, `lg`, `small`, `large`.
        :param str sizing: The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated. Valid values are `fill`, `contain`, `cover`, `none`, `scale-down`, `zoom`, `fit`, `center`.
        :param str url_dark_theme: The URL in dark mode to use as a data source for the widget.
        :param str vertical_align: The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        pulumi.set(__self__, "url", url)
        if has_background is not None:
            pulumi.set(__self__, "has_background", has_background)
        if has_border is not None:
            pulumi.set(__self__, "has_border", has_border)
        if horizontal_align is not None:
            pulumi.set(__self__, "horizontal_align", horizontal_align)
        if margin is not None:
            pulumi.set(__self__, "margin", margin)
        if sizing is not None:
            pulumi.set(__self__, "sizing", sizing)
        if url_dark_theme is not None:
            pulumi.set(__self__, "url_dark_theme", url_dark_theme)
        if vertical_align is not None:
            pulumi.set(__self__, "vertical_align", vertical_align)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The URL to use as a data source for the widget.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="hasBackground")
    def has_background(self) -> Optional[bool]:
        """
        Whether to display a background or not. Defaults to `true`.
        """
        return pulumi.get(self, "has_background")

    @property
    @pulumi.getter(name="hasBorder")
    def has_border(self) -> Optional[bool]:
        """
        Whether to display a border or not. Defaults to `true`.
        """
        return pulumi.get(self, "has_border")

    @property
    @pulumi.getter(name="horizontalAlign")
    def horizontal_align(self) -> Optional[str]:
        """
        The horizontal alignment for the widget. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "horizontal_align")

    @property
    @pulumi.getter
    def margin(self) -> Optional[str]:
        """
        The margins to use around the image. Note: `small` and `large` values are deprecated. Valid values are `sm`, `md`, `lg`, `small`, `large`.
        """
        return pulumi.get(self, "margin")

    @property
    @pulumi.getter
    def sizing(self) -> Optional[str]:
        """
        The preferred method to adapt the dimensions of the image. The values are based on the image `object-fit` CSS properties. Note: `zoom`, `fit` and `center` values are deprecated. Valid values are `fill`, `contain`, `cover`, `none`, `scale-down`, `zoom`, `fit`, `center`.
        """
        return pulumi.get(self, "sizing")

    @property
    @pulumi.getter(name="urlDarkTheme")
    def url_dark_theme(self) -> Optional[str]:
        """
        The URL in dark mode to use as a data source for the widget.
        """
        return pulumi.get(self, "url_dark_theme")

    @property
    @pulumi.getter(name="verticalAlign")
    def vertical_align(self) -> Optional[str]:
        """
        The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        return pulumi.get(self, "vertical_align")


@pulumi.output_type
class PowerpackWidgetListStreamDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetListStreamDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetListStreamDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetListStreamDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 requests: Sequence['outputs.PowerpackWidgetListStreamDefinitionRequest'],
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetListStreamDefinitionRequestArgs'] requests: Nested block describing the requests to use when displaying the widget. Multiple `request` blocks are allowed with the structure below.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title. Default is 16.
        """
        pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def requests(self) -> Sequence['outputs.PowerpackWidgetListStreamDefinitionRequest']:
        """
        Nested block describing the requests to use when displaying the widget. Multiple `request` blocks are allowed with the structure below.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title. Default is 16.
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetListStreamDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseFormat":
            suggest = "response_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetListStreamDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetListStreamDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetListStreamDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Sequence['outputs.PowerpackWidgetListStreamDefinitionRequestColumn'],
                 query: 'outputs.PowerpackWidgetListStreamDefinitionRequestQuery',
                 response_format: str):
        """
        :param Sequence['PowerpackWidgetListStreamDefinitionRequestColumnArgs'] columns: Widget columns.
        :param 'PowerpackWidgetListStreamDefinitionRequestQueryArgs' query: Updated list stream widget.
        :param str response_format: Widget response format. Valid values are `event_list`.
        """
        pulumi.set(__self__, "columns", columns)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "response_format", response_format)

    @property
    @pulumi.getter
    def columns(self) -> Sequence['outputs.PowerpackWidgetListStreamDefinitionRequestColumn']:
        """
        Widget columns.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def query(self) -> 'outputs.PowerpackWidgetListStreamDefinitionRequestQuery':
        """
        Updated list stream widget.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="responseFormat")
    def response_format(self) -> str:
        """
        Widget response format. Valid values are `event_list`.
        """
        return pulumi.get(self, "response_format")


@pulumi.output_type
class PowerpackWidgetListStreamDefinitionRequestColumn(dict):
    def __init__(__self__, *,
                 field: str,
                 width: str):
        """
        :param str field: Widget column field.
        :param str width: Widget column width. Valid values are `auto`, `compact`, `full`.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "width", width)

    @property
    @pulumi.getter
    def field(self) -> str:
        """
        Widget column field.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def width(self) -> str:
        """
        Widget column width. Valid values are `auto`, `compact`, `full`.
        """
        return pulumi.get(self, "width")


@pulumi.output_type
class PowerpackWidgetListStreamDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "eventSize":
            suggest = "event_size"
        elif key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetListStreamDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetListStreamDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetListStreamDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 event_size: Optional[str] = None,
                 indexes: Optional[Sequence[str]] = None,
                 query_string: Optional[str] = None,
                 sort: Optional['outputs.PowerpackWidgetListStreamDefinitionRequestQuerySort'] = None,
                 storage: Optional[str] = None):
        """
        :param str data_source: Source from which to query items to display in the stream. Valid values are `logs_stream`, `audit_stream`, `ci_pipeline_stream`, `ci_test_stream`, `rum_issue_stream`, `apm_issue_stream`, `trace_stream`, `logs_issue_stream`, `logs_pattern_stream`, `logs_transaction_stream`, `event_stream`, `rum_stream`, `llm_observability_stream`.
        :param str event_size: Size of events displayed in widget. Required if `data_source` is `event_stream`. Valid values are `s`, `l`.
        :param Sequence[str] indexes: List of indexes.
        :param str query_string: Widget query.
        :param 'PowerpackWidgetListStreamDefinitionRequestQuerySortArgs' sort: The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "data_source", data_source)
        if event_size is not None:
            pulumi.set(__self__, "event_size", event_size)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if query_string is not None:
            pulumi.set(__self__, "query_string", query_string)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        Source from which to query items to display in the stream. Valid values are `logs_stream`, `audit_stream`, `ci_pipeline_stream`, `ci_test_stream`, `rum_issue_stream`, `apm_issue_stream`, `trace_stream`, `logs_issue_stream`, `logs_pattern_stream`, `logs_transaction_stream`, `event_stream`, `rum_stream`, `llm_observability_stream`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter(name="eventSize")
    def event_size(self) -> Optional[str]:
        """
        Size of events displayed in widget. Required if `data_source` is `event_stream`. Valid values are `s`, `l`.
        """
        return pulumi.get(self, "event_size")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        List of indexes.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> Optional[str]:
        """
        Widget query.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.PowerpackWidgetListStreamDefinitionRequestQuerySort']:
        """
        The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class PowerpackWidgetListStreamDefinitionRequestQuerySort(dict):
    def __init__(__self__, *,
                 column: str,
                 order: str):
        """
        :param str column: The facet path for the column.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetLogStreamDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "liveSpan":
            suggest = "live_span"
        elif key == "messageDisplay":
            suggest = "message_display"
        elif key == "showDateColumn":
            suggest = "show_date_column"
        elif key == "showMessageColumn":
            suggest = "show_message_column"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetLogStreamDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetLogStreamDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetLogStreamDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 columns: Optional[Sequence[str]] = None,
                 indexes: Optional[Sequence[str]] = None,
                 live_span: Optional[str] = None,
                 message_display: Optional[str] = None,
                 query: Optional[str] = None,
                 show_date_column: Optional[bool] = None,
                 show_message_column: Optional[bool] = None,
                 sort: Optional['outputs.PowerpackWidgetLogStreamDefinitionSort'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence[str] columns: Stringified list of columns to use, for example: `["column1","column2","column3"]`.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param str message_display: The number of log lines to display. Valid values are `inline`, `expanded-md`, `expanded-lg`.
        :param str query: The query to use in the widget.
        :param bool show_date_column: If the date column should be displayed.
        :param bool show_message_column: If the message column should be displayed.
        :param 'PowerpackWidgetLogStreamDefinitionSortArgs' sort: The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if message_display is not None:
            pulumi.set(__self__, "message_display", message_display)
        if query is not None:
            pulumi.set(__self__, "query", query)
        if show_date_column is not None:
            pulumi.set(__self__, "show_date_column", show_date_column)
        if show_message_column is not None:
            pulumi.set(__self__, "show_message_column", show_message_column)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence[str]]:
        """
        Stringified list of columns to use, for example: `["column1","column2","column3"]`.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="messageDisplay")
    def message_display(self) -> Optional[str]:
        """
        The number of log lines to display. Valid values are `inline`, `expanded-md`, `expanded-lg`.
        """
        return pulumi.get(self, "message_display")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="showDateColumn")
    def show_date_column(self) -> Optional[bool]:
        """
        If the date column should be displayed.
        """
        return pulumi.get(self, "show_date_column")

    @property
    @pulumi.getter(name="showMessageColumn")
    def show_message_column(self) -> Optional[bool]:
        """
        If the message column should be displayed.
        """
        return pulumi.get(self, "show_message_column")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.PowerpackWidgetLogStreamDefinitionSort']:
        """
        The facet and order to sort the data, for example: `{"column": "time", "order": "desc"}`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetLogStreamDefinitionSort(dict):
    def __init__(__self__, *,
                 column: str,
                 order: str):
        """
        :param str column: The facet path for the column.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetManageStatusDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorPreference":
            suggest = "color_preference"
        elif key == "displayFormat":
            suggest = "display_format"
        elif key == "hideZeroCounts":
            suggest = "hide_zero_counts"
        elif key == "showLastTriggered":
            suggest = "show_last_triggered"
        elif key == "showPriority":
            suggest = "show_priority"
        elif key == "summaryType":
            suggest = "summary_type"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetManageStatusDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetManageStatusDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetManageStatusDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 color_preference: Optional[str] = None,
                 display_format: Optional[str] = None,
                 hide_zero_counts: Optional[bool] = None,
                 show_last_triggered: Optional[bool] = None,
                 show_priority: Optional[bool] = None,
                 sort: Optional[str] = None,
                 summary_type: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str query: The query to use in the widget.
        :param str color_preference: Whether to colorize text or background. Valid values are `background`, `text`.
        :param str display_format: The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
        :param bool hide_zero_counts: A Boolean indicating whether to hide empty categories.
        :param bool show_last_triggered: A Boolean indicating whether to show when monitors/groups last triggered.
        :param bool show_priority: Whether to show the priorities column.
        :param str sort: The method to sort the monitors. Valid values are `name`, `group`, `status`, `tags`, `triggered`, `group,asc`, `group,desc`, `name,asc`, `name,desc`, `status,asc`, `status,desc`, `tags,asc`, `tags,desc`, `triggered,asc`, `triggered,desc`, `priority,asc`, `priority,desc`.
        :param str summary_type: The summary type to use. Valid values are `monitors`, `groups`, `combined`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "query", query)
        if color_preference is not None:
            pulumi.set(__self__, "color_preference", color_preference)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if hide_zero_counts is not None:
            pulumi.set(__self__, "hide_zero_counts", hide_zero_counts)
        if show_last_triggered is not None:
            pulumi.set(__self__, "show_last_triggered", show_last_triggered)
        if show_priority is not None:
            pulumi.set(__self__, "show_priority", show_priority)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if summary_type is not None:
            pulumi.set(__self__, "summary_type", summary_type)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The query to use in the widget.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="colorPreference")
    def color_preference(self) -> Optional[str]:
        """
        Whether to colorize text or background. Valid values are `background`, `text`.
        """
        return pulumi.get(self, "color_preference")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        """
        The display setting to use. Valid values are `counts`, `countsAndList`, `list`.
        """
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter(name="hideZeroCounts")
    def hide_zero_counts(self) -> Optional[bool]:
        """
        A Boolean indicating whether to hide empty categories.
        """
        return pulumi.get(self, "hide_zero_counts")

    @property
    @pulumi.getter(name="showLastTriggered")
    def show_last_triggered(self) -> Optional[bool]:
        """
        A Boolean indicating whether to show when monitors/groups last triggered.
        """
        return pulumi.get(self, "show_last_triggered")

    @property
    @pulumi.getter(name="showPriority")
    def show_priority(self) -> Optional[bool]:
        """
        Whether to show the priorities column.
        """
        return pulumi.get(self, "show_priority")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The method to sort the monitors. Valid values are `name`, `group`, `status`, `tags`, `triggered`, `group,asc`, `group,desc`, `name,asc`, `name,desc`, `status,asc`, `status,desc`, `tags,asc`, `tags,desc`, `triggered,asc`, `triggered,desc`, `priority,asc`, `priority,desc`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="summaryType")
    def summary_type(self) -> Optional[str]:
        """
        The summary type to use. Valid values are `monitors`, `groups`, `combined`.
        """
        return pulumi.get(self, "summary_type")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetNoteDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "backgroundColor":
            suggest = "background_color"
        elif key == "fontSize":
            suggest = "font_size"
        elif key == "hasPadding":
            suggest = "has_padding"
        elif key == "showTick":
            suggest = "show_tick"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "tickEdge":
            suggest = "tick_edge"
        elif key == "tickPos":
            suggest = "tick_pos"
        elif key == "verticalAlign":
            suggest = "vertical_align"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetNoteDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetNoteDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetNoteDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content: str,
                 background_color: Optional[str] = None,
                 font_size: Optional[str] = None,
                 has_padding: Optional[bool] = None,
                 show_tick: Optional[bool] = None,
                 text_align: Optional[str] = None,
                 tick_edge: Optional[str] = None,
                 tick_pos: Optional[str] = None,
                 vertical_align: Optional[str] = None):
        """
        :param str content: The content of the note.
        :param str background_color: The background color of the note.
        :param str font_size: The size of the text.
        :param bool has_padding: Whether to add padding or not. Defaults to `true`.
        :param bool show_tick: Whether to show a tick or not.
        :param str text_align: The alignment of the widget's text. Valid values are `center`, `left`, `right`.
        :param str tick_edge: When `tick = true`, a string indicating on which side of the widget the tick should be displayed. Valid values are `bottom`, `left`, `right`, `top`.
        :param str tick_pos: When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tick_pos = "50%"` is centered alignment.
        :param str vertical_align: The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        pulumi.set(__self__, "content", content)
        if background_color is not None:
            pulumi.set(__self__, "background_color", background_color)
        if font_size is not None:
            pulumi.set(__self__, "font_size", font_size)
        if has_padding is not None:
            pulumi.set(__self__, "has_padding", has_padding)
        if show_tick is not None:
            pulumi.set(__self__, "show_tick", show_tick)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if tick_edge is not None:
            pulumi.set(__self__, "tick_edge", tick_edge)
        if tick_pos is not None:
            pulumi.set(__self__, "tick_pos", tick_pos)
        if vertical_align is not None:
            pulumi.set(__self__, "vertical_align", vertical_align)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        The content of the note.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="backgroundColor")
    def background_color(self) -> Optional[str]:
        """
        The background color of the note.
        """
        return pulumi.get(self, "background_color")

    @property
    @pulumi.getter(name="fontSize")
    def font_size(self) -> Optional[str]:
        """
        The size of the text.
        """
        return pulumi.get(self, "font_size")

    @property
    @pulumi.getter(name="hasPadding")
    def has_padding(self) -> Optional[bool]:
        """
        Whether to add padding or not. Defaults to `true`.
        """
        return pulumi.get(self, "has_padding")

    @property
    @pulumi.getter(name="showTick")
    def show_tick(self) -> Optional[bool]:
        """
        Whether to show a tick or not.
        """
        return pulumi.get(self, "show_tick")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the widget's text. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter(name="tickEdge")
    def tick_edge(self) -> Optional[str]:
        """
        When `tick = true`, a string indicating on which side of the widget the tick should be displayed. Valid values are `bottom`, `left`, `right`, `top`.
        """
        return pulumi.get(self, "tick_edge")

    @property
    @pulumi.getter(name="tickPos")
    def tick_pos(self) -> Optional[str]:
        """
        When `tick = true`, a string with a percent sign indicating the position of the tick, for example: `tick_pos = "50%"` is centered alignment.
        """
        return pulumi.get(self, "tick_pos")

    @property
    @pulumi.getter(name="verticalAlign")
    def vertical_align(self) -> Optional[str]:
        """
        The vertical alignment for the widget. Valid values are `center`, `top`, `bottom`.
        """
        return pulumi.get(self, "vertical_align")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "hasSearchBar":
            suggest = "has_search_bar"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionCustomLink']] = None,
                 has_search_bar: Optional[str] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetQueryTableDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str has_search_bar: Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence['PowerpackWidgetQueryTableDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the `request` block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if has_search_bar is not None:
            pulumi.set(__self__, "has_search_bar", has_search_bar)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="hasSearchBar")
    def has_search_bar(self) -> Optional[str]:
        """
        Controls the display of the search bar. Valid values are `always`, `never`, `auto`.
        """
        return pulumi.get(self, "has_search_bar")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "apmStatsQuery":
            suggest = "apm_stats_query"
        elif key == "cellDisplayModes":
            suggest = "cell_display_modes"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"
        elif key == "textFormats":
            suggest = "text_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 alias: Optional[str] = None,
                 apm_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestApmQuery'] = None,
                 apm_stats_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestApmStatsQuery'] = None,
                 cell_display_modes: Optional[Sequence[str]] = None,
                 conditional_formats: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestConditionalFormat']] = None,
                 formulas: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestFormula']] = None,
                 limit: Optional[int] = None,
                 log_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestLogQuery'] = None,
                 order: Optional[str] = None,
                 process_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQuery'] = None,
                 text_formats: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestTextFormat']] = None):
        """
        :param str aggregator: The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str alias: The alias for the column name (defaults to metric name).
        :param 'PowerpackWidgetQueryTableDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param Sequence[str] cell_display_modes: A list of display modes for each table cell. List items one of `number`, `bar`. Valid values are `number`, `bar`.
        :param Sequence['PowerpackWidgetQueryTableDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param int limit: The number of lines to show in the table.
        :param 'PowerpackWidgetQueryTableDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param str order: The sort order for the rows. Valid values are `asc`, `desc`.
        :param 'PowerpackWidgetQueryTableDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'PowerpackWidgetQueryTableDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'PowerpackWidgetQueryTableDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param Sequence['PowerpackWidgetQueryTableDefinitionRequestTextFormatArgs'] text_formats: Text formats define how to format text in table widget content. Multiple `text_formats` blocks are allowed using the structure below. This resource is in beta and is subject to change.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if apm_stats_query is not None:
            pulumi.set(__self__, "apm_stats_query", apm_stats_query)
        if cell_display_modes is not None:
            pulumi.set(__self__, "cell_display_modes", cell_display_modes)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if order is not None:
            pulumi.set(__self__, "order", order)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if text_formats is not None:
            pulumi.set(__self__, "text_formats", text_formats)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        The alias for the column name (defaults to metric name).
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="apmStatsQuery")
    def apm_stats_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestApmStatsQuery']:
        return pulumi.get(self, "apm_stats_query")

    @property
    @pulumi.getter(name="cellDisplayModes")
    def cell_display_modes(self) -> Optional[Sequence[str]]:
        """
        A list of display modes for each table cell. List items one of `number`, `bar`. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_modes")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of lines to show in the table.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The sort order for the rows. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter(name="textFormats")
    def text_formats(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestTextFormat']]:
        """
        Text formats define how to format text in table widget content. Multiple `text_formats` blocks are allowed using the structure below. This resource is in beta and is subject to change.
        """
        return pulumi.get(self, "text_formats")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetQueryTableDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetQueryTableDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestApmStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "primaryTag":
            suggest = "primary_tag"
        elif key == "rowType":
            suggest = "row_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestApmStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestApmStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env: str,
                 name: str,
                 primary_tag: str,
                 row_type: str,
                 service: str,
                 columns: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumn']] = None,
                 resource: Optional[str] = None):
        """
        :param str env: The environment name.
        :param str name: The operation name associated with the service.
        :param str primary_tag: The organization's host group name and value.
        :param str row_type: The level of detail for the request. Valid values are `service`, `resource`, `span`.
        :param str service: The service name.
        :param Sequence['PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumnArgs'] columns: Column properties used by the front end for display.
        :param str resource: The resource name.
        """
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "primary_tag", primary_tag)
        pulumi.set(__self__, "row_type", row_type)
        pulumi.set(__self__, "service", service)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        The environment name.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The operation name associated with the service.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="primaryTag")
    def primary_tag(self) -> str:
        """
        The organization's host group name and value.
        """
        return pulumi.get(self, "primary_tag")

    @property
    @pulumi.getter(name="rowType")
    def row_type(self) -> str:
        """
        The level of detail for the request. Valid values are `service`, `resource`, `span`.
        """
        return pulumi.get(self, "row_type")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The service name.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumn']]:
        """
        Column properties used by the front end for display.
        """
        return pulumi.get(self, "columns")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        The resource name.
        """
        return pulumi.get(self, "resource")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cellDisplayMode":
            suggest = "cell_display_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestApmStatsQueryColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str name: The column name.
        :param str alias: A user-assigned alias for the column.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "name", name)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The column name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        A user-assigned alias for the column.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'PowerpackWidgetQueryTableDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'PowerpackWidgetQueryTableDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetQueryTableDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetQueryTableDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'PowerpackWidgetQueryTableDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'PowerpackWidgetQueryTableDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'PowerpackWidgetQueryTableDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'PowerpackWidgetQueryTableDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetQueryTableDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetQueryTableDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetQueryTableDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetQueryTableDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestTextFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "textFormats":
            suggest = "text_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestTextFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestTextFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestTextFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 text_formats: Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormat']] = None):
        """
        :param Sequence['PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormatArgs'] text_formats: The text format to apply to the items in a table widget column.
        """
        if text_formats is not None:
            pulumi.set(__self__, "text_formats", text_formats)

    @property
    @pulumi.getter(name="textFormats")
    def text_formats(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormat']]:
        """
        The text format to apply to the items in a table widget column.
        """
        return pulumi.get(self, "text_formats")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match: 'outputs.PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormatMatch',
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 palette: Optional[str] = None,
                 replace: Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormatReplace'] = None):
        """
        :param 'PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormatMatchArgs' match: Match rule for the table widget text format.
        :param str custom_bg_color: The custom color palette to apply to the background.
        :param str custom_fg_color: The custom color palette to apply to the foreground text.
        :param str palette: The color palette to apply. Valid values are `white_on_red`, `white_on_yellow`, `white_on_green`, `black_on_light_red`, `black_on_light_yellow`, `black_on_light_green`, `red_on_white`, `yellow_on_white`, `green_on_white`, `custom_bg`, `custom_text`.
        :param 'PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormatReplaceArgs' replace: Match rule for the table widget text format.
        """
        pulumi.set(__self__, "match", match)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if replace is not None:
            pulumi.set(__self__, "replace", replace)

    @property
    @pulumi.getter
    def match(self) -> 'outputs.PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormatMatch':
        """
        Match rule for the table widget text format.
        """
        return pulumi.get(self, "match")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The custom color palette to apply to the background.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The custom color palette to apply to the foreground text.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette to apply. Valid values are `white_on_red`, `white_on_yellow`, `white_on_green`, `black_on_light_red`, `black_on_light_yellow`, `black_on_light_green`, `red_on_white`, `yellow_on_white`, `green_on_white`, `custom_bg`, `custom_text`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def replace(self) -> Optional['outputs.PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormatReplace']:
        """
        Match rule for the table widget text format.
        """
        return pulumi.get(self, "replace")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormatMatch(dict):
    def __init__(__self__, *,
                 type: str,
                 value: str):
        """
        :param str type: Match or compare option. Valid values are `is`, `is_not`, `contains`, `does_not_contain`, `starts_with`, `ends_with`.
        :param str value: Table Widget Match String.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Match or compare option. Valid values are `is`, `is_not`, `contains`, `does_not_contain`, `starts_with`, `ends_with`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Table Widget Match String.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormatReplace(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "with":
            suggest = "with_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormatReplace. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormatReplace.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryTableDefinitionRequestTextFormatTextFormatReplace.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 with_: str,
                 substring: Optional[str] = None):
        """
        :param str type: Table widget text format replace all type.
        :param str with_: Table Widget Match String.
        :param str substring: Text that will be replaced. Must be used with type `substring`.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "with_", with_)
        if substring is not None:
            pulumi.set(__self__, "substring", substring)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Table widget text format replace all type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="with")
    def with_(self) -> str:
        """
        Table Widget Match String.
        """
        return pulumi.get(self, "with_")

    @property
    @pulumi.getter
    def substring(self) -> Optional[str]:
        """
        Text that will be replaced. Must be used with type `substring`.
        """
        return pulumi.get(self, "substring")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "customUnit":
            suggest = "custom_unit"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "textAlign":
            suggest = "text_align"
        elif key == "timeseriesBackground":
            suggest = "timeseries_background"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscale: Optional[bool] = None,
                 custom_links: Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionCustomLink']] = None,
                 custom_unit: Optional[str] = None,
                 live_span: Optional[str] = None,
                 precision: Optional[int] = None,
                 requests: Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequest']] = None,
                 text_align: Optional[str] = None,
                 timeseries_background: Optional['outputs.PowerpackWidgetQueryValueDefinitionTimeseriesBackground'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param bool autoscale: A Boolean indicating whether to automatically scale the tile.
        :param Sequence['PowerpackWidgetQueryValueDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str custom_unit: The unit for the value displayed in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param int precision: The precision to use when displaying the tile.
        :param Sequence['PowerpackWidgetQueryValueDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
        :param str text_align: The alignment of the widget's text. Valid values are `center`, `left`, `right`.
        :param 'PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundArgs' timeseries_background: Set a timeseries on the widget background.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        if autoscale is not None:
            pulumi.set(__self__, "autoscale", autoscale)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if custom_unit is not None:
            pulumi.set(__self__, "custom_unit", custom_unit)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if text_align is not None:
            pulumi.set(__self__, "text_align", text_align)
        if timeseries_background is not None:
            pulumi.set(__self__, "timeseries_background", timeseries_background)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def autoscale(self) -> Optional[bool]:
        """
        A Boolean indicating whether to automatically scale the tile.
        """
        return pulumi.get(self, "autoscale")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="customUnit")
    def custom_unit(self) -> Optional[str]:
        """
        The unit for the value displayed in the widget.
        """
        return pulumi.get(self, "custom_unit")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def precision(self) -> Optional[int]:
        """
        The precision to use when displaying the tile.
        """
        return pulumi.get(self, "precision")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="textAlign")
    def text_align(self) -> Optional[str]:
        """
        The alignment of the widget's text. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "text_align")

    @property
    @pulumi.getter(name="timeseriesBackground")
    def timeseries_background(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionTimeseriesBackground']:
        """
        Set a timeseries on the widget background.
        """
        return pulumi.get(self, "timeseries_background")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "auditQuery":
            suggest = "audit_query"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestApmQuery'] = None,
                 audit_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQuery'] = None,
                 conditional_formats: Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestConditionalFormat']] = None,
                 formulas: Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQuery'] = None):
        """
        :param str aggregator: The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param 'PowerpackWidgetQueryValueDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'PowerpackWidgetQueryValueDefinitionRequestAuditQueryArgs' audit_query: The query to use for this widget.
        :param Sequence['PowerpackWidgetQueryValueDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'PowerpackWidgetQueryValueDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param 'PowerpackWidgetQueryValueDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'PowerpackWidgetQueryValueDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'PowerpackWidgetQueryValueDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if audit_query is not None:
            pulumi.set(__self__, "audit_query", audit_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregator to use for time aggregation. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetQueryValueDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetQueryValueDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestAuditQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestAuditQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestAuditQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestAuditQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetQueryValueDefinitionRequestAuditQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetQueryValueDefinitionRequestAuditQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestAuditQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestAuditQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestAuditQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'PowerpackWidgetQueryValueDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'PowerpackWidgetQueryValueDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetQueryValueDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetQueryValueDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'PowerpackWidgetQueryValueDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'PowerpackWidgetQueryValueDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'PowerpackWidgetQueryValueDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'PowerpackWidgetQueryValueDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetQueryValueDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetQueryValueDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetQueryValueDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetQueryValueDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionTimeseriesBackground(dict):
    def __init__(__self__, *,
                 type: str,
                 yaxis: Optional['outputs.PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxis'] = None):
        """
        :param str type: Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        :param 'PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        pulumi.set(__self__, "type", type)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Whether the Timeseries is made using an area or bars. Valid values are `bars`, `area`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxis']:
        """
        A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetQueryValueDefinitionTimeseriesBackgroundYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class PowerpackWidgetRunWorkflowDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workflowId":
            suggest = "workflow_id"
        elif key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetRunWorkflowDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetRunWorkflowDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetRunWorkflowDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workflow_id: str,
                 custom_links: Optional[Sequence['outputs.PowerpackWidgetRunWorkflowDefinitionCustomLink']] = None,
                 inputs: Optional[Sequence['outputs.PowerpackWidgetRunWorkflowDefinitionInput']] = None,
                 live_span: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str workflow_id: Workflow ID
        :param Sequence['PowerpackWidgetRunWorkflowDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetRunWorkflowDefinitionInputArgs'] inputs: Array of workflow inputs to map to dashboard template variables.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "workflow_id", workflow_id)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="workflowId")
    def workflow_id(self) -> str:
        """
        Workflow ID
        """
        return pulumi.get(self, "workflow_id")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.PowerpackWidgetRunWorkflowDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def inputs(self) -> Optional[Sequence['outputs.PowerpackWidgetRunWorkflowDefinitionInput']]:
        """
        Array of workflow inputs to map to dashboard template variables.
        """
        return pulumi.get(self, "inputs")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetRunWorkflowDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetRunWorkflowDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetRunWorkflowDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetRunWorkflowDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class PowerpackWidgetRunWorkflowDefinitionInput(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Name of the workflow input.
        :param str value: Dashboard template variable. Can be suffixed with `.value` or `.key`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the workflow input.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Dashboard template variable. Can be suffixed with `.value` or `.key`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "colorByGroups":
            suggest = "color_by_groups"
        elif key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 color_by_groups: Optional[Sequence[str]] = None,
                 custom_links: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 request: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequest'] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 xaxis: Optional['outputs.PowerpackWidgetScatterplotDefinitionXaxis'] = None,
                 yaxis: Optional['outputs.PowerpackWidgetScatterplotDefinitionYaxis'] = None):
        """
        :param Sequence[str] color_by_groups: List of groups used for colors.
        :param Sequence['PowerpackWidgetScatterplotDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param 'PowerpackWidgetScatterplotDefinitionRequestArgs' request: A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed using the structure below.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param 'PowerpackWidgetScatterplotDefinitionXaxisArgs' xaxis: A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
        :param 'PowerpackWidgetScatterplotDefinitionYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        if color_by_groups is not None:
            pulumi.set(__self__, "color_by_groups", color_by_groups)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if xaxis is not None:
            pulumi.set(__self__, "xaxis", xaxis)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="colorByGroups")
    def color_by_groups(self) -> Optional[Sequence[str]]:
        """
        List of groups used for colors.
        """
        return pulumi.get(self, "color_by_groups")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequest']:
        """
        A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed using the structure below.
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def xaxis(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionXaxis']:
        """
        A nested block describing the X-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "xaxis")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionYaxis']:
        """
        A nested block describing the Y-Axis Controls. Exactly one nested block is allowed using the structure below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scatterplotTables":
            suggest = "scatterplot_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scatterplot_tables: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTable']] = None,
                 xes: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestX']] = None,
                 ys: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestY']] = None):
        """
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableArgs'] scatterplot_tables: Scatterplot request containing formulas and functions.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestXArgs'] xes: The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestYArgs'] ys: The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        if scatterplot_tables is not None:
            pulumi.set(__self__, "scatterplot_tables", scatterplot_tables)
        if xes is not None:
            pulumi.set(__self__, "xes", xes)
        if ys is not None:
            pulumi.set(__self__, "ys", ys)

    @property
    @pulumi.getter(name="scatterplotTables")
    def scatterplot_tables(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTable']]:
        """
        Scatterplot request containing formulas and functions.
        """
        return pulumi.get(self, "scatterplot_tables")

    @property
    @pulumi.getter
    def xes(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestX']]:
        """
        The query used for the X-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        return pulumi.get(self, "xes")

    @property
    @pulumi.getter
    def ys(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestY']]:
        """
        The query used for the Y-Axis. Exactly one nested block is allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query`, `apm_stats_query` or `process_query` is required within the block).
        """
        return pulumi.get(self, "ys")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTable(dict):
    def __init__(__self__, *,
                 formulas: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableFormula']] = None,
                 queries: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuery']] = None):
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuery']]:
        return pulumi.get(self, "queries")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestScatterplotTableFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dimension: str,
                 formula_expression: str,
                 alias: Optional[str] = None):
        """
        :param str dimension: Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        """
        pulumi.set(__self__, "dimension", dimension)
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)

    @property
    @pulumi.getter
    def dimension(self) -> str:
        """
        Dimension of the Scatterplot. Valid values are `x`, `y`, `radius`, `color`.
        """
        return pulumi.get(self, "dimension")

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery'] = None,
                 metric_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery'] = None):
        """
        :param 'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestScatterplotTableQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestX(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestX. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestX.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestX.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQuery'] = None,
                 log_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQuery'] = None,
                 security_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQuery'] = None):
        """
        :param str aggregator: Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param 'PowerpackWidgetScatterplotDefinitionRequestXApmQueryArgs' apm_query: The query to use for this widget.
        :param 'PowerpackWidgetScatterplotDefinitionRequestXLogQueryArgs' log_query: The query to use for this widget.
        :param 'PowerpackWidgetScatterplotDefinitionRequestXProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'PowerpackWidgetScatterplotDefinitionRequestXRumQueryArgs' rum_query: The query to use for this widget.
        :param 'PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryArgs' security_query: The query to use for this widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestXApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetScatterplotDefinitionRequestXApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestXApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestXLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetScatterplotDefinitionRequestXLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestXLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestXProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestXRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetScatterplotDefinitionRequestXRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestXRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestXSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestXSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestY(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestY. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestY.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestY.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregator: Optional[str] = None,
                 apm_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQuery'] = None,
                 log_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYProcessQuery'] = None,
                 q: Optional[str] = None,
                 rum_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQuery'] = None,
                 security_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQuery'] = None):
        """
        :param str aggregator: Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param 'PowerpackWidgetScatterplotDefinitionRequestYApmQueryArgs' apm_query: The query to use for this widget.
        :param 'PowerpackWidgetScatterplotDefinitionRequestYLogQueryArgs' log_query: The query to use for this widget.
        :param 'PowerpackWidgetScatterplotDefinitionRequestYProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'PowerpackWidgetScatterplotDefinitionRequestYRumQueryArgs' rum_query: The query to use for this widget.
        :param 'PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryArgs' security_query: The query to use for this widget.
        """
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        Aggregator used for the request. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestYApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetScatterplotDefinitionRequestYApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestYApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestYLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetScatterplotDefinitionRequestYLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestYLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestYProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestYRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetScatterplotDefinitionRequestYRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestYRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestYSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionRequestYSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionXaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionXaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionXaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionXaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class PowerpackWidgetScatterplotDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetScatterplotDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetScatterplotDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetScatterplotDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class PowerpackWidgetServiceLevelObjectiveDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sloId":
            suggest = "slo_id"
        elif key == "timeWindows":
            suggest = "time_windows"
        elif key == "viewMode":
            suggest = "view_mode"
        elif key == "viewType":
            suggest = "view_type"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "globalTimeTarget":
            suggest = "global_time_target"
        elif key == "showErrorBudget":
            suggest = "show_error_budget"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetServiceLevelObjectiveDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetServiceLevelObjectiveDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetServiceLevelObjectiveDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 slo_id: str,
                 time_windows: Sequence[str],
                 view_mode: str,
                 view_type: str,
                 additional_query_filters: Optional[str] = None,
                 global_time_target: Optional[str] = None,
                 show_error_budget: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str slo_id: The ID of the service level objective used by the widget.
        :param Sequence[str] time_windows: A list of time windows to display in the widget. Valid values are `7d`, `30d`, `90d`, `week_to_date`, `previous_week`, `month_to_date`, `previous_month`, `global_time`.
        :param str view_mode: The view mode for the widget. Valid values are `overall`, `component`, `both`.
        :param str view_type: The type of view to use when displaying the widget. Only `detail` is supported.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str global_time_target: The global time target of the widget.
        :param bool show_error_budget: Whether to show the error budget or not.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "slo_id", slo_id)
        pulumi.set(__self__, "time_windows", time_windows)
        pulumi.set(__self__, "view_mode", view_mode)
        pulumi.set(__self__, "view_type", view_type)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if global_time_target is not None:
            pulumi.set(__self__, "global_time_target", global_time_target)
        if show_error_budget is not None:
            pulumi.set(__self__, "show_error_budget", show_error_budget)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        The ID of the service level objective used by the widget.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="timeWindows")
    def time_windows(self) -> Sequence[str]:
        """
        A list of time windows to display in the widget. Valid values are `7d`, `30d`, `90d`, `week_to_date`, `previous_week`, `month_to_date`, `previous_month`, `global_time`.
        """
        return pulumi.get(self, "time_windows")

    @property
    @pulumi.getter(name="viewMode")
    def view_mode(self) -> str:
        """
        The view mode for the widget. Valid values are `overall`, `component`, `both`.
        """
        return pulumi.get(self, "view_mode")

    @property
    @pulumi.getter(name="viewType")
    def view_type(self) -> str:
        """
        The type of view to use when displaying the widget. Only `detail` is supported.
        """
        return pulumi.get(self, "view_type")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="globalTimeTarget")
    def global_time_target(self) -> Optional[str]:
        """
        The global time target of the widget.
        """
        return pulumi.get(self, "global_time_target")

    @property
    @pulumi.getter(name="showErrorBudget")
    def show_error_budget(self) -> Optional[bool]:
        """
        Whether to show the error budget or not.
        """
        return pulumi.get(self, "show_error_budget")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetServicemapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetServicemapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetServicemapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetServicemapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Sequence[str],
                 service: str,
                 custom_links: Optional[Sequence['outputs.PowerpackWidgetServicemapDefinitionCustomLink']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence[str] filters: Your environment and primary tag (or `*` if enabled for your account).
        :param str service: The ID of the service to map.
        :param Sequence['PowerpackWidgetServicemapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "service", service)
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def filters(self) -> Sequence[str]:
        """
        Your environment and primary tag (or `*` if enabled for your account).
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The ID of the service to map.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.PowerpackWidgetServicemapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetServicemapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetServicemapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetServicemapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetServicemapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class PowerpackWidgetSloListDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSloListDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSloListDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSloListDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 request: 'outputs.PowerpackWidgetSloListDefinitionRequest',
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param 'PowerpackWidgetSloListDefinitionRequestArgs' request: A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "request", request)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def request(self) -> 'outputs.PowerpackWidgetSloListDefinitionRequest':
        """
        A nested block describing the request to use when displaying the widget. Exactly one `request` block is allowed.
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetSloListDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestType":
            suggest = "request_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSloListDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSloListDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSloListDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: 'outputs.PowerpackWidgetSloListDefinitionRequestQuery',
                 request_type: str):
        """
        :param 'PowerpackWidgetSloListDefinitionRequestQueryArgs' query: Updated SLO List widget.
        :param str request_type: The request type for the SLO List request. Valid values are `slo_list`.
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "request_type", request_type)

    @property
    @pulumi.getter
    def query(self) -> 'outputs.PowerpackWidgetSloListDefinitionRequestQuery':
        """
        Updated SLO List widget.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> str:
        """
        The request type for the SLO List request. Valid values are `slo_list`.
        """
        return pulumi.get(self, "request_type")


@pulumi.output_type
class PowerpackWidgetSloListDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryString":
            suggest = "query_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSloListDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSloListDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSloListDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_string: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.PowerpackWidgetSloListDefinitionRequestQuerySort'] = None):
        """
        :param str query_string: Widget query.
        :param int limit: Maximum number of results to display in the table. Defaults to `100`.
        :param 'PowerpackWidgetSloListDefinitionRequestQuerySortArgs' sort: The facet and order to sort the data, for example: `{"column": "status.sli", "order": "desc"}`.
        """
        pulumi.set(__self__, "query_string", query_string)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> str:
        """
        Widget query.
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        Maximum number of results to display in the table. Defaults to `100`.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.PowerpackWidgetSloListDefinitionRequestQuerySort']:
        """
        The facet and order to sort the data, for example: `{"column": "status.sli", "order": "desc"}`.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class PowerpackWidgetSloListDefinitionRequestQuerySort(dict):
    def __init__(__self__, *,
                 column: str,
                 order: str):
        """
        :param str column: The facet path for the column.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        The facet path for the column.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetSunburstDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "hideTotal":
            suggest = "hide_total"
        elif key == "legendInline":
            suggest = "legend_inline"
        elif key == "legendTable":
            suggest = "legend_table"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionCustomLink']] = None,
                 hide_total: Optional[bool] = None,
                 legend_inline: Optional['outputs.PowerpackWidgetSunburstDefinitionLegendInline'] = None,
                 legend_table: Optional['outputs.PowerpackWidgetSunburstDefinitionLegendTable'] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetSunburstDefinitionCustomLinkArgs'] custom_links: Nested block describing a custom link. Multiple `custom_link` blocks are allowed with the structure below.
        :param bool hide_total: Whether or not to show the total value in the widget.
        :param 'PowerpackWidgetSunburstDefinitionLegendInlineArgs' legend_inline: Used to configure the inline legend. Cannot be used in conjunction with legend*table.
        :param 'PowerpackWidgetSunburstDefinitionLegendTableArgs' legend_table: Used to configure the table legend. Cannot be used in conjunction with legend*inline.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence['PowerpackWidgetSunburstDefinitionRequestArgs'] requests: Nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed with the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. One of `left`, `center`, or `right`. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title. Default is 16.
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if hide_total is not None:
            pulumi.set(__self__, "hide_total", hide_total)
        if legend_inline is not None:
            pulumi.set(__self__, "legend_inline", legend_inline)
        if legend_table is not None:
            pulumi.set(__self__, "legend_table", legend_table)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionCustomLink']]:
        """
        Nested block describing a custom link. Multiple `custom_link` blocks are allowed with the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="hideTotal")
    def hide_total(self) -> Optional[bool]:
        """
        Whether or not to show the total value in the widget.
        """
        return pulumi.get(self, "hide_total")

    @property
    @pulumi.getter(name="legendInline")
    def legend_inline(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionLegendInline']:
        """
        Used to configure the inline legend. Cannot be used in conjunction with legend*table.
        """
        return pulumi.get(self, "legend_inline")

    @property
    @pulumi.getter(name="legendTable")
    def legend_table(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionLegendTable']:
        """
        Used to configure the table legend. Cannot be used in conjunction with legend*inline.
        """
        return pulumi.get(self, "legend_table")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequest']]:
        """
        Nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed with the structure below (exactly one of `q`, `log_query` or `rum_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. One of `left`, `center`, or `right`. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title. Default is 16.
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionLegendInline(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hidePercent":
            suggest = "hide_percent"
        elif key == "hideValue":
            suggest = "hide_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionLegendInline. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionLegendInline.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionLegendInline.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 hide_percent: Optional[bool] = None,
                 hide_value: Optional[bool] = None):
        """
        :param str type: The type of legend (inline or automatic). Valid values are `inline`, `automatic`.
        :param bool hide_percent: Whether to hide the percentages of the groups.
        :param bool hide_value: Whether to hide the values of the groups.
        """
        pulumi.set(__self__, "type", type)
        if hide_percent is not None:
            pulumi.set(__self__, "hide_percent", hide_percent)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of legend (inline or automatic). Valid values are `inline`, `automatic`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="hidePercent")
    def hide_percent(self) -> Optional[bool]:
        """
        Whether to hide the percentages of the groups.
        """
        return pulumi.get(self, "hide_percent")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Whether to hide the values of the groups.
        """
        return pulumi.get(self, "hide_value")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionLegendTable(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: The type of legend (table or none). Valid values are `table`, `none`.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of legend (table or none). Valid values are `table`, `none`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "auditQuery":
            suggest = "audit_query"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "networkQuery":
            suggest = "network_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestApmQuery'] = None,
                 audit_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestAuditQuery'] = None,
                 formulas: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestLogQuery'] = None,
                 network_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestStyle'] = None):
        """
        :param 'PowerpackWidgetSunburstDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'PowerpackWidgetSunburstDefinitionRequestAuditQueryArgs' audit_query: The query to use for this widget.
        :param 'PowerpackWidgetSunburstDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param 'PowerpackWidgetSunburstDefinitionRequestNetworkQueryArgs' network_query: The query to use for this widget.
        :param 'PowerpackWidgetSunburstDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'PowerpackWidgetSunburstDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'PowerpackWidgetSunburstDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'PowerpackWidgetSunburstDefinitionRequestStyleArgs' style: Define style for the widget's request.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if audit_query is not None:
            pulumi.set(__self__, "audit_query", audit_query)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if network_query is not None:
            pulumi.set(__self__, "network_query", network_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestAuditQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "network_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestStyle']:
        """
        Define style for the widget's request.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetSunburstDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetSunburstDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetSunburstDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestAuditQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestAuditQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestAuditQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestAuditQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestAuditQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestAuditQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetSunburstDefinitionRequestAuditQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetSunburstDefinitionRequestAuditQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestAuditQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestAuditQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestAuditQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestAuditQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestAuditQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'PowerpackWidgetSunburstDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'PowerpackWidgetSunburstDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetSunburstDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetSunburstDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetSunburstDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestNetworkQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestNetworkQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestNetworkQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestNetworkQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetSunburstDefinitionRequestNetworkQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetSunburstDefinitionRequestNetworkQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestNetworkQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestNetworkQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestNetworkQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'PowerpackWidgetSunburstDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'PowerpackWidgetSunburstDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'PowerpackWidgetSunburstDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'PowerpackWidgetSunburstDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'PowerpackWidgetSunburstDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetSunburstDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetSunburstDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetSunburstDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetSunburstDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetSunburstDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetSunburstDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "legendColumns":
            suggest = "legend_columns"
        elif key == "legendLayout":
            suggest = "legend_layout"
        elif key == "legendSize":
            suggest = "legend_size"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "rightYaxis":
            suggest = "right_yaxis"
        elif key == "showLegend":
            suggest = "show_legend"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionCustomLink']] = None,
                 events: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionEvent']] = None,
                 legend_columns: Optional[Sequence[str]] = None,
                 legend_layout: Optional[str] = None,
                 legend_size: Optional[str] = None,
                 live_span: Optional[str] = None,
                 markers: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionMarker']] = None,
                 requests: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequest']] = None,
                 right_yaxis: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRightYaxis'] = None,
                 show_legend: Optional[bool] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None,
                 yaxis: Optional['outputs.PowerpackWidgetTimeseriesDefinitionYaxis'] = None):
        """
        :param Sequence['PowerpackWidgetTimeseriesDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionEventArgs'] events: The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        :param Sequence[str] legend_columns: A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
        :param str legend_layout: The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
        :param str legend_size: The size of the legend displayed in the widget.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionMarkerArgs'] markers: A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tile_def` block.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `network_query`, `security_query` or `process_query` is required within the `request` block).
        :param 'PowerpackWidgetTimeseriesDefinitionRightYaxisArgs' right_yaxis: A nested block describing the right Y-Axis Controls. See the `on_right_yaxis` property for which request will use this axis. The structure of this block is described below.
        :param bool show_legend: Whether or not to show the legend on this widget.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        :param 'PowerpackWidgetTimeseriesDefinitionYaxisArgs' yaxis: A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if events is not None:
            pulumi.set(__self__, "events", events)
        if legend_columns is not None:
            pulumi.set(__self__, "legend_columns", legend_columns)
        if legend_layout is not None:
            pulumi.set(__self__, "legend_layout", legend_layout)
        if legend_size is not None:
            pulumi.set(__self__, "legend_size", legend_size)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if markers is not None:
            pulumi.set(__self__, "markers", markers)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if right_yaxis is not None:
            pulumi.set(__self__, "right_yaxis", right_yaxis)
        if show_legend is not None:
            pulumi.set(__self__, "show_legend", show_legend)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)
        if yaxis is not None:
            pulumi.set(__self__, "yaxis", yaxis)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def events(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionEvent']]:
        """
        The definition of the event to overlay on the graph. Multiple `event` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter(name="legendColumns")
    def legend_columns(self) -> Optional[Sequence[str]]:
        """
        A list of columns to display in the legend. Valid values are `value`, `avg`, `sum`, `min`, `max`.
        """
        return pulumi.get(self, "legend_columns")

    @property
    @pulumi.getter(name="legendLayout")
    def legend_layout(self) -> Optional[str]:
        """
        The layout of the legend displayed in the widget. Valid values are `auto`, `horizontal`, `vertical`.
        """
        return pulumi.get(self, "legend_layout")

    @property
    @pulumi.getter(name="legendSize")
    def legend_size(self) -> Optional[str]:
        """
        The size of the legend displayed in the widget.
        """
        return pulumi.get(self, "legend_size")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def markers(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionMarker']]:
        """
        A nested block describing the marker to use when displaying the widget. The structure of this block is described below. Multiple `marker` blocks are allowed within a given `tile_def` block.
        """
        return pulumi.get(self, "markers")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `network_query`, `security_query` or `process_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter(name="rightYaxis")
    def right_yaxis(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRightYaxis']:
        """
        A nested block describing the right Y-Axis Controls. See the `on_right_yaxis` property for which request will use this axis. The structure of this block is described below.
        """
        return pulumi.get(self, "right_yaxis")

    @property
    @pulumi.getter(name="showLegend")
    def show_legend(self) -> Optional[bool]:
        """
        Whether or not to show the legend on this widget.
        """
        return pulumi.get(self, "show_legend")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")

    @property
    @pulumi.getter
    def yaxis(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionYaxis']:
        """
        A nested block describing the Y-Axis Controls. The structure of this block is described below.
        """
        return pulumi.get(self, "yaxis")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionEvent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagsExecution":
            suggest = "tags_execution"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionEvent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionEvent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionEvent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 q: str,
                 tags_execution: Optional[str] = None):
        """
        :param str q: The event query to use in the widget.
        :param str tags_execution: The execution method for multi-value filters.
        """
        pulumi.set(__self__, "q", q)
        if tags_execution is not None:
            pulumi.set(__self__, "tags_execution", tags_execution)

    @property
    @pulumi.getter
    def q(self) -> str:
        """
        The event query to use in the widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter(name="tagsExecution")
    def tags_execution(self) -> Optional[str]:
        """
        The execution method for multi-value filters.
        """
        return pulumi.get(self, "tags_execution")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionMarker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayType":
            suggest = "display_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionMarker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionMarker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionMarker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: str,
                 display_type: Optional[str] = None,
                 label: Optional[str] = None):
        """
        :param str value: A mathematical expression describing the marker, for example: `y > 1`, `-5 < y < 0`, `y = 19`.
        :param str display_type: How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
        :param str label: A label for the line or range.
        """
        pulumi.set(__self__, "value", value)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        A mathematical expression describing the marker, for example: `y > 1`, `-5 < y < 0`, `y = 19`.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[str]:
        """
        How the marker lines are displayed, options are one of {`error`, `warning`, `info`, `ok`} combined with one of {`dashed`, `solid`, `bold`}. Example: `error dashed`.
        """
        return pulumi.get(self, "display_type")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        A label for the line or range.
        """
        return pulumi.get(self, "label")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "auditQuery":
            suggest = "audit_query"
        elif key == "displayType":
            suggest = "display_type"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "networkQuery":
            suggest = "network_query"
        elif key == "onRightYaxis":
            suggest = "on_right_yaxis"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQuery'] = None,
                 audit_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQuery'] = None,
                 display_type: Optional[str] = None,
                 formulas: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQuery'] = None,
                 metadatas: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestMetadata']] = None,
                 network_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQuery'] = None,
                 on_right_yaxis: Optional[bool] = None,
                 process_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestStyle'] = None):
        """
        :param 'PowerpackWidgetTimeseriesDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestAuditQueryArgs' audit_query: The query to use for this widget.
        :param str display_type: How to display the marker lines. Valid values are `area`, `bars`, `line`, `overlay`.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionRequestMetadataArgs'] metadatas: Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryArgs' network_query: The query to use for this widget.
        :param bool on_right_yaxis: A Boolean indicating whether the request uses the right or left Y-Axis.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestStyleArgs' style: The style of the widget graph. Exactly one `style` block is allowed using the structure below.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if audit_query is not None:
            pulumi.set(__self__, "audit_query", audit_query)
        if display_type is not None:
            pulumi.set(__self__, "display_type", display_type)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if metadatas is not None:
            pulumi.set(__self__, "metadatas", metadatas)
        if network_query is not None:
            pulumi.set(__self__, "network_query", network_query)
        if on_right_yaxis is not None:
            pulumi.set(__self__, "on_right_yaxis", on_right_yaxis)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @property
    @pulumi.getter(name="displayType")
    def display_type(self) -> Optional[str]:
        """
        How to display the marker lines. Valid values are `area`, `bars`, `line`, `overlay`.
        """
        return pulumi.get(self, "display_type")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter
    def metadatas(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestMetadata']]:
        """
        Used to define expression aliases. Multiple `metadata` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "metadatas")

    @property
    @pulumi.getter(name="networkQuery")
    def network_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "network_query")

    @property
    @pulumi.getter(name="onRightYaxis")
    def on_right_yaxis(self) -> Optional[bool]:
        """
        A Boolean indicating whether the request uses the right or left Y-Axis.
        """
        return pulumi.get(self, "on_right_yaxis")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestStyle']:
        """
        The style of the widget graph. Exactly one `style` block is allowed using the structure below.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestAuditQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestAuditQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestAuditQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestAuditQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestAuditQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionRequestAuditQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestAuditQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestAuditQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestAuditQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aliasName":
            suggest = "alias_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expression: str,
                 alias_name: Optional[str] = None):
        """
        :param str expression: The expression name.
        :param str alias_name: The expression alias.
        """
        pulumi.set(__self__, "expression", expression)
        if alias_name is not None:
            pulumi.set(__self__, "alias_name", alias_name)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The expression name.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter(name="aliasName")
    def alias_name(self) -> Optional[str]:
        """
        The expression alias.
        """
        return pulumi.get(self, "alias_name")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestNetworkQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestNetworkQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestNetworkQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestNetworkQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestNetworkQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRequestStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lineType":
            suggest = "line_type"
        elif key == "lineWidth":
            suggest = "line_width"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRequestStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRequestStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 line_type: Optional[str] = None,
                 line_width: Optional[str] = None,
                 palette: Optional[str] = None):
        """
        :param str line_type: The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
        :param str line_width: The width of line displayed. Valid values are `normal`, `thick`, `thin`.
        :param str palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if line_type is not None:
            pulumi.set(__self__, "line_type", line_type)
        if line_width is not None:
            pulumi.set(__self__, "line_width", line_width)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter(name="lineType")
    def line_type(self) -> Optional[str]:
        """
        The type of lines displayed. Valid values are `dashed`, `dotted`, `solid`.
        """
        return pulumi.get(self, "line_type")

    @property
    @pulumi.getter(name="lineWidth")
    def line_width(self) -> Optional[str]:
        """
        The width of line displayed. Valid values are `normal`, `thick`, `thin`.
        """
        return pulumi.get(self, "line_width")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionRightYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionRightYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionRightYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionRightYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class PowerpackWidgetTimeseriesDefinitionYaxis(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeZero":
            suggest = "include_zero"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTimeseriesDefinitionYaxis. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTimeseriesDefinitionYaxis.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTimeseriesDefinitionYaxis.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 include_zero: Optional[bool] = None,
                 label: Optional[str] = None,
                 max: Optional[str] = None,
                 min: Optional[str] = None,
                 scale: Optional[str] = None):
        """
        :param bool include_zero: Always include zero or fit the axis to the data range.
        :param str label: The label of the axis to display on the graph.
        :param str max: Specify the maximum value to show on the Y-axis.
        :param str min: Specify the minimum value to show on the Y-axis.
        :param str scale: Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        if include_zero is not None:
            pulumi.set(__self__, "include_zero", include_zero)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter(name="includeZero")
    def include_zero(self) -> Optional[bool]:
        """
        Always include zero or fit the axis to the data range.
        """
        return pulumi.get(self, "include_zero")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label of the axis to display on the graph.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def max(self) -> Optional[str]:
        """
        Specify the maximum value to show on the Y-axis.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[str]:
        """
        Specify the minimum value to show on the Y-axis.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def scale(self) -> Optional[str]:
        """
        Specify the scale type, options: `linear`, `log`, `pow`, `sqrt`.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class PowerpackWidgetToplistDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionCustomLink']] = None,
                 live_span: Optional[str] = None,
                 requests: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequest']] = None,
                 styles: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionStyle']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetToplistDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param Sequence['PowerpackWidgetToplistDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
        :param Sequence['PowerpackWidgetToplistDefinitionStyleArgs'] styles: The style of the widget
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if styles is not None:
            pulumi.set(__self__, "styles", styles)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple `request` blocks are allowed using the structure below (exactly one of `q`, `apm_query`, `log_query`, `rum_query`, `security_query` or `process_query` is required within the `request` block).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def styles(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionStyle']]:
        """
        The style of the widget
        """
        return pulumi.get(self, "styles")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmQuery":
            suggest = "apm_query"
        elif key == "auditQuery":
            suggest = "audit_query"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"
        elif key == "logQuery":
            suggest = "log_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "rumQuery":
            suggest = "rum_query"
        elif key == "securityQuery":
            suggest = "security_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestApmQuery'] = None,
                 audit_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestAuditQuery'] = None,
                 conditional_formats: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestConditionalFormat']] = None,
                 formulas: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestFormula']] = None,
                 log_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestLogQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestProcessQuery'] = None,
                 q: Optional[str] = None,
                 queries: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestQuery']] = None,
                 rum_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestRumQuery'] = None,
                 security_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestSecurityQuery'] = None,
                 style: Optional['outputs.PowerpackWidgetToplistDefinitionRequestStyle'] = None):
        """
        :param 'PowerpackWidgetToplistDefinitionRequestApmQueryArgs' apm_query: The query to use for this widget.
        :param 'PowerpackWidgetToplistDefinitionRequestAuditQueryArgs' audit_query: The query to use for this widget.
        :param Sequence['PowerpackWidgetToplistDefinitionRequestConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'PowerpackWidgetToplistDefinitionRequestLogQueryArgs' log_query: The query to use for this widget.
        :param 'PowerpackWidgetToplistDefinitionRequestProcessQueryArgs' process_query: The process query to use in the widget. The structure of this block is described below.
        :param str q: The metric query to use for this widget.
        :param 'PowerpackWidgetToplistDefinitionRequestRumQueryArgs' rum_query: The query to use for this widget.
        :param 'PowerpackWidgetToplistDefinitionRequestSecurityQueryArgs' security_query: The query to use for this widget.
        :param 'PowerpackWidgetToplistDefinitionRequestStyleArgs' style: Define request for the widget's style.
        """
        if apm_query is not None:
            pulumi.set(__self__, "apm_query", apm_query)
        if audit_query is not None:
            pulumi.set(__self__, "audit_query", audit_query)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if log_query is not None:
            pulumi.set(__self__, "log_query", log_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if q is not None:
            pulumi.set(__self__, "q", q)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if rum_query is not None:
            pulumi.set(__self__, "rum_query", rum_query)
        if security_query is not None:
            pulumi.set(__self__, "security_query", security_query)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="apmQuery")
    def apm_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestApmQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "apm_query")

    @property
    @pulumi.getter(name="auditQuery")
    def audit_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestAuditQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "audit_query")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background, depending on a rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter(name="logQuery")
    def log_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestLogQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "log_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestProcessQuery']:
        """
        The process query to use in the widget. The structure of this block is described below.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter
    def q(self) -> Optional[str]:
        """
        The metric query to use for this widget.
        """
        return pulumi.get(self, "q")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="rumQuery")
    def rum_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestRumQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "rum_query")

    @property
    @pulumi.getter(name="securityQuery")
    def security_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestSecurityQuery']:
        """
        The query to use for this widget.
        """
        return pulumi.get(self, "security_query")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestStyle']:
        """
        Define request for the widget's style.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestApmQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestApmQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestApmQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestApmQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestApmQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestApmQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestApmQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetToplistDefinitionRequestApmQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetToplistDefinitionRequestApmQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetToplistDefinitionRequestApmQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestApmQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestApmQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestApmQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestApmQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestApmQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestApmQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestApmQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestApmQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetToplistDefinitionRequestApmQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestApmQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestApmQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestApmQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestAuditQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestAuditQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestAuditQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestAuditQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestAuditQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestAuditQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetToplistDefinitionRequestAuditQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetToplistDefinitionRequestAuditQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetToplistDefinitionRequestAuditQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestAuditQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestAuditQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestAuditQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestAuditQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestAuditQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.PowerpackWidgetToplistDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.PowerpackWidgetToplistDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'PowerpackWidgetToplistDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'PowerpackWidgetToplistDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestLogQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestLogQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestLogQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestLogQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestLogQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestLogQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestLogQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetToplistDefinitionRequestLogQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetToplistDefinitionRequestLogQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetToplistDefinitionRequestLogQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestLogQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestLogQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestLogQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestLogQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestLogQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestLogQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestLogQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestLogQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetToplistDefinitionRequestLogQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestLogQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestLogQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestLogQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterBies":
            suggest = "filter_bies"
        elif key == "searchBy":
            suggest = "search_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric: str,
                 filter_bies: Optional[Sequence[str]] = None,
                 limit: Optional[int] = None,
                 search_by: Optional[str] = None):
        """
        :param str metric: Your chosen metric.
        :param Sequence[str] filter_bies: A list of processes.
        :param int limit: The max number of items in the filter list.
        :param str search_by: Your chosen search term.
        """
        pulumi.set(__self__, "metric", metric)
        if filter_bies is not None:
            pulumi.set(__self__, "filter_bies", filter_bies)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if search_by is not None:
            pulumi.set(__self__, "search_by", search_by)

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        Your chosen metric.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="filterBies")
    def filter_bies(self) -> Optional[Sequence[str]]:
        """
        A list of processes.
        """
        return pulumi.get(self, "filter_bies")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The max number of items in the filter list.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="searchBy")
    def search_by(self) -> Optional[str]:
        """
        Your chosen search term.
        """
        return pulumi.get(self, "search_by")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'PowerpackWidgetToplistDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'PowerpackWidgetToplistDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'PowerpackWidgetToplistDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'PowerpackWidgetToplistDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'PowerpackWidgetToplistDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetToplistDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'PowerpackWidgetToplistDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestRumQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestRumQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestRumQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestRumQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestRumQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestRumQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestRumQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetToplistDefinitionRequestRumQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetToplistDefinitionRequestRumQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetToplistDefinitionRequestRumQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestRumQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestRumQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestRumQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestRumQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestRumQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestRumQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestRumQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestRumQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetToplistDefinitionRequestRumQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestRumQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestRumQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestRumQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestSecurityQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "computeQuery":
            suggest = "compute_query"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "multiComputes":
            suggest = "multi_computes"
        elif key == "searchQuery":
            suggest = "search_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestSecurityQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestSecurityQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestSecurityQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 index: str,
                 compute_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestSecurityQueryComputeQuery'] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBy']] = None,
                 multi_computes: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestSecurityQueryMultiCompute']] = None,
                 search_query: Optional[str] = None):
        """
        :param str index: The name of the index to query.
        :param 'PowerpackWidgetToplistDefinitionRequestSecurityQueryComputeQueryArgs' compute_query: `compute_query` or `multi_compute` is required. The map keys are listed below.
        :param Sequence['PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupByArgs'] group_bies: Multiple `group_by` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetToplistDefinitionRequestSecurityQueryMultiComputeArgs'] multi_computes: `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        :param str search_query: The search query to use.
        """
        pulumi.set(__self__, "index", index)
        if compute_query is not None:
            pulumi.set(__self__, "compute_query", compute_query)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if multi_computes is not None:
            pulumi.set(__self__, "multi_computes", multi_computes)
        if search_query is not None:
            pulumi.set(__self__, "search_query", search_query)

    @property
    @pulumi.getter
    def index(self) -> str:
        """
        The name of the index to query.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter(name="computeQuery")
    def compute_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestSecurityQueryComputeQuery']:
        """
        `compute_query` or `multi_compute` is required. The map keys are listed below.
        """
        return pulumi.get(self, "compute_query")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBy']]:
        """
        Multiple `group_by` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="multiComputes")
    def multi_computes(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionRequestSecurityQueryMultiCompute']]:
        """
        `compute_query` or `multi_compute` is required. Multiple `multi_compute` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "multi_computes")

    @property
    @pulumi.getter(name="searchQuery")
    def search_query(self) -> Optional[str]:
        """
        The search query to use.
        """
        return pulumi.get(self, "search_query")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestSecurityQueryComputeQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sortQuery":
            suggest = "sort_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet: Optional[str] = None,
                 limit: Optional[int] = None,
                 sort_query: Optional['outputs.PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery'] = None):
        """
        :param str facet: The facet name.
        :param int limit: The maximum number of items in the group.
        :param 'PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBySortQueryArgs' sort_query: A list of exactly one element describing the sort query to use.
        """
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort_query is not None:
            pulumi.set(__self__, "sort_query", sort_query)

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The maximum number of items in the group.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter(name="sortQuery")
    def sort_query(self) -> Optional['outputs.PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery']:
        """
        A list of exactly one element describing the sort query to use.
        """
        return pulumi.get(self, "sort_query")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestSecurityQueryGroupBySortQuery(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 order: str,
                 facet: Optional[str] = None):
        """
        :param str aggregation: The aggregation method.
        :param str order: Widget sorting methods. Valid values are `asc`, `desc`.
        :param str facet: The facet name.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        pulumi.set(__self__, "order", order)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def order(self) -> str:
        """
        Widget sorting methods. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestSecurityQueryMultiCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 facet: Optional[str] = None,
                 interval: Optional[int] = None):
        """
        :param str aggregation: The aggregation method.
        :param str facet: The facet name.
        :param int interval: Define the time interval in seconds.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if facet is not None:
            pulumi.set(__self__, "facet", facet)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation method.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def facet(self) -> Optional[str]:
        """
        The facet name.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Define the time interval in seconds.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionRequestStyle(dict):
    def __init__(__self__, *,
                 palette: Optional[str] = None):
        """
        :param str palette: A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        A color palette to apply to the widget. The available options are available at: https://docs.datadoghq.com/dashboards/widgets/timeseries/#appearance.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionStyle(dict):
    def __init__(__self__, *,
                 displays: Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionStyleDisplay']] = None,
                 palette: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetToplistDefinitionStyleDisplayArgs'] displays: The display mode for the widget.
        :param str palette: The color palette for the widget.
        """
        if displays is not None:
            pulumi.set(__self__, "displays", displays)
        if palette is not None:
            pulumi.set(__self__, "palette", palette)

    @property
    @pulumi.getter
    def displays(self) -> Optional[Sequence['outputs.PowerpackWidgetToplistDefinitionStyleDisplay']]:
        """
        The display mode for the widget.
        """
        return pulumi.get(self, "displays")

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette for the widget.
        """
        return pulumi.get(self, "palette")


@pulumi.output_type
class PowerpackWidgetToplistDefinitionStyleDisplay(dict):
    def __init__(__self__, *,
                 type: str):
        """
        :param str type: The display type for the widget.
        """
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The display type for the widget.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PowerpackWidgetTopologyMapDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customLinks":
            suggest = "custom_links"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTopologyMapDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTopologyMapDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTopologyMapDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_links: Optional[Sequence['outputs.PowerpackWidgetTopologyMapDefinitionCustomLink']] = None,
                 requests: Optional[Sequence['outputs.PowerpackWidgetTopologyMapDefinitionRequest']] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetTopologyMapDefinitionCustomLinkArgs'] custom_links: A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        :param Sequence['PowerpackWidgetTopologyMapDefinitionRequestArgs'] requests: A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (`query` and `request_type` are required within the request).
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        if custom_links is not None:
            pulumi.set(__self__, "custom_links", custom_links)
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter(name="customLinks")
    def custom_links(self) -> Optional[Sequence['outputs.PowerpackWidgetTopologyMapDefinitionCustomLink']]:
        """
        A nested block describing a custom link. Multiple `custom_link` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "custom_links")

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.PowerpackWidgetTopologyMapDefinitionRequest']]:
        """
        A nested block describing the request to use when displaying the widget. Multiple request blocks are allowed using the structure below (`query` and `request_type` are required within the request).
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetTopologyMapDefinitionCustomLink(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isHidden":
            suggest = "is_hidden"
        elif key == "overrideLabel":
            suggest = "override_label"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTopologyMapDefinitionCustomLink. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTopologyMapDefinitionCustomLink.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTopologyMapDefinitionCustomLink.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_hidden: Optional[bool] = None,
                 label: Optional[str] = None,
                 link: Optional[str] = None,
                 override_label: Optional[str] = None):
        """
        :param bool is_hidden: The flag for toggling context menu link visibility.
        :param str label: The label for the custom link URL.
        :param str link: The URL of the custom link.
        :param str override_label: The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        if is_hidden is not None:
            pulumi.set(__self__, "is_hidden", is_hidden)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)
        if override_label is not None:
            pulumi.set(__self__, "override_label", override_label)

    @property
    @pulumi.getter(name="isHidden")
    def is_hidden(self) -> Optional[bool]:
        """
        The flag for toggling context menu link visibility.
        """
        return pulumi.get(self, "is_hidden")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        The label for the custom link URL.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[str]:
        """
        The URL of the custom link.
        """
        return pulumi.get(self, "link")

    @property
    @pulumi.getter(name="overrideLabel")
    def override_label(self) -> Optional[str]:
        """
        The label ID that refers to a context menu link item. When `override_label` is provided, the client request omits the label field.
        """
        return pulumi.get(self, "override_label")


@pulumi.output_type
class PowerpackWidgetTopologyMapDefinitionRequest(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestType":
            suggest = "request_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTopologyMapDefinitionRequest. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTopologyMapDefinitionRequest.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTopologyMapDefinitionRequest.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queries: Sequence['outputs.PowerpackWidgetTopologyMapDefinitionRequestQuery'],
                 request_type: str):
        """
        :param Sequence['PowerpackWidgetTopologyMapDefinitionRequestQueryArgs'] queries: The query for a Topology request.
        :param str request_type: The request type for the Topology request ('topology'). Valid values are `topology`.
        """
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "request_type", request_type)

    @property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.PowerpackWidgetTopologyMapDefinitionRequestQuery']:
        """
        The query for a Topology request.
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="requestType")
    def request_type(self) -> str:
        """
        The request type for the Topology request ('topology'). Valid values are `topology`.
        """
        return pulumi.get(self, "request_type")


@pulumi.output_type
class PowerpackWidgetTopologyMapDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTopologyMapDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTopologyMapDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTopologyMapDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 filters: Sequence[str],
                 service: str):
        """
        :param str data_source: The data source for the Topology request ('service*map' or 'data*streams'). Valid values are `data_streams`, `service_map`.
        :param Sequence[str] filters: Your environment and primary tag (or `*` if enabled for your account).
        :param str service: The ID of the service to map.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "service", service)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for the Topology request ('service*map' or 'data*streams'). Valid values are `data_streams`, `service_map`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def filters(self) -> Sequence[str]:
        """
        Your environment and primary tag (or `*` if enabled for your account).
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        The ID of the service to map.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class PowerpackWidgetTraceServiceDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "spanName":
            suggest = "span_name"
        elif key == "displayFormat":
            suggest = "display_format"
        elif key == "liveSpan":
            suggest = "live_span"
        elif key == "showBreakdown":
            suggest = "show_breakdown"
        elif key == "showDistribution":
            suggest = "show_distribution"
        elif key == "showErrors":
            suggest = "show_errors"
        elif key == "showHits":
            suggest = "show_hits"
        elif key == "showLatency":
            suggest = "show_latency"
        elif key == "showResourceList":
            suggest = "show_resource_list"
        elif key == "sizeFormat":
            suggest = "size_format"
        elif key == "titleAlign":
            suggest = "title_align"
        elif key == "titleSize":
            suggest = "title_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTraceServiceDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTraceServiceDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTraceServiceDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 env: str,
                 service: str,
                 span_name: str,
                 display_format: Optional[str] = None,
                 live_span: Optional[str] = None,
                 show_breakdown: Optional[bool] = None,
                 show_distribution: Optional[bool] = None,
                 show_errors: Optional[bool] = None,
                 show_hits: Optional[bool] = None,
                 show_latency: Optional[bool] = None,
                 show_resource_list: Optional[bool] = None,
                 size_format: Optional[str] = None,
                 title: Optional[str] = None,
                 title_align: Optional[str] = None,
                 title_size: Optional[str] = None):
        """
        :param str env: APM environment.
        :param str service: APM service.
        :param str span_name: APM span name
        :param str display_format: The number of columns to display. Valid values are `one_column`, `two_column`, `three_column`.
        :param str live_span: The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        :param bool show_breakdown: Whether to show the latency breakdown or not.
        :param bool show_distribution: Whether to show the latency distribution or not.
        :param bool show_errors: Whether to show the error metrics or not.
        :param bool show_hits: Whether to show the hits metrics or not
        :param bool show_latency: Whether to show the latency metrics or not.
        :param bool show_resource_list: Whether to show the resource list or not.
        :param str size_format: The size of the widget. Valid values are `small`, `medium`, `large`.
        :param str title: The title of the widget.
        :param str title_align: The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        :param str title_size: The size of the widget's title (defaults to 16).
        """
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "span_name", span_name)
        if display_format is not None:
            pulumi.set(__self__, "display_format", display_format)
        if live_span is not None:
            pulumi.set(__self__, "live_span", live_span)
        if show_breakdown is not None:
            pulumi.set(__self__, "show_breakdown", show_breakdown)
        if show_distribution is not None:
            pulumi.set(__self__, "show_distribution", show_distribution)
        if show_errors is not None:
            pulumi.set(__self__, "show_errors", show_errors)
        if show_hits is not None:
            pulumi.set(__self__, "show_hits", show_hits)
        if show_latency is not None:
            pulumi.set(__self__, "show_latency", show_latency)
        if show_resource_list is not None:
            pulumi.set(__self__, "show_resource_list", show_resource_list)
        if size_format is not None:
            pulumi.set(__self__, "size_format", size_format)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if title_align is not None:
            pulumi.set(__self__, "title_align", title_align)
        if title_size is not None:
            pulumi.set(__self__, "title_size", title_size)

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="spanName")
    def span_name(self) -> str:
        """
        APM span name
        """
        return pulumi.get(self, "span_name")

    @property
    @pulumi.getter(name="displayFormat")
    def display_format(self) -> Optional[str]:
        """
        The number of columns to display. Valid values are `one_column`, `two_column`, `three_column`.
        """
        return pulumi.get(self, "display_format")

    @property
    @pulumi.getter(name="liveSpan")
    def live_span(self) -> Optional[str]:
        """
        The timeframe to use when displaying the widget. Valid values are `1m`, `5m`, `10m`, `15m`, `30m`, `1h`, `4h`, `1d`, `2d`, `1w`, `1mo`, `3mo`, `6mo`, `week_to_date`, `month_to_date`, `1y`, `alert`.
        """
        return pulumi.get(self, "live_span")

    @property
    @pulumi.getter(name="showBreakdown")
    def show_breakdown(self) -> Optional[bool]:
        """
        Whether to show the latency breakdown or not.
        """
        return pulumi.get(self, "show_breakdown")

    @property
    @pulumi.getter(name="showDistribution")
    def show_distribution(self) -> Optional[bool]:
        """
        Whether to show the latency distribution or not.
        """
        return pulumi.get(self, "show_distribution")

    @property
    @pulumi.getter(name="showErrors")
    def show_errors(self) -> Optional[bool]:
        """
        Whether to show the error metrics or not.
        """
        return pulumi.get(self, "show_errors")

    @property
    @pulumi.getter(name="showHits")
    def show_hits(self) -> Optional[bool]:
        """
        Whether to show the hits metrics or not
        """
        return pulumi.get(self, "show_hits")

    @property
    @pulumi.getter(name="showLatency")
    def show_latency(self) -> Optional[bool]:
        """
        Whether to show the latency metrics or not.
        """
        return pulumi.get(self, "show_latency")

    @property
    @pulumi.getter(name="showResourceList")
    def show_resource_list(self) -> Optional[bool]:
        """
        Whether to show the resource list or not.
        """
        return pulumi.get(self, "show_resource_list")

    @property
    @pulumi.getter(name="sizeFormat")
    def size_format(self) -> Optional[str]:
        """
        The size of the widget. Valid values are `small`, `medium`, `large`.
        """
        return pulumi.get(self, "size_format")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="titleAlign")
    def title_align(self) -> Optional[str]:
        """
        The alignment of the widget's title. Valid values are `center`, `left`, `right`.
        """
        return pulumi.get(self, "title_align")

    @property
    @pulumi.getter(name="titleSize")
    def title_size(self) -> Optional[str]:
        """
        The size of the widget's title (defaults to 16).
        """
        return pulumi.get(self, "title_size")


@pulumi.output_type
class PowerpackWidgetTreemapDefinition(dict):
    def __init__(__self__, *,
                 requests: Optional[Sequence['outputs.PowerpackWidgetTreemapDefinitionRequest']] = None,
                 title: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetTreemapDefinitionRequestArgs'] requests: Nested block describing the request to use when displaying the widget.
        :param str title: The title of the widget.
        """
        if requests is not None:
            pulumi.set(__self__, "requests", requests)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def requests(self) -> Optional[Sequence['outputs.PowerpackWidgetTreemapDefinitionRequest']]:
        """
        Nested block describing the request to use when displaying the widget.
        """
        return pulumi.get(self, "requests")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        The title of the widget.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class PowerpackWidgetTreemapDefinitionRequest(dict):
    def __init__(__self__, *,
                 formulas: Optional[Sequence['outputs.PowerpackWidgetTreemapDefinitionRequestFormula']] = None,
                 queries: Optional[Sequence['outputs.PowerpackWidgetTreemapDefinitionRequestQuery']] = None):
        if formulas is not None:
            pulumi.set(__self__, "formulas", formulas)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def formulas(self) -> Optional[Sequence['outputs.PowerpackWidgetTreemapDefinitionRequestFormula']]:
        return pulumi.get(self, "formulas")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.PowerpackWidgetTreemapDefinitionRequestQuery']]:
        return pulumi.get(self, "queries")


@pulumi.output_type
class PowerpackWidgetTreemapDefinitionRequestFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"
        elif key == "cellDisplayMode":
            suggest = "cell_display_mode"
        elif key == "conditionalFormats":
            suggest = "conditional_formats"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTreemapDefinitionRequestFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTreemapDefinitionRequestFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTreemapDefinitionRequestFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str,
                 alias: Optional[str] = None,
                 cell_display_mode: Optional[str] = None,
                 conditional_formats: Optional[Sequence['outputs.PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormat']] = None,
                 limit: Optional['outputs.PowerpackWidgetTreemapDefinitionRequestFormulaLimit'] = None,
                 style: Optional['outputs.PowerpackWidgetTreemapDefinitionRequestFormulaStyle'] = None):
        """
        :param str formula_expression: A string expression built from queries, formulas, and functions.
        :param str alias: An expression alias.
        :param str cell_display_mode: A list of display modes for each table cell. Valid values are `number`, `bar`.
        :param Sequence['PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormatArgs'] conditional_formats: Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        :param 'PowerpackWidgetTreemapDefinitionRequestFormulaLimitArgs' limit: The options for limiting results returned.
        :param 'PowerpackWidgetTreemapDefinitionRequestFormulaStyleArgs' style: Styling options for widget formulas.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)
        if alias is not None:
            pulumi.set(__self__, "alias", alias)
        if cell_display_mode is not None:
            pulumi.set(__self__, "cell_display_mode", cell_display_mode)
        if conditional_formats is not None:
            pulumi.set(__self__, "conditional_formats", conditional_formats)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if style is not None:
            pulumi.set(__self__, "style", style)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        A string expression built from queries, formulas, and functions.
        """
        return pulumi.get(self, "formula_expression")

    @property
    @pulumi.getter
    def alias(self) -> Optional[str]:
        """
        An expression alias.
        """
        return pulumi.get(self, "alias")

    @property
    @pulumi.getter(name="cellDisplayMode")
    def cell_display_mode(self) -> Optional[str]:
        """
        A list of display modes for each table cell. Valid values are `number`, `bar`.
        """
        return pulumi.get(self, "cell_display_mode")

    @property
    @pulumi.getter(name="conditionalFormats")
    def conditional_formats(self) -> Optional[Sequence['outputs.PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormat']]:
        """
        Conditional formats allow you to set the color of your widget content or background depending on the rule applied to your data. Multiple `conditional_formats` blocks are allowed using the structure below.
        """
        return pulumi.get(self, "conditional_formats")

    @property
    @pulumi.getter
    def limit(self) -> Optional['outputs.PowerpackWidgetTreemapDefinitionRequestFormulaLimit']:
        """
        The options for limiting results returned.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def style(self) -> Optional['outputs.PowerpackWidgetTreemapDefinitionRequestFormulaStyle']:
        """
        Styling options for widget formulas.
        """
        return pulumi.get(self, "style")


@pulumi.output_type
class PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customBgColor":
            suggest = "custom_bg_color"
        elif key == "customFgColor":
            suggest = "custom_fg_color"
        elif key == "hideValue":
            suggest = "hide_value"
        elif key == "imageUrl":
            suggest = "image_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTreemapDefinitionRequestFormulaConditionalFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 palette: str,
                 value: float,
                 custom_bg_color: Optional[str] = None,
                 custom_fg_color: Optional[str] = None,
                 hide_value: Optional[bool] = None,
                 image_url: Optional[str] = None,
                 metric: Optional[str] = None,
                 timeframe: Optional[str] = None):
        """
        :param str comparator: The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        :param str palette: The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        :param float value: A value for the comparator.
        :param str custom_bg_color: The color palette to apply to the background, same values available as palette.
        :param str custom_fg_color: The color palette to apply to the foreground, same values available as palette.
        :param bool hide_value: Setting this to True hides values.
        :param str image_url: Displays an image as the background.
        :param str metric: The metric from the request to correlate with this conditional format.
        :param str timeframe: Defines the displayed timeframe.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "palette", palette)
        pulumi.set(__self__, "value", value)
        if custom_bg_color is not None:
            pulumi.set(__self__, "custom_bg_color", custom_bg_color)
        if custom_fg_color is not None:
            pulumi.set(__self__, "custom_fg_color", custom_fg_color)
        if hide_value is not None:
            pulumi.set(__self__, "hide_value", hide_value)
        if image_url is not None:
            pulumi.set(__self__, "image_url", image_url)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if timeframe is not None:
            pulumi.set(__self__, "timeframe", timeframe)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator to use. Valid values are `=`, `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def palette(self) -> str:
        """
        The color palette to apply. Valid values are `blue`, `custom_bg`, `custom_image`, `custom_text`, `gray_on_white`, `grey`, `green`, `orange`, `red`, `red_on_white`, `white_on_gray`, `white_on_green`, `green_on_white`, `white_on_red`, `white_on_yellow`, `yellow_on_white`, `black_on_light_yellow`, `black_on_light_green`, `black_on_light_red`.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        A value for the comparator.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="customBgColor")
    def custom_bg_color(self) -> Optional[str]:
        """
        The color palette to apply to the background, same values available as palette.
        """
        return pulumi.get(self, "custom_bg_color")

    @property
    @pulumi.getter(name="customFgColor")
    def custom_fg_color(self) -> Optional[str]:
        """
        The color palette to apply to the foreground, same values available as palette.
        """
        return pulumi.get(self, "custom_fg_color")

    @property
    @pulumi.getter(name="hideValue")
    def hide_value(self) -> Optional[bool]:
        """
        Setting this to True hides values.
        """
        return pulumi.get(self, "hide_value")

    @property
    @pulumi.getter(name="imageUrl")
    def image_url(self) -> Optional[str]:
        """
        Displays an image as the background.
        """
        return pulumi.get(self, "image_url")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric from the request to correlate with this conditional format.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def timeframe(self) -> Optional[str]:
        """
        Defines the displayed timeframe.
        """
        return pulumi.get(self, "timeframe")


@pulumi.output_type
class PowerpackWidgetTreemapDefinitionRequestFormulaLimit(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 order: Optional[str] = None):
        """
        :param int count: The number of results to return.
        :param str order: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        The number of results to return.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetTreemapDefinitionRequestFormulaStyle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "paletteIndex":
            suggest = "palette_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTreemapDefinitionRequestFormulaStyle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTreemapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTreemapDefinitionRequestFormulaStyle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 palette: Optional[str] = None,
                 palette_index: Optional[int] = None):
        """
        :param str palette: The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        :param int palette_index: Index specifying which color to use within the palette.
        """
        if palette is not None:
            pulumi.set(__self__, "palette", palette)
        if palette_index is not None:
            pulumi.set(__self__, "palette_index", palette_index)

    @property
    @pulumi.getter
    def palette(self) -> Optional[str]:
        """
        The color palette used to display the formula. A guide to the available color palettes can be found at https://docs.datadoghq.com/dashboards/guide/widget_colors.
        """
        return pulumi.get(self, "palette")

    @property
    @pulumi.getter(name="paletteIndex")
    def palette_index(self) -> Optional[int]:
        """
        Index specifying which color to use within the palette.
        """
        return pulumi.get(self, "palette_index")


@pulumi.output_type
class PowerpackWidgetTreemapDefinitionRequestQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apmDependencyStatsQuery":
            suggest = "apm_dependency_stats_query"
        elif key == "apmResourceStatsQuery":
            suggest = "apm_resource_stats_query"
        elif key == "cloudCostQuery":
            suggest = "cloud_cost_query"
        elif key == "eventQuery":
            suggest = "event_query"
        elif key == "metricQuery":
            suggest = "metric_query"
        elif key == "processQuery":
            suggest = "process_query"
        elif key == "sloQuery":
            suggest = "slo_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTreemapDefinitionRequestQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTreemapDefinitionRequestQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTreemapDefinitionRequestQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apm_dependency_stats_query: Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery'] = None,
                 apm_resource_stats_query: Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery'] = None,
                 cloud_cost_query: Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQuery'] = None,
                 event_query: Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQuery'] = None,
                 metric_query: Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQueryMetricQuery'] = None,
                 process_query: Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQueryProcessQuery'] = None,
                 slo_query: Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQuerySloQuery'] = None):
        """
        :param 'PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQueryArgs' apm_dependency_stats_query: The APM Dependency Stats query using formulas and functions.
        :param 'PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQueryArgs' apm_resource_stats_query: The APM Resource Stats query using formulas and functions.
        :param 'PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQueryArgs' cloud_cost_query: The Cloud Cost query using formulas and functions.
        :param 'PowerpackWidgetTreemapDefinitionRequestQueryEventQueryArgs' event_query: A timeseries formula and functions events query.
        :param 'PowerpackWidgetTreemapDefinitionRequestQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        :param 'PowerpackWidgetTreemapDefinitionRequestQueryProcessQueryArgs' process_query: The process query using formulas and functions.
        :param 'PowerpackWidgetTreemapDefinitionRequestQuerySloQueryArgs' slo_query: The SLO query using formulas and functions.
        """
        if apm_dependency_stats_query is not None:
            pulumi.set(__self__, "apm_dependency_stats_query", apm_dependency_stats_query)
        if apm_resource_stats_query is not None:
            pulumi.set(__self__, "apm_resource_stats_query", apm_resource_stats_query)
        if cloud_cost_query is not None:
            pulumi.set(__self__, "cloud_cost_query", cloud_cost_query)
        if event_query is not None:
            pulumi.set(__self__, "event_query", event_query)
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)
        if process_query is not None:
            pulumi.set(__self__, "process_query", process_query)
        if slo_query is not None:
            pulumi.set(__self__, "slo_query", slo_query)

    @property
    @pulumi.getter(name="apmDependencyStatsQuery")
    def apm_dependency_stats_query(self) -> Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery']:
        """
        The APM Dependency Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_dependency_stats_query")

    @property
    @pulumi.getter(name="apmResourceStatsQuery")
    def apm_resource_stats_query(self) -> Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery']:
        """
        The APM Resource Stats query using formulas and functions.
        """
        return pulumi.get(self, "apm_resource_stats_query")

    @property
    @pulumi.getter(name="cloudCostQuery")
    def cloud_cost_query(self) -> Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQuery']:
        """
        The Cloud Cost query using formulas and functions.
        """
        return pulumi.get(self, "cloud_cost_query")

    @property
    @pulumi.getter(name="eventQuery")
    def event_query(self) -> Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQuery']:
        """
        A timeseries formula and functions events query.
        """
        return pulumi.get(self, "event_query")

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")

    @property
    @pulumi.getter(name="processQuery")
    def process_query(self) -> Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQueryProcessQuery']:
        """
        The process query using formulas and functions.
        """
        return pulumi.get(self, "process_query")

    @property
    @pulumi.getter(name="sloQuery")
    def slo_query(self) -> Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQuerySloQuery']:
        """
        The SLO query using formulas and functions.
        """
        return pulumi.get(self, "slo_query")


@pulumi.output_type
class PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "resourceName":
            suggest = "resource_name"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isUpstream":
            suggest = "is_upstream"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTreemapDefinitionRequestQueryApmDependencyStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 operation_name: str,
                 resource_name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 is_upstream: Optional[bool] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None):
        """
        :param str data_source: The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str operation_name: Name of operation on service.
        :param str resource_name: APM resource.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_upstream: Determines whether stats for upstream or downstream dependencies should be queried.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "operation_name", operation_name)
        pulumi.set(__self__, "resource_name", resource_name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_upstream is not None:
            pulumi.set(__self__, "is_upstream", is_upstream)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Dependency Stats queries. Valid values are `apm_dependency_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> str:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> str:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `avg_duration`, `avg_root_duration`, `avg_spans_per_trace`, `error_rate`, `pct_exec_time`, `pct_of_traces`, `total_traces_count`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isUpstream")
    def is_upstream(self) -> Optional[bool]:
        """
        Determines whether stats for upstream or downstream dependencies should be queried.
        """
        return pulumi.get(self, "is_upstream")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")


@pulumi.output_type
class PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"
        elif key == "operationName":
            suggest = "operation_name"
        elif key == "primaryTagName":
            suggest = "primary_tag_name"
        elif key == "primaryTagValue":
            suggest = "primary_tag_value"
        elif key == "resourceName":
            suggest = "resource_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTreemapDefinitionRequestQueryApmResourceStatsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 env: str,
                 name: str,
                 service: str,
                 stat: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence[str]] = None,
                 operation_name: Optional[str] = None,
                 primary_tag_name: Optional[str] = None,
                 primary_tag_value: Optional[str] = None,
                 resource_name: Optional[str] = None):
        """
        :param str data_source: The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        :param str env: APM environment.
        :param str name: The name of query for use in formulas.
        :param str service: APM service.
        :param str stat: APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence[str] group_bies: Array of fields to group results by.
        :param str operation_name: Name of operation on service.
        :param str primary_tag_name: The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        :param str primary_tag_value: Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        :param str resource_name: APM resource.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "env", env)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "service", service)
        pulumi.set(__self__, "stat", stat)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if operation_name is not None:
            pulumi.set(__self__, "operation_name", operation_name)
        if primary_tag_name is not None:
            pulumi.set(__self__, "primary_tag_name", primary_tag_name)
        if primary_tag_value is not None:
            pulumi.set(__self__, "primary_tag_value", primary_tag_value)
        if resource_name is not None:
            pulumi.set(__self__, "resource_name", resource_name)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for APM Resource Stats queries. Valid values are `apm_resource_stats`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def env(self) -> str:
        """
        APM environment.
        """
        return pulumi.get(self, "env")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def service(self) -> str:
        """
        APM service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter
    def stat(self) -> str:
        """
        APM statistic. Valid values are `errors`, `error_rate`, `hits`, `latency_avg`, `latency_distribution`, `latency_max`, `latency_p50`, `latency_p75`, `latency_p90`, `latency_p95`, `latency_p99`.
        """
        return pulumi.get(self, "stat")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence[str]]:
        """
        Array of fields to group results by.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter(name="operationName")
    def operation_name(self) -> Optional[str]:
        """
        Name of operation on service.
        """
        return pulumi.get(self, "operation_name")

    @property
    @pulumi.getter(name="primaryTagName")
    def primary_tag_name(self) -> Optional[str]:
        """
        The name of the second primary tag used within APM; required when `primary_tag_value` is specified. See https://docs.datadoghq.com/tracing/guide/setting*primary*tags*to*scope/#add-a-second-primary-tag-in-datadog.
        """
        return pulumi.get(self, "primary_tag_name")

    @property
    @pulumi.getter(name="primaryTagValue")
    def primary_tag_value(self) -> Optional[str]:
        """
        Filter APM data by the second primary tag. `primary_tag_name` must also be specified.
        """
        return pulumi.get(self, "primary_tag_value")

    @property
    @pulumi.getter(name="resourceName")
    def resource_name(self) -> Optional[str]:
        """
        APM resource.
        """
        return pulumi.get(self, "resource_name")


@pulumi.output_type
class PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTreemapDefinitionRequestQueryCloudCostQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None):
        """
        :param str data_source: The data source for cloud cost queries. Valid values are `cloud_cost`.
        :param str name: The name of the query for use in formulas.
        :param str query: The cloud cost query definition.
        :param str aggregator: The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for cloud cost queries. Valid values are `cloud_cost`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The cloud cost query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for cloud cost queries. Valid values are `avg`, `last`, `max`, `min`, `sum`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")


@pulumi.output_type
class PowerpackWidgetTreemapDefinitionRequestQueryEventQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupBies":
            suggest = "group_bies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTreemapDefinitionRequestQueryEventQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTreemapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTreemapDefinitionRequestQueryEventQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 computes: Sequence['outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQueryCompute'],
                 data_source: str,
                 name: str,
                 cross_org_uuids: Optional[str] = None,
                 group_bies: Optional[Sequence['outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBy']] = None,
                 indexes: Optional[Sequence[str]] = None,
                 search: Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQuerySearch'] = None,
                 storage: Optional[str] = None):
        """
        :param Sequence['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryComputeArgs'] computes: The compute options.
        :param str data_source: The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        :param str name: The name of query for use in formulas.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param Sequence['PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupByArgs'] group_bies: Group by options.
        :param Sequence[str] indexes: An array of index names to query in the stream.
        :param 'PowerpackWidgetTreemapDefinitionRequestQueryEventQuerySearchArgs' search: The search options.
        :param str storage: Storage location (private beta).
        """
        pulumi.set(__self__, "computes", computes)
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "name", name)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_bies is not None:
            pulumi.set(__self__, "group_bies", group_bies)
        if indexes is not None:
            pulumi.set(__self__, "indexes", indexes)
        if search is not None:
            pulumi.set(__self__, "search", search)
        if storage is not None:
            pulumi.set(__self__, "storage", storage)

    @property
    @pulumi.getter
    def computes(self) -> Sequence['outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQueryCompute']:
        """
        The compute options.
        """
        return pulumi.get(self, "computes")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for event platform-based queries. Valid values are `logs`, `spans`, `network`, `rum`, `security_signals`, `profiles`, `audit`, `events`, `ci_tests`, `ci_pipelines`, `incident_analytics`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupBies")
    def group_bies(self) -> Optional[Sequence['outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBy']]:
        """
        Group by options.
        """
        return pulumi.get(self, "group_bies")

    @property
    @pulumi.getter
    def indexes(self) -> Optional[Sequence[str]]:
        """
        An array of index names to query in the stream.
        """
        return pulumi.get(self, "indexes")

    @property
    @pulumi.getter
    def search(self) -> Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQuerySearch']:
        """
        The search options.
        """
        return pulumi.get(self, "search")

    @property
    @pulumi.getter
    def storage(self) -> Optional[str]:
        """
        Storage location (private beta).
        """
        return pulumi.get(self, "storage")


@pulumi.output_type
class PowerpackWidgetTreemapDefinitionRequestQueryEventQueryCompute(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 interval: Optional[int] = None,
                 metric: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param int interval: A time interval in milliseconds.
        :param str metric: The measurable attribute to compute.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        A time interval in milliseconds.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The measurable attribute to compute.
        """
        return pulumi.get(self, "metric")


@pulumi.output_type
class PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBy(dict):
    def __init__(__self__, *,
                 facet: str,
                 limit: Optional[int] = None,
                 sort: Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort'] = None):
        """
        :param str facet: The event facet.
        :param int limit: The number of groups to return.
        :param 'PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBySortArgs' sort: The options for sorting group by results.
        """
        pulumi.set(__self__, "facet", facet)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)

    @property
    @pulumi.getter
    def facet(self) -> str:
        """
        The event facet.
        """
        return pulumi.get(self, "facet")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of groups to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional['outputs.PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort']:
        """
        The options for sorting group by results.
        """
        return pulumi.get(self, "sort")


@pulumi.output_type
class PowerpackWidgetTreemapDefinitionRequestQueryEventQueryGroupBySort(dict):
    def __init__(__self__, *,
                 aggregation: str,
                 metric: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str aggregation: The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        :param str metric: The metric used for sorting group by results.
        :param str order: Direction of sort. Valid values are `asc`, `desc`.
        """
        pulumi.set(__self__, "aggregation", aggregation)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def aggregation(self) -> str:
        """
        The aggregation methods for the event platform queries. Valid values are `count`, `cardinality`, `median`, `pc75`, `pc90`, `pc95`, `pc98`, `pc99`, `sum`, `min`, `max`, `avg`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter
    def metric(self) -> Optional[str]:
        """
        The metric used for sorting group by results.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        Direction of sort. Valid values are `asc`, `desc`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class PowerpackWidgetTreemapDefinitionRequestQueryEventQuerySearch(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: The events search string.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The events search string.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class PowerpackWidgetTreemapDefinitionRequestQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTreemapDefinitionRequestQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTreemapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTreemapDefinitionRequestQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class PowerpackWidgetTreemapDefinitionRequestQueryProcessQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "isNormalizedCpu":
            suggest = "is_normalized_cpu"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "textFilter":
            suggest = "text_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTreemapDefinitionRequestQueryProcessQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTreemapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTreemapDefinitionRequestQueryProcessQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 metric: str,
                 name: str,
                 aggregator: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 is_normalized_cpu: Optional[bool] = None,
                 limit: Optional[int] = None,
                 sort: Optional[str] = None,
                 tag_filters: Optional[Sequence[str]] = None,
                 text_filter: Optional[str] = None):
        """
        :param str data_source: The data source for process queries. Valid values are `process`, `container`.
        :param str metric: The process metric name.
        :param str name: The name of query for use in formulas.
        :param str aggregator: The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param bool is_normalized_cpu: Whether to normalize the CPU percentages.
        :param int limit: The number of hits to return.
        :param str sort: The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        :param Sequence[str] tag_filters: An array of tags to filter by.
        :param str text_filter: The text to use as a filter.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "metric", metric)
        pulumi.set(__self__, "name", name)
        if aggregator is not None:
            pulumi.set(__self__, "aggregator", aggregator)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if is_normalized_cpu is not None:
            pulumi.set(__self__, "is_normalized_cpu", is_normalized_cpu)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if sort is not None:
            pulumi.set(__self__, "sort", sort)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if text_filter is not None:
            pulumi.set(__self__, "text_filter", text_filter)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for process queries. Valid values are `process`, `container`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def metric(self) -> str:
        """
        The process metric name.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def aggregator(self) -> Optional[str]:
        """
        The aggregation methods available for metrics queries. Valid values are `avg`, `min`, `max`, `sum`, `last`, `area`, `l2norm`, `percentile`.
        """
        return pulumi.get(self, "aggregator")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="isNormalizedCpu")
    def is_normalized_cpu(self) -> Optional[bool]:
        """
        Whether to normalize the CPU percentages.
        """
        return pulumi.get(self, "is_normalized_cpu")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        The number of hits to return.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def sort(self) -> Optional[str]:
        """
        The direction of the sort. Valid values are `asc`, `desc`. Defaults to `"desc"`.
        """
        return pulumi.get(self, "sort")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        An array of tags to filter by.
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="textFilter")
    def text_filter(self) -> Optional[str]:
        """
        The text to use as a filter.
        """
        return pulumi.get(self, "text_filter")


@pulumi.output_type
class PowerpackWidgetTreemapDefinitionRequestQuerySloQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"
        elif key == "sloId":
            suggest = "slo_id"
        elif key == "additionalQueryFilters":
            suggest = "additional_query_filters"
        elif key == "crossOrgUuids":
            suggest = "cross_org_uuids"
        elif key == "groupMode":
            suggest = "group_mode"
        elif key == "sloQueryType":
            suggest = "slo_query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetTreemapDefinitionRequestQuerySloQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetTreemapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetTreemapDefinitionRequestQuerySloQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_source: str,
                 measure: str,
                 slo_id: str,
                 additional_query_filters: Optional[str] = None,
                 cross_org_uuids: Optional[str] = None,
                 group_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 slo_query_type: Optional[str] = None):
        """
        :param str data_source: The data source for SLO queries. Valid values are `slo`.
        :param str measure: SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        :param str slo_id: ID of an SLO to query.
        :param str additional_query_filters: Additional filters applied to the SLO query.
        :param str cross_org_uuids: The source organization UUID for cross organization queries. Feature in Private Beta.
        :param str group_mode: Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        :param str name: The name of query for use in formulas.
        :param str slo_query_type: type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        pulumi.set(__self__, "data_source", data_source)
        pulumi.set(__self__, "measure", measure)
        pulumi.set(__self__, "slo_id", slo_id)
        if additional_query_filters is not None:
            pulumi.set(__self__, "additional_query_filters", additional_query_filters)
        if cross_org_uuids is not None:
            pulumi.set(__self__, "cross_org_uuids", cross_org_uuids)
        if group_mode is not None:
            pulumi.set(__self__, "group_mode", group_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if slo_query_type is not None:
            pulumi.set(__self__, "slo_query_type", slo_query_type)

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> str:
        """
        The data source for SLO queries. Valid values are `slo`.
        """
        return pulumi.get(self, "data_source")

    @property
    @pulumi.getter
    def measure(self) -> str:
        """
        SLO measures queries. Valid values are `good_events`, `bad_events`, `good_minutes`, `bad_minutes`, `slo_status`, `error_budget_remaining`, `burn_rate`, `error_budget_burndown`.
        """
        return pulumi.get(self, "measure")

    @property
    @pulumi.getter(name="sloId")
    def slo_id(self) -> str:
        """
        ID of an SLO to query.
        """
        return pulumi.get(self, "slo_id")

    @property
    @pulumi.getter(name="additionalQueryFilters")
    def additional_query_filters(self) -> Optional[str]:
        """
        Additional filters applied to the SLO query.
        """
        return pulumi.get(self, "additional_query_filters")

    @property
    @pulumi.getter(name="crossOrgUuids")
    def cross_org_uuids(self) -> Optional[str]:
        """
        The source organization UUID for cross organization queries. Feature in Private Beta.
        """
        return pulumi.get(self, "cross_org_uuids")

    @property
    @pulumi.getter(name="groupMode")
    def group_mode(self) -> Optional[str]:
        """
        Group mode to query measures. Valid values are `overall`, `components`. Defaults to `"overall"`.
        """
        return pulumi.get(self, "group_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sloQueryType")
    def slo_query_type(self) -> Optional[str]:
        """
        type of the SLO to query. Valid values are `metric`, `time_slice`. Defaults to `"metric"`.
        """
        return pulumi.get(self, "slo_query_type")


@pulumi.output_type
class PowerpackWidgetWidgetLayout(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isColumnBreak":
            suggest = "is_column_break"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PowerpackWidgetWidgetLayout. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PowerpackWidgetWidgetLayout.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PowerpackWidgetWidgetLayout.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 height: int,
                 width: int,
                 x: int,
                 y: int,
                 is_column_break: Optional[bool] = None):
        """
        :param int height: The height of the widget.
        :param int width: The width of the widget.
        :param int x: The position of the widget on the x (horizontal) axis. Must be greater than or equal to 0.
        :param int y: The position of the widget on the y (vertical) axis. Must be greater than or equal to 0.
        :param bool is_column_break: Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
        """
        pulumi.set(__self__, "height", height)
        pulumi.set(__self__, "width", width)
        pulumi.set(__self__, "x", x)
        pulumi.set(__self__, "y", y)
        if is_column_break is not None:
            pulumi.set(__self__, "is_column_break", is_column_break)

    @property
    @pulumi.getter
    def height(self) -> int:
        """
        The height of the widget.
        """
        return pulumi.get(self, "height")

    @property
    @pulumi.getter
    def width(self) -> int:
        """
        The width of the widget.
        """
        return pulumi.get(self, "width")

    @property
    @pulumi.getter
    def x(self) -> int:
        """
        The position of the widget on the x (horizontal) axis. Must be greater than or equal to 0.
        """
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> int:
        """
        The position of the widget on the y (vertical) axis. Must be greater than or equal to 0.
        """
        return pulumi.get(self, "y")

    @property
    @pulumi.getter(name="isColumnBreak")
    def is_column_break(self) -> Optional[bool]:
        """
        Whether the widget should be the first one on the second column in high density or not. Only one widget in the dashboard should have this property set to `true`.
        """
        return pulumi.get(self, "is_column_break")


@pulumi.output_type
class RestrictionPolicyBinding(dict):
    def __init__(__self__, *,
                 principals: Sequence[str],
                 relation: str):
        """
        :param Sequence[str] principals: An array of principals. A principal is a subject or group of subjects. Each principal is formatted as `type:id`. Supported types: `role`, `team`, `user`, and `org`. Org ID can be obtained using a `GET /api/v2/current_user` API request. Find it in the `data.relationships.org.data.id` field.
        :param str relation: The role/level of access. See this page for more details https://docs.datadoghq.com/api/latest/restriction-policies/#supported-relations-for-resources
        """
        pulumi.set(__self__, "principals", principals)
        pulumi.set(__self__, "relation", relation)

    @property
    @pulumi.getter
    def principals(self) -> Sequence[str]:
        """
        An array of principals. A principal is a subject or group of subjects. Each principal is formatted as `type:id`. Supported types: `role`, `team`, `user`, and `org`. Org ID can be obtained using a `GET /api/v2/current_user` API request. Find it in the `data.relationships.org.data.id` field.
        """
        return pulumi.get(self, "principals")

    @property
    @pulumi.getter
    def relation(self) -> str:
        """
        The role/level of access. See this page for more details https://docs.datadoghq.com/api/latest/restriction-policies/#supported-relations-for-resources
        """
        return pulumi.get(self, "relation")


@pulumi.output_type
class RolePermission(dict):
    def __init__(__self__, *,
                 id: str,
                 name: Optional[str] = None):
        """
        :param str id: ID of the permission to assign.
        :param str name: Name of the permission.
        """
        pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the permission to assign.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the permission.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RumMetricCompute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"
        elif key == "includePercentiles":
            suggest = "include_percentiles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RumMetricCompute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RumMetricCompute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RumMetricCompute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_type: str,
                 include_percentiles: Optional[bool] = None,
                 path: Optional[str] = None):
        """
        :param str aggregation_type: The type of aggregation to use.
        :param bool include_percentiles: Toggle to include or exclude percentile aggregations for distribution metrics. Only present when `aggregation_type` is `distribution`.
        :param str path: The path to the value the RUM-based metric will aggregate on. Only present when `aggregation_type` is `distribution`.
        """
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        if include_percentiles is not None:
            pulumi.set(__self__, "include_percentiles", include_percentiles)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> str:
        """
        The type of aggregation to use.
        """
        return pulumi.get(self, "aggregation_type")

    @property
    @pulumi.getter(name="includePercentiles")
    def include_percentiles(self) -> Optional[bool]:
        """
        Toggle to include or exclude percentile aggregations for distribution metrics. Only present when `aggregation_type` is `distribution`.
        """
        return pulumi.get(self, "include_percentiles")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to the value the RUM-based metric will aggregate on. Only present when `aggregation_type` is `distribution`.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class RumMetricFilter(dict):
    def __init__(__self__, *,
                 query: Optional[str] = None):
        """
        :param str query: The search query. Follows RUM search syntax.
        """
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        The search query. Follows RUM search syntax.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class RumMetricGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagName":
            suggest = "tag_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RumMetricGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RumMetricGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RumMetricGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: Optional[str] = None,
                 tag_name: Optional[str] = None):
        """
        :param str path: The path to the value the RUM-based metric will be aggregated over.
        :param str tag_name: Name of the tag that gets created. By default, `path` is used as the tag name.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to the value the RUM-based metric will be aggregated over.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[str]:
        """
        Name of the tag that gets created. By default, `path` is used as the tag name.
        """
        return pulumi.get(self, "tag_name")


@pulumi.output_type
class RumMetricUniqueness(dict):
    def __init__(__self__, *,
                 when: Optional[str] = None):
        """
        :param str when: When to count updatable events. `match` when the event is first seen, or `end` when the event is complete.
        """
        if when is not None:
            pulumi.set(__self__, "when", when)

    @property
    @pulumi.getter
    def when(self) -> Optional[str]:
        """
        When to count updatable events. `match` when the event is first seen, or `end` when the event is complete.
        """
        return pulumi.get(self, "when")


@pulumi.output_type
class SecurityMonitoringDefaultRuleCase(dict):
    def __init__(__self__, *,
                 notifications: Sequence[str],
                 status: str):
        """
        :param Sequence[str] notifications: Notification targets for each rule case.
        :param str status: Status of the rule case to match. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        """
        pulumi.set(__self__, "notifications", notifications)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def notifications(self) -> Sequence[str]:
        """
        Notification targets for each rule case.
        """
        return pulumi.get(self, "notifications")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Status of the rule case to match. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class SecurityMonitoringDefaultRuleFilter(dict):
    def __init__(__self__, *,
                 action: str,
                 query: str):
        """
        :param str action: The type of filtering action. Allowed enum values: require, suppress Valid values are `require`, `suppress`.
        :param str query: Query for selecting logs to apply the filtering action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The type of filtering action. Allowed enum values: require, suppress Valid values are `require`, `suppress`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for selecting logs to apply the filtering action.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SecurityMonitoringDefaultRuleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decreaseCriticalityBasedOnEnv":
            suggest = "decrease_criticality_based_on_env"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringDefaultRuleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringDefaultRuleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringDefaultRuleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decrease_criticality_based_on_env: Optional[bool] = None):
        """
        :param bool decrease_criticality_based_on_env: If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `log_detection`. Defaults to `false`.
        """
        if decrease_criticality_based_on_env is not None:
            pulumi.set(__self__, "decrease_criticality_based_on_env", decrease_criticality_based_on_env)

    @property
    @pulumi.getter(name="decreaseCriticalityBasedOnEnv")
    def decrease_criticality_based_on_env(self) -> Optional[bool]:
        """
        If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `log_detection`. Defaults to `false`.
        """
        return pulumi.get(self, "decrease_criticality_based_on_env")


@pulumi.output_type
class SecurityMonitoringFilterExclusionFilter(dict):
    def __init__(__self__, *,
                 name: str,
                 query: str):
        """
        :param str name: Exclusion filter name.
        :param str query: Exclusion filter query. Logs that match this query are excluded from the security filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Exclusion filter name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Exclusion filter query. Logs that match this query are excluded from the security filter.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SecurityMonitoringRuleCase(dict):
    def __init__(__self__, *,
                 status: str,
                 condition: Optional[str] = None,
                 name: Optional[str] = None,
                 notifications: Optional[Sequence[str]] = None):
        """
        :param str status: Severity of the Security Signal. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        :param str condition: A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated based on the event counts in the previously defined queries.
        :param str name: Name of the case.
        :param Sequence[str] notifications: Notification targets for each rule case.
        """
        pulumi.set(__self__, "status", status)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Severity of the Security Signal. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated based on the event counts in the previously defined queries.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the case.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def notifications(self) -> Optional[Sequence[str]]:
        """
        Notification targets for each rule case.
        """
        return pulumi.get(self, "notifications")


@pulumi.output_type
class SecurityMonitoringRuleFilter(dict):
    def __init__(__self__, *,
                 action: str,
                 query: str):
        """
        :param str action: The type of filtering action. Valid values are `require`, `suppress`.
        :param str query: Query for selecting logs to apply the filtering action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The type of filtering action. Valid values are `require`, `suppress`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for selecting logs to apply the filtering action.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SecurityMonitoringRuleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "decreaseCriticalityBasedOnEnv":
            suggest = "decrease_criticality_based_on_env"
        elif key == "detectionMethod":
            suggest = "detection_method"
        elif key == "evaluationWindow":
            suggest = "evaluation_window"
        elif key == "impossibleTravelOptions":
            suggest = "impossible_travel_options"
        elif key == "keepAlive":
            suggest = "keep_alive"
        elif key == "maxSignalDuration":
            suggest = "max_signal_duration"
        elif key == "newValueOptions":
            suggest = "new_value_options"
        elif key == "thirdPartyRuleOptions":
            suggest = "third_party_rule_options"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringRuleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringRuleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringRuleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 decrease_criticality_based_on_env: Optional[bool] = None,
                 detection_method: Optional[str] = None,
                 evaluation_window: Optional[int] = None,
                 impossible_travel_options: Optional['outputs.SecurityMonitoringRuleOptionsImpossibleTravelOptions'] = None,
                 keep_alive: Optional[int] = None,
                 max_signal_duration: Optional[int] = None,
                 new_value_options: Optional['outputs.SecurityMonitoringRuleOptionsNewValueOptions'] = None,
                 third_party_rule_options: Optional['outputs.SecurityMonitoringRuleOptionsThirdPartyRuleOptions'] = None):
        """
        :param bool decrease_criticality_based_on_env: If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `log_detection`. Defaults to `false`.
        :param str detection_method: The detection method. Valid values are `threshold`, `new_value`, `anomaly_detection`, `impossible_travel`, `hardcoded`, `third_party`, `anomaly_threshold`. Defaults to `"threshold"`.
        :param int evaluation_window: A time window is specified to match when at least one of the cases matches true. This is a sliding window and evaluates in real time. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`.
        :param 'SecurityMonitoringRuleOptionsImpossibleTravelOptionsArgs' impossible_travel_options: Options for rules using the impossible travel detection method.
        :param int keep_alive: Once a signal is generated, the signal will remain open if a case is matched at least once within this keep alive window (in seconds). Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`.
        :param int max_signal_duration: A signal will close regardless of the query being matched once the time exceeds the maximum duration (in seconds). This time is calculated from the first seen timestamp. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`, `43200`, `86400`.
        :param 'SecurityMonitoringRuleOptionsNewValueOptionsArgs' new_value_options: New value rules specific options.
        :param 'SecurityMonitoringRuleOptionsThirdPartyRuleOptionsArgs' third_party_rule_options: Options for rules using the third-party detection method.
        """
        if decrease_criticality_based_on_env is not None:
            pulumi.set(__self__, "decrease_criticality_based_on_env", decrease_criticality_based_on_env)
        if detection_method is not None:
            pulumi.set(__self__, "detection_method", detection_method)
        if evaluation_window is not None:
            pulumi.set(__self__, "evaluation_window", evaluation_window)
        if impossible_travel_options is not None:
            pulumi.set(__self__, "impossible_travel_options", impossible_travel_options)
        if keep_alive is not None:
            pulumi.set(__self__, "keep_alive", keep_alive)
        if max_signal_duration is not None:
            pulumi.set(__self__, "max_signal_duration", max_signal_duration)
        if new_value_options is not None:
            pulumi.set(__self__, "new_value_options", new_value_options)
        if third_party_rule_options is not None:
            pulumi.set(__self__, "third_party_rule_options", third_party_rule_options)

    @property
    @pulumi.getter(name="decreaseCriticalityBasedOnEnv")
    def decrease_criticality_based_on_env(self) -> Optional[bool]:
        """
        If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `log_detection`. Defaults to `false`.
        """
        return pulumi.get(self, "decrease_criticality_based_on_env")

    @property
    @pulumi.getter(name="detectionMethod")
    def detection_method(self) -> Optional[str]:
        """
        The detection method. Valid values are `threshold`, `new_value`, `anomaly_detection`, `impossible_travel`, `hardcoded`, `third_party`, `anomaly_threshold`. Defaults to `"threshold"`.
        """
        return pulumi.get(self, "detection_method")

    @property
    @pulumi.getter(name="evaluationWindow")
    def evaluation_window(self) -> Optional[int]:
        """
        A time window is specified to match when at least one of the cases matches true. This is a sliding window and evaluates in real time. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`.
        """
        return pulumi.get(self, "evaluation_window")

    @property
    @pulumi.getter(name="impossibleTravelOptions")
    def impossible_travel_options(self) -> Optional['outputs.SecurityMonitoringRuleOptionsImpossibleTravelOptions']:
        """
        Options for rules using the impossible travel detection method.
        """
        return pulumi.get(self, "impossible_travel_options")

    @property
    @pulumi.getter(name="keepAlive")
    def keep_alive(self) -> Optional[int]:
        """
        Once a signal is generated, the signal will remain open if a case is matched at least once within this keep alive window (in seconds). Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`.
        """
        return pulumi.get(self, "keep_alive")

    @property
    @pulumi.getter(name="maxSignalDuration")
    def max_signal_duration(self) -> Optional[int]:
        """
        A signal will close regardless of the query being matched once the time exceeds the maximum duration (in seconds). This time is calculated from the first seen timestamp. Valid values are `0`, `60`, `300`, `600`, `900`, `1800`, `3600`, `7200`, `10800`, `21600`, `43200`, `86400`.
        """
        return pulumi.get(self, "max_signal_duration")

    @property
    @pulumi.getter(name="newValueOptions")
    def new_value_options(self) -> Optional['outputs.SecurityMonitoringRuleOptionsNewValueOptions']:
        """
        New value rules specific options.
        """
        return pulumi.get(self, "new_value_options")

    @property
    @pulumi.getter(name="thirdPartyRuleOptions")
    def third_party_rule_options(self) -> Optional['outputs.SecurityMonitoringRuleOptionsThirdPartyRuleOptions']:
        """
        Options for rules using the third-party detection method.
        """
        return pulumi.get(self, "third_party_rule_options")


@pulumi.output_type
class SecurityMonitoringRuleOptionsImpossibleTravelOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baselineUserLocations":
            suggest = "baseline_user_locations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringRuleOptionsImpossibleTravelOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringRuleOptionsImpossibleTravelOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringRuleOptionsImpossibleTravelOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 baseline_user_locations: Optional[bool] = None):
        """
        :param bool baseline_user_locations: If true, signals are suppressed for the first 24 hours. During that time, Datadog learns the user's regular access locations. This can be helpful to reduce noise and infer VPN usage or credentialed API access. Defaults to `false`.
        """
        if baseline_user_locations is not None:
            pulumi.set(__self__, "baseline_user_locations", baseline_user_locations)

    @property
    @pulumi.getter(name="baselineUserLocations")
    def baseline_user_locations(self) -> Optional[bool]:
        """
        If true, signals are suppressed for the first 24 hours. During that time, Datadog learns the user's regular access locations. This can be helpful to reduce noise and infer VPN usage or credentialed API access. Defaults to `false`.
        """
        return pulumi.get(self, "baseline_user_locations")


@pulumi.output_type
class SecurityMonitoringRuleOptionsNewValueOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forgetAfter":
            suggest = "forget_after"
        elif key == "learningDuration":
            suggest = "learning_duration"
        elif key == "learningMethod":
            suggest = "learning_method"
        elif key == "learningThreshold":
            suggest = "learning_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringRuleOptionsNewValueOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringRuleOptionsNewValueOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringRuleOptionsNewValueOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forget_after: int,
                 learning_duration: Optional[int] = None,
                 learning_method: Optional[str] = None,
                 learning_threshold: Optional[int] = None):
        """
        :param int forget_after: The duration in days after which a learned value is forgotten. Valid values are `1`, `2`, `7`, `14`, `21`, `28`.
        :param int learning_duration: The duration in days during which values are learned, and after which signals will be generated for values that weren't learned. If set to 0, a signal will be generated for all new values after the first value is learned. Valid values are `0`, `1`, `7`. Defaults to `1`.
        :param str learning_method: The learning method used to determine when signals should be generated for values that weren't learned. Valid values are `duration`, `threshold`. Defaults to `"duration"`.
        :param int learning_threshold: A number of occurrences after which signals are generated for values that weren't learned. Valid values are `0`, `1`. Defaults to `0`.
        """
        pulumi.set(__self__, "forget_after", forget_after)
        if learning_duration is not None:
            pulumi.set(__self__, "learning_duration", learning_duration)
        if learning_method is not None:
            pulumi.set(__self__, "learning_method", learning_method)
        if learning_threshold is not None:
            pulumi.set(__self__, "learning_threshold", learning_threshold)

    @property
    @pulumi.getter(name="forgetAfter")
    def forget_after(self) -> int:
        """
        The duration in days after which a learned value is forgotten. Valid values are `1`, `2`, `7`, `14`, `21`, `28`.
        """
        return pulumi.get(self, "forget_after")

    @property
    @pulumi.getter(name="learningDuration")
    def learning_duration(self) -> Optional[int]:
        """
        The duration in days during which values are learned, and after which signals will be generated for values that weren't learned. If set to 0, a signal will be generated for all new values after the first value is learned. Valid values are `0`, `1`, `7`. Defaults to `1`.
        """
        return pulumi.get(self, "learning_duration")

    @property
    @pulumi.getter(name="learningMethod")
    def learning_method(self) -> Optional[str]:
        """
        The learning method used to determine when signals should be generated for values that weren't learned. Valid values are `duration`, `threshold`. Defaults to `"duration"`.
        """
        return pulumi.get(self, "learning_method")

    @property
    @pulumi.getter(name="learningThreshold")
    def learning_threshold(self) -> Optional[int]:
        """
        A number of occurrences after which signals are generated for values that weren't learned. Valid values are `0`, `1`. Defaults to `0`.
        """
        return pulumi.get(self, "learning_threshold")


@pulumi.output_type
class SecurityMonitoringRuleOptionsThirdPartyRuleOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultStatus":
            suggest = "default_status"
        elif key == "rootQueries":
            suggest = "root_queries"
        elif key == "defaultNotifications":
            suggest = "default_notifications"
        elif key == "signalTitleTemplate":
            suggest = "signal_title_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringRuleOptionsThirdPartyRuleOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringRuleOptionsThirdPartyRuleOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringRuleOptionsThirdPartyRuleOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_status: str,
                 root_queries: Sequence['outputs.SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQuery'],
                 default_notifications: Optional[Sequence[str]] = None,
                 signal_title_template: Optional[str] = None):
        """
        :param str default_status: Severity of the default rule case, when none of the third-party cases match. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        :param Sequence['SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQueryArgs'] root_queries: Queries to be combined with third-party case queries. Each of them can have different group by fields, to aggregate differently based on the type of alert.
        :param Sequence[str] default_notifications: Notification targets for the default rule case, when none of the third-party cases match.
        :param str signal_title_template: A template for the signal title; if omitted, the title is generated based on the case name.
        """
        pulumi.set(__self__, "default_status", default_status)
        pulumi.set(__self__, "root_queries", root_queries)
        if default_notifications is not None:
            pulumi.set(__self__, "default_notifications", default_notifications)
        if signal_title_template is not None:
            pulumi.set(__self__, "signal_title_template", signal_title_template)

    @property
    @pulumi.getter(name="defaultStatus")
    def default_status(self) -> str:
        """
        Severity of the default rule case, when none of the third-party cases match. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        """
        return pulumi.get(self, "default_status")

    @property
    @pulumi.getter(name="rootQueries")
    def root_queries(self) -> Sequence['outputs.SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQuery']:
        """
        Queries to be combined with third-party case queries. Each of them can have different group by fields, to aggregate differently based on the type of alert.
        """
        return pulumi.get(self, "root_queries")

    @property
    @pulumi.getter(name="defaultNotifications")
    def default_notifications(self) -> Optional[Sequence[str]]:
        """
        Notification targets for the default rule case, when none of the third-party cases match.
        """
        return pulumi.get(self, "default_notifications")

    @property
    @pulumi.getter(name="signalTitleTemplate")
    def signal_title_template(self) -> Optional[str]:
        """
        A template for the signal title; if omitted, the title is generated based on the case name.
        """
        return pulumi.get(self, "signal_title_template")


@pulumi.output_type
class SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupByFields":
            suggest = "group_by_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringRuleOptionsThirdPartyRuleOptionsRootQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 group_by_fields: Optional[Sequence[str]] = None):
        """
        :param str query: Query to filter logs.
        :param Sequence[str] group_by_fields: Fields to group by. If empty, each log triggers a signal.
        """
        pulumi.set(__self__, "query", query)
        if group_by_fields is not None:
            pulumi.set(__self__, "group_by_fields", group_by_fields)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query to filter logs.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="groupByFields")
    def group_by_fields(self) -> Optional[Sequence[str]]:
        """
        Fields to group by. If empty, each log triggers a signal.
        """
        return pulumi.get(self, "group_by_fields")


@pulumi.output_type
class SecurityMonitoringRuleQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentRules":
            suggest = "agent_rules"
        elif key == "distinctFields":
            suggest = "distinct_fields"
        elif key == "groupByFields":
            suggest = "group_by_fields"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringRuleQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringRuleQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringRuleQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 agent_rules: Optional[Sequence['outputs.SecurityMonitoringRuleQueryAgentRule']] = None,
                 aggregation: Optional[str] = None,
                 distinct_fields: Optional[Sequence[str]] = None,
                 group_by_fields: Optional[Sequence[str]] = None,
                 metric: Optional[str] = None,
                 metrics: Optional[Sequence[str]] = None,
                 name: Optional[str] = None):
        """
        :param str query: Query to run on logs.
        :param Sequence['SecurityMonitoringRuleQueryAgentRuleArgs'] agent_rules: **Deprecated**. It won't be applied anymore. **Deprecated.** `agent_rule` has been deprecated in favor of new Agent Rule resource.
        :param str aggregation: The aggregation type. For Signal Correlation rules, it must be event_count. Valid values are `count`, `cardinality`, `sum`, `max`, `new_value`, `geo_data`, `event_count`, `none`. Defaults to `"count"`.
        :param Sequence[str] distinct_fields: Field for which the cardinality is measured. Sent as an array.
        :param Sequence[str] group_by_fields: Fields to group by.
        :param str metric: The target field to aggregate over when using the `sum`, `max`, or `geo_data` aggregations. **Deprecated.** Configure `metrics` instead. This attribute will be removed in the next major version of the provider.
        :param Sequence[str] metrics: Group of target fields to aggregate over when using the `sum`, `max`, `geo_data`, or `new_value` aggregations. The `sum`, `max`, and `geo_data` aggregations only accept one value in this list, whereas the `new_value` aggregation accepts up to five values.
        :param str name: Name of the query. Not compatible with `new_value` aggregations.
        """
        pulumi.set(__self__, "query", query)
        if agent_rules is not None:
            pulumi.set(__self__, "agent_rules", agent_rules)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if distinct_fields is not None:
            pulumi.set(__self__, "distinct_fields", distinct_fields)
        if group_by_fields is not None:
            pulumi.set(__self__, "group_by_fields", group_by_fields)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if metrics is not None:
            pulumi.set(__self__, "metrics", metrics)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query to run on logs.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="agentRules")
    @_utilities.deprecated("""`agent_rule` has been deprecated in favor of new Agent Rule resource.""")
    def agent_rules(self) -> Optional[Sequence['outputs.SecurityMonitoringRuleQueryAgentRule']]:
        """
        **Deprecated**. It won't be applied anymore. **Deprecated.** `agent_rule` has been deprecated in favor of new Agent Rule resource.
        """
        return pulumi.get(self, "agent_rules")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        The aggregation type. For Signal Correlation rules, it must be event_count. Valid values are `count`, `cardinality`, `sum`, `max`, `new_value`, `geo_data`, `event_count`, `none`. Defaults to `"count"`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="distinctFields")
    def distinct_fields(self) -> Optional[Sequence[str]]:
        """
        Field for which the cardinality is measured. Sent as an array.
        """
        return pulumi.get(self, "distinct_fields")

    @property
    @pulumi.getter(name="groupByFields")
    def group_by_fields(self) -> Optional[Sequence[str]]:
        """
        Fields to group by.
        """
        return pulumi.get(self, "group_by_fields")

    @property
    @pulumi.getter
    @_utilities.deprecated("""Configure `metrics` instead. This attribute will be removed in the next major version of the provider.""")
    def metric(self) -> Optional[str]:
        """
        The target field to aggregate over when using the `sum`, `max`, or `geo_data` aggregations. **Deprecated.** Configure `metrics` instead. This attribute will be removed in the next major version of the provider.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def metrics(self) -> Optional[Sequence[str]]:
        """
        Group of target fields to aggregate over when using the `sum`, `max`, `geo_data`, or `new_value` aggregations. The `sum`, `max`, and `geo_data` aggregations only accept one value in this list, whereas the `new_value` aggregation accepts up to five values.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the query. Not compatible with `new_value` aggregations.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecurityMonitoringRuleQueryAgentRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentRuleId":
            suggest = "agent_rule_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringRuleQueryAgentRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringRuleQueryAgentRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringRuleQueryAgentRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_rule_id: str,
                 expression: str):
        """
        :param str agent_rule_id: **Deprecated**. It won't be applied anymore.
        :param str expression: **Deprecated**. It won't be applied anymore.
        """
        pulumi.set(__self__, "agent_rule_id", agent_rule_id)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="agentRuleId")
    def agent_rule_id(self) -> str:
        """
        **Deprecated**. It won't be applied anymore.
        """
        return pulumi.get(self, "agent_rule_id")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        **Deprecated**. It won't be applied anymore.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class SecurityMonitoringRuleReferenceTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkPresence":
            suggest = "check_presence"
        elif key == "columnName":
            suggest = "column_name"
        elif key == "logFieldPath":
            suggest = "log_field_path"
        elif key == "ruleQueryName":
            suggest = "rule_query_name"
        elif key == "tableName":
            suggest = "table_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringRuleReferenceTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringRuleReferenceTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringRuleReferenceTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check_presence: bool,
                 column_name: str,
                 log_field_path: str,
                 rule_query_name: str,
                 table_name: str):
        """
        :param bool check_presence: Whether to include or exclude logs that match the reference table.
        :param str column_name: The name of the column in the reference table.
        :param str log_field_path: The field in the log that should be matched against the reference table.
        :param str rule_query_name: The name of the query to filter.
        :param str table_name: The name of the reference table.
        """
        pulumi.set(__self__, "check_presence", check_presence)
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "log_field_path", log_field_path)
        pulumi.set(__self__, "rule_query_name", rule_query_name)
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="checkPresence")
    def check_presence(self) -> bool:
        """
        Whether to include or exclude logs that match the reference table.
        """
        return pulumi.get(self, "check_presence")

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        The name of the column in the reference table.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="logFieldPath")
    def log_field_path(self) -> str:
        """
        The field in the log that should be matched against the reference table.
        """
        return pulumi.get(self, "log_field_path")

    @property
    @pulumi.getter(name="ruleQueryName")
    def rule_query_name(self) -> str:
        """
        The name of the query to filter.
        """
        return pulumi.get(self, "rule_query_name")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        The name of the reference table.
        """
        return pulumi.get(self, "table_name")


@pulumi.output_type
class SecurityMonitoringRuleSignalQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleId":
            suggest = "rule_id"
        elif key == "correlatedByFields":
            suggest = "correlated_by_fields"
        elif key == "correlatedQueryIndex":
            suggest = "correlated_query_index"
        elif key == "defaultRuleId":
            suggest = "default_rule_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SecurityMonitoringRuleSignalQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SecurityMonitoringRuleSignalQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SecurityMonitoringRuleSignalQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rule_id: str,
                 aggregation: Optional[str] = None,
                 correlated_by_fields: Optional[Sequence[str]] = None,
                 correlated_query_index: Optional[str] = None,
                 default_rule_id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str rule_id: Rule ID of the signal to correlate.
        :param str aggregation: The aggregation type. For Signal Correlation rules, it must be event_count. Valid values are `count`, `cardinality`, `sum`, `max`, `new_value`, `geo_data`, `event_count`, `none`. Defaults to `"event_count"`.
        :param Sequence[str] correlated_by_fields: Fields to correlate by.
        :param str correlated_query_index: Index of the rule query used to retrieve the correlated field. An empty string applies correlation on the non-projected per query attributes of the rule. Defaults to `""`.
        :param str default_rule_id: Default Rule ID of the signal to correlate. This value is READ-ONLY.
        :param str name: Name of the query. Not compatible with `new_value` aggregations.
        """
        pulumi.set(__self__, "rule_id", rule_id)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if correlated_by_fields is not None:
            pulumi.set(__self__, "correlated_by_fields", correlated_by_fields)
        if correlated_query_index is not None:
            pulumi.set(__self__, "correlated_query_index", correlated_query_index)
        if default_rule_id is not None:
            pulumi.set(__self__, "default_rule_id", default_rule_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> str:
        """
        Rule ID of the signal to correlate.
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        The aggregation type. For Signal Correlation rules, it must be event_count. Valid values are `count`, `cardinality`, `sum`, `max`, `new_value`, `geo_data`, `event_count`, `none`. Defaults to `"event_count"`.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="correlatedByFields")
    def correlated_by_fields(self) -> Optional[Sequence[str]]:
        """
        Fields to correlate by.
        """
        return pulumi.get(self, "correlated_by_fields")

    @property
    @pulumi.getter(name="correlatedQueryIndex")
    def correlated_query_index(self) -> Optional[str]:
        """
        Index of the rule query used to retrieve the correlated field. An empty string applies correlation on the non-projected per query attributes of the rule. Defaults to `""`.
        """
        return pulumi.get(self, "correlated_query_index")

    @property
    @pulumi.getter(name="defaultRuleId")
    def default_rule_id(self) -> Optional[str]:
        """
        Default Rule ID of the signal to correlate. This value is READ-ONLY.
        """
        return pulumi.get(self, "default_rule_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the query. Not compatible with `new_value` aggregations.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecurityMonitoringRuleThirdPartyCase(dict):
    def __init__(__self__, *,
                 status: str,
                 name: Optional[str] = None,
                 notifications: Optional[Sequence[str]] = None,
                 query: Optional[str] = None):
        """
        :param str status: Severity of the Security Signal. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        :param str name: Name of the case.
        :param Sequence[str] notifications: Notification targets for each rule case.
        :param str query: A query to associate a third-party event to this case.
        """
        pulumi.set(__self__, "status", status)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Severity of the Security Signal. Valid values are `info`, `low`, `medium`, `high`, `critical`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the case.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def notifications(self) -> Optional[Sequence[str]]:
        """
        Notification targets for each rule case.
        """
        return pulumi.get(self, "notifications")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        A query to associate a third-party event to this case.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SensitiveDataScannerGroupFilter(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Query to filter the events.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query to filter the events.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SensitiveDataScannerRuleIncludedKeywordConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "characterCount":
            suggest = "character_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SensitiveDataScannerRuleIncludedKeywordConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SensitiveDataScannerRuleIncludedKeywordConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SensitiveDataScannerRuleIncludedKeywordConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 character_count: int,
                 keywords: Sequence[str]):
        """
        :param int character_count: Number of characters before the match to find a keyword validating the match. It must be between 1 and 50 (inclusive).
        :param Sequence[str] keywords: Keyword list that is checked during scanning in order to validate a match. The number of keywords in the list must be lower than or equal to 30.
        """
        pulumi.set(__self__, "character_count", character_count)
        pulumi.set(__self__, "keywords", keywords)

    @property
    @pulumi.getter(name="characterCount")
    def character_count(self) -> int:
        """
        Number of characters before the match to find a keyword validating the match. It must be between 1 and 50 (inclusive).
        """
        return pulumi.get(self, "character_count")

    @property
    @pulumi.getter
    def keywords(self) -> Sequence[str]:
        """
        Keyword list that is checked during scanning in order to validate a match. The number of keywords in the list must be lower than or equal to 30.
        """
        return pulumi.get(self, "keywords")


@pulumi.output_type
class SensitiveDataScannerRuleTextReplacement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "numberOfChars":
            suggest = "number_of_chars"
        elif key == "replacementString":
            suggest = "replacement_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SensitiveDataScannerRuleTextReplacement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SensitiveDataScannerRuleTextReplacement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SensitiveDataScannerRuleTextReplacement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 number_of_chars: Optional[int] = None,
                 replacement_string: Optional[str] = None):
        """
        :param str type: Type of the replacement text. None means no replacement. hash means the data will be stubbed. replacement*string means that one can chose a text to replace the data. partial*replacement*from*beginning allows a user to partially replace the data from the beginning, and partial*replacement*from_end on the other hand, allows to replace data from the end. Valid values are `none`, `hash`, `replacement_string`, `partial_replacement_from_beginning`, `partial_replacement_from_end`.
        :param int number_of_chars: Required if type == 'partial*replacement*from*beginning' or 'partial*replacement*from*end'. It must be > 0.
        :param str replacement_string: Required if type == 'replacement_string'.
        """
        pulumi.set(__self__, "type", type)
        if number_of_chars is not None:
            pulumi.set(__self__, "number_of_chars", number_of_chars)
        if replacement_string is not None:
            pulumi.set(__self__, "replacement_string", replacement_string)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the replacement text. None means no replacement. hash means the data will be stubbed. replacement*string means that one can chose a text to replace the data. partial*replacement*from*beginning allows a user to partially replace the data from the beginning, and partial*replacement*from_end on the other hand, allows to replace data from the end. Valid values are `none`, `hash`, `replacement_string`, `partial_replacement_from_beginning`, `partial_replacement_from_end`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="numberOfChars")
    def number_of_chars(self) -> Optional[int]:
        """
        Required if type == 'partial*replacement*from*beginning' or 'partial*replacement*from*end'. It must be > 0.
        """
        return pulumi.get(self, "number_of_chars")

    @property
    @pulumi.getter(name="replacementString")
    def replacement_string(self) -> Optional[str]:
        """
        Required if type == 'replacement_string'.
        """
        return pulumi.get(self, "replacement_string")


@pulumi.output_type
class ServiceLevelObjectiveQuery(dict):
    def __init__(__self__, *,
                 denominator: str,
                 numerator: str):
        """
        :param str denominator: The sum of the `total` events.
        :param str numerator: The sum of all the `good` events.
        """
        pulumi.set(__self__, "denominator", denominator)
        pulumi.set(__self__, "numerator", numerator)

    @property
    @pulumi.getter
    def denominator(self) -> str:
        """
        The sum of the `total` events.
        """
        return pulumi.get(self, "denominator")

    @property
    @pulumi.getter
    def numerator(self) -> str:
        """
        The sum of all the `good` events.
        """
        return pulumi.get(self, "numerator")


@pulumi.output_type
class ServiceLevelObjectiveSliSpecification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeSlice":
            suggest = "time_slice"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceLevelObjectiveSliSpecification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceLevelObjectiveSliSpecification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceLevelObjectiveSliSpecification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_slice: 'outputs.ServiceLevelObjectiveSliSpecificationTimeSlice'):
        """
        :param 'ServiceLevelObjectiveSliSpecificationTimeSliceArgs' time_slice: The time slice condition, composed of 3 parts: 1. The timeseries query, 2. The comparator, and 3. The threshold. Optionally, a fourth part, the query interval, can be provided.
        """
        pulumi.set(__self__, "time_slice", time_slice)

    @property
    @pulumi.getter(name="timeSlice")
    def time_slice(self) -> 'outputs.ServiceLevelObjectiveSliSpecificationTimeSlice':
        """
        The time slice condition, composed of 3 parts: 1. The timeseries query, 2. The comparator, and 3. The threshold. Optionally, a fourth part, the query interval, can be provided.
        """
        return pulumi.get(self, "time_slice")


@pulumi.output_type
class ServiceLevelObjectiveSliSpecificationTimeSlice(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryIntervalSeconds":
            suggest = "query_interval_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceLevelObjectiveSliSpecificationTimeSlice. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceLevelObjectiveSliSpecificationTimeSlice.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceLevelObjectiveSliSpecificationTimeSlice.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comparator: str,
                 query: 'outputs.ServiceLevelObjectiveSliSpecificationTimeSliceQuery',
                 threshold: float,
                 query_interval_seconds: Optional[int] = None):
        """
        :param str comparator: The comparator used to compare the SLI value to the threshold. Valid values are `>`, `>=`, `<`, `<=`.
        :param 'ServiceLevelObjectiveSliSpecificationTimeSliceQueryArgs' query: A timeseries query, containing named data-source-specific queries and a formula involving the named queries.
        :param float threshold: The threshold value to which each SLI value will be compared.
        :param int query_interval_seconds: The interval used when querying data, which defines the size of a time slice. Valid values are `60`, `300`. Defaults to `300`.
        """
        pulumi.set(__self__, "comparator", comparator)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "threshold", threshold)
        if query_interval_seconds is not None:
            pulumi.set(__self__, "query_interval_seconds", query_interval_seconds)

    @property
    @pulumi.getter
    def comparator(self) -> str:
        """
        The comparator used to compare the SLI value to the threshold. Valid values are `>`, `>=`, `<`, `<=`.
        """
        return pulumi.get(self, "comparator")

    @property
    @pulumi.getter
    def query(self) -> 'outputs.ServiceLevelObjectiveSliSpecificationTimeSliceQuery':
        """
        A timeseries query, containing named data-source-specific queries and a formula involving the named queries.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def threshold(self) -> float:
        """
        The threshold value to which each SLI value will be compared.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="queryIntervalSeconds")
    def query_interval_seconds(self) -> Optional[int]:
        """
        The interval used when querying data, which defines the size of a time slice. Valid values are `60`, `300`. Defaults to `300`.
        """
        return pulumi.get(self, "query_interval_seconds")


@pulumi.output_type
class ServiceLevelObjectiveSliSpecificationTimeSliceQuery(dict):
    def __init__(__self__, *,
                 formula: 'outputs.ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormula',
                 queries: Sequence['outputs.ServiceLevelObjectiveSliSpecificationTimeSliceQueryQuery']):
        """
        :param 'ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormulaArgs' formula: A list that contains exactly one formula, as only a single formula may be used to define a timeseries query for a time-slice SLO.
        :param Sequence['ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryArgs'] queries: A list of data-source-specific queries that are in the formula.
        """
        pulumi.set(__self__, "formula", formula)
        pulumi.set(__self__, "queries", queries)

    @property
    @pulumi.getter
    def formula(self) -> 'outputs.ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormula':
        """
        A list that contains exactly one formula, as only a single formula may be used to define a timeseries query for a time-slice SLO.
        """
        return pulumi.get(self, "formula")

    @property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.ServiceLevelObjectiveSliSpecificationTimeSliceQueryQuery']:
        """
        A list of data-source-specific queries that are in the formula.
        """
        return pulumi.get(self, "queries")


@pulumi.output_type
class ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormula(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "formulaExpression":
            suggest = "formula_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormula. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormula.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceLevelObjectiveSliSpecificationTimeSliceQueryFormula.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 formula_expression: str):
        """
        :param str formula_expression: The formula string, which is an expression involving named queries.
        """
        pulumi.set(__self__, "formula_expression", formula_expression)

    @property
    @pulumi.getter(name="formulaExpression")
    def formula_expression(self) -> str:
        """
        The formula string, which is an expression involving named queries.
        """
        return pulumi.get(self, "formula_expression")


@pulumi.output_type
class ServiceLevelObjectiveSliSpecificationTimeSliceQueryQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "metricQuery":
            suggest = "metric_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceLevelObjectiveSliSpecificationTimeSliceQueryQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceLevelObjectiveSliSpecificationTimeSliceQueryQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceLevelObjectiveSliSpecificationTimeSliceQueryQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 metric_query: Optional['outputs.ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQuery'] = None):
        """
        :param 'ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQueryArgs' metric_query: A timeseries formula and functions metrics query.
        """
        if metric_query is not None:
            pulumi.set(__self__, "metric_query", metric_query)

    @property
    @pulumi.getter(name="metricQuery")
    def metric_query(self) -> Optional['outputs.ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQuery']:
        """
        A timeseries formula and functions metrics query.
        """
        return pulumi.get(self, "metric_query")


@pulumi.output_type
class ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceLevelObjectiveSliSpecificationTimeSliceQueryQueryMetricQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 query: str,
                 data_source: Optional[str] = None):
        """
        :param str name: The name of the query for use in formulas.
        :param str query: The metrics query definition.
        :param str data_source: The data source for metrics queries. Defaults to `"metrics"`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the query for use in formulas.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The metrics query definition.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[str]:
        """
        The data source for metrics queries. Defaults to `"metrics"`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class ServiceLevelObjectiveThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetDisplay":
            suggest = "target_display"
        elif key == "warningDisplay":
            suggest = "warning_display"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceLevelObjectiveThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceLevelObjectiveThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceLevelObjectiveThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target: float,
                 timeframe: str,
                 target_display: Optional[str] = None,
                 warning: Optional[float] = None,
                 warning_display: Optional[str] = None):
        """
        :param float target: The objective's target in `(0,100)`.
        :param str timeframe: The time frame for the objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API documentation page. Valid values are `7d`, `30d`, `90d`, `custom`.
        :param str target_display: A string representation of the target that indicates its precision. It uses trailing zeros to show significant decimal places (e.g. `98.00`).
        :param float warning: The objective's warning value in `(0,100)`. This must be greater than the target value.
        :param str warning_display: A string representation of the warning target (see the description of the target_display field for details).
        """
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "timeframe", timeframe)
        if target_display is not None:
            pulumi.set(__self__, "target_display", target_display)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)
        if warning_display is not None:
            pulumi.set(__self__, "warning_display", warning_display)

    @property
    @pulumi.getter
    def target(self) -> float:
        """
        The objective's target in `(0,100)`.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def timeframe(self) -> str:
        """
        The time frame for the objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API documentation page. Valid values are `7d`, `30d`, `90d`, `custom`.
        """
        return pulumi.get(self, "timeframe")

    @property
    @pulumi.getter(name="targetDisplay")
    def target_display(self) -> Optional[str]:
        """
        A string representation of the target that indicates its precision. It uses trailing zeros to show significant decimal places (e.g. `98.00`).
        """
        return pulumi.get(self, "target_display")

    @property
    @pulumi.getter
    def warning(self) -> Optional[float]:
        """
        The objective's warning value in `(0,100)`. This must be greater than the target value.
        """
        return pulumi.get(self, "warning")

    @property
    @pulumi.getter(name="warningDisplay")
    def warning_display(self) -> Optional[str]:
        """
        A string representation of the warning target (see the description of the target_display field for details).
        """
        return pulumi.get(self, "warning_display")


@pulumi.output_type
class SpansMetricCompute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"
        elif key == "includePercentiles":
            suggest = "include_percentiles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpansMetricCompute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpansMetricCompute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpansMetricCompute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregation_type: str,
                 include_percentiles: Optional[bool] = None,
                 path: Optional[str] = None):
        """
        :param str aggregation_type: The type of aggregation to use. This field can't be updated after creation.
        :param bool include_percentiles: Toggle to include or exclude percentile aggregations for distribution metrics. Only present when the `aggregation_type` is `distribution`.
        :param str path: The path to the value the span-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
        """
        pulumi.set(__self__, "aggregation_type", aggregation_type)
        if include_percentiles is not None:
            pulumi.set(__self__, "include_percentiles", include_percentiles)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> str:
        """
        The type of aggregation to use. This field can't be updated after creation.
        """
        return pulumi.get(self, "aggregation_type")

    @property
    @pulumi.getter(name="includePercentiles")
    def include_percentiles(self) -> Optional[bool]:
        """
        Toggle to include or exclude percentile aggregations for distribution metrics. Only present when the `aggregation_type` is `distribution`.
        """
        return pulumi.get(self, "include_percentiles")

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        The path to the value the span-based metric will aggregate on (only used if the aggregation type is a "distribution"). This field can't be updated after creation.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class SpansMetricFilter(dict):
    def __init__(__self__, *,
                 query: Optional[str] = None):
        """
        :param str query: The search query - following the span search syntax. Defaults to `"*"`.
        """
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        The search query - following the span search syntax. Defaults to `"*"`.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class SpansMetricGroupBy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagName":
            suggest = "tag_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpansMetricGroupBy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpansMetricGroupBy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpansMetricGroupBy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 tag_name: Optional[str] = None):
        """
        :param str path: The path to the value the span-based metric will be aggregated over.
        :param str tag_name: Eventual name of the tag that gets created. By default, the path attribute is used as the tag name.
        """
        pulumi.set(__self__, "path", path)
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The path to the value the span-based metric will be aggregated over.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[str]:
        """
        Eventual name of the tag that gets created. By default, the path attribute is used as the tag name.
        """
        return pulumi.get(self, "tag_name")


@pulumi.output_type
class SyntheticsGlobalVariableOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "totpParameters":
            suggest = "totp_parameters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsGlobalVariableOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsGlobalVariableOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsGlobalVariableOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 totp_parameters: Optional['outputs.SyntheticsGlobalVariableOptionsTotpParameters'] = None):
        """
        :param 'SyntheticsGlobalVariableOptionsTotpParametersArgs' totp_parameters: Parameters needed for MFA/TOTP.
        """
        if totp_parameters is not None:
            pulumi.set(__self__, "totp_parameters", totp_parameters)

    @property
    @pulumi.getter(name="totpParameters")
    def totp_parameters(self) -> Optional['outputs.SyntheticsGlobalVariableOptionsTotpParameters']:
        """
        Parameters needed for MFA/TOTP.
        """
        return pulumi.get(self, "totp_parameters")


@pulumi.output_type
class SyntheticsGlobalVariableOptionsTotpParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "refreshInterval":
            suggest = "refresh_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsGlobalVariableOptionsTotpParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsGlobalVariableOptionsTotpParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsGlobalVariableOptionsTotpParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 digits: int,
                 refresh_interval: int):
        """
        :param int digits: Number of digits for the OTP.
        :param int refresh_interval: Interval for which to refresh the token (in seconds).
        """
        pulumi.set(__self__, "digits", digits)
        pulumi.set(__self__, "refresh_interval", refresh_interval)

    @property
    @pulumi.getter
    def digits(self) -> int:
        """
        Number of digits for the OTP.
        """
        return pulumi.get(self, "digits")

    @property
    @pulumi.getter(name="refreshInterval")
    def refresh_interval(self) -> int:
        """
        Interval for which to refresh the token (in seconds).
        """
        return pulumi.get(self, "refresh_interval")


@pulumi.output_type
class SyntheticsGlobalVariableParseTestOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localVariableName":
            suggest = "local_variable_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsGlobalVariableParseTestOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsGlobalVariableParseTestOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsGlobalVariableParseTestOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 field: Optional[str] = None,
                 local_variable_name: Optional[str] = None,
                 parser: Optional['outputs.SyntheticsGlobalVariableParseTestOptionsParser'] = None):
        """
        :param str type: Defines the source to use to extract the value. Valid values are `http_body`, `http_header`, `http_status_code`, `local_variable`.
        :param str field: Required when type = `http_header`. Defines the header to use to extract the value
        :param str local_variable_name: When type is `local_variable`, name of the local variable to use to extract the value.
        """
        pulumi.set(__self__, "type", type)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if local_variable_name is not None:
            pulumi.set(__self__, "local_variable_name", local_variable_name)
        if parser is not None:
            pulumi.set(__self__, "parser", parser)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Defines the source to use to extract the value. Valid values are `http_body`, `http_header`, `http_status_code`, `local_variable`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        """
        Required when type = `http_header`. Defines the header to use to extract the value
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter(name="localVariableName")
    def local_variable_name(self) -> Optional[str]:
        """
        When type is `local_variable`, name of the local variable to use to extract the value.
        """
        return pulumi.get(self, "local_variable_name")

    @property
    @pulumi.getter
    def parser(self) -> Optional['outputs.SyntheticsGlobalVariableParseTestOptionsParser']:
        return pulumi.get(self, "parser")


@pulumi.output_type
class SyntheticsGlobalVariableParseTestOptionsParser(dict):
    def __init__(__self__, *,
                 type: str,
                 value: Optional[str] = None):
        """
        :param str type: Type of parser to extract the value. Valid values are `raw`, `json_path`, `regex`, `x_path`.
        :param str value: Value for the parser to use, required for type `json_path` or `regex`.
        """
        pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of parser to extract the value. Valid values are `raw`, `json_path`, `regex`, `x_path`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value for the parser to use, required for type `json_path` or `regex`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SyntheticsPrivateLocationMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "restrictedRoles":
            suggest = "restricted_roles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsPrivateLocationMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsPrivateLocationMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsPrivateLocationMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 restricted_roles: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] restricted_roles: A list of role identifiers pulled from the Roles API to restrict read and write access.
        """
        if restricted_roles is not None:
            pulumi.set(__self__, "restricted_roles", restricted_roles)

    @property
    @pulumi.getter(name="restrictedRoles")
    def restricted_roles(self) -> Optional[Sequence[str]]:
        """
        A list of role identifiers pulled from the Roles API to restrict read and write access.
        """
        return pulumi.get(self, "restricted_roles")


@pulumi.output_type
class SyntheticsTestApiStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowFailure":
            suggest = "allow_failure"
        elif key == "exitIfSucceed":
            suggest = "exit_if_succeed"
        elif key == "extractedValues":
            suggest = "extracted_values"
        elif key == "isCritical":
            suggest = "is_critical"
        elif key == "requestBasicauth":
            suggest = "request_basicauth"
        elif key == "requestClientCertificate":
            suggest = "request_client_certificate"
        elif key == "requestDefinition":
            suggest = "request_definition"
        elif key == "requestFiles":
            suggest = "request_files"
        elif key == "requestHeaders":
            suggest = "request_headers"
        elif key == "requestMetadata":
            suggest = "request_metadata"
        elif key == "requestProxy":
            suggest = "request_proxy"
        elif key == "requestQuery":
            suggest = "request_query"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestApiStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestApiStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestApiStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 allow_failure: Optional[bool] = None,
                 assertions: Optional[Sequence['outputs.SyntheticsTestApiStepAssertion']] = None,
                 exit_if_succeed: Optional[bool] = None,
                 extracted_values: Optional[Sequence['outputs.SyntheticsTestApiStepExtractedValue']] = None,
                 is_critical: Optional[bool] = None,
                 request_basicauth: Optional['outputs.SyntheticsTestApiStepRequestBasicauth'] = None,
                 request_client_certificate: Optional['outputs.SyntheticsTestApiStepRequestClientCertificate'] = None,
                 request_definition: Optional['outputs.SyntheticsTestApiStepRequestDefinition'] = None,
                 request_files: Optional[Sequence['outputs.SyntheticsTestApiStepRequestFile']] = None,
                 request_headers: Optional[Mapping[str, str]] = None,
                 request_metadata: Optional[Mapping[str, str]] = None,
                 request_proxy: Optional['outputs.SyntheticsTestApiStepRequestProxy'] = None,
                 request_query: Optional[Mapping[str, str]] = None,
                 retry: Optional['outputs.SyntheticsTestApiStepRetry'] = None,
                 subtype: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param str name: The name of the step.
        :param bool allow_failure: Determines whether or not to continue with test if this step fails.
        :param Sequence['SyntheticsTestApiStepAssertionArgs'] assertions: Assertions used for the test. Multiple `assertion` blocks are allowed with the structure below.
        :param bool exit_if_succeed: Determines whether or not to exit the test if the step succeeds.
        :param Sequence['SyntheticsTestApiStepExtractedValueArgs'] extracted_values: Values to parse and save as variables from the response.
        :param bool is_critical: Determines whether or not to consider the entire test as failed if this step fails. Can be used only if `allow_failure` is `true`.
        :param 'SyntheticsTestApiStepRequestBasicauthArgs' request_basicauth: The HTTP basic authentication credentials. Exactly one nested block is allowed with the structure below.
        :param 'SyntheticsTestApiStepRequestClientCertificateArgs' request_client_certificate: Client certificate to use when performing the test request. Exactly one nested block is allowed with the structure below.
        :param 'SyntheticsTestApiStepRequestDefinitionArgs' request_definition: The request for the api step.
        :param Sequence['SyntheticsTestApiStepRequestFileArgs'] request_files: Files to be used as part of the request in the test.
        :param Mapping[str, str] request_headers: Header name and value map.
        :param Mapping[str, str] request_metadata: Metadata to include when performing the gRPC request.
        :param 'SyntheticsTestApiStepRequestProxyArgs' request_proxy: The proxy to perform the test.
        :param Mapping[str, str] request_query: Query arguments name and value map.
        :param str subtype: The subtype of the Synthetic multi-step API test step. Valid values are `http`, `grpc`, `wait`. Defaults to `"http"`.
        :param int value: The time to wait in seconds. Minimum value: 0. Maximum value: 180.
        """
        pulumi.set(__self__, "name", name)
        if allow_failure is not None:
            pulumi.set(__self__, "allow_failure", allow_failure)
        if assertions is not None:
            pulumi.set(__self__, "assertions", assertions)
        if exit_if_succeed is not None:
            pulumi.set(__self__, "exit_if_succeed", exit_if_succeed)
        if extracted_values is not None:
            pulumi.set(__self__, "extracted_values", extracted_values)
        if is_critical is not None:
            pulumi.set(__self__, "is_critical", is_critical)
        if request_basicauth is not None:
            pulumi.set(__self__, "request_basicauth", request_basicauth)
        if request_client_certificate is not None:
            pulumi.set(__self__, "request_client_certificate", request_client_certificate)
        if request_definition is not None:
            pulumi.set(__self__, "request_definition", request_definition)
        if request_files is not None:
            pulumi.set(__self__, "request_files", request_files)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if request_metadata is not None:
            pulumi.set(__self__, "request_metadata", request_metadata)
        if request_proxy is not None:
            pulumi.set(__self__, "request_proxy", request_proxy)
        if request_query is not None:
            pulumi.set(__self__, "request_query", request_query)
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if subtype is not None:
            pulumi.set(__self__, "subtype", subtype)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the step.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="allowFailure")
    def allow_failure(self) -> Optional[bool]:
        """
        Determines whether or not to continue with test if this step fails.
        """
        return pulumi.get(self, "allow_failure")

    @property
    @pulumi.getter
    def assertions(self) -> Optional[Sequence['outputs.SyntheticsTestApiStepAssertion']]:
        """
        Assertions used for the test. Multiple `assertion` blocks are allowed with the structure below.
        """
        return pulumi.get(self, "assertions")

    @property
    @pulumi.getter(name="exitIfSucceed")
    def exit_if_succeed(self) -> Optional[bool]:
        """
        Determines whether or not to exit the test if the step succeeds.
        """
        return pulumi.get(self, "exit_if_succeed")

    @property
    @pulumi.getter(name="extractedValues")
    def extracted_values(self) -> Optional[Sequence['outputs.SyntheticsTestApiStepExtractedValue']]:
        """
        Values to parse and save as variables from the response.
        """
        return pulumi.get(self, "extracted_values")

    @property
    @pulumi.getter(name="isCritical")
    def is_critical(self) -> Optional[bool]:
        """
        Determines whether or not to consider the entire test as failed if this step fails. Can be used only if `allow_failure` is `true`.
        """
        return pulumi.get(self, "is_critical")

    @property
    @pulumi.getter(name="requestBasicauth")
    def request_basicauth(self) -> Optional['outputs.SyntheticsTestApiStepRequestBasicauth']:
        """
        The HTTP basic authentication credentials. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "request_basicauth")

    @property
    @pulumi.getter(name="requestClientCertificate")
    def request_client_certificate(self) -> Optional['outputs.SyntheticsTestApiStepRequestClientCertificate']:
        """
        Client certificate to use when performing the test request. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "request_client_certificate")

    @property
    @pulumi.getter(name="requestDefinition")
    def request_definition(self) -> Optional['outputs.SyntheticsTestApiStepRequestDefinition']:
        """
        The request for the api step.
        """
        return pulumi.get(self, "request_definition")

    @property
    @pulumi.getter(name="requestFiles")
    def request_files(self) -> Optional[Sequence['outputs.SyntheticsTestApiStepRequestFile']]:
        """
        Files to be used as part of the request in the test.
        """
        return pulumi.get(self, "request_files")

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[Mapping[str, str]]:
        """
        Header name and value map.
        """
        return pulumi.get(self, "request_headers")

    @property
    @pulumi.getter(name="requestMetadata")
    def request_metadata(self) -> Optional[Mapping[str, str]]:
        """
        Metadata to include when performing the gRPC request.
        """
        return pulumi.get(self, "request_metadata")

    @property
    @pulumi.getter(name="requestProxy")
    def request_proxy(self) -> Optional['outputs.SyntheticsTestApiStepRequestProxy']:
        """
        The proxy to perform the test.
        """
        return pulumi.get(self, "request_proxy")

    @property
    @pulumi.getter(name="requestQuery")
    def request_query(self) -> Optional[Mapping[str, str]]:
        """
        Query arguments name and value map.
        """
        return pulumi.get(self, "request_query")

    @property
    @pulumi.getter
    def retry(self) -> Optional['outputs.SyntheticsTestApiStepRetry']:
        return pulumi.get(self, "retry")

    @property
    @pulumi.getter
    def subtype(self) -> Optional[str]:
        """
        The subtype of the Synthetic multi-step API test step. Valid values are `http`, `grpc`, `wait`. Defaults to `"http"`.
        """
        return pulumi.get(self, "subtype")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        The time to wait in seconds. Minimum value: 0. Maximum value: 180.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SyntheticsTestApiStepAssertion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timingsScope":
            suggest = "timings_scope"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestApiStepAssertion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestApiStepAssertion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestApiStepAssertion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 code: Optional[str] = None,
                 operator: Optional[str] = None,
                 property: Optional[str] = None,
                 target: Optional[str] = None,
                 targetjsonpath: Optional['outputs.SyntheticsTestApiStepAssertionTargetjsonpath'] = None,
                 targetjsonschema: Optional['outputs.SyntheticsTestApiStepAssertionTargetjsonschema'] = None,
                 targetxpath: Optional['outputs.SyntheticsTestApiStepAssertionTargetxpath'] = None,
                 timings_scope: Optional[str] = None):
        """
        :param str type: Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`, `bodyHash`, `javascript`.
        :param str code: If assertion type is `javascript`, this is the JavaScript code that performs the assertions.
        :param str operator: Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        :param str property: If assertion type is `header`, this is the header name.
        :param str target: Expected value. Depends on the assertion type, refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test) for details.
        :param 'SyntheticsTestApiStepAssertionTargetjsonpathArgs' targetjsonpath: Expected structure if `operator` is `validatesJSONPath`. Exactly one nested block is allowed with the structure below.
        :param 'SyntheticsTestApiStepAssertionTargetjsonschemaArgs' targetjsonschema: Expected structure if `operator` is `validatesJSONSchema`. Exactly one nested block is allowed with the structure below.
        :param 'SyntheticsTestApiStepAssertionTargetxpathArgs' targetxpath: Expected structure if `operator` is `validatesXPath`. Exactly one nested block is allowed with the structure below.
        :param str timings_scope: Timings scope for response time assertions. Valid values are `all`, `withoutDNS`.
        """
        pulumi.set(__self__, "type", type)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if targetjsonpath is not None:
            pulumi.set(__self__, "targetjsonpath", targetjsonpath)
        if targetjsonschema is not None:
            pulumi.set(__self__, "targetjsonschema", targetjsonschema)
        if targetxpath is not None:
            pulumi.set(__self__, "targetxpath", targetxpath)
        if timings_scope is not None:
            pulumi.set(__self__, "timings_scope", timings_scope)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`, `bodyHash`, `javascript`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        If assertion type is `javascript`, this is the JavaScript code that performs the assertions.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Expected value. Depends on the assertion type, refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test) for details.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def targetjsonpath(self) -> Optional['outputs.SyntheticsTestApiStepAssertionTargetjsonpath']:
        """
        Expected structure if `operator` is `validatesJSONPath`. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "targetjsonpath")

    @property
    @pulumi.getter
    def targetjsonschema(self) -> Optional['outputs.SyntheticsTestApiStepAssertionTargetjsonschema']:
        """
        Expected structure if `operator` is `validatesJSONSchema`. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "targetjsonschema")

    @property
    @pulumi.getter
    def targetxpath(self) -> Optional['outputs.SyntheticsTestApiStepAssertionTargetxpath']:
        """
        Expected structure if `operator` is `validatesXPath`. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "targetxpath")

    @property
    @pulumi.getter(name="timingsScope")
    def timings_scope(self) -> Optional[str]:
        """
        Timings scope for response time assertions. Valid values are `all`, `withoutDNS`.
        """
        return pulumi.get(self, "timings_scope")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        """
        If assertion type is `header`, this is the header name.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class SyntheticsTestApiStepAssertionTargetjsonpath(dict):
    def __init__(__self__, *,
                 jsonpath: str,
                 operator: str,
                 elementsoperator: Optional[str] = None,
                 targetvalue: Optional[str] = None):
        """
        :param str jsonpath: The JSON path to assert.
        :param str operator: The specific operator to use on the path.
        :param str elementsoperator: The element from the list of results to assert on. Select from `firstElementMatches` (the first element in the list), `everyElementMatches` (every element in the list), `atLeastOneElementMatches` (at least one element in the list), or `serializationMatches` (the serialized value of the list). Defaults to `firstElementMatches`. Defaults to `"firstElementMatches"`.
        :param str targetvalue: Expected matching value.
        """
        pulumi.set(__self__, "jsonpath", jsonpath)
        pulumi.set(__self__, "operator", operator)
        if elementsoperator is not None:
            pulumi.set(__self__, "elementsoperator", elementsoperator)
        if targetvalue is not None:
            pulumi.set(__self__, "targetvalue", targetvalue)

    @property
    @pulumi.getter
    def jsonpath(self) -> str:
        """
        The JSON path to assert.
        """
        return pulumi.get(self, "jsonpath")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The specific operator to use on the path.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def elementsoperator(self) -> Optional[str]:
        """
        The element from the list of results to assert on. Select from `firstElementMatches` (the first element in the list), `everyElementMatches` (every element in the list), `atLeastOneElementMatches` (at least one element in the list), or `serializationMatches` (the serialized value of the list). Defaults to `firstElementMatches`. Defaults to `"firstElementMatches"`.
        """
        return pulumi.get(self, "elementsoperator")

    @property
    @pulumi.getter
    def targetvalue(self) -> Optional[str]:
        """
        Expected matching value.
        """
        return pulumi.get(self, "targetvalue")


@pulumi.output_type
class SyntheticsTestApiStepAssertionTargetjsonschema(dict):
    def __init__(__self__, *,
                 jsonschema: str,
                 metaschema: Optional[str] = None):
        """
        :param str jsonschema: The JSON Schema to validate the body against.
        :param str metaschema: The meta schema to use for the JSON Schema. Defaults to `"draft-07"`.
        """
        pulumi.set(__self__, "jsonschema", jsonschema)
        if metaschema is not None:
            pulumi.set(__self__, "metaschema", metaschema)

    @property
    @pulumi.getter
    def jsonschema(self) -> str:
        """
        The JSON Schema to validate the body against.
        """
        return pulumi.get(self, "jsonschema")

    @property
    @pulumi.getter
    def metaschema(self) -> Optional[str]:
        """
        The meta schema to use for the JSON Schema. Defaults to `"draft-07"`.
        """
        return pulumi.get(self, "metaschema")


@pulumi.output_type
class SyntheticsTestApiStepAssertionTargetxpath(dict):
    def __init__(__self__, *,
                 operator: str,
                 xpath: str,
                 targetvalue: Optional[str] = None):
        """
        :param str operator: The specific operator to use on the path.
        :param str xpath: The xpath to assert.
        :param str targetvalue: Expected matching value.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "xpath", xpath)
        if targetvalue is not None:
            pulumi.set(__self__, "targetvalue", targetvalue)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The specific operator to use on the path.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def xpath(self) -> str:
        """
        The xpath to assert.
        """
        return pulumi.get(self, "xpath")

    @property
    @pulumi.getter
    def targetvalue(self) -> Optional[str]:
        """
        Expected matching value.
        """
        return pulumi.get(self, "targetvalue")


@pulumi.output_type
class SyntheticsTestApiStepExtractedValue(dict):
    def __init__(__self__, *,
                 name: str,
                 parser: 'outputs.SyntheticsTestApiStepExtractedValueParser',
                 type: str,
                 field: Optional[str] = None,
                 secure: Optional[bool] = None):
        """
        :param str type: Property of the Synthetics Test Response to use for the variable. Valid values are `grpc_message`, `grpc_metadata`, `http_body`, `http_header`, `http_status_code`.
        :param str field: When type is `http_header` or `grpc_metadata`, name of the header or metadatum to extract.
        :param bool secure: Determines whether or not the extracted value will be obfuscated.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parser", parser)
        pulumi.set(__self__, "type", type)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parser(self) -> 'outputs.SyntheticsTestApiStepExtractedValueParser':
        return pulumi.get(self, "parser")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Property of the Synthetics Test Response to use for the variable. Valid values are `grpc_message`, `grpc_metadata`, `http_body`, `http_header`, `http_status_code`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        """
        When type is `http_header` or `grpc_metadata`, name of the header or metadatum to extract.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def secure(self) -> Optional[bool]:
        """
        Determines whether or not the extracted value will be obfuscated.
        """
        return pulumi.get(self, "secure")


@pulumi.output_type
class SyntheticsTestApiStepExtractedValueParser(dict):
    def __init__(__self__, *,
                 type: str,
                 value: Optional[str] = None):
        """
        :param str type: Type of parser for a Synthetics global variable from a synthetics test. Valid values are `raw`, `json_path`, `regex`, `x_path`.
        :param str value: Regex or JSON path used for the parser. Not used with type `raw`.
        """
        pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of parser for a Synthetics global variable from a synthetics test. Valid values are `raw`, `json_path`, `regex`, `x_path`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Regex or JSON path used for the parser. Not used with type `raw`.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class SyntheticsTestApiStepRequestBasicauth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accessTokenUrl":
            suggest = "access_token_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "sessionToken":
            suggest = "session_token"
        elif key == "tokenApiAuthentication":
            suggest = "token_api_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestApiStepRequestBasicauth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestApiStepRequestBasicauth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestApiStepRequestBasicauth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 access_token_url: Optional[str] = None,
                 audience: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 domain: Optional[str] = None,
                 password: Optional[str] = None,
                 region: Optional[str] = None,
                 resource: Optional[str] = None,
                 scope: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 service_name: Optional[str] = None,
                 session_token: Optional[str] = None,
                 token_api_authentication: Optional[str] = None,
                 type: Optional[str] = None,
                 username: Optional[str] = None,
                 workstation: Optional[str] = None):
        """
        :param str access_key: Access key for `SIGV4` authentication.
        :param str access_token_url: Access token url for `oauth-client` or `oauth-rop` authentication.
        :param str audience: Audience for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        :param str client_id: Client ID for `oauth-client` or `oauth-rop` authentication.
        :param str client_secret: Client secret for `oauth-client` or `oauth-rop` authentication.
        :param str domain: Domain for `ntlm` authentication.
        :param str password: Password for authentication.
        :param str region: Region for `SIGV4` authentication.
        :param str resource: Resource for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        :param str scope: Scope for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        :param str secret_key: Secret key for `SIGV4` authentication.
        :param str service_name: Service name for `SIGV4` authentication.
        :param str session_token: Session token for `SIGV4` authentication.
        :param str token_api_authentication: Token API Authentication for `oauth-client` or `oauth-rop` authentication. Valid values are `header`, `body`.
        :param str type: Type of basic authentication to use when performing the test. Defaults to `"web"`.
        :param str username: Username for authentication.
        :param str workstation: Workstation for `ntlm` authentication.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if access_token_url is not None:
            pulumi.set(__self__, "access_token_url", access_token_url)
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)
        if token_api_authentication is not None:
            pulumi.set(__self__, "token_api_authentication", token_api_authentication)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if workstation is not None:
            pulumi.set(__self__, "workstation", workstation)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Access key for `SIGV4` authentication.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accessTokenUrl")
    def access_token_url(self) -> Optional[str]:
        """
        Access token url for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "access_token_url")

    @property
    @pulumi.getter
    def audience(self) -> Optional[str]:
        """
        Audience for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Client ID for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        Client secret for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Domain for `ntlm` authentication.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region for `SIGV4` authentication.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        Resource for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        Scope for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Secret key for `SIGV4` authentication.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        Service name for `SIGV4` authentication.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[str]:
        """
        Session token for `SIGV4` authentication.
        """
        return pulumi.get(self, "session_token")

    @property
    @pulumi.getter(name="tokenApiAuthentication")
    def token_api_authentication(self) -> Optional[str]:
        """
        Token API Authentication for `oauth-client` or `oauth-rop` authentication. Valid values are `header`, `body`.
        """
        return pulumi.get(self, "token_api_authentication")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of basic authentication to use when performing the test. Defaults to `"web"`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def workstation(self) -> Optional[str]:
        """
        Workstation for `ntlm` authentication.
        """
        return pulumi.get(self, "workstation")


@pulumi.output_type
class SyntheticsTestApiStepRequestClientCertificate(dict):
    def __init__(__self__, *,
                 cert: 'outputs.SyntheticsTestApiStepRequestClientCertificateCert',
                 key: 'outputs.SyntheticsTestApiStepRequestClientCertificateKey'):
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def cert(self) -> 'outputs.SyntheticsTestApiStepRequestClientCertificateCert':
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def key(self) -> 'outputs.SyntheticsTestApiStepRequestClientCertificateKey':
        return pulumi.get(self, "key")


@pulumi.output_type
class SyntheticsTestApiStepRequestClientCertificateCert(dict):
    def __init__(__self__, *,
                 content: str,
                 filename: Optional[str] = None):
        """
        :param str content: Content of the certificate.
        :param str filename: File name for the certificate.
        """
        pulumi.set(__self__, "content", content)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Content of the certificate.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        """
        File name for the certificate.
        """
        return pulumi.get(self, "filename")


@pulumi.output_type
class SyntheticsTestApiStepRequestClientCertificateKey(dict):
    def __init__(__self__, *,
                 content: str,
                 filename: Optional[str] = None):
        """
        :param str content: Content of the certificate.
        :param str filename: File name for the certificate.
        """
        pulumi.set(__self__, "content", content)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Content of the certificate.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        """
        File name for the certificate.
        """
        return pulumi.get(self, "filename")


@pulumi.output_type
class SyntheticsTestApiStepRequestDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowInsecure":
            suggest = "allow_insecure"
        elif key == "bodyType":
            suggest = "body_type"
        elif key == "callType":
            suggest = "call_type"
        elif key == "certificateDomains":
            suggest = "certificate_domains"
        elif key == "dnsServer":
            suggest = "dns_server"
        elif key == "dnsServerPort":
            suggest = "dns_server_port"
        elif key == "followRedirects":
            suggest = "follow_redirects"
        elif key == "httpVersion":
            suggest = "http_version"
        elif key == "noSavingResponseBody":
            suggest = "no_saving_response_body"
        elif key == "numberOfPackets":
            suggest = "number_of_packets"
        elif key == "persistCookies":
            suggest = "persist_cookies"
        elif key == "plainProtoFile":
            suggest = "plain_proto_file"
        elif key == "protoJsonDescriptor":
            suggest = "proto_json_descriptor"
        elif key == "shouldTrackHops":
            suggest = "should_track_hops"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestApiStepRequestDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestApiStepRequestDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestApiStepRequestDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_insecure: Optional[bool] = None,
                 body: Optional[str] = None,
                 body_type: Optional[str] = None,
                 call_type: Optional[str] = None,
                 certificate_domains: Optional[Sequence[str]] = None,
                 dns_server: Optional[str] = None,
                 dns_server_port: Optional[str] = None,
                 follow_redirects: Optional[bool] = None,
                 host: Optional[str] = None,
                 http_version: Optional[str] = None,
                 message: Optional[str] = None,
                 method: Optional[str] = None,
                 no_saving_response_body: Optional[bool] = None,
                 number_of_packets: Optional[int] = None,
                 persist_cookies: Optional[bool] = None,
                 plain_proto_file: Optional[str] = None,
                 port: Optional[str] = None,
                 proto_json_descriptor: Optional[str] = None,
                 servername: Optional[str] = None,
                 service: Optional[str] = None,
                 should_track_hops: Optional[bool] = None,
                 timeout: Optional[int] = None,
                 url: Optional[str] = None):
        """
        :param bool allow_insecure: Allows loading insecure content for a request in an API test or in a multistep API test step.
        :param str body: The request body.
        :param str body_type: Type of the request body. Valid values are `text/plain`, `application/json`, `text/xml`, `text/html`, `application/x-www-form-urlencoded`, `graphql`, `application/octet-stream`, `multipart/form-data`.
        :param str call_type: The type of gRPC call to perform. Valid values are `healthcheck`, `unary`.
        :param Sequence[str] certificate_domains: By default, the client certificate is applied on the domain of the starting URL for browser tests. If you want your client certificate to be applied on other domains instead, add them in `certificate_domains`.
        :param str dns_server: DNS server to use for DNS tests (`subtype = "dns"`).
        :param str dns_server_port: DNS server port to use for DNS tests.
        :param bool follow_redirects: Determines whether or not the API HTTP test should follow redirects.
        :param str host: Host name to perform the test with.
        :param str http_version: HTTP version to use for an HTTP request in an API test or step. Valid values are `http1`, `http2`, `any`. Defaults to `"any"`.
        :param str message: For UDP and websocket tests, message to send with the request.
        :param str method: Either the HTTP method/verb to use or a gRPC method available on the service set in the `service` field. Required if `subtype` is `HTTP` or if `subtype` is `grpc` and `callType` is `unary`.
        :param bool no_saving_response_body: Determines whether or not to save the response body.
        :param int number_of_packets: Number of pings to use per test for ICMP tests (`subtype = "icmp"`) between 0 and 10.
        :param bool persist_cookies: Persist cookies across redirects.
        :param str plain_proto_file: The content of a proto file as a string.
        :param str port: Port to use when performing the test.
        :param str proto_json_descriptor: A protobuf JSON descriptor. **Deprecated.** Use `plain_proto_file` instead.
        :param str servername: For SSL tests, it specifies on which server you want to initiate the TLS handshake, allowing the server to present one of multiple possible certificates on the same IP address and TCP port number.
        :param str service: The gRPC service on which you want to perform the gRPC call.
        :param bool should_track_hops: This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (`subtype = "icmp"`).
        :param int timeout: Timeout in seconds for the test.
        :param str url: The URL to send the request to.
        """
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if body is not None:
            pulumi.set(__self__, "body", body)
        if body_type is not None:
            pulumi.set(__self__, "body_type", body_type)
        if call_type is not None:
            pulumi.set(__self__, "call_type", call_type)
        if certificate_domains is not None:
            pulumi.set(__self__, "certificate_domains", certificate_domains)
        if dns_server is not None:
            pulumi.set(__self__, "dns_server", dns_server)
        if dns_server_port is not None:
            pulumi.set(__self__, "dns_server_port", dns_server_port)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_version is not None:
            pulumi.set(__self__, "http_version", http_version)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if no_saving_response_body is not None:
            pulumi.set(__self__, "no_saving_response_body", no_saving_response_body)
        if number_of_packets is not None:
            pulumi.set(__self__, "number_of_packets", number_of_packets)
        if persist_cookies is not None:
            pulumi.set(__self__, "persist_cookies", persist_cookies)
        if plain_proto_file is not None:
            pulumi.set(__self__, "plain_proto_file", plain_proto_file)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if proto_json_descriptor is not None:
            pulumi.set(__self__, "proto_json_descriptor", proto_json_descriptor)
        if servername is not None:
            pulumi.set(__self__, "servername", servername)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if should_track_hops is not None:
            pulumi.set(__self__, "should_track_hops", should_track_hops)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[bool]:
        """
        Allows loading insecure content for a request in an API test or in a multistep API test step.
        """
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        The request body.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="bodyType")
    def body_type(self) -> Optional[str]:
        """
        Type of the request body. Valid values are `text/plain`, `application/json`, `text/xml`, `text/html`, `application/x-www-form-urlencoded`, `graphql`, `application/octet-stream`, `multipart/form-data`.
        """
        return pulumi.get(self, "body_type")

    @property
    @pulumi.getter(name="callType")
    def call_type(self) -> Optional[str]:
        """
        The type of gRPC call to perform. Valid values are `healthcheck`, `unary`.
        """
        return pulumi.get(self, "call_type")

    @property
    @pulumi.getter(name="certificateDomains")
    def certificate_domains(self) -> Optional[Sequence[str]]:
        """
        By default, the client certificate is applied on the domain of the starting URL for browser tests. If you want your client certificate to be applied on other domains instead, add them in `certificate_domains`.
        """
        return pulumi.get(self, "certificate_domains")

    @property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> Optional[str]:
        """
        DNS server to use for DNS tests (`subtype = "dns"`).
        """
        return pulumi.get(self, "dns_server")

    @property
    @pulumi.getter(name="dnsServerPort")
    def dns_server_port(self) -> Optional[str]:
        """
        DNS server port to use for DNS tests.
        """
        return pulumi.get(self, "dns_server_port")

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[bool]:
        """
        Determines whether or not the API HTTP test should follow redirects.
        """
        return pulumi.get(self, "follow_redirects")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to perform the test with.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpVersion")
    def http_version(self) -> Optional[str]:
        """
        HTTP version to use for an HTTP request in an API test or step. Valid values are `http1`, `http2`, `any`. Defaults to `"any"`.
        """
        return pulumi.get(self, "http_version")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        For UDP and websocket tests, message to send with the request.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Either the HTTP method/verb to use or a gRPC method available on the service set in the `service` field. Required if `subtype` is `HTTP` or if `subtype` is `grpc` and `callType` is `unary`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="noSavingResponseBody")
    def no_saving_response_body(self) -> Optional[bool]:
        """
        Determines whether or not to save the response body.
        """
        return pulumi.get(self, "no_saving_response_body")

    @property
    @pulumi.getter(name="numberOfPackets")
    def number_of_packets(self) -> Optional[int]:
        """
        Number of pings to use per test for ICMP tests (`subtype = "icmp"`) between 0 and 10.
        """
        return pulumi.get(self, "number_of_packets")

    @property
    @pulumi.getter(name="persistCookies")
    def persist_cookies(self) -> Optional[bool]:
        """
        Persist cookies across redirects.
        """
        return pulumi.get(self, "persist_cookies")

    @property
    @pulumi.getter(name="plainProtoFile")
    def plain_proto_file(self) -> Optional[str]:
        """
        The content of a proto file as a string.
        """
        return pulumi.get(self, "plain_proto_file")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Port to use when performing the test.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="protoJsonDescriptor")
    @_utilities.deprecated("""Use `plain_proto_file` instead.""")
    def proto_json_descriptor(self) -> Optional[str]:
        """
        A protobuf JSON descriptor. **Deprecated.** Use `plain_proto_file` instead.
        """
        return pulumi.get(self, "proto_json_descriptor")

    @property
    @pulumi.getter
    def servername(self) -> Optional[str]:
        """
        For SSL tests, it specifies on which server you want to initiate the TLS handshake, allowing the server to present one of multiple possible certificates on the same IP address and TCP port number.
        """
        return pulumi.get(self, "servername")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        The gRPC service on which you want to perform the gRPC call.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="shouldTrackHops")
    def should_track_hops(self) -> Optional[bool]:
        """
        This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (`subtype = "icmp"`).
        """
        return pulumi.get(self, "should_track_hops")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        Timeout in seconds for the test.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL to send the request to.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class SyntheticsTestApiStepRequestFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketKey":
            suggest = "bucket_key"
        elif key == "originalFileName":
            suggest = "original_file_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestApiStepRequestFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestApiStepRequestFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestApiStepRequestFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 size: int,
                 type: str,
                 bucket_key: Optional[str] = None,
                 content: Optional[str] = None,
                 original_file_name: Optional[str] = None):
        """
        :param str name: Name of the file.
        :param int size: Size of the file.
        :param str type: Type of the file.
        :param str bucket_key: Bucket key of the file.
        :param str content: Content of the file.
        :param str original_file_name: Original name of the file.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        if bucket_key is not None:
            pulumi.set(__self__, "bucket_key", bucket_key)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if original_file_name is not None:
            pulumi.set(__self__, "original_file_name", original_file_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the file.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Size of the file.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the file.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketKey")
    def bucket_key(self) -> Optional[str]:
        """
        Bucket key of the file.
        """
        return pulumi.get(self, "bucket_key")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        Content of the file.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="originalFileName")
    def original_file_name(self) -> Optional[str]:
        """
        Original name of the file.
        """
        return pulumi.get(self, "original_file_name")


@pulumi.output_type
class SyntheticsTestApiStepRequestProxy(dict):
    def __init__(__self__, *,
                 url: str,
                 headers: Optional[Mapping[str, str]] = None):
        """
        :param str url: URL of the proxy to perform the test.
        :param Mapping[str, str] headers: Header name and value map.
        """
        pulumi.set(__self__, "url", url)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL of the proxy to perform the test.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, str]]:
        """
        Header name and value map.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class SyntheticsTestApiStepRetry(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 interval: Optional[int] = None):
        """
        :param int count: Number of retries needed to consider a location as failed before sending a notification alert. Maximum value: `5`. Defaults to `0`.
        :param int interval: Interval between a failed test and the next retry in milliseconds. Maximum value: `5000`. Defaults to `300`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        Number of retries needed to consider a location as failed before sending a notification alert. Maximum value: `5`. Defaults to `0`.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Interval between a failed test and the next retry in milliseconds. Maximum value: `5000`. Defaults to `300`.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class SyntheticsTestAssertion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timingsScope":
            suggest = "timings_scope"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestAssertion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestAssertion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestAssertion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 code: Optional[str] = None,
                 operator: Optional[str] = None,
                 property: Optional[str] = None,
                 target: Optional[str] = None,
                 targetjsonpath: Optional['outputs.SyntheticsTestAssertionTargetjsonpath'] = None,
                 targetjsonschema: Optional['outputs.SyntheticsTestAssertionTargetjsonschema'] = None,
                 targetxpath: Optional['outputs.SyntheticsTestAssertionTargetxpath'] = None,
                 timings_scope: Optional[str] = None):
        """
        :param str type: Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`, `bodyHash`, `javascript`.
        :param str code: If assertion type is `javascript`, this is the JavaScript code that performs the assertions.
        :param str operator: Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        :param str property: If assertion type is `header`, this is the header name.
        :param str target: Expected value. Depends on the assertion type, refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test) for details.
        :param 'SyntheticsTestAssertionTargetjsonpathArgs' targetjsonpath: Expected structure if `operator` is `validatesJSONPath`. Exactly one nested block is allowed with the structure below.
        :param 'SyntheticsTestAssertionTargetjsonschemaArgs' targetjsonschema: Expected structure if `operator` is `validatesJSONSchema`. Exactly one nested block is allowed with the structure below.
        :param 'SyntheticsTestAssertionTargetxpathArgs' targetxpath: Expected structure if `operator` is `validatesXPath`. Exactly one nested block is allowed with the structure below.
        :param str timings_scope: Timings scope for response time assertions. Valid values are `all`, `withoutDNS`.
        """
        pulumi.set(__self__, "type", type)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if property is not None:
            pulumi.set(__self__, "property", property)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if targetjsonpath is not None:
            pulumi.set(__self__, "targetjsonpath", targetjsonpath)
        if targetjsonschema is not None:
            pulumi.set(__self__, "targetjsonschema", targetjsonschema)
        if targetxpath is not None:
            pulumi.set(__self__, "targetxpath", targetxpath)
        if timings_scope is not None:
            pulumi.set(__self__, "timings_scope", timings_scope)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of assertion. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)). Valid values are `body`, `header`, `statusCode`, `certificate`, `responseTime`, `property`, `recordEvery`, `recordSome`, `tlsVersion`, `minTlsVersion`, `latency`, `packetLossPercentage`, `packetsReceived`, `networkHop`, `receivedMessage`, `grpcHealthcheckStatus`, `grpcMetadata`, `grpcProto`, `connection`, `bodyHash`, `javascript`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        If assertion type is `javascript`, this is the JavaScript code that performs the assertions.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Assertion operator. **Note** Only some combinations of `type` and `operator` are valid (please refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test)).
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Expected value. Depends on the assertion type, refer to [Datadog documentation](https://docs.datadoghq.com/api/latest/synthetics/#create-a-test) for details.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def targetjsonpath(self) -> Optional['outputs.SyntheticsTestAssertionTargetjsonpath']:
        """
        Expected structure if `operator` is `validatesJSONPath`. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "targetjsonpath")

    @property
    @pulumi.getter
    def targetjsonschema(self) -> Optional['outputs.SyntheticsTestAssertionTargetjsonschema']:
        """
        Expected structure if `operator` is `validatesJSONSchema`. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "targetjsonschema")

    @property
    @pulumi.getter
    def targetxpath(self) -> Optional['outputs.SyntheticsTestAssertionTargetxpath']:
        """
        Expected structure if `operator` is `validatesXPath`. Exactly one nested block is allowed with the structure below.
        """
        return pulumi.get(self, "targetxpath")

    @property
    @pulumi.getter(name="timingsScope")
    def timings_scope(self) -> Optional[str]:
        """
        Timings scope for response time assertions. Valid values are `all`, `withoutDNS`.
        """
        return pulumi.get(self, "timings_scope")

    @property
    @pulumi.getter
    def property(self) -> Optional[str]:
        """
        If assertion type is `header`, this is the header name.
        """
        return pulumi.get(self, "property")


@pulumi.output_type
class SyntheticsTestAssertionTargetjsonpath(dict):
    def __init__(__self__, *,
                 jsonpath: str,
                 operator: str,
                 elementsoperator: Optional[str] = None,
                 targetvalue: Optional[str] = None):
        """
        :param str jsonpath: The JSON path to assert.
        :param str operator: The specific operator to use on the path.
        :param str elementsoperator: The element from the list of results to assert on. Select from `firstElementMatches` (the first element in the list), `everyElementMatches` (every element in the list), `atLeastOneElementMatches` (at least one element in the list), or `serializationMatches` (the serialized value of the list). Defaults to `firstElementMatches`. Defaults to `"firstElementMatches"`.
        :param str targetvalue: Expected matching value.
        """
        pulumi.set(__self__, "jsonpath", jsonpath)
        pulumi.set(__self__, "operator", operator)
        if elementsoperator is not None:
            pulumi.set(__self__, "elementsoperator", elementsoperator)
        if targetvalue is not None:
            pulumi.set(__self__, "targetvalue", targetvalue)

    @property
    @pulumi.getter
    def jsonpath(self) -> str:
        """
        The JSON path to assert.
        """
        return pulumi.get(self, "jsonpath")

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The specific operator to use on the path.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def elementsoperator(self) -> Optional[str]:
        """
        The element from the list of results to assert on. Select from `firstElementMatches` (the first element in the list), `everyElementMatches` (every element in the list), `atLeastOneElementMatches` (at least one element in the list), or `serializationMatches` (the serialized value of the list). Defaults to `firstElementMatches`. Defaults to `"firstElementMatches"`.
        """
        return pulumi.get(self, "elementsoperator")

    @property
    @pulumi.getter
    def targetvalue(self) -> Optional[str]:
        """
        Expected matching value.
        """
        return pulumi.get(self, "targetvalue")


@pulumi.output_type
class SyntheticsTestAssertionTargetjsonschema(dict):
    def __init__(__self__, *,
                 jsonschema: str,
                 metaschema: Optional[str] = None):
        """
        :param str jsonschema: The JSON Schema to validate the body against.
        :param str metaschema: The meta schema to use for the JSON Schema. Defaults to `"draft-07"`.
        """
        pulumi.set(__self__, "jsonschema", jsonschema)
        if metaschema is not None:
            pulumi.set(__self__, "metaschema", metaschema)

    @property
    @pulumi.getter
    def jsonschema(self) -> str:
        """
        The JSON Schema to validate the body against.
        """
        return pulumi.get(self, "jsonschema")

    @property
    @pulumi.getter
    def metaschema(self) -> Optional[str]:
        """
        The meta schema to use for the JSON Schema. Defaults to `"draft-07"`.
        """
        return pulumi.get(self, "metaschema")


@pulumi.output_type
class SyntheticsTestAssertionTargetxpath(dict):
    def __init__(__self__, *,
                 operator: str,
                 xpath: str,
                 targetvalue: Optional[str] = None):
        """
        :param str operator: The specific operator to use on the path.
        :param str xpath: The xpath to assert.
        :param str targetvalue: Expected matching value.
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "xpath", xpath)
        if targetvalue is not None:
            pulumi.set(__self__, "targetvalue", targetvalue)

    @property
    @pulumi.getter
    def operator(self) -> str:
        """
        The specific operator to use on the path.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def xpath(self) -> str:
        """
        The xpath to assert.
        """
        return pulumi.get(self, "xpath")

    @property
    @pulumi.getter
    def targetvalue(self) -> Optional[str]:
        """
        Expected matching value.
        """
        return pulumi.get(self, "targetvalue")


@pulumi.output_type
class SyntheticsTestBrowserStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowFailure":
            suggest = "allow_failure"
        elif key == "alwaysExecute":
            suggest = "always_execute"
        elif key == "exitIfSucceed":
            suggest = "exit_if_succeed"
        elif key == "forceElementUpdate":
            suggest = "force_element_update"
        elif key == "isCritical":
            suggest = "is_critical"
        elif key == "noScreenshot":
            suggest = "no_screenshot"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestBrowserStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestBrowserStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestBrowserStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 params: 'outputs.SyntheticsTestBrowserStepParams',
                 type: str,
                 allow_failure: Optional[bool] = None,
                 always_execute: Optional[bool] = None,
                 exit_if_succeed: Optional[bool] = None,
                 force_element_update: Optional[bool] = None,
                 is_critical: Optional[bool] = None,
                 no_screenshot: Optional[bool] = None,
                 timeout: Optional[int] = None):
        """
        :param str name: Name of the step.
        :param 'SyntheticsTestBrowserStepParamsArgs' params: Parameters for the step.
        :param str type: Type of the step. Valid values are `assertCurrentUrl`, `assertElementAttribute`, `assertElementContent`, `assertElementPresent`, `assertEmail`, `assertFileDownload`, `assertFromJavascript`, `assertPageContains`, `assertPageLacks`, `click`, `extractFromJavascript`, `extractVariable`, `goToEmailLink`, `goToUrl`, `goToUrlAndMeasureTti`, `hover`, `playSubTest`, `pressKey`, `refresh`, `runApiTest`, `scroll`, `selectOption`, `typeText`, `uploadFiles`, `wait`.
        :param bool allow_failure: Determines if the step should be allowed to fail.
        :param bool always_execute: Determines whether or not to always execute this step even if the previous step failed or was skipped.
        :param bool exit_if_succeed: Determines whether or not to exit the test if the step succeeds.
        :param bool force_element_update: Force update of the "element" parameter for the step
        :param bool is_critical: Determines whether or not to consider the entire test as failed if this step fails. Can be used only if `allow_failure` is `true`.
        :param bool no_screenshot: Prevents saving screenshots of the step.
        :param int timeout: Used to override the default timeout of a step.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "params", params)
        pulumi.set(__self__, "type", type)
        if allow_failure is not None:
            pulumi.set(__self__, "allow_failure", allow_failure)
        if always_execute is not None:
            pulumi.set(__self__, "always_execute", always_execute)
        if exit_if_succeed is not None:
            pulumi.set(__self__, "exit_if_succeed", exit_if_succeed)
        if force_element_update is not None:
            pulumi.set(__self__, "force_element_update", force_element_update)
        if is_critical is not None:
            pulumi.set(__self__, "is_critical", is_critical)
        if no_screenshot is not None:
            pulumi.set(__self__, "no_screenshot", no_screenshot)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the step.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def params(self) -> 'outputs.SyntheticsTestBrowserStepParams':
        """
        Parameters for the step.
        """
        return pulumi.get(self, "params")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the step. Valid values are `assertCurrentUrl`, `assertElementAttribute`, `assertElementContent`, `assertElementPresent`, `assertEmail`, `assertFileDownload`, `assertFromJavascript`, `assertPageContains`, `assertPageLacks`, `click`, `extractFromJavascript`, `extractVariable`, `goToEmailLink`, `goToUrl`, `goToUrlAndMeasureTti`, `hover`, `playSubTest`, `pressKey`, `refresh`, `runApiTest`, `scroll`, `selectOption`, `typeText`, `uploadFiles`, `wait`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="allowFailure")
    def allow_failure(self) -> Optional[bool]:
        """
        Determines if the step should be allowed to fail.
        """
        return pulumi.get(self, "allow_failure")

    @property
    @pulumi.getter(name="alwaysExecute")
    def always_execute(self) -> Optional[bool]:
        """
        Determines whether or not to always execute this step even if the previous step failed or was skipped.
        """
        return pulumi.get(self, "always_execute")

    @property
    @pulumi.getter(name="exitIfSucceed")
    def exit_if_succeed(self) -> Optional[bool]:
        """
        Determines whether or not to exit the test if the step succeeds.
        """
        return pulumi.get(self, "exit_if_succeed")

    @property
    @pulumi.getter(name="forceElementUpdate")
    def force_element_update(self) -> Optional[bool]:
        """
        Force update of the "element" parameter for the step
        """
        return pulumi.get(self, "force_element_update")

    @property
    @pulumi.getter(name="isCritical")
    def is_critical(self) -> Optional[bool]:
        """
        Determines whether or not to consider the entire test as failed if this step fails. Can be used only if `allow_failure` is `true`.
        """
        return pulumi.get(self, "is_critical")

    @property
    @pulumi.getter(name="noScreenshot")
    def no_screenshot(self) -> Optional[bool]:
        """
        Prevents saving screenshots of the step.
        """
        return pulumi.get(self, "no_screenshot")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        Used to override the default timeout of a step.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class SyntheticsTestBrowserStepParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clickType":
            suggest = "click_type"
        elif key == "elementUserLocator":
            suggest = "element_user_locator"
        elif key == "playingTabId":
            suggest = "playing_tab_id"
        elif key == "subtestPublicId":
            suggest = "subtest_public_id"
        elif key == "withClick":
            suggest = "with_click"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestBrowserStepParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestBrowserStepParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestBrowserStepParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute: Optional[str] = None,
                 check: Optional[str] = None,
                 click_type: Optional[str] = None,
                 code: Optional[str] = None,
                 delay: Optional[int] = None,
                 element: Optional[str] = None,
                 element_user_locator: Optional['outputs.SyntheticsTestBrowserStepParamsElementUserLocator'] = None,
                 email: Optional[str] = None,
                 file: Optional[str] = None,
                 files: Optional[str] = None,
                 modifiers: Optional[Sequence[str]] = None,
                 playing_tab_id: Optional[str] = None,
                 request: Optional[str] = None,
                 subtest_public_id: Optional[str] = None,
                 value: Optional[str] = None,
                 variable: Optional['outputs.SyntheticsTestBrowserStepParamsVariable'] = None,
                 with_click: Optional[bool] = None,
                 x: Optional[int] = None,
                 y: Optional[int] = None):
        """
        :param str attribute: Name of the attribute to use for an "assert attribute" step.
        :param str check: Check type to use for an assertion step. Valid values are `equals`, `notEquals`, `contains`, `notContains`, `startsWith`, `notStartsWith`, `greater`, `lower`, `greaterEquals`, `lowerEquals`, `matchRegex`, `between`, `isEmpty`, `notIsEmpty`.
        :param str click_type: Type of click to use for a "click" step.
        :param str code: Javascript code to use for the step.
        :param int delay: Delay between each key stroke for a "type test" step.
        :param str element: Element to use for the step, JSON encoded string.
        :param 'SyntheticsTestBrowserStepParamsElementUserLocatorArgs' element_user_locator: Custom user selector to use for the step.
        :param str email: Details of the email for an "assert email" step, JSON encoded string.
        :param str file: JSON encoded string used for an "assert download" step. Refer to the examples for a usage example showing the schema.
        :param str files: Details of the files for an "upload files" step, JSON encoded string.
        :param Sequence[str] modifiers: Modifier to use for a "press key" step.
        :param str playing_tab_id: ID of the tab to play the subtest.
        :param str request: Request for an API step.
        :param str subtest_public_id: ID of the Synthetics test to use as subtest.
        :param str value: Value of the step.
        :param 'SyntheticsTestBrowserStepParamsVariableArgs' variable: Details of the variable to extract.
        :param bool with_click: For "file upload" steps.
        :param int x: X coordinates for a "scroll step".
        :param int y: Y coordinates for a "scroll step".
        """
        if attribute is not None:
            pulumi.set(__self__, "attribute", attribute)
        if check is not None:
            pulumi.set(__self__, "check", check)
        if click_type is not None:
            pulumi.set(__self__, "click_type", click_type)
        if code is not None:
            pulumi.set(__self__, "code", code)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if element is not None:
            pulumi.set(__self__, "element", element)
        if element_user_locator is not None:
            pulumi.set(__self__, "element_user_locator", element_user_locator)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if file is not None:
            pulumi.set(__self__, "file", file)
        if files is not None:
            pulumi.set(__self__, "files", files)
        if modifiers is not None:
            pulumi.set(__self__, "modifiers", modifiers)
        if playing_tab_id is not None:
            pulumi.set(__self__, "playing_tab_id", playing_tab_id)
        if request is not None:
            pulumi.set(__self__, "request", request)
        if subtest_public_id is not None:
            pulumi.set(__self__, "subtest_public_id", subtest_public_id)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if variable is not None:
            pulumi.set(__self__, "variable", variable)
        if with_click is not None:
            pulumi.set(__self__, "with_click", with_click)
        if x is not None:
            pulumi.set(__self__, "x", x)
        if y is not None:
            pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def attribute(self) -> Optional[str]:
        """
        Name of the attribute to use for an "assert attribute" step.
        """
        return pulumi.get(self, "attribute")

    @property
    @pulumi.getter
    def check(self) -> Optional[str]:
        """
        Check type to use for an assertion step. Valid values are `equals`, `notEquals`, `contains`, `notContains`, `startsWith`, `notStartsWith`, `greater`, `lower`, `greaterEquals`, `lowerEquals`, `matchRegex`, `between`, `isEmpty`, `notIsEmpty`.
        """
        return pulumi.get(self, "check")

    @property
    @pulumi.getter(name="clickType")
    def click_type(self) -> Optional[str]:
        """
        Type of click to use for a "click" step.
        """
        return pulumi.get(self, "click_type")

    @property
    @pulumi.getter
    def code(self) -> Optional[str]:
        """
        Javascript code to use for the step.
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def delay(self) -> Optional[int]:
        """
        Delay between each key stroke for a "type test" step.
        """
        return pulumi.get(self, "delay")

    @property
    @pulumi.getter
    def element(self) -> Optional[str]:
        """
        Element to use for the step, JSON encoded string.
        """
        return pulumi.get(self, "element")

    @property
    @pulumi.getter(name="elementUserLocator")
    def element_user_locator(self) -> Optional['outputs.SyntheticsTestBrowserStepParamsElementUserLocator']:
        """
        Custom user selector to use for the step.
        """
        return pulumi.get(self, "element_user_locator")

    @property
    @pulumi.getter
    def email(self) -> Optional[str]:
        """
        Details of the email for an "assert email" step, JSON encoded string.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def file(self) -> Optional[str]:
        """
        JSON encoded string used for an "assert download" step. Refer to the examples for a usage example showing the schema.
        """
        return pulumi.get(self, "file")

    @property
    @pulumi.getter
    def files(self) -> Optional[str]:
        """
        Details of the files for an "upload files" step, JSON encoded string.
        """
        return pulumi.get(self, "files")

    @property
    @pulumi.getter
    def modifiers(self) -> Optional[Sequence[str]]:
        """
        Modifier to use for a "press key" step.
        """
        return pulumi.get(self, "modifiers")

    @property
    @pulumi.getter(name="playingTabId")
    def playing_tab_id(self) -> Optional[str]:
        """
        ID of the tab to play the subtest.
        """
        return pulumi.get(self, "playing_tab_id")

    @property
    @pulumi.getter
    def request(self) -> Optional[str]:
        """
        Request for an API step.
        """
        return pulumi.get(self, "request")

    @property
    @pulumi.getter(name="subtestPublicId")
    def subtest_public_id(self) -> Optional[str]:
        """
        ID of the Synthetics test to use as subtest.
        """
        return pulumi.get(self, "subtest_public_id")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the step.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def variable(self) -> Optional['outputs.SyntheticsTestBrowserStepParamsVariable']:
        """
        Details of the variable to extract.
        """
        return pulumi.get(self, "variable")

    @property
    @pulumi.getter(name="withClick")
    def with_click(self) -> Optional[bool]:
        """
        For "file upload" steps.
        """
        return pulumi.get(self, "with_click")

    @property
    @pulumi.getter
    def x(self) -> Optional[int]:
        """
        X coordinates for a "scroll step".
        """
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> Optional[int]:
        """
        Y coordinates for a "scroll step".
        """
        return pulumi.get(self, "y")


@pulumi.output_type
class SyntheticsTestBrowserStepParamsElementUserLocator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failTestOnCannotLocate":
            suggest = "fail_test_on_cannot_locate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestBrowserStepParamsElementUserLocator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestBrowserStepParamsElementUserLocator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestBrowserStepParamsElementUserLocator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 value: 'outputs.SyntheticsTestBrowserStepParamsElementUserLocatorValue',
                 fail_test_on_cannot_locate: Optional[bool] = None):
        """
        :param bool fail_test_on_cannot_locate: Defaults to `false`.
        """
        pulumi.set(__self__, "value", value)
        if fail_test_on_cannot_locate is not None:
            pulumi.set(__self__, "fail_test_on_cannot_locate", fail_test_on_cannot_locate)

    @property
    @pulumi.getter
    def value(self) -> 'outputs.SyntheticsTestBrowserStepParamsElementUserLocatorValue':
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="failTestOnCannotLocate")
    def fail_test_on_cannot_locate(self) -> Optional[bool]:
        """
        Defaults to `false`.
        """
        return pulumi.get(self, "fail_test_on_cannot_locate")


@pulumi.output_type
class SyntheticsTestBrowserStepParamsElementUserLocatorValue(dict):
    def __init__(__self__, *,
                 value: str,
                 type: Optional[str] = None):
        """
        :param str type: Defaults to `"css"`.
        """
        pulumi.set(__self__, "value", value)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Defaults to `"css"`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SyntheticsTestBrowserStepParamsVariable(dict):
    def __init__(__self__, *,
                 example: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str example: Example of the extracted variable. Defaults to `""`.
        :param str name: Name of the extracted variable.
        """
        if example is not None:
            pulumi.set(__self__, "example", example)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def example(self) -> Optional[str]:
        """
        Example of the extracted variable. Defaults to `""`.
        """
        return pulumi.get(self, "example")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the extracted variable.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SyntheticsTestBrowserVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 example: Optional[str] = None,
                 id: Optional[str] = None,
                 pattern: Optional[str] = None,
                 secure: Optional[bool] = None):
        """
        :param str name: Name of the variable.
        :param str type: Type of browser test variable. Valid values are `element`, `email`, `global`, `javascript`, `text`.
        :param str example: Example for the variable. Defaults to `""`.
        :param str id: ID of the global variable to use. This is actually only used (and required) in the case of using a variable of type `global`.
        :param str pattern: Pattern of the variable. Defaults to `""`.
        :param bool secure: Determines whether or not the browser test variable is obfuscated. Can only be used with a browser variable of type `text`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if example is not None:
            pulumi.set(__self__, "example", example)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of browser test variable. Valid values are `element`, `email`, `global`, `javascript`, `text`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def example(self) -> Optional[str]:
        """
        Example for the variable. Defaults to `""`.
        """
        return pulumi.get(self, "example")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the global variable to use. This is actually only used (and required) in the case of using a variable of type `global`.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        """
        Pattern of the variable. Defaults to `""`.
        """
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter
    def secure(self) -> Optional[bool]:
        """
        Determines whether or not the browser test variable is obfuscated. Can only be used with a browser variable of type `text`
        """
        return pulumi.get(self, "secure")


@pulumi.output_type
class SyntheticsTestConfigVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 example: Optional[str] = None,
                 id: Optional[str] = None,
                 pattern: Optional[str] = None,
                 secure: Optional[bool] = None):
        """
        :param str name: Name of the variable.
        :param str type: Type of test configuration variable. Valid values are `global`, `text`, `email`.
        :param str id: When type = `global`, ID of the global variable to use.
        :param bool secure: Whether the value of this variable will be obfuscated in test results. Defaults to `false`.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        if example is not None:
            pulumi.set(__self__, "example", example)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if secure is not None:
            pulumi.set(__self__, "secure", secure)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of test configuration variable. Valid values are `global`, `text`, `email`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def example(self) -> Optional[str]:
        return pulumi.get(self, "example")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        When type = `global`, ID of the global variable to use.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter
    def secure(self) -> Optional[bool]:
        """
        Whether the value of this variable will be obfuscated in test results. Defaults to `false`.
        """
        return pulumi.get(self, "secure")


@pulumi.output_type
class SyntheticsTestMobileOptionsList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deviceIds":
            suggest = "device_ids"
        elif key == "mobileApplication":
            suggest = "mobile_application"
        elif key == "tickEvery":
            suggest = "tick_every"
        elif key == "allowApplicationCrash":
            suggest = "allow_application_crash"
        elif key == "defaultStepTimeout":
            suggest = "default_step_timeout"
        elif key == "disableAutoAcceptAlert":
            suggest = "disable_auto_accept_alert"
        elif key == "minFailureDuration":
            suggest = "min_failure_duration"
        elif key == "monitorName":
            suggest = "monitor_name"
        elif key == "monitorOptions":
            suggest = "monitor_options"
        elif key == "monitorPriority":
            suggest = "monitor_priority"
        elif key == "noScreenshot":
            suggest = "no_screenshot"
        elif key == "restrictedRoles":
            suggest = "restricted_roles"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestMobileOptionsList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestMobileOptionsList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestMobileOptionsList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 device_ids: Sequence[str],
                 mobile_application: 'outputs.SyntheticsTestMobileOptionsListMobileApplication',
                 tick_every: int,
                 allow_application_crash: Optional[bool] = None,
                 bindings: Optional[Sequence['outputs.SyntheticsTestMobileOptionsListBinding']] = None,
                 ci: Optional['outputs.SyntheticsTestMobileOptionsListCi'] = None,
                 default_step_timeout: Optional[int] = None,
                 disable_auto_accept_alert: Optional[bool] = None,
                 min_failure_duration: Optional[int] = None,
                 monitor_name: Optional[str] = None,
                 monitor_options: Optional['outputs.SyntheticsTestMobileOptionsListMonitorOptions'] = None,
                 monitor_priority: Optional[int] = None,
                 no_screenshot: Optional[bool] = None,
                 restricted_roles: Optional[Sequence[str]] = None,
                 retry: Optional['outputs.SyntheticsTestMobileOptionsListRetry'] = None,
                 scheduling: Optional['outputs.SyntheticsTestMobileOptionsListScheduling'] = None,
                 verbosity: Optional[int] = None):
        """
        :param int tick_every: How often the test should run (in seconds).
        :param 'SyntheticsTestMobileOptionsListCiArgs' ci: CI/CD options for a Synthetic test.
        :param int min_failure_duration: Minimum amount of time in failure required to trigger an alert (in seconds). Default is `0`.
        :param str monitor_name: The monitor name is used for the alert title as well as for all monitor dashboard widgets and SLOs.
        :param bool no_screenshot: Prevents saving screenshots of the steps.
        :param Sequence[str] restricted_roles: A list of role identifiers pulled from the Roles API to restrict read and write access.
        :param 'SyntheticsTestMobileOptionsListSchedulingArgs' scheduling: Object containing timeframes and timezone used for advanced scheduling.
        """
        pulumi.set(__self__, "device_ids", device_ids)
        pulumi.set(__self__, "mobile_application", mobile_application)
        pulumi.set(__self__, "tick_every", tick_every)
        if allow_application_crash is not None:
            pulumi.set(__self__, "allow_application_crash", allow_application_crash)
        if bindings is not None:
            pulumi.set(__self__, "bindings", bindings)
        if ci is not None:
            pulumi.set(__self__, "ci", ci)
        if default_step_timeout is not None:
            pulumi.set(__self__, "default_step_timeout", default_step_timeout)
        if disable_auto_accept_alert is not None:
            pulumi.set(__self__, "disable_auto_accept_alert", disable_auto_accept_alert)
        if min_failure_duration is not None:
            pulumi.set(__self__, "min_failure_duration", min_failure_duration)
        if monitor_name is not None:
            pulumi.set(__self__, "monitor_name", monitor_name)
        if monitor_options is not None:
            pulumi.set(__self__, "monitor_options", monitor_options)
        if monitor_priority is not None:
            pulumi.set(__self__, "monitor_priority", monitor_priority)
        if no_screenshot is not None:
            pulumi.set(__self__, "no_screenshot", no_screenshot)
        if restricted_roles is not None:
            pulumi.set(__self__, "restricted_roles", restricted_roles)
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if scheduling is not None:
            pulumi.set(__self__, "scheduling", scheduling)
        if verbosity is not None:
            pulumi.set(__self__, "verbosity", verbosity)

    @property
    @pulumi.getter(name="deviceIds")
    def device_ids(self) -> Sequence[str]:
        return pulumi.get(self, "device_ids")

    @property
    @pulumi.getter(name="mobileApplication")
    def mobile_application(self) -> 'outputs.SyntheticsTestMobileOptionsListMobileApplication':
        return pulumi.get(self, "mobile_application")

    @property
    @pulumi.getter(name="tickEvery")
    def tick_every(self) -> int:
        """
        How often the test should run (in seconds).
        """
        return pulumi.get(self, "tick_every")

    @property
    @pulumi.getter(name="allowApplicationCrash")
    def allow_application_crash(self) -> Optional[bool]:
        return pulumi.get(self, "allow_application_crash")

    @property
    @pulumi.getter
    def bindings(self) -> Optional[Sequence['outputs.SyntheticsTestMobileOptionsListBinding']]:
        return pulumi.get(self, "bindings")

    @property
    @pulumi.getter
    def ci(self) -> Optional['outputs.SyntheticsTestMobileOptionsListCi']:
        """
        CI/CD options for a Synthetic test.
        """
        return pulumi.get(self, "ci")

    @property
    @pulumi.getter(name="defaultStepTimeout")
    def default_step_timeout(self) -> Optional[int]:
        return pulumi.get(self, "default_step_timeout")

    @property
    @pulumi.getter(name="disableAutoAcceptAlert")
    def disable_auto_accept_alert(self) -> Optional[bool]:
        return pulumi.get(self, "disable_auto_accept_alert")

    @property
    @pulumi.getter(name="minFailureDuration")
    def min_failure_duration(self) -> Optional[int]:
        """
        Minimum amount of time in failure required to trigger an alert (in seconds). Default is `0`.
        """
        return pulumi.get(self, "min_failure_duration")

    @property
    @pulumi.getter(name="monitorName")
    def monitor_name(self) -> Optional[str]:
        """
        The monitor name is used for the alert title as well as for all monitor dashboard widgets and SLOs.
        """
        return pulumi.get(self, "monitor_name")

    @property
    @pulumi.getter(name="monitorOptions")
    def monitor_options(self) -> Optional['outputs.SyntheticsTestMobileOptionsListMonitorOptions']:
        return pulumi.get(self, "monitor_options")

    @property
    @pulumi.getter(name="monitorPriority")
    def monitor_priority(self) -> Optional[int]:
        return pulumi.get(self, "monitor_priority")

    @property
    @pulumi.getter(name="noScreenshot")
    def no_screenshot(self) -> Optional[bool]:
        """
        Prevents saving screenshots of the steps.
        """
        return pulumi.get(self, "no_screenshot")

    @property
    @pulumi.getter(name="restrictedRoles")
    def restricted_roles(self) -> Optional[Sequence[str]]:
        """
        A list of role identifiers pulled from the Roles API to restrict read and write access.
        """
        return pulumi.get(self, "restricted_roles")

    @property
    @pulumi.getter
    def retry(self) -> Optional['outputs.SyntheticsTestMobileOptionsListRetry']:
        return pulumi.get(self, "retry")

    @property
    @pulumi.getter
    def scheduling(self) -> Optional['outputs.SyntheticsTestMobileOptionsListScheduling']:
        """
        Object containing timeframes and timezone used for advanced scheduling.
        """
        return pulumi.get(self, "scheduling")

    @property
    @pulumi.getter
    def verbosity(self) -> Optional[int]:
        return pulumi.get(self, "verbosity")


@pulumi.output_type
class SyntheticsTestMobileOptionsListBinding(dict):
    def __init__(__self__, *,
                 principals: Optional[Sequence[str]] = None,
                 relation: Optional[str] = None):
        """
        :param str relation: Valid values are `editor`, `viewer`.
        """
        if principals is not None:
            pulumi.set(__self__, "principals", principals)
        if relation is not None:
            pulumi.set(__self__, "relation", relation)

    @property
    @pulumi.getter
    def principals(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "principals")

    @property
    @pulumi.getter
    def relation(self) -> Optional[str]:
        """
        Valid values are `editor`, `viewer`.
        """
        return pulumi.get(self, "relation")


@pulumi.output_type
class SyntheticsTestMobileOptionsListCi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionRule":
            suggest = "execution_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestMobileOptionsListCi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestMobileOptionsListCi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestMobileOptionsListCi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_rule: str):
        """
        :param str execution_rule: Execution rule for a Synthetics test. Valid values are `blocking`, `non_blocking`, `skipped`.
        """
        pulumi.set(__self__, "execution_rule", execution_rule)

    @property
    @pulumi.getter(name="executionRule")
    def execution_rule(self) -> str:
        """
        Execution rule for a Synthetics test. Valid values are `blocking`, `non_blocking`, `skipped`.
        """
        return pulumi.get(self, "execution_rule")


@pulumi.output_type
class SyntheticsTestMobileOptionsListMobileApplication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "applicationId":
            suggest = "application_id"
        elif key == "referenceId":
            suggest = "reference_id"
        elif key == "referenceType":
            suggest = "reference_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestMobileOptionsListMobileApplication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestMobileOptionsListMobileApplication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestMobileOptionsListMobileApplication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 application_id: str,
                 reference_id: str,
                 reference_type: str):
        """
        :param str reference_type: Valid values are `latest`, `version`.
        """
        pulumi.set(__self__, "application_id", application_id)
        pulumi.set(__self__, "reference_id", reference_id)
        pulumi.set(__self__, "reference_type", reference_type)

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> str:
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="referenceId")
    def reference_id(self) -> str:
        return pulumi.get(self, "reference_id")

    @property
    @pulumi.getter(name="referenceType")
    def reference_type(self) -> str:
        """
        Valid values are `latest`, `version`.
        """
        return pulumi.get(self, "reference_type")


@pulumi.output_type
class SyntheticsTestMobileOptionsListMonitorOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationMessage":
            suggest = "escalation_message"
        elif key == "notificationPresetName":
            suggest = "notification_preset_name"
        elif key == "renotifyInterval":
            suggest = "renotify_interval"
        elif key == "renotifyOccurrences":
            suggest = "renotify_occurrences"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestMobileOptionsListMonitorOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestMobileOptionsListMonitorOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestMobileOptionsListMonitorOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 escalation_message: Optional[str] = None,
                 notification_preset_name: Optional[str] = None,
                 renotify_interval: Optional[int] = None,
                 renotify_occurrences: Optional[int] = None):
        """
        :param str notification_preset_name: Valid values are `show_all`, `hide_all`, `hide_query`, `hide_handles`.
        :param int renotify_interval: Specify a renotification frequency in minutes. Values available by default are `0`, `10`, `20`, `30`, `40`, `50`, `60`, `90`, `120`, `180`, `240`, `300`, `360`, `720`, `1440`. Defaults to `0`.
        """
        if escalation_message is not None:
            pulumi.set(__self__, "escalation_message", escalation_message)
        if notification_preset_name is not None:
            pulumi.set(__self__, "notification_preset_name", notification_preset_name)
        if renotify_interval is not None:
            pulumi.set(__self__, "renotify_interval", renotify_interval)
        if renotify_occurrences is not None:
            pulumi.set(__self__, "renotify_occurrences", renotify_occurrences)

    @property
    @pulumi.getter(name="escalationMessage")
    def escalation_message(self) -> Optional[str]:
        return pulumi.get(self, "escalation_message")

    @property
    @pulumi.getter(name="notificationPresetName")
    def notification_preset_name(self) -> Optional[str]:
        """
        Valid values are `show_all`, `hide_all`, `hide_query`, `hide_handles`.
        """
        return pulumi.get(self, "notification_preset_name")

    @property
    @pulumi.getter(name="renotifyInterval")
    def renotify_interval(self) -> Optional[int]:
        """
        Specify a renotification frequency in minutes. Values available by default are `0`, `10`, `20`, `30`, `40`, `50`, `60`, `90`, `120`, `180`, `240`, `300`, `360`, `720`, `1440`. Defaults to `0`.
        """
        return pulumi.get(self, "renotify_interval")

    @property
    @pulumi.getter(name="renotifyOccurrences")
    def renotify_occurrences(self) -> Optional[int]:
        return pulumi.get(self, "renotify_occurrences")


@pulumi.output_type
class SyntheticsTestMobileOptionsListRetry(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 interval: Optional[int] = None):
        """
        :param int count: Number of retries needed to consider a location as failed before sending a notification alert. Maximum value: `5`. Defaults to `0`.
        :param int interval: Interval between a failed test and the next retry in milliseconds. Maximum value: `5000`. Defaults to `300`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        Number of retries needed to consider a location as failed before sending a notification alert. Maximum value: `5`. Defaults to `0`.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Interval between a failed test and the next retry in milliseconds. Maximum value: `5000`. Defaults to `300`.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class SyntheticsTestMobileOptionsListScheduling(dict):
    def __init__(__self__, *,
                 timeframes: Sequence['outputs.SyntheticsTestMobileOptionsListSchedulingTimeframe'],
                 timezone: str):
        """
        :param Sequence['SyntheticsTestMobileOptionsListSchedulingTimeframeArgs'] timeframes: Array containing objects describing the scheduling pattern to apply to each day.
        :param str timezone: Timezone in which the timeframe is based.
        """
        pulumi.set(__self__, "timeframes", timeframes)
        pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter
    def timeframes(self) -> Sequence['outputs.SyntheticsTestMobileOptionsListSchedulingTimeframe']:
        """
        Array containing objects describing the scheduling pattern to apply to each day.
        """
        return pulumi.get(self, "timeframes")

    @property
    @pulumi.getter
    def timezone(self) -> str:
        """
        Timezone in which the timeframe is based.
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class SyntheticsTestMobileOptionsListSchedulingTimeframe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestMobileOptionsListSchedulingTimeframe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestMobileOptionsListSchedulingTimeframe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestMobileOptionsListSchedulingTimeframe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day: int,
                 from_: str,
                 to: str):
        """
        :param int day: Number representing the day of the week
        :param str from_: The hour of the day on which scheduling starts.
        :param str to: The hour of the day on which scheduling ends.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter
    def day(self) -> int:
        """
        Number representing the day of the week
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter(name="from")
    def from_(self) -> str:
        """
        The hour of the day on which scheduling starts.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> str:
        """
        The hour of the day on which scheduling ends.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class SyntheticsTestMobileStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowFailure":
            suggest = "allow_failure"
        elif key == "hasNewStepElement":
            suggest = "has_new_step_element"
        elif key == "isCritical":
            suggest = "is_critical"
        elif key == "noScreenshot":
            suggest = "no_screenshot"
        elif key == "publicId":
            suggest = "public_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestMobileStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestMobileStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestMobileStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 params: 'outputs.SyntheticsTestMobileStepParams',
                 type: str,
                 allow_failure: Optional[bool] = None,
                 has_new_step_element: Optional[bool] = None,
                 is_critical: Optional[bool] = None,
                 no_screenshot: Optional[bool] = None,
                 public_id: Optional[str] = None,
                 timeout: Optional[int] = None):
        """
        :param str name: The name of the step.
        :param 'SyntheticsTestMobileStepParamsArgs' params: Parameters for the step.
        :param str type: The type of the step. Valid values are `assertElementContent`, `assertScreenContains`, `assertScreenLacks`, `doubleTap`, `extractVariable`, `flick`, `openDeeplink`, `playSubTest`, `pressBack`, `restartApplication`, `rotate`, `scroll`, `scrollToElement`, `tap`, `toggleWiFi`, `typeText`, `wait`.
        :param bool allow_failure: A boolean set to allow this step to fail.
        :param bool has_new_step_element: A boolean set to determine if the step has a new step element.
        :param bool is_critical: A boolean to use in addition to `allowFailure` to determine if the test should be marked as failed when the step fails.
        :param bool no_screenshot: A boolean set to not take a screenshot for the step.
        :param str public_id: The public ID of the step.
        :param int timeout: The time before declaring a step failed.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "params", params)
        pulumi.set(__self__, "type", type)
        if allow_failure is not None:
            pulumi.set(__self__, "allow_failure", allow_failure)
        if has_new_step_element is not None:
            pulumi.set(__self__, "has_new_step_element", has_new_step_element)
        if is_critical is not None:
            pulumi.set(__self__, "is_critical", is_critical)
        if no_screenshot is not None:
            pulumi.set(__self__, "no_screenshot", no_screenshot)
        if public_id is not None:
            pulumi.set(__self__, "public_id", public_id)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the step.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def params(self) -> 'outputs.SyntheticsTestMobileStepParams':
        """
        Parameters for the step.
        """
        return pulumi.get(self, "params")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the step. Valid values are `assertElementContent`, `assertScreenContains`, `assertScreenLacks`, `doubleTap`, `extractVariable`, `flick`, `openDeeplink`, `playSubTest`, `pressBack`, `restartApplication`, `rotate`, `scroll`, `scrollToElement`, `tap`, `toggleWiFi`, `typeText`, `wait`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="allowFailure")
    def allow_failure(self) -> Optional[bool]:
        """
        A boolean set to allow this step to fail.
        """
        return pulumi.get(self, "allow_failure")

    @property
    @pulumi.getter(name="hasNewStepElement")
    def has_new_step_element(self) -> Optional[bool]:
        """
        A boolean set to determine if the step has a new step element.
        """
        return pulumi.get(self, "has_new_step_element")

    @property
    @pulumi.getter(name="isCritical")
    def is_critical(self) -> Optional[bool]:
        """
        A boolean to use in addition to `allowFailure` to determine if the test should be marked as failed when the step fails.
        """
        return pulumi.get(self, "is_critical")

    @property
    @pulumi.getter(name="noScreenshot")
    def no_screenshot(self) -> Optional[bool]:
        """
        A boolean set to not take a screenshot for the step.
        """
        return pulumi.get(self, "no_screenshot")

    @property
    @pulumi.getter(name="publicId")
    def public_id(self) -> Optional[str]:
        """
        The public ID of the step.
        """
        return pulumi.get(self, "public_id")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        The time before declaring a step failed.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class SyntheticsTestMobileStepParams(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxScrolls":
            suggest = "max_scrolls"
        elif key == "subtestPublicId":
            suggest = "subtest_public_id"
        elif key == "withEnter":
            suggest = "with_enter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestMobileStepParams. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestMobileStepParams.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestMobileStepParams.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 check: Optional[str] = None,
                 delay: Optional[int] = None,
                 direction: Optional[str] = None,
                 element: Optional['outputs.SyntheticsTestMobileStepParamsElement'] = None,
                 enable: Optional[bool] = None,
                 max_scrolls: Optional[int] = None,
                 positions: Optional[Sequence['outputs.SyntheticsTestMobileStepParamsPosition']] = None,
                 subtest_public_id: Optional[str] = None,
                 value: Optional[str] = None,
                 variable: Optional['outputs.SyntheticsTestMobileStepParamsVariable'] = None,
                 with_enter: Optional[bool] = None,
                 x: Optional[float] = None,
                 y: Optional[float] = None):
        """
        :param str check: Check type to use for an assertion step. Valid values are `equals`, `notEquals`, `contains`, `notContains`, `startsWith`, `notStartsWith`, `greater`, `lower`, `greaterEquals`, `lowerEquals`, `matchRegex`, `between`, `isEmpty`, `notIsEmpty`.
        :param int delay: Delay between each key stroke for a "type test" step.
        :param str direction: Valid values are `up`, `down`, `left`, `right`.
        :param 'SyntheticsTestMobileStepParamsElementArgs' element: Element to use for the step, JSON encoded string.
        :param str subtest_public_id: ID of the Synthetics test to use as subtest.
        :param str value: Value of the step.
        :param 'SyntheticsTestMobileStepParamsVariableArgs' variable: Details of the variable to extract.
        :param float x: X coordinates for a "scroll step".
        :param float y: Y coordinates for a "scroll step".
        """
        if check is not None:
            pulumi.set(__self__, "check", check)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if element is not None:
            pulumi.set(__self__, "element", element)
        if enable is not None:
            pulumi.set(__self__, "enable", enable)
        if max_scrolls is not None:
            pulumi.set(__self__, "max_scrolls", max_scrolls)
        if positions is not None:
            pulumi.set(__self__, "positions", positions)
        if subtest_public_id is not None:
            pulumi.set(__self__, "subtest_public_id", subtest_public_id)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if variable is not None:
            pulumi.set(__self__, "variable", variable)
        if with_enter is not None:
            pulumi.set(__self__, "with_enter", with_enter)
        if x is not None:
            pulumi.set(__self__, "x", x)
        if y is not None:
            pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def check(self) -> Optional[str]:
        """
        Check type to use for an assertion step. Valid values are `equals`, `notEquals`, `contains`, `notContains`, `startsWith`, `notStartsWith`, `greater`, `lower`, `greaterEquals`, `lowerEquals`, `matchRegex`, `between`, `isEmpty`, `notIsEmpty`.
        """
        return pulumi.get(self, "check")

    @property
    @pulumi.getter
    def delay(self) -> Optional[int]:
        """
        Delay between each key stroke for a "type test" step.
        """
        return pulumi.get(self, "delay")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Valid values are `up`, `down`, `left`, `right`.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def element(self) -> Optional['outputs.SyntheticsTestMobileStepParamsElement']:
        """
        Element to use for the step, JSON encoded string.
        """
        return pulumi.get(self, "element")

    @property
    @pulumi.getter
    def enable(self) -> Optional[bool]:
        return pulumi.get(self, "enable")

    @property
    @pulumi.getter(name="maxScrolls")
    def max_scrolls(self) -> Optional[int]:
        return pulumi.get(self, "max_scrolls")

    @property
    @pulumi.getter
    def positions(self) -> Optional[Sequence['outputs.SyntheticsTestMobileStepParamsPosition']]:
        return pulumi.get(self, "positions")

    @property
    @pulumi.getter(name="subtestPublicId")
    def subtest_public_id(self) -> Optional[str]:
        """
        ID of the Synthetics test to use as subtest.
        """
        return pulumi.get(self, "subtest_public_id")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value of the step.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def variable(self) -> Optional['outputs.SyntheticsTestMobileStepParamsVariable']:
        """
        Details of the variable to extract.
        """
        return pulumi.get(self, "variable")

    @property
    @pulumi.getter(name="withEnter")
    def with_enter(self) -> Optional[bool]:
        return pulumi.get(self, "with_enter")

    @property
    @pulumi.getter
    def x(self) -> Optional[float]:
        """
        X coordinates for a "scroll step".
        """
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> Optional[float]:
        """
        Y coordinates for a "scroll step".
        """
        return pulumi.get(self, "y")


@pulumi.output_type
class SyntheticsTestMobileStepParamsElement(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contextType":
            suggest = "context_type"
        elif key == "elementDescription":
            suggest = "element_description"
        elif key == "multiLocator":
            suggest = "multi_locator"
        elif key == "relativePosition":
            suggest = "relative_position"
        elif key == "textContent":
            suggest = "text_content"
        elif key == "userLocator":
            suggest = "user_locator"
        elif key == "viewName":
            suggest = "view_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestMobileStepParamsElement. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestMobileStepParamsElement.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestMobileStepParamsElement.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 context: Optional[str] = None,
                 context_type: Optional[str] = None,
                 element_description: Optional[str] = None,
                 multi_locator: Optional[Mapping[str, str]] = None,
                 relative_position: Optional['outputs.SyntheticsTestMobileStepParamsElementRelativePosition'] = None,
                 text_content: Optional[str] = None,
                 user_locator: Optional['outputs.SyntheticsTestMobileStepParamsElementUserLocator'] = None,
                 view_name: Optional[str] = None):
        """
        :param str context_type: Valid values are `native`, `web`.
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if context_type is not None:
            pulumi.set(__self__, "context_type", context_type)
        if element_description is not None:
            pulumi.set(__self__, "element_description", element_description)
        if multi_locator is not None:
            pulumi.set(__self__, "multi_locator", multi_locator)
        if relative_position is not None:
            pulumi.set(__self__, "relative_position", relative_position)
        if text_content is not None:
            pulumi.set(__self__, "text_content", text_content)
        if user_locator is not None:
            pulumi.set(__self__, "user_locator", user_locator)
        if view_name is not None:
            pulumi.set(__self__, "view_name", view_name)

    @property
    @pulumi.getter
    def context(self) -> Optional[str]:
        return pulumi.get(self, "context")

    @property
    @pulumi.getter(name="contextType")
    def context_type(self) -> Optional[str]:
        """
        Valid values are `native`, `web`.
        """
        return pulumi.get(self, "context_type")

    @property
    @pulumi.getter(name="elementDescription")
    def element_description(self) -> Optional[str]:
        return pulumi.get(self, "element_description")

    @property
    @pulumi.getter(name="multiLocator")
    def multi_locator(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "multi_locator")

    @property
    @pulumi.getter(name="relativePosition")
    def relative_position(self) -> Optional['outputs.SyntheticsTestMobileStepParamsElementRelativePosition']:
        return pulumi.get(self, "relative_position")

    @property
    @pulumi.getter(name="textContent")
    def text_content(self) -> Optional[str]:
        return pulumi.get(self, "text_content")

    @property
    @pulumi.getter(name="userLocator")
    def user_locator(self) -> Optional['outputs.SyntheticsTestMobileStepParamsElementUserLocator']:
        return pulumi.get(self, "user_locator")

    @property
    @pulumi.getter(name="viewName")
    def view_name(self) -> Optional[str]:
        return pulumi.get(self, "view_name")


@pulumi.output_type
class SyntheticsTestMobileStepParamsElementRelativePosition(dict):
    def __init__(__self__, *,
                 x: Optional[float] = None,
                 y: Optional[float] = None):
        if x is not None:
            pulumi.set(__self__, "x", x)
        if y is not None:
            pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def x(self) -> Optional[float]:
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> Optional[float]:
        return pulumi.get(self, "y")


@pulumi.output_type
class SyntheticsTestMobileStepParamsElementUserLocator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failTestOnCannotLocate":
            suggest = "fail_test_on_cannot_locate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestMobileStepParamsElementUserLocator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestMobileStepParamsElementUserLocator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestMobileStepParamsElementUserLocator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fail_test_on_cannot_locate: Optional[bool] = None,
                 values: Optional[Sequence['outputs.SyntheticsTestMobileStepParamsElementUserLocatorValue']] = None):
        if fail_test_on_cannot_locate is not None:
            pulumi.set(__self__, "fail_test_on_cannot_locate", fail_test_on_cannot_locate)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter(name="failTestOnCannotLocate")
    def fail_test_on_cannot_locate(self) -> Optional[bool]:
        return pulumi.get(self, "fail_test_on_cannot_locate")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.SyntheticsTestMobileStepParamsElementUserLocatorValue']]:
        return pulumi.get(self, "values")


@pulumi.output_type
class SyntheticsTestMobileStepParamsElementUserLocatorValue(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str type: Valid values are `accessibility-id`, `id`, `ios-predicate-string`, `ios-class-chain`, `xpath`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Valid values are `accessibility-id`, `id`, `ios-predicate-string`, `ios-class-chain`, `xpath`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class SyntheticsTestMobileStepParamsPosition(dict):
    def __init__(__self__, *,
                 x: Optional[float] = None,
                 y: Optional[float] = None):
        if x is not None:
            pulumi.set(__self__, "x", x)
        if y is not None:
            pulumi.set(__self__, "y", y)

    @property
    @pulumi.getter
    def x(self) -> Optional[float]:
        return pulumi.get(self, "x")

    @property
    @pulumi.getter
    def y(self) -> Optional[float]:
        return pulumi.get(self, "y")


@pulumi.output_type
class SyntheticsTestMobileStepParamsVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 example: Optional[str] = None):
        """
        :param str name: Name of the extracted variable.
        :param str example: Example of the extracted variable. Defaults to `""`.
        """
        pulumi.set(__self__, "name", name)
        if example is not None:
            pulumi.set(__self__, "example", example)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the extracted variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def example(self) -> Optional[str]:
        """
        Example of the extracted variable. Defaults to `""`.
        """
        return pulumi.get(self, "example")


@pulumi.output_type
class SyntheticsTestOptionsList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tickEvery":
            suggest = "tick_every"
        elif key == "acceptSelfSigned":
            suggest = "accept_self_signed"
        elif key == "allowInsecure":
            suggest = "allow_insecure"
        elif key == "checkCertificateRevocation":
            suggest = "check_certificate_revocation"
        elif key == "disableCors":
            suggest = "disable_cors"
        elif key == "disableCsp":
            suggest = "disable_csp"
        elif key == "followRedirects":
            suggest = "follow_redirects"
        elif key == "httpVersion":
            suggest = "http_version"
        elif key == "ignoreServerCertificateError":
            suggest = "ignore_server_certificate_error"
        elif key == "initialNavigationTimeout":
            suggest = "initial_navigation_timeout"
        elif key == "minFailureDuration":
            suggest = "min_failure_duration"
        elif key == "minLocationFailed":
            suggest = "min_location_failed"
        elif key == "monitorName":
            suggest = "monitor_name"
        elif key == "monitorOptions":
            suggest = "monitor_options"
        elif key == "monitorPriority":
            suggest = "monitor_priority"
        elif key == "noScreenshot":
            suggest = "no_screenshot"
        elif key == "restrictedRoles":
            suggest = "restricted_roles"
        elif key == "rumSettings":
            suggest = "rum_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestOptionsList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestOptionsList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestOptionsList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tick_every: int,
                 accept_self_signed: Optional[bool] = None,
                 allow_insecure: Optional[bool] = None,
                 check_certificate_revocation: Optional[bool] = None,
                 ci: Optional['outputs.SyntheticsTestOptionsListCi'] = None,
                 disable_cors: Optional[bool] = None,
                 disable_csp: Optional[bool] = None,
                 follow_redirects: Optional[bool] = None,
                 http_version: Optional[str] = None,
                 ignore_server_certificate_error: Optional[bool] = None,
                 initial_navigation_timeout: Optional[int] = None,
                 min_failure_duration: Optional[int] = None,
                 min_location_failed: Optional[int] = None,
                 monitor_name: Optional[str] = None,
                 monitor_options: Optional['outputs.SyntheticsTestOptionsListMonitorOptions'] = None,
                 monitor_priority: Optional[int] = None,
                 no_screenshot: Optional[bool] = None,
                 restricted_roles: Optional[Sequence[str]] = None,
                 retry: Optional['outputs.SyntheticsTestOptionsListRetry'] = None,
                 rum_settings: Optional['outputs.SyntheticsTestOptionsListRumSettings'] = None,
                 scheduling: Optional['outputs.SyntheticsTestOptionsListScheduling'] = None):
        """
        :param int tick_every: How often the test should run (in seconds).
        :param bool accept_self_signed: For SSL test, whether or not the test should allow self signed certificates.
        :param bool allow_insecure: Allows loading insecure content for a request in an API test or in a multistep API test step.
        :param bool check_certificate_revocation: For SSL test, whether or not the test should fail on revoked certificate in stapled OCSP.
        :param 'SyntheticsTestOptionsListCiArgs' ci: CI/CD options for a Synthetic test.
        :param bool disable_cors: Disable Cross-Origin Resource Sharing for browser tests.
        :param bool disable_csp: Disable Content Security Policy for browser tests.
        :param bool follow_redirects: Determines whether or not the API HTTP test should follow redirects.
        :param str http_version: HTTP version to use for an HTTP request in an API test or step. Valid values are `http1`, `http2`, `any`. Defaults to `"any"`.
        :param bool ignore_server_certificate_error: Ignore server certificate error for browser tests.
        :param int initial_navigation_timeout: Timeout before declaring the initial step as failed (in seconds) for browser tests.
        :param int min_failure_duration: Minimum amount of time in failure required to trigger an alert (in seconds). Default is `0`.
        :param int min_location_failed: Minimum number of locations in failure required to trigger an alert. Defaults to `1`.
        :param str monitor_name: The monitor name is used for the alert title as well as for all monitor dashboard widgets and SLOs.
        :param bool no_screenshot: Prevents saving screenshots of the steps.
        :param Sequence[str] restricted_roles: A list of role identifiers pulled from the Roles API to restrict read and write access.
        :param 'SyntheticsTestOptionsListRumSettingsArgs' rum_settings: The RUM data collection settings for the Synthetic browser test.
        :param 'SyntheticsTestOptionsListSchedulingArgs' scheduling: Object containing timeframes and timezone used for advanced scheduling.
        """
        pulumi.set(__self__, "tick_every", tick_every)
        if accept_self_signed is not None:
            pulumi.set(__self__, "accept_self_signed", accept_self_signed)
        if allow_insecure is not None:
            pulumi.set(__self__, "allow_insecure", allow_insecure)
        if check_certificate_revocation is not None:
            pulumi.set(__self__, "check_certificate_revocation", check_certificate_revocation)
        if ci is not None:
            pulumi.set(__self__, "ci", ci)
        if disable_cors is not None:
            pulumi.set(__self__, "disable_cors", disable_cors)
        if disable_csp is not None:
            pulumi.set(__self__, "disable_csp", disable_csp)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if http_version is not None:
            pulumi.set(__self__, "http_version", http_version)
        if ignore_server_certificate_error is not None:
            pulumi.set(__self__, "ignore_server_certificate_error", ignore_server_certificate_error)
        if initial_navigation_timeout is not None:
            pulumi.set(__self__, "initial_navigation_timeout", initial_navigation_timeout)
        if min_failure_duration is not None:
            pulumi.set(__self__, "min_failure_duration", min_failure_duration)
        if min_location_failed is not None:
            pulumi.set(__self__, "min_location_failed", min_location_failed)
        if monitor_name is not None:
            pulumi.set(__self__, "monitor_name", monitor_name)
        if monitor_options is not None:
            pulumi.set(__self__, "monitor_options", monitor_options)
        if monitor_priority is not None:
            pulumi.set(__self__, "monitor_priority", monitor_priority)
        if no_screenshot is not None:
            pulumi.set(__self__, "no_screenshot", no_screenshot)
        if restricted_roles is not None:
            pulumi.set(__self__, "restricted_roles", restricted_roles)
        if retry is not None:
            pulumi.set(__self__, "retry", retry)
        if rum_settings is not None:
            pulumi.set(__self__, "rum_settings", rum_settings)
        if scheduling is not None:
            pulumi.set(__self__, "scheduling", scheduling)

    @property
    @pulumi.getter(name="tickEvery")
    def tick_every(self) -> int:
        """
        How often the test should run (in seconds).
        """
        return pulumi.get(self, "tick_every")

    @property
    @pulumi.getter(name="acceptSelfSigned")
    def accept_self_signed(self) -> Optional[bool]:
        """
        For SSL test, whether or not the test should allow self signed certificates.
        """
        return pulumi.get(self, "accept_self_signed")

    @property
    @pulumi.getter(name="allowInsecure")
    def allow_insecure(self) -> Optional[bool]:
        """
        Allows loading insecure content for a request in an API test or in a multistep API test step.
        """
        return pulumi.get(self, "allow_insecure")

    @property
    @pulumi.getter(name="checkCertificateRevocation")
    def check_certificate_revocation(self) -> Optional[bool]:
        """
        For SSL test, whether or not the test should fail on revoked certificate in stapled OCSP.
        """
        return pulumi.get(self, "check_certificate_revocation")

    @property
    @pulumi.getter
    def ci(self) -> Optional['outputs.SyntheticsTestOptionsListCi']:
        """
        CI/CD options for a Synthetic test.
        """
        return pulumi.get(self, "ci")

    @property
    @pulumi.getter(name="disableCors")
    def disable_cors(self) -> Optional[bool]:
        """
        Disable Cross-Origin Resource Sharing for browser tests.
        """
        return pulumi.get(self, "disable_cors")

    @property
    @pulumi.getter(name="disableCsp")
    def disable_csp(self) -> Optional[bool]:
        """
        Disable Content Security Policy for browser tests.
        """
        return pulumi.get(self, "disable_csp")

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[bool]:
        """
        Determines whether or not the API HTTP test should follow redirects.
        """
        return pulumi.get(self, "follow_redirects")

    @property
    @pulumi.getter(name="httpVersion")
    def http_version(self) -> Optional[str]:
        """
        HTTP version to use for an HTTP request in an API test or step. Valid values are `http1`, `http2`, `any`. Defaults to `"any"`.
        """
        return pulumi.get(self, "http_version")

    @property
    @pulumi.getter(name="ignoreServerCertificateError")
    def ignore_server_certificate_error(self) -> Optional[bool]:
        """
        Ignore server certificate error for browser tests.
        """
        return pulumi.get(self, "ignore_server_certificate_error")

    @property
    @pulumi.getter(name="initialNavigationTimeout")
    def initial_navigation_timeout(self) -> Optional[int]:
        """
        Timeout before declaring the initial step as failed (in seconds) for browser tests.
        """
        return pulumi.get(self, "initial_navigation_timeout")

    @property
    @pulumi.getter(name="minFailureDuration")
    def min_failure_duration(self) -> Optional[int]:
        """
        Minimum amount of time in failure required to trigger an alert (in seconds). Default is `0`.
        """
        return pulumi.get(self, "min_failure_duration")

    @property
    @pulumi.getter(name="minLocationFailed")
    def min_location_failed(self) -> Optional[int]:
        """
        Minimum number of locations in failure required to trigger an alert. Defaults to `1`.
        """
        return pulumi.get(self, "min_location_failed")

    @property
    @pulumi.getter(name="monitorName")
    def monitor_name(self) -> Optional[str]:
        """
        The monitor name is used for the alert title as well as for all monitor dashboard widgets and SLOs.
        """
        return pulumi.get(self, "monitor_name")

    @property
    @pulumi.getter(name="monitorOptions")
    def monitor_options(self) -> Optional['outputs.SyntheticsTestOptionsListMonitorOptions']:
        return pulumi.get(self, "monitor_options")

    @property
    @pulumi.getter(name="monitorPriority")
    def monitor_priority(self) -> Optional[int]:
        return pulumi.get(self, "monitor_priority")

    @property
    @pulumi.getter(name="noScreenshot")
    def no_screenshot(self) -> Optional[bool]:
        """
        Prevents saving screenshots of the steps.
        """
        return pulumi.get(self, "no_screenshot")

    @property
    @pulumi.getter(name="restrictedRoles")
    def restricted_roles(self) -> Optional[Sequence[str]]:
        """
        A list of role identifiers pulled from the Roles API to restrict read and write access.
        """
        return pulumi.get(self, "restricted_roles")

    @property
    @pulumi.getter
    def retry(self) -> Optional['outputs.SyntheticsTestOptionsListRetry']:
        return pulumi.get(self, "retry")

    @property
    @pulumi.getter(name="rumSettings")
    def rum_settings(self) -> Optional['outputs.SyntheticsTestOptionsListRumSettings']:
        """
        The RUM data collection settings for the Synthetic browser test.
        """
        return pulumi.get(self, "rum_settings")

    @property
    @pulumi.getter
    def scheduling(self) -> Optional['outputs.SyntheticsTestOptionsListScheduling']:
        """
        Object containing timeframes and timezone used for advanced scheduling.
        """
        return pulumi.get(self, "scheduling")


@pulumi.output_type
class SyntheticsTestOptionsListCi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "executionRule":
            suggest = "execution_rule"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestOptionsListCi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestOptionsListCi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestOptionsListCi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 execution_rule: Optional[str] = None):
        """
        :param str execution_rule: Execution rule for a Synthetics test. Valid values are `blocking`, `non_blocking`, `skipped`.
        """
        if execution_rule is not None:
            pulumi.set(__self__, "execution_rule", execution_rule)

    @property
    @pulumi.getter(name="executionRule")
    def execution_rule(self) -> Optional[str]:
        """
        Execution rule for a Synthetics test. Valid values are `blocking`, `non_blocking`, `skipped`.
        """
        return pulumi.get(self, "execution_rule")


@pulumi.output_type
class SyntheticsTestOptionsListMonitorOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renotifyInterval":
            suggest = "renotify_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestOptionsListMonitorOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestOptionsListMonitorOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestOptionsListMonitorOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 renotify_interval: Optional[int] = None):
        """
        :param int renotify_interval: Specify a renotification frequency in minutes. Values available by default are `0`, `10`, `20`, `30`, `40`, `50`, `60`, `90`, `120`, `180`, `240`, `300`, `360`, `720`, `1440`. Defaults to `0`.
        """
        if renotify_interval is not None:
            pulumi.set(__self__, "renotify_interval", renotify_interval)

    @property
    @pulumi.getter(name="renotifyInterval")
    def renotify_interval(self) -> Optional[int]:
        """
        Specify a renotification frequency in minutes. Values available by default are `0`, `10`, `20`, `30`, `40`, `50`, `60`, `90`, `120`, `180`, `240`, `300`, `360`, `720`, `1440`. Defaults to `0`.
        """
        return pulumi.get(self, "renotify_interval")


@pulumi.output_type
class SyntheticsTestOptionsListRetry(dict):
    def __init__(__self__, *,
                 count: Optional[int] = None,
                 interval: Optional[int] = None):
        """
        :param int count: Number of retries needed to consider a location as failed before sending a notification alert. Maximum value: `5`. Defaults to `0`.
        :param int interval: Interval between a failed test and the next retry in milliseconds. Maximum value: `5000`. Defaults to `300`.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)

    @property
    @pulumi.getter
    def count(self) -> Optional[int]:
        """
        Number of retries needed to consider a location as failed before sending a notification alert. Maximum value: `5`. Defaults to `0`.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def interval(self) -> Optional[int]:
        """
        Interval between a failed test and the next retry in milliseconds. Maximum value: `5000`. Defaults to `300`.
        """
        return pulumi.get(self, "interval")


@pulumi.output_type
class SyntheticsTestOptionsListRumSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"
        elif key == "applicationId":
            suggest = "application_id"
        elif key == "clientTokenId":
            suggest = "client_token_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestOptionsListRumSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestOptionsListRumSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestOptionsListRumSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: bool,
                 application_id: Optional[str] = None,
                 client_token_id: Optional[int] = None):
        """
        :param bool is_enabled: Determines whether RUM data is collected during test runs.
        :param str application_id: RUM application ID used to collect RUM data for the browser test.
        :param int client_token_id: RUM application API key ID used to collect RUM data for the browser test.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        if application_id is not None:
            pulumi.set(__self__, "application_id", application_id)
        if client_token_id is not None:
            pulumi.set(__self__, "client_token_id", client_token_id)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Determines whether RUM data is collected during test runs.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="applicationId")
    def application_id(self) -> Optional[str]:
        """
        RUM application ID used to collect RUM data for the browser test.
        """
        return pulumi.get(self, "application_id")

    @property
    @pulumi.getter(name="clientTokenId")
    def client_token_id(self) -> Optional[int]:
        """
        RUM application API key ID used to collect RUM data for the browser test.
        """
        return pulumi.get(self, "client_token_id")


@pulumi.output_type
class SyntheticsTestOptionsListScheduling(dict):
    def __init__(__self__, *,
                 timeframes: Sequence['outputs.SyntheticsTestOptionsListSchedulingTimeframe'],
                 timezone: str):
        """
        :param Sequence['SyntheticsTestOptionsListSchedulingTimeframeArgs'] timeframes: Array containing objects describing the scheduling pattern to apply to each day.
        :param str timezone: Timezone in which the timeframe is based.
        """
        pulumi.set(__self__, "timeframes", timeframes)
        pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter
    def timeframes(self) -> Sequence['outputs.SyntheticsTestOptionsListSchedulingTimeframe']:
        """
        Array containing objects describing the scheduling pattern to apply to each day.
        """
        return pulumi.get(self, "timeframes")

    @property
    @pulumi.getter
    def timezone(self) -> str:
        """
        Timezone in which the timeframe is based.
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class SyntheticsTestOptionsListSchedulingTimeframe(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestOptionsListSchedulingTimeframe. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestOptionsListSchedulingTimeframe.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestOptionsListSchedulingTimeframe.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day: int,
                 from_: str,
                 to: str):
        """
        :param int day: Number representing the day of the week
        :param str from_: The hour of the day on which scheduling starts.
        :param str to: The hour of the day on which scheduling ends.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter
    def day(self) -> int:
        """
        Number representing the day of the week
        """
        return pulumi.get(self, "day")

    @property
    @pulumi.getter(name="from")
    def from_(self) -> str:
        """
        The hour of the day on which scheduling starts.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> str:
        """
        The hour of the day on which scheduling ends.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class SyntheticsTestRequestBasicauth(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "accessTokenUrl":
            suggest = "access_token_url"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "serviceName":
            suggest = "service_name"
        elif key == "sessionToken":
            suggest = "session_token"
        elif key == "tokenApiAuthentication":
            suggest = "token_api_authentication"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestRequestBasicauth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestRequestBasicauth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestRequestBasicauth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[str] = None,
                 access_token_url: Optional[str] = None,
                 audience: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_secret: Optional[str] = None,
                 domain: Optional[str] = None,
                 password: Optional[str] = None,
                 region: Optional[str] = None,
                 resource: Optional[str] = None,
                 scope: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 service_name: Optional[str] = None,
                 session_token: Optional[str] = None,
                 token_api_authentication: Optional[str] = None,
                 type: Optional[str] = None,
                 username: Optional[str] = None,
                 workstation: Optional[str] = None):
        """
        :param str access_key: Access key for `SIGV4` authentication.
        :param str access_token_url: Access token url for `oauth-client` or `oauth-rop` authentication.
        :param str audience: Audience for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        :param str client_id: Client ID for `oauth-client` or `oauth-rop` authentication.
        :param str client_secret: Client secret for `oauth-client` or `oauth-rop` authentication.
        :param str domain: Domain for `ntlm` authentication.
        :param str password: Password for authentication.
        :param str region: Region for `SIGV4` authentication.
        :param str resource: Resource for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        :param str scope: Scope for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        :param str secret_key: Secret key for `SIGV4` authentication.
        :param str service_name: Service name for `SIGV4` authentication.
        :param str session_token: Session token for `SIGV4` authentication.
        :param str token_api_authentication: Token API Authentication for `oauth-client` or `oauth-rop` authentication. Valid values are `header`, `body`.
        :param str type: Type of basic authentication to use when performing the test. Defaults to `"web"`.
        :param str username: Username for authentication.
        :param str workstation: Workstation for `ntlm` authentication.
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if access_token_url is not None:
            pulumi.set(__self__, "access_token_url", access_token_url)
        if audience is not None:
            pulumi.set(__self__, "audience", audience)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)
        if session_token is not None:
            pulumi.set(__self__, "session_token", session_token)
        if token_api_authentication is not None:
            pulumi.set(__self__, "token_api_authentication", token_api_authentication)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if username is not None:
            pulumi.set(__self__, "username", username)
        if workstation is not None:
            pulumi.set(__self__, "workstation", workstation)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Access key for `SIGV4` authentication.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="accessTokenUrl")
    def access_token_url(self) -> Optional[str]:
        """
        Access token url for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "access_token_url")

    @property
    @pulumi.getter
    def audience(self) -> Optional[str]:
        """
        Audience for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        """
        return pulumi.get(self, "audience")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        Client ID for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[str]:
        """
        Client secret for `oauth-client` or `oauth-rop` authentication.
        """
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Domain for `ntlm` authentication.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def password(self) -> Optional[str]:
        """
        Password for authentication.
        """
        return pulumi.get(self, "password")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Region for `SIGV4` authentication.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter
    def resource(self) -> Optional[str]:
        """
        Resource for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def scope(self) -> Optional[str]:
        """
        Scope for `oauth-client` or `oauth-rop` authentication. Defaults to `""`.
        """
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Secret key for `SIGV4` authentication.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        Service name for `SIGV4` authentication.
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="sessionToken")
    def session_token(self) -> Optional[str]:
        """
        Session token for `SIGV4` authentication.
        """
        return pulumi.get(self, "session_token")

    @property
    @pulumi.getter(name="tokenApiAuthentication")
    def token_api_authentication(self) -> Optional[str]:
        """
        Token API Authentication for `oauth-client` or `oauth-rop` authentication. Valid values are `header`, `body`.
        """
        return pulumi.get(self, "token_api_authentication")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of basic authentication to use when performing the test. Defaults to `"web"`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def username(self) -> Optional[str]:
        """
        Username for authentication.
        """
        return pulumi.get(self, "username")

    @property
    @pulumi.getter
    def workstation(self) -> Optional[str]:
        """
        Workstation for `ntlm` authentication.
        """
        return pulumi.get(self, "workstation")


@pulumi.output_type
class SyntheticsTestRequestClientCertificate(dict):
    def __init__(__self__, *,
                 cert: 'outputs.SyntheticsTestRequestClientCertificateCert',
                 key: 'outputs.SyntheticsTestRequestClientCertificateKey'):
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def cert(self) -> 'outputs.SyntheticsTestRequestClientCertificateCert':
        return pulumi.get(self, "cert")

    @property
    @pulumi.getter
    def key(self) -> 'outputs.SyntheticsTestRequestClientCertificateKey':
        return pulumi.get(self, "key")


@pulumi.output_type
class SyntheticsTestRequestClientCertificateCert(dict):
    def __init__(__self__, *,
                 content: str,
                 filename: Optional[str] = None):
        """
        :param str content: Content of the certificate.
        :param str filename: File name for the certificate.
        """
        pulumi.set(__self__, "content", content)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Content of the certificate.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        """
        File name for the certificate.
        """
        return pulumi.get(self, "filename")


@pulumi.output_type
class SyntheticsTestRequestClientCertificateKey(dict):
    def __init__(__self__, *,
                 content: str,
                 filename: Optional[str] = None):
        """
        :param str content: Content of the certificate.
        :param str filename: File name for the certificate.
        """
        pulumi.set(__self__, "content", content)
        if filename is not None:
            pulumi.set(__self__, "filename", filename)

    @property
    @pulumi.getter
    def content(self) -> str:
        """
        Content of the certificate.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter
    def filename(self) -> Optional[str]:
        """
        File name for the certificate.
        """
        return pulumi.get(self, "filename")


@pulumi.output_type
class SyntheticsTestRequestDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodyType":
            suggest = "body_type"
        elif key == "callType":
            suggest = "call_type"
        elif key == "certificateDomains":
            suggest = "certificate_domains"
        elif key == "dnsServer":
            suggest = "dns_server"
        elif key == "dnsServerPort":
            suggest = "dns_server_port"
        elif key == "httpVersion":
            suggest = "http_version"
        elif key == "noSavingResponseBody":
            suggest = "no_saving_response_body"
        elif key == "numberOfPackets":
            suggest = "number_of_packets"
        elif key == "persistCookies":
            suggest = "persist_cookies"
        elif key == "plainProtoFile":
            suggest = "plain_proto_file"
        elif key == "protoJsonDescriptor":
            suggest = "proto_json_descriptor"
        elif key == "shouldTrackHops":
            suggest = "should_track_hops"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestRequestDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestRequestDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestRequestDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body: Optional[str] = None,
                 body_type: Optional[str] = None,
                 call_type: Optional[str] = None,
                 certificate_domains: Optional[Sequence[str]] = None,
                 dns_server: Optional[str] = None,
                 dns_server_port: Optional[str] = None,
                 host: Optional[str] = None,
                 http_version: Optional[str] = None,
                 message: Optional[str] = None,
                 method: Optional[str] = None,
                 no_saving_response_body: Optional[bool] = None,
                 number_of_packets: Optional[int] = None,
                 persist_cookies: Optional[bool] = None,
                 plain_proto_file: Optional[str] = None,
                 port: Optional[str] = None,
                 proto_json_descriptor: Optional[str] = None,
                 servername: Optional[str] = None,
                 service: Optional[str] = None,
                 should_track_hops: Optional[bool] = None,
                 timeout: Optional[int] = None,
                 url: Optional[str] = None):
        """
        :param str body: The request body.
        :param str body_type: Type of the request body. Valid values are `text/plain`, `application/json`, `text/xml`, `text/html`, `application/x-www-form-urlencoded`, `graphql`, `application/octet-stream`, `multipart/form-data`.
        :param str call_type: The type of gRPC call to perform. Valid values are `healthcheck`, `unary`.
        :param Sequence[str] certificate_domains: By default, the client certificate is applied on the domain of the starting URL for browser tests. If you want your client certificate to be applied on other domains instead, add them in `certificate_domains`.
        :param str dns_server: DNS server to use for DNS tests (`subtype = "dns"`).
        :param str dns_server_port: DNS server port to use for DNS tests.
        :param str host: Host name to perform the test with.
        :param str http_version: HTTP version to use for an HTTP request in an API test or step. **Deprecated.** Use `http_version` in the `options_list` field instead.
        :param str message: For UDP and websocket tests, message to send with the request.
        :param str method: Either the HTTP method/verb to use or a gRPC method available on the service set in the `service` field. Required if `subtype` is `HTTP` or if `subtype` is `grpc` and `callType` is `unary`.
        :param bool no_saving_response_body: Determines whether or not to save the response body.
        :param int number_of_packets: Number of pings to use per test for ICMP tests (`subtype = "icmp"`) between 0 and 10.
        :param bool persist_cookies: Persist cookies across redirects.
        :param str plain_proto_file: The content of a proto file as a string.
        :param str port: Port to use when performing the test.
        :param str proto_json_descriptor: A protobuf JSON descriptor. **Deprecated.** Use `plain_proto_file` instead.
        :param str servername: For SSL tests, it specifies on which server you want to initiate the TLS handshake, allowing the server to present one of multiple possible certificates on the same IP address and TCP port number.
        :param str service: The gRPC service on which you want to perform the gRPC call.
        :param bool should_track_hops: This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (`subtype = "icmp"`).
        :param int timeout: Timeout in seconds for the test.
        :param str url: The URL to send the request to.
        """
        if body is not None:
            pulumi.set(__self__, "body", body)
        if body_type is not None:
            pulumi.set(__self__, "body_type", body_type)
        if call_type is not None:
            pulumi.set(__self__, "call_type", call_type)
        if certificate_domains is not None:
            pulumi.set(__self__, "certificate_domains", certificate_domains)
        if dns_server is not None:
            pulumi.set(__self__, "dns_server", dns_server)
        if dns_server_port is not None:
            pulumi.set(__self__, "dns_server_port", dns_server_port)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if http_version is not None:
            pulumi.set(__self__, "http_version", http_version)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if no_saving_response_body is not None:
            pulumi.set(__self__, "no_saving_response_body", no_saving_response_body)
        if number_of_packets is not None:
            pulumi.set(__self__, "number_of_packets", number_of_packets)
        if persist_cookies is not None:
            pulumi.set(__self__, "persist_cookies", persist_cookies)
        if plain_proto_file is not None:
            pulumi.set(__self__, "plain_proto_file", plain_proto_file)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if proto_json_descriptor is not None:
            pulumi.set(__self__, "proto_json_descriptor", proto_json_descriptor)
        if servername is not None:
            pulumi.set(__self__, "servername", servername)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if should_track_hops is not None:
            pulumi.set(__self__, "should_track_hops", should_track_hops)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def body(self) -> Optional[str]:
        """
        The request body.
        """
        return pulumi.get(self, "body")

    @property
    @pulumi.getter(name="bodyType")
    def body_type(self) -> Optional[str]:
        """
        Type of the request body. Valid values are `text/plain`, `application/json`, `text/xml`, `text/html`, `application/x-www-form-urlencoded`, `graphql`, `application/octet-stream`, `multipart/form-data`.
        """
        return pulumi.get(self, "body_type")

    @property
    @pulumi.getter(name="callType")
    def call_type(self) -> Optional[str]:
        """
        The type of gRPC call to perform. Valid values are `healthcheck`, `unary`.
        """
        return pulumi.get(self, "call_type")

    @property
    @pulumi.getter(name="certificateDomains")
    def certificate_domains(self) -> Optional[Sequence[str]]:
        """
        By default, the client certificate is applied on the domain of the starting URL for browser tests. If you want your client certificate to be applied on other domains instead, add them in `certificate_domains`.
        """
        return pulumi.get(self, "certificate_domains")

    @property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> Optional[str]:
        """
        DNS server to use for DNS tests (`subtype = "dns"`).
        """
        return pulumi.get(self, "dns_server")

    @property
    @pulumi.getter(name="dnsServerPort")
    def dns_server_port(self) -> Optional[str]:
        """
        DNS server port to use for DNS tests.
        """
        return pulumi.get(self, "dns_server_port")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Host name to perform the test with.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="httpVersion")
    @_utilities.deprecated("""Use `http_version` in the `options_list` field instead.""")
    def http_version(self) -> Optional[str]:
        """
        HTTP version to use for an HTTP request in an API test or step. **Deprecated.** Use `http_version` in the `options_list` field instead.
        """
        return pulumi.get(self, "http_version")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        For UDP and websocket tests, message to send with the request.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def method(self) -> Optional[str]:
        """
        Either the HTTP method/verb to use or a gRPC method available on the service set in the `service` field. Required if `subtype` is `HTTP` or if `subtype` is `grpc` and `callType` is `unary`.
        """
        return pulumi.get(self, "method")

    @property
    @pulumi.getter(name="noSavingResponseBody")
    def no_saving_response_body(self) -> Optional[bool]:
        """
        Determines whether or not to save the response body.
        """
        return pulumi.get(self, "no_saving_response_body")

    @property
    @pulumi.getter(name="numberOfPackets")
    def number_of_packets(self) -> Optional[int]:
        """
        Number of pings to use per test for ICMP tests (`subtype = "icmp"`) between 0 and 10.
        """
        return pulumi.get(self, "number_of_packets")

    @property
    @pulumi.getter(name="persistCookies")
    def persist_cookies(self) -> Optional[bool]:
        """
        Persist cookies across redirects.
        """
        return pulumi.get(self, "persist_cookies")

    @property
    @pulumi.getter(name="plainProtoFile")
    def plain_proto_file(self) -> Optional[str]:
        """
        The content of a proto file as a string.
        """
        return pulumi.get(self, "plain_proto_file")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Port to use when performing the test.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="protoJsonDescriptor")
    @_utilities.deprecated("""Use `plain_proto_file` instead.""")
    def proto_json_descriptor(self) -> Optional[str]:
        """
        A protobuf JSON descriptor. **Deprecated.** Use `plain_proto_file` instead.
        """
        return pulumi.get(self, "proto_json_descriptor")

    @property
    @pulumi.getter
    def servername(self) -> Optional[str]:
        """
        For SSL tests, it specifies on which server you want to initiate the TLS handshake, allowing the server to present one of multiple possible certificates on the same IP address and TCP port number.
        """
        return pulumi.get(self, "servername")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        The gRPC service on which you want to perform the gRPC call.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="shouldTrackHops")
    def should_track_hops(self) -> Optional[bool]:
        """
        This will turn on a traceroute probe to discover all gateways along the path to the host destination. For ICMP tests (`subtype = "icmp"`).
        """
        return pulumi.get(self, "should_track_hops")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        Timeout in seconds for the test.
        """
        return pulumi.get(self, "timeout")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The URL to send the request to.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class SyntheticsTestRequestFile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketKey":
            suggest = "bucket_key"
        elif key == "originalFileName":
            suggest = "original_file_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SyntheticsTestRequestFile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SyntheticsTestRequestFile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SyntheticsTestRequestFile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 size: int,
                 type: str,
                 bucket_key: Optional[str] = None,
                 content: Optional[str] = None,
                 original_file_name: Optional[str] = None):
        """
        :param str name: Name of the file.
        :param int size: Size of the file.
        :param str type: Type of the file.
        :param str bucket_key: Bucket key of the file.
        :param str content: Content of the file.
        :param str original_file_name: Original name of the file.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "type", type)
        if bucket_key is not None:
            pulumi.set(__self__, "bucket_key", bucket_key)
        if content is not None:
            pulumi.set(__self__, "content", content)
        if original_file_name is not None:
            pulumi.set(__self__, "original_file_name", original_file_name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the file.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def size(self) -> int:
        """
        Size of the file.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the file.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketKey")
    def bucket_key(self) -> Optional[str]:
        """
        Bucket key of the file.
        """
        return pulumi.get(self, "bucket_key")

    @property
    @pulumi.getter
    def content(self) -> Optional[str]:
        """
        Content of the file.
        """
        return pulumi.get(self, "content")

    @property
    @pulumi.getter(name="originalFileName")
    def original_file_name(self) -> Optional[str]:
        """
        Original name of the file.
        """
        return pulumi.get(self, "original_file_name")


@pulumi.output_type
class SyntheticsTestRequestProxy(dict):
    def __init__(__self__, *,
                 url: str,
                 headers: Optional[Mapping[str, str]] = None):
        """
        :param str url: URL of the proxy to perform the test.
        :param Mapping[str, str] headers: Header name and value map.
        """
        pulumi.set(__self__, "url", url)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        URL of the proxy to perform the test.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, str]]:
        """
        Header name and value map.
        """
        return pulumi.get(self, "headers")


@pulumi.output_type
class GetCloudWorkloadSecurityAgentRulesAgentRuleResult(dict):
    def __init__(__self__, *,
                 description: str,
                 enabled: bool,
                 expression: str,
                 id: str,
                 name: str):
        """
        :param str description: The description of the Agent rule.
        :param bool enabled: Whether the Agent rule is enabled.
        :param str expression: The SECL expression of the Agent rule.
        :param str id: The id of the Agent rule.
        :param str name: The name of the Agent rule.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        The description of the Agent rule.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the Agent rule is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The SECL expression of the Agent rule.
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the Agent rule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Agent rule.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCsmThreatsAgentRulesAgentRuleResult(dict):
    def __init__(__self__, *,
                 description: str,
                 enabled: bool,
                 expression: str,
                 id: str,
                 name: str):
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def expression(self) -> str:
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


@pulumi.output_type
class GetHostsHostListResult(dict):
    def __init__(__self__, *,
                 aliases: Sequence[str],
                 apps: Sequence[str],
                 aws_name: str,
                 host_name: str,
                 id: int,
                 is_muted: bool,
                 last_reported_time: int,
                 meta: 'outputs.GetHostsHostListMetaResult',
                 metrics: 'outputs.GetHostsHostListMetricsResult',
                 mute_timeout: int,
                 name: str,
                 sources: Sequence[str],
                 tags_by_source: Mapping[str, Sequence[str]],
                 up: bool):
        pulumi.set(__self__, "aliases", aliases)
        pulumi.set(__self__, "apps", apps)
        pulumi.set(__self__, "aws_name", aws_name)
        pulumi.set(__self__, "host_name", host_name)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_muted", is_muted)
        pulumi.set(__self__, "last_reported_time", last_reported_time)
        pulumi.set(__self__, "meta", meta)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "mute_timeout", mute_timeout)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sources", sources)
        pulumi.set(__self__, "tags_by_source", tags_by_source)
        pulumi.set(__self__, "up", up)

    @property
    @pulumi.getter
    def aliases(self) -> Sequence[str]:
        return pulumi.get(self, "aliases")

    @property
    @pulumi.getter
    def apps(self) -> Sequence[str]:
        return pulumi.get(self, "apps")

    @property
    @pulumi.getter(name="awsName")
    def aws_name(self) -> str:
        return pulumi.get(self, "aws_name")

    @property
    @pulumi.getter(name="hostName")
    def host_name(self) -> str:
        return pulumi.get(self, "host_name")

    @property
    @pulumi.getter
    def id(self) -> int:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isMuted")
    def is_muted(self) -> bool:
        return pulumi.get(self, "is_muted")

    @property
    @pulumi.getter(name="lastReportedTime")
    def last_reported_time(self) -> int:
        return pulumi.get(self, "last_reported_time")

    @property
    @pulumi.getter
    def meta(self) -> 'outputs.GetHostsHostListMetaResult':
        return pulumi.get(self, "meta")

    @property
    @pulumi.getter
    def metrics(self) -> 'outputs.GetHostsHostListMetricsResult':
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter(name="muteTimeout")
    def mute_timeout(self) -> int:
        return pulumi.get(self, "mute_timeout")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def sources(self) -> Sequence[str]:
        return pulumi.get(self, "sources")

    @property
    @pulumi.getter(name="tagsBySource")
    def tags_by_source(self) -> Mapping[str, Sequence[str]]:
        return pulumi.get(self, "tags_by_source")

    @property
    @pulumi.getter
    def up(self) -> bool:
        return pulumi.get(self, "up")


@pulumi.output_type
class GetHostsHostListMetaResult(dict):
    def __init__(__self__, *,
                 agent_version: str,
                 cpu_cores: int,
                 gohai: str,
                 machine: str,
                 platform: str,
                 processor: str,
                 python_version: str,
                 socket_fqdn: str,
                 socket_hostname: str):
        pulumi.set(__self__, "agent_version", agent_version)
        pulumi.set(__self__, "cpu_cores", cpu_cores)
        pulumi.set(__self__, "gohai", gohai)
        pulumi.set(__self__, "machine", machine)
        pulumi.set(__self__, "platform", platform)
        pulumi.set(__self__, "processor", processor)
        pulumi.set(__self__, "python_version", python_version)
        pulumi.set(__self__, "socket_fqdn", socket_fqdn)
        pulumi.set(__self__, "socket_hostname", socket_hostname)

    @property
    @pulumi.getter(name="agentVersion")
    def agent_version(self) -> str:
        return pulumi.get(self, "agent_version")

    @property
    @pulumi.getter(name="cpuCores")
    def cpu_cores(self) -> int:
        return pulumi.get(self, "cpu_cores")

    @property
    @pulumi.getter
    def gohai(self) -> str:
        return pulumi.get(self, "gohai")

    @property
    @pulumi.getter
    def machine(self) -> str:
        return pulumi.get(self, "machine")

    @property
    @pulumi.getter
    def platform(self) -> str:
        return pulumi.get(self, "platform")

    @property
    @pulumi.getter
    def processor(self) -> str:
        return pulumi.get(self, "processor")

    @property
    @pulumi.getter(name="pythonVersion")
    def python_version(self) -> str:
        return pulumi.get(self, "python_version")

    @property
    @pulumi.getter(name="socketFqdn")
    def socket_fqdn(self) -> str:
        return pulumi.get(self, "socket_fqdn")

    @property
    @pulumi.getter(name="socketHostname")
    def socket_hostname(self) -> str:
        return pulumi.get(self, "socket_hostname")


@pulumi.output_type
class GetHostsHostListMetricsResult(dict):
    def __init__(__self__, *,
                 cpu: float,
                 iowait: float,
                 load: float):
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "iowait", iowait)
        pulumi.set(__self__, "load", load)

    @property
    @pulumi.getter
    def cpu(self) -> float:
        return pulumi.get(self, "cpu")

    @property
    @pulumi.getter
    def iowait(self) -> float:
        return pulumi.get(self, "iowait")

    @property
    @pulumi.getter
    def load(self) -> float:
        return pulumi.get(self, "load")


@pulumi.output_type
class GetLogsIndexesLogsIndexResult(dict):
    def __init__(__self__, *,
                 daily_limit: int,
                 daily_limit_resets: Sequence['outputs.GetLogsIndexesLogsIndexDailyLimitResetResult'],
                 daily_limit_warning_threshold_percentage: float,
                 exclusion_filters: Sequence['outputs.GetLogsIndexesLogsIndexExclusionFilterResult'],
                 filters: Sequence['outputs.GetLogsIndexesLogsIndexFilterResult'],
                 flex_retention_days: int,
                 name: str,
                 retention_days: int):
        """
        :param int daily_limit: The number of log events you can send in this index per day before you are rate-limited.
        :param Sequence['GetLogsIndexesLogsIndexDailyLimitResetArgs'] daily_limit_resets: Object containing options to override the default daily limit reset time.
        :param float daily_limit_warning_threshold_percentage: The percentage threshold of the daily quota at which a Datadog warning event is generated.
        :param Sequence['GetLogsIndexesLogsIndexExclusionFilterArgs'] exclusion_filters: List of exclusion filters.
        :param Sequence['GetLogsIndexesLogsIndexFilterArgs'] filters: Logs filter
        :param int flex_retention_days: The total number of days logs are stored in Standard and Flex Tier before being deleted from the index.
        :param str name: The name of the index.
        :param int retention_days: The number of days logs are stored in Standard Tier before aging into the Flex Tier or being deleted from the index.
        """
        pulumi.set(__self__, "daily_limit", daily_limit)
        pulumi.set(__self__, "daily_limit_resets", daily_limit_resets)
        pulumi.set(__self__, "daily_limit_warning_threshold_percentage", daily_limit_warning_threshold_percentage)
        pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "flex_retention_days", flex_retention_days)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "retention_days", retention_days)

    @property
    @pulumi.getter(name="dailyLimit")
    def daily_limit(self) -> int:
        """
        The number of log events you can send in this index per day before you are rate-limited.
        """
        return pulumi.get(self, "daily_limit")

    @property
    @pulumi.getter(name="dailyLimitResets")
    def daily_limit_resets(self) -> Sequence['outputs.GetLogsIndexesLogsIndexDailyLimitResetResult']:
        """
        Object containing options to override the default daily limit reset time.
        """
        return pulumi.get(self, "daily_limit_resets")

    @property
    @pulumi.getter(name="dailyLimitWarningThresholdPercentage")
    def daily_limit_warning_threshold_percentage(self) -> float:
        """
        The percentage threshold of the daily quota at which a Datadog warning event is generated.
        """
        return pulumi.get(self, "daily_limit_warning_threshold_percentage")

    @property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Sequence['outputs.GetLogsIndexesLogsIndexExclusionFilterResult']:
        """
        List of exclusion filters.
        """
        return pulumi.get(self, "exclusion_filters")

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.GetLogsIndexesLogsIndexFilterResult']:
        """
        Logs filter
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="flexRetentionDays")
    def flex_retention_days(self) -> int:
        """
        The total number of days logs are stored in Standard and Flex Tier before being deleted from the index.
        """
        return pulumi.get(self, "flex_retention_days")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the index.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="retentionDays")
    def retention_days(self) -> int:
        """
        The number of days logs are stored in Standard Tier before aging into the Flex Tier or being deleted from the index.
        """
        return pulumi.get(self, "retention_days")


@pulumi.output_type
class GetLogsIndexesLogsIndexDailyLimitResetResult(dict):
    def __init__(__self__, *,
                 reset_time: str,
                 reset_utc_offset: str):
        """
        :param str reset_time: String in `HH:00` format representing the time of day the daily limit should be reset. The hours between 00 and 23 (inclusive).
        :param str reset_utc_offset: String in `(-|+)HH:00` format representing the UTC offset to apply to the given reset time. The hours between -12 and +14 (inclusive).
        """
        pulumi.set(__self__, "reset_time", reset_time)
        pulumi.set(__self__, "reset_utc_offset", reset_utc_offset)

    @property
    @pulumi.getter(name="resetTime")
    def reset_time(self) -> str:
        """
        String in `HH:00` format representing the time of day the daily limit should be reset. The hours between 00 and 23 (inclusive).
        """
        return pulumi.get(self, "reset_time")

    @property
    @pulumi.getter(name="resetUtcOffset")
    def reset_utc_offset(self) -> str:
        """
        String in `(-|+)HH:00` format representing the UTC offset to apply to the given reset time. The hours between -12 and +14 (inclusive).
        """
        return pulumi.get(self, "reset_utc_offset")


@pulumi.output_type
class GetLogsIndexesLogsIndexExclusionFilterResult(dict):
    def __init__(__self__, *,
                 is_enabled: bool,
                 name: str,
                 filters: Optional[Sequence['outputs.GetLogsIndexesLogsIndexExclusionFilterFilterResult']] = None):
        """
        :param bool is_enabled: A boolean stating if the exclusion is active or not.
        :param str name: The name of the exclusion filter.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "name", name)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        A boolean stating if the exclusion is active or not.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the exclusion filter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.GetLogsIndexesLogsIndexExclusionFilterFilterResult']]:
        return pulumi.get(self, "filters")


@pulumi.output_type
class GetLogsIndexesLogsIndexExclusionFilterFilterResult(dict):
    def __init__(__self__, *,
                 query: str,
                 sample_rate: float):
        """
        :param str query: Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.
        :param float sample_rate: The fraction of logs excluded by the exclusion filter, when active.
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "sample_rate", sample_rate)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Only logs matching the filter criteria and the query of the parent index will be considered for this exclusion filter.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="sampleRate")
    def sample_rate(self) -> float:
        """
        The fraction of logs excluded by the exclusion filter, when active.
        """
        return pulumi.get(self, "sample_rate")


@pulumi.output_type
class GetLogsIndexesLogsIndexFilterResult(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Logs filter criteria. Only logs matching this filter criteria are considered for this index.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Logs filter criteria. Only logs matching this filter criteria are considered for this index.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class GetLogsPipelinesLogsPipelineResult(dict):
    def __init__(__self__, *,
                 filters: Sequence['outputs.GetLogsPipelinesLogsPipelineFilterResult'],
                 id: str,
                 is_enabled: bool,
                 is_read_only: bool,
                 name: str,
                 type: str):
        """
        :param Sequence['GetLogsPipelinesLogsPipelineFilterArgs'] filters: Pipelines filter
        :param str id: ID of the pipeline
        :param bool is_enabled: Whether or not the pipeline is enabled.
        :param bool is_read_only: Whether or not the pipeline can be edited.
        :param str name: The name of the pipeline.
        :param str type: Whether or not the pipeline can be edited.
        """
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "is_read_only", is_read_only)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.GetLogsPipelinesLogsPipelineFilterResult']:
        """
        Pipelines filter
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the pipeline
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Whether or not the pipeline is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter(name="isReadOnly")
    def is_read_only(self) -> bool:
        """
        Whether or not the pipeline can be edited.
        """
        return pulumi.get(self, "is_read_only")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the pipeline.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Whether or not the pipeline can be edited.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetLogsPipelinesLogsPipelineFilterResult(dict):
    def __init__(__self__, *,
                 query: str):
        """
        :param str query: Pipeline filter criteria.
        """
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Pipeline filter criteria.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class GetMonitorConfigPoliciesMonitorConfigPolicyResult(dict):
    def __init__(__self__, *,
                 id: str,
                 policy_type: str,
                 tag_policy: 'outputs.GetMonitorConfigPoliciesMonitorConfigPolicyTagPolicyResult'):
        """
        :param str id: ID of the monitor config policy
        :param str policy_type: The monitor config policy type
        :param 'GetMonitorConfigPoliciesMonitorConfigPolicyTagPolicyArgs' tag_policy: Config for a tag policy. Only set if `policy_type` is `tag`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "policy_type", policy_type)
        pulumi.set(__self__, "tag_policy", tag_policy)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the monitor config policy
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="policyType")
    def policy_type(self) -> str:
        """
        The monitor config policy type
        """
        return pulumi.get(self, "policy_type")

    @property
    @pulumi.getter(name="tagPolicy")
    def tag_policy(self) -> 'outputs.GetMonitorConfigPoliciesMonitorConfigPolicyTagPolicyResult':
        """
        Config for a tag policy. Only set if `policy_type` is `tag`.
        """
        return pulumi.get(self, "tag_policy")


@pulumi.output_type
class GetMonitorConfigPoliciesMonitorConfigPolicyTagPolicyResult(dict):
    def __init__(__self__, *,
                 tag_key: str,
                 tag_key_required: bool,
                 valid_tag_values: Sequence[str]):
        """
        :param str tag_key: The key of the tag
        :param bool tag_key_required: If a tag key is required for monitor creation
        :param Sequence[str] valid_tag_values: Valid values for the tag
        """
        pulumi.set(__self__, "tag_key", tag_key)
        pulumi.set(__self__, "tag_key_required", tag_key_required)
        pulumi.set(__self__, "valid_tag_values", valid_tag_values)

    @property
    @pulumi.getter(name="tagKey")
    def tag_key(self) -> str:
        """
        The key of the tag
        """
        return pulumi.get(self, "tag_key")

    @property
    @pulumi.getter(name="tagKeyRequired")
    def tag_key_required(self) -> bool:
        """
        If a tag key is required for monitor creation
        """
        return pulumi.get(self, "tag_key_required")

    @property
    @pulumi.getter(name="validTagValues")
    def valid_tag_values(self) -> Sequence[str]:
        """
        Valid values for the tag
        """
        return pulumi.get(self, "valid_tag_values")


@pulumi.output_type
class GetMonitorMonitorThresholdResult(dict):
    def __init__(__self__, *,
                 critical: str,
                 critical_recovery: str,
                 ok: str,
                 unknown: str,
                 warning: str,
                 warning_recovery: str):
        pulumi.set(__self__, "critical", critical)
        pulumi.set(__self__, "critical_recovery", critical_recovery)
        pulumi.set(__self__, "ok", ok)
        pulumi.set(__self__, "unknown", unknown)
        pulumi.set(__self__, "warning", warning)
        pulumi.set(__self__, "warning_recovery", warning_recovery)

    @property
    @pulumi.getter
    def critical(self) -> str:
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter(name="criticalRecovery")
    def critical_recovery(self) -> str:
        return pulumi.get(self, "critical_recovery")

    @property
    @pulumi.getter
    def ok(self) -> str:
        return pulumi.get(self, "ok")

    @property
    @pulumi.getter
    def unknown(self) -> str:
        return pulumi.get(self, "unknown")

    @property
    @pulumi.getter
    def warning(self) -> str:
        return pulumi.get(self, "warning")

    @property
    @pulumi.getter(name="warningRecovery")
    def warning_recovery(self) -> str:
        return pulumi.get(self, "warning_recovery")


@pulumi.output_type
class GetMonitorMonitorThresholdWindowResult(dict):
    def __init__(__self__, *,
                 recovery_window: str,
                 trigger_window: str):
        pulumi.set(__self__, "recovery_window", recovery_window)
        pulumi.set(__self__, "trigger_window", trigger_window)

    @property
    @pulumi.getter(name="recoveryWindow")
    def recovery_window(self) -> str:
        return pulumi.get(self, "recovery_window")

    @property
    @pulumi.getter(name="triggerWindow")
    def trigger_window(self) -> str:
        return pulumi.get(self, "trigger_window")


@pulumi.output_type
class GetMonitorSchedulingOptionResult(dict):
    def __init__(__self__, *,
                 custom_schedules: Sequence['outputs.GetMonitorSchedulingOptionCustomScheduleResult'],
                 evaluation_windows: Sequence['outputs.GetMonitorSchedulingOptionEvaluationWindowResult']):
        """
        :param Sequence['GetMonitorSchedulingOptionCustomScheduleArgs'] custom_schedules: Configuration options for the custom schedules. If `start` is omitted, the monitor creation time will be used.
        :param Sequence['GetMonitorSchedulingOptionEvaluationWindowArgs'] evaluation_windows: Configuration options for the evaluation window. If `hour_starts` is set, no other fields may be set. Otherwise, `day_starts` and `month_starts` must be set together.
        """
        pulumi.set(__self__, "custom_schedules", custom_schedules)
        pulumi.set(__self__, "evaluation_windows", evaluation_windows)

    @property
    @pulumi.getter(name="customSchedules")
    def custom_schedules(self) -> Sequence['outputs.GetMonitorSchedulingOptionCustomScheduleResult']:
        """
        Configuration options for the custom schedules. If `start` is omitted, the monitor creation time will be used.
        """
        return pulumi.get(self, "custom_schedules")

    @property
    @pulumi.getter(name="evaluationWindows")
    def evaluation_windows(self) -> Sequence['outputs.GetMonitorSchedulingOptionEvaluationWindowResult']:
        """
        Configuration options for the evaluation window. If `hour_starts` is set, no other fields may be set. Otherwise, `day_starts` and `month_starts` must be set together.
        """
        return pulumi.get(self, "evaluation_windows")


@pulumi.output_type
class GetMonitorSchedulingOptionCustomScheduleResult(dict):
    def __init__(__self__, *,
                 recurrences: Sequence['outputs.GetMonitorSchedulingOptionCustomScheduleRecurrenceResult']):
        """
        :param Sequence['GetMonitorSchedulingOptionCustomScheduleRecurrenceArgs'] recurrences: A list of recurrence definitions. Length must be 1.
        """
        pulumi.set(__self__, "recurrences", recurrences)

    @property
    @pulumi.getter
    def recurrences(self) -> Sequence['outputs.GetMonitorSchedulingOptionCustomScheduleRecurrenceResult']:
        """
        A list of recurrence definitions. Length must be 1.
        """
        return pulumi.get(self, "recurrences")


@pulumi.output_type
class GetMonitorSchedulingOptionCustomScheduleRecurrenceResult(dict):
    def __init__(__self__, *,
                 rrule: str,
                 start: str,
                 timezone: str):
        """
        :param str rrule: Must be a valid rrule. See api docs for supported fields
        :param str start: Time to start recurrence cycle. Similar to DTSTART. Expected format 'YYYY-MM-DDThh:mm:ss'
        :param str timezone: 'tz database' format. ex: 'America/New_York' or UTC
        """
        pulumi.set(__self__, "rrule", rrule)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "timezone", timezone)

    @property
    @pulumi.getter
    def rrule(self) -> str:
        """
        Must be a valid rrule. See api docs for supported fields
        """
        return pulumi.get(self, "rrule")

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        Time to start recurrence cycle. Similar to DTSTART. Expected format 'YYYY-MM-DDThh:mm:ss'
        """
        return pulumi.get(self, "start")

    @property
    @pulumi.getter
    def timezone(self) -> str:
        """
        'tz database' format. ex: 'America/New_York' or UTC
        """
        return pulumi.get(self, "timezone")


@pulumi.output_type
class GetMonitorSchedulingOptionEvaluationWindowResult(dict):
    def __init__(__self__, *,
                 day_starts: str,
                 hour_starts: int,
                 month_starts: int):
        """
        :param str day_starts: The time of the day at which a one day cumulative evaluation window starts. Must be defined in UTC time in `HH:mm` format.
        :param int hour_starts: The minute of the hour at which a one hour cumulative evaluation window starts. Must be between 0 and 59.
        :param int month_starts: The day of the month at which a one month cumulative evaluation window starts. Must be a value of 1.
        """
        pulumi.set(__self__, "day_starts", day_starts)
        pulumi.set(__self__, "hour_starts", hour_starts)
        pulumi.set(__self__, "month_starts", month_starts)

    @property
    @pulumi.getter(name="dayStarts")
    def day_starts(self) -> str:
        """
        The time of the day at which a one day cumulative evaluation window starts. Must be defined in UTC time in `HH:mm` format.
        """
        return pulumi.get(self, "day_starts")

    @property
    @pulumi.getter(name="hourStarts")
    def hour_starts(self) -> int:
        """
        The minute of the hour at which a one hour cumulative evaluation window starts. Must be between 0 and 59.
        """
        return pulumi.get(self, "hour_starts")

    @property
    @pulumi.getter(name="monthStarts")
    def month_starts(self) -> int:
        """
        The day of the month at which a one month cumulative evaluation window starts. Must be a value of 1.
        """
        return pulumi.get(self, "month_starts")


@pulumi.output_type
class GetMonitorsMonitorResult(dict):
    def __init__(__self__, *,
                 id: int,
                 name: str,
                 type: str):
        """
        :param int id: ID of the monitor
        :param str name: Name of the monitor
        :param str type: Type of the monitor.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        ID of the monitor
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the monitor
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the monitor.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetRoleUsersRoleUserResult(dict):
    def __init__(__self__, *,
                 role_id: str,
                 user_id: str):
        pulumi.set(__self__, "role_id", role_id)
        pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter(name="roleId")
    def role_id(self) -> str:
        return pulumi.get(self, "role_id")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetRolesRoleResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 user_count: int):
        """
        :param str id: ID of the Datadog role
        :param str name: Name of the Datadog role
        :param int user_count: Number of users that have this role.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "user_count", user_count)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the Datadog role
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Datadog role
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="userCount")
    def user_count(self) -> int:
        """
        Number of users that have this role.
        """
        return pulumi.get(self, "user_count")


@pulumi.output_type
class GetSecurityMonitoringFiltersFilterResult(dict):
    def __init__(__self__, *,
                 is_enabled: bool,
                 name: str,
                 query: str,
                 version: int,
                 exclusion_filters: Optional[Sequence['outputs.GetSecurityMonitoringFiltersFilterExclusionFilterResult']] = None,
                 filtered_data_type: Optional[str] = None):
        """
        :param bool is_enabled: Whether the security filter is enabled.
        :param str name: The name of the security filter.
        :param str query: The query of the security filter.
        :param int version: The version of the security filter.
        :param Sequence['GetSecurityMonitoringFiltersFilterExclusionFilterArgs'] exclusion_filters: Exclusion filters to exclude some logs from the security filter.
        :param str filtered_data_type: The filtered data type.
        """
        pulumi.set(__self__, "is_enabled", is_enabled)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "version", version)
        if exclusion_filters is not None:
            pulumi.set(__self__, "exclusion_filters", exclusion_filters)
        if filtered_data_type is not None:
            pulumi.set(__self__, "filtered_data_type", filtered_data_type)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> bool:
        """
        Whether the security filter is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the security filter.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        The query of the security filter.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter
    def version(self) -> int:
        """
        The version of the security filter.
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="exclusionFilters")
    def exclusion_filters(self) -> Optional[Sequence['outputs.GetSecurityMonitoringFiltersFilterExclusionFilterResult']]:
        """
        Exclusion filters to exclude some logs from the security filter.
        """
        return pulumi.get(self, "exclusion_filters")

    @property
    @pulumi.getter(name="filteredDataType")
    def filtered_data_type(self) -> Optional[str]:
        """
        The filtered data type.
        """
        return pulumi.get(self, "filtered_data_type")


@pulumi.output_type
class GetSecurityMonitoringFiltersFilterExclusionFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 query: str):
        """
        :param str name: Exclusion filter name.
        :param str query: Exclusion filter query. Logs that match this query are excluded from the security filter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Exclusion filter name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Exclusion filter query. Logs that match this query are excluded from the security filter.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleResult(dict):
    def __init__(__self__, *,
                 message: str,
                 name: str,
                 cases: Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleCaseResult']] = None,
                 enabled: Optional[bool] = None,
                 filters: Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleFilterResult']] = None,
                 has_extended_title: Optional[bool] = None,
                 options: Optional['outputs.GetSecurityMonitoringRulesRuleOptionsResult'] = None,
                 queries: Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleQueryResult']] = None,
                 reference_tables: Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleReferenceTableResult']] = None,
                 signal_queries: Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleSignalQueryResult']] = None,
                 tags: Optional[Sequence[str]] = None,
                 third_party_cases: Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleThirdPartyCaseResult']] = None,
                 type: Optional[str] = None):
        """
        :param str message: Message for generated signals.
        :param str name: The name of the rule.
        :param Sequence['GetSecurityMonitoringRulesRuleCaseArgs'] cases: Cases for generating signals.
        :param bool enabled: Whether the rule is enabled.
        :param Sequence['GetSecurityMonitoringRulesRuleFilterArgs'] filters: Additional queries to filter matched events before they are processed. **Note**: This field is deprecated for log detection, signal correlation, and workload security rules.
        :param bool has_extended_title: Whether the notifications include the triggering group-by values in their title.
        :param 'GetSecurityMonitoringRulesRuleOptionsArgs' options: Options on rules.
        :param Sequence['GetSecurityMonitoringRulesRuleQueryArgs'] queries: Queries for selecting logs which are part of the rule.
        :param Sequence['GetSecurityMonitoringRulesRuleReferenceTableArgs'] reference_tables: Reference tables for filtering query results.
        :param Sequence['GetSecurityMonitoringRulesRuleSignalQueryArgs'] signal_queries: Queries for selecting logs which are part of the rule.
        :param Sequence[str] tags: Tags for generated signals.
        :param Sequence['GetSecurityMonitoringRulesRuleThirdPartyCaseArgs'] third_party_cases: Cases for generating signals for third-party rules. Only required and accepted for third-party rules
        :param str type: The rule type.
        """
        pulumi.set(__self__, "message", message)
        pulumi.set(__self__, "name", name)
        if cases is not None:
            pulumi.set(__self__, "cases", cases)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if has_extended_title is not None:
            pulumi.set(__self__, "has_extended_title", has_extended_title)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if reference_tables is not None:
            pulumi.set(__self__, "reference_tables", reference_tables)
        if signal_queries is not None:
            pulumi.set(__self__, "signal_queries", signal_queries)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if third_party_cases is not None:
            pulumi.set(__self__, "third_party_cases", third_party_cases)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def message(self) -> str:
        """
        Message for generated signals.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the rule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def cases(self) -> Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleCaseResult']]:
        """
        Cases for generating signals.
        """
        return pulumi.get(self, "cases")

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether the rule is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleFilterResult']]:
        """
        Additional queries to filter matched events before they are processed. **Note**: This field is deprecated for log detection, signal correlation, and workload security rules.
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="hasExtendedTitle")
    def has_extended_title(self) -> Optional[bool]:
        """
        Whether the notifications include the triggering group-by values in their title.
        """
        return pulumi.get(self, "has_extended_title")

    @property
    @pulumi.getter
    def options(self) -> Optional['outputs.GetSecurityMonitoringRulesRuleOptionsResult']:
        """
        Options on rules.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleQueryResult']]:
        """
        Queries for selecting logs which are part of the rule.
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="referenceTables")
    def reference_tables(self) -> Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleReferenceTableResult']]:
        """
        Reference tables for filtering query results.
        """
        return pulumi.get(self, "reference_tables")

    @property
    @pulumi.getter(name="signalQueries")
    def signal_queries(self) -> Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleSignalQueryResult']]:
        """
        Queries for selecting logs which are part of the rule.
        """
        return pulumi.get(self, "signal_queries")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        Tags for generated signals.
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter(name="thirdPartyCases")
    def third_party_cases(self) -> Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleThirdPartyCaseResult']]:
        """
        Cases for generating signals for third-party rules. Only required and accepted for third-party rules
        """
        return pulumi.get(self, "third_party_cases")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The rule type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleCaseResult(dict):
    def __init__(__self__, *,
                 status: str,
                 condition: Optional[str] = None,
                 name: Optional[str] = None,
                 notifications: Optional[Sequence[str]] = None):
        """
        :param str status: Severity of the Security Signal.
        :param str condition: A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated based on the event counts in the previously defined queries.
        :param str name: Name of the case.
        :param Sequence[str] notifications: Notification targets for each rule case.
        """
        pulumi.set(__self__, "status", status)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Severity of the Security Signal.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def condition(self) -> Optional[str]:
        """
        A rule case contains logical operations (`>`,`>=`, `&&`, `||`) to determine if a signal should be generated based on the event counts in the previously defined queries.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the case.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def notifications(self) -> Optional[Sequence[str]]:
        """
        Notification targets for each rule case.
        """
        return pulumi.get(self, "notifications")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleFilterResult(dict):
    def __init__(__self__, *,
                 action: str,
                 query: str):
        """
        :param str action: The type of filtering action.
        :param str query: Query for selecting logs to apply the filtering action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The type of filtering action.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query for selecting logs to apply the filtering action.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleOptionsResult(dict):
    def __init__(__self__, *,
                 decrease_criticality_based_on_env: Optional[bool] = None,
                 detection_method: Optional[str] = None,
                 evaluation_window: Optional[int] = None,
                 impossible_travel_options: Optional['outputs.GetSecurityMonitoringRulesRuleOptionsImpossibleTravelOptionsResult'] = None,
                 keep_alive: Optional[int] = None,
                 max_signal_duration: Optional[int] = None,
                 new_value_options: Optional['outputs.GetSecurityMonitoringRulesRuleOptionsNewValueOptionsResult'] = None,
                 third_party_rule_options: Optional['outputs.GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptionsResult'] = None):
        """
        :param bool decrease_criticality_based_on_env: If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `log_detection`.
        :param str detection_method: The detection method.
        :param int evaluation_window: A time window is specified to match when at least one of the cases matches true. This is a sliding window and evaluates in real time.
        :param 'GetSecurityMonitoringRulesRuleOptionsImpossibleTravelOptionsArgs' impossible_travel_options: Options for rules using the impossible travel detection method.
        :param int keep_alive: Once a signal is generated, the signal will remain open if a case is matched at least once within this keep alive window (in seconds).
        :param int max_signal_duration: A signal will close regardless of the query being matched once the time exceeds the maximum duration (in seconds). This time is calculated from the first seen timestamp.
        :param 'GetSecurityMonitoringRulesRuleOptionsNewValueOptionsArgs' new_value_options: New value rules specific options.
        :param 'GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptionsArgs' third_party_rule_options: Options for rules using the third-party detection method.
        """
        if decrease_criticality_based_on_env is not None:
            pulumi.set(__self__, "decrease_criticality_based_on_env", decrease_criticality_based_on_env)
        if detection_method is not None:
            pulumi.set(__self__, "detection_method", detection_method)
        if evaluation_window is not None:
            pulumi.set(__self__, "evaluation_window", evaluation_window)
        if impossible_travel_options is not None:
            pulumi.set(__self__, "impossible_travel_options", impossible_travel_options)
        if keep_alive is not None:
            pulumi.set(__self__, "keep_alive", keep_alive)
        if max_signal_duration is not None:
            pulumi.set(__self__, "max_signal_duration", max_signal_duration)
        if new_value_options is not None:
            pulumi.set(__self__, "new_value_options", new_value_options)
        if third_party_rule_options is not None:
            pulumi.set(__self__, "third_party_rule_options", third_party_rule_options)

    @property
    @pulumi.getter(name="decreaseCriticalityBasedOnEnv")
    def decrease_criticality_based_on_env(self) -> Optional[bool]:
        """
        If true, signals in non-production environments have a lower severity than what is defined by the rule case, which can reduce noise. The decrement is applied when the environment tag of the signal starts with `staging`, `test`, or `dev`. Only available when the rule type is `log_detection`.
        """
        return pulumi.get(self, "decrease_criticality_based_on_env")

    @property
    @pulumi.getter(name="detectionMethod")
    def detection_method(self) -> Optional[str]:
        """
        The detection method.
        """
        return pulumi.get(self, "detection_method")

    @property
    @pulumi.getter(name="evaluationWindow")
    def evaluation_window(self) -> Optional[int]:
        """
        A time window is specified to match when at least one of the cases matches true. This is a sliding window and evaluates in real time.
        """
        return pulumi.get(self, "evaluation_window")

    @property
    @pulumi.getter(name="impossibleTravelOptions")
    def impossible_travel_options(self) -> Optional['outputs.GetSecurityMonitoringRulesRuleOptionsImpossibleTravelOptionsResult']:
        """
        Options for rules using the impossible travel detection method.
        """
        return pulumi.get(self, "impossible_travel_options")

    @property
    @pulumi.getter(name="keepAlive")
    def keep_alive(self) -> Optional[int]:
        """
        Once a signal is generated, the signal will remain open if a case is matched at least once within this keep alive window (in seconds).
        """
        return pulumi.get(self, "keep_alive")

    @property
    @pulumi.getter(name="maxSignalDuration")
    def max_signal_duration(self) -> Optional[int]:
        """
        A signal will close regardless of the query being matched once the time exceeds the maximum duration (in seconds). This time is calculated from the first seen timestamp.
        """
        return pulumi.get(self, "max_signal_duration")

    @property
    @pulumi.getter(name="newValueOptions")
    def new_value_options(self) -> Optional['outputs.GetSecurityMonitoringRulesRuleOptionsNewValueOptionsResult']:
        """
        New value rules specific options.
        """
        return pulumi.get(self, "new_value_options")

    @property
    @pulumi.getter(name="thirdPartyRuleOptions")
    def third_party_rule_options(self) -> Optional['outputs.GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptionsResult']:
        """
        Options for rules using the third-party detection method.
        """
        return pulumi.get(self, "third_party_rule_options")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleOptionsImpossibleTravelOptionsResult(dict):
    def __init__(__self__, *,
                 baseline_user_locations: Optional[bool] = None):
        """
        :param bool baseline_user_locations: If true, signals are suppressed for the first 24 hours. During that time, Datadog learns the user's regular access locations. This can be helpful to reduce noise and infer VPN usage or credentialed API access.
        """
        if baseline_user_locations is not None:
            pulumi.set(__self__, "baseline_user_locations", baseline_user_locations)

    @property
    @pulumi.getter(name="baselineUserLocations")
    def baseline_user_locations(self) -> Optional[bool]:
        """
        If true, signals are suppressed for the first 24 hours. During that time, Datadog learns the user's regular access locations. This can be helpful to reduce noise and infer VPN usage or credentialed API access.
        """
        return pulumi.get(self, "baseline_user_locations")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleOptionsNewValueOptionsResult(dict):
    def __init__(__self__, *,
                 forget_after: int,
                 learning_duration: Optional[int] = None,
                 learning_method: Optional[str] = None,
                 learning_threshold: Optional[int] = None):
        """
        :param int forget_after: The duration in days after which a learned value is forgotten.
        :param int learning_duration: The duration in days during which values are learned, and after which signals will be generated for values that weren't learned. If set to 0, a signal will be generated for all new values after the first value is learned.
        :param str learning_method: The learning method used to determine when signals should be generated for values that weren't learned.
        :param int learning_threshold: A number of occurrences after which signals are generated for values that weren't learned.
        """
        pulumi.set(__self__, "forget_after", forget_after)
        if learning_duration is not None:
            pulumi.set(__self__, "learning_duration", learning_duration)
        if learning_method is not None:
            pulumi.set(__self__, "learning_method", learning_method)
        if learning_threshold is not None:
            pulumi.set(__self__, "learning_threshold", learning_threshold)

    @property
    @pulumi.getter(name="forgetAfter")
    def forget_after(self) -> int:
        """
        The duration in days after which a learned value is forgotten.
        """
        return pulumi.get(self, "forget_after")

    @property
    @pulumi.getter(name="learningDuration")
    def learning_duration(self) -> Optional[int]:
        """
        The duration in days during which values are learned, and after which signals will be generated for values that weren't learned. If set to 0, a signal will be generated for all new values after the first value is learned.
        """
        return pulumi.get(self, "learning_duration")

    @property
    @pulumi.getter(name="learningMethod")
    def learning_method(self) -> Optional[str]:
        """
        The learning method used to determine when signals should be generated for values that weren't learned.
        """
        return pulumi.get(self, "learning_method")

    @property
    @pulumi.getter(name="learningThreshold")
    def learning_threshold(self) -> Optional[int]:
        """
        A number of occurrences after which signals are generated for values that weren't learned.
        """
        return pulumi.get(self, "learning_threshold")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptionsResult(dict):
    def __init__(__self__, *,
                 default_status: str,
                 root_queries: Sequence['outputs.GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptionsRootQueryResult'],
                 default_notifications: Optional[Sequence[str]] = None,
                 signal_title_template: Optional[str] = None):
        """
        :param str default_status: Severity of the default rule case, when none of the third-party cases match.
        :param Sequence['GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptionsRootQueryArgs'] root_queries: Queries to be combined with third-party case queries. Each of them can have different group by fields, to aggregate differently based on the type of alert.
        :param Sequence[str] default_notifications: Notification targets for the default rule case, when none of the third-party cases match.
        :param str signal_title_template: A template for the signal title; if omitted, the title is generated based on the case name.
        """
        pulumi.set(__self__, "default_status", default_status)
        pulumi.set(__self__, "root_queries", root_queries)
        if default_notifications is not None:
            pulumi.set(__self__, "default_notifications", default_notifications)
        if signal_title_template is not None:
            pulumi.set(__self__, "signal_title_template", signal_title_template)

    @property
    @pulumi.getter(name="defaultStatus")
    def default_status(self) -> str:
        """
        Severity of the default rule case, when none of the third-party cases match.
        """
        return pulumi.get(self, "default_status")

    @property
    @pulumi.getter(name="rootQueries")
    def root_queries(self) -> Sequence['outputs.GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptionsRootQueryResult']:
        """
        Queries to be combined with third-party case queries. Each of them can have different group by fields, to aggregate differently based on the type of alert.
        """
        return pulumi.get(self, "root_queries")

    @property
    @pulumi.getter(name="defaultNotifications")
    def default_notifications(self) -> Optional[Sequence[str]]:
        """
        Notification targets for the default rule case, when none of the third-party cases match.
        """
        return pulumi.get(self, "default_notifications")

    @property
    @pulumi.getter(name="signalTitleTemplate")
    def signal_title_template(self) -> Optional[str]:
        """
        A template for the signal title; if omitted, the title is generated based on the case name.
        """
        return pulumi.get(self, "signal_title_template")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleOptionsThirdPartyRuleOptionsRootQueryResult(dict):
    def __init__(__self__, *,
                 query: str,
                 group_by_fields: Optional[Sequence[str]] = None):
        """
        :param str query: Query to filter logs.
        :param Sequence[str] group_by_fields: Fields to group by. If empty, each log triggers a signal.
        """
        pulumi.set(__self__, "query", query)
        if group_by_fields is not None:
            pulumi.set(__self__, "group_by_fields", group_by_fields)

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query to filter logs.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="groupByFields")
    def group_by_fields(self) -> Optional[Sequence[str]]:
        """
        Fields to group by. If empty, each log triggers a signal.
        """
        return pulumi.get(self, "group_by_fields")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleQueryResult(dict):
    def __init__(__self__, *,
                 metrics: Sequence[str],
                 query: str,
                 agent_rules: Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleQueryAgentRuleResult']] = None,
                 aggregation: Optional[str] = None,
                 distinct_fields: Optional[Sequence[str]] = None,
                 group_by_fields: Optional[Sequence[str]] = None,
                 metric: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param Sequence[str] metrics: Group of target fields to aggregate over when using the `sum`, `max`, `geo_data`, or `new_value` aggregations. The `sum`, `max`, and `geo_data` aggregations only accept one value in this list, whereas the `new_value` aggregation accepts up to five values.
        :param str query: Query to run on logs.
        :param Sequence['GetSecurityMonitoringRulesRuleQueryAgentRuleArgs'] agent_rules: **Deprecated**. It won't be applied anymore.
        :param str aggregation: The aggregation type. For Signal Correlation rules, it must be event_count.
        :param Sequence[str] distinct_fields: Field for which the cardinality is measured. Sent as an array.
        :param Sequence[str] group_by_fields: Fields to group by.
        :param str metric: The target field to aggregate over when using the `sum`, `max`, or `geo_data` aggregations.
        :param str name: Name of the query. Not compatible with `new_value` aggregations.
        """
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "query", query)
        if agent_rules is not None:
            pulumi.set(__self__, "agent_rules", agent_rules)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if distinct_fields is not None:
            pulumi.set(__self__, "distinct_fields", distinct_fields)
        if group_by_fields is not None:
            pulumi.set(__self__, "group_by_fields", group_by_fields)
        if metric is not None:
            pulumi.set(__self__, "metric", metric)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def metrics(self) -> Sequence[str]:
        """
        Group of target fields to aggregate over when using the `sum`, `max`, `geo_data`, or `new_value` aggregations. The `sum`, `max`, and `geo_data` aggregations only accept one value in this list, whereas the `new_value` aggregation accepts up to five values.
        """
        return pulumi.get(self, "metrics")

    @property
    @pulumi.getter
    def query(self) -> str:
        """
        Query to run on logs.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="agentRules")
    @_utilities.deprecated("""`agent_rule` has been deprecated in favor of new Agent Rule resource.""")
    def agent_rules(self) -> Optional[Sequence['outputs.GetSecurityMonitoringRulesRuleQueryAgentRuleResult']]:
        """
        **Deprecated**. It won't be applied anymore.
        """
        return pulumi.get(self, "agent_rules")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        The aggregation type. For Signal Correlation rules, it must be event_count.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="distinctFields")
    def distinct_fields(self) -> Optional[Sequence[str]]:
        """
        Field for which the cardinality is measured. Sent as an array.
        """
        return pulumi.get(self, "distinct_fields")

    @property
    @pulumi.getter(name="groupByFields")
    def group_by_fields(self) -> Optional[Sequence[str]]:
        """
        Fields to group by.
        """
        return pulumi.get(self, "group_by_fields")

    @property
    @pulumi.getter
    @_utilities.deprecated("""Configure `metrics` instead. This attribute will be removed in the next major version of the provider.""")
    def metric(self) -> Optional[str]:
        """
        The target field to aggregate over when using the `sum`, `max`, or `geo_data` aggregations.
        """
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the query. Not compatible with `new_value` aggregations.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleQueryAgentRuleResult(dict):
    def __init__(__self__, *,
                 agent_rule_id: str,
                 expression: str):
        """
        :param str agent_rule_id: **Deprecated**. It won't be applied anymore.
        :param str expression: **Deprecated**. It won't be applied anymore.
        """
        pulumi.set(__self__, "agent_rule_id", agent_rule_id)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="agentRuleId")
    def agent_rule_id(self) -> str:
        """
        **Deprecated**. It won't be applied anymore.
        """
        return pulumi.get(self, "agent_rule_id")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        **Deprecated**. It won't be applied anymore.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleReferenceTableResult(dict):
    def __init__(__self__, *,
                 check_presence: bool,
                 column_name: str,
                 log_field_path: str,
                 rule_query_name: str,
                 table_name: str):
        """
        :param bool check_presence: Whether to include or exclude logs that match the reference table.
        :param str column_name: The name of the column in the reference table.
        :param str log_field_path: The field in the log that should be matched against the reference table.
        :param str rule_query_name: The name of the query to filter.
        :param str table_name: The name of the reference table.
        """
        pulumi.set(__self__, "check_presence", check_presence)
        pulumi.set(__self__, "column_name", column_name)
        pulumi.set(__self__, "log_field_path", log_field_path)
        pulumi.set(__self__, "rule_query_name", rule_query_name)
        pulumi.set(__self__, "table_name", table_name)

    @property
    @pulumi.getter(name="checkPresence")
    def check_presence(self) -> bool:
        """
        Whether to include or exclude logs that match the reference table.
        """
        return pulumi.get(self, "check_presence")

    @property
    @pulumi.getter(name="columnName")
    def column_name(self) -> str:
        """
        The name of the column in the reference table.
        """
        return pulumi.get(self, "column_name")

    @property
    @pulumi.getter(name="logFieldPath")
    def log_field_path(self) -> str:
        """
        The field in the log that should be matched against the reference table.
        """
        return pulumi.get(self, "log_field_path")

    @property
    @pulumi.getter(name="ruleQueryName")
    def rule_query_name(self) -> str:
        """
        The name of the query to filter.
        """
        return pulumi.get(self, "rule_query_name")

    @property
    @pulumi.getter(name="tableName")
    def table_name(self) -> str:
        """
        The name of the reference table.
        """
        return pulumi.get(self, "table_name")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleSignalQueryResult(dict):
    def __init__(__self__, *,
                 rule_id: str,
                 aggregation: Optional[str] = None,
                 correlated_by_fields: Optional[Sequence[str]] = None,
                 correlated_query_index: Optional[str] = None,
                 default_rule_id: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str rule_id: Rule ID of the signal to correlate.
        :param str aggregation: The aggregation type. For Signal Correlation rules, it must be event_count.
        :param Sequence[str] correlated_by_fields: Fields to correlate by.
        :param str correlated_query_index: Index of the rule query used to retrieve the correlated field. An empty string applies correlation on the non-projected per query attributes of the rule.
        :param str default_rule_id: Default Rule ID of the signal to correlate. This value is READ-ONLY.
        :param str name: Name of the query. Not compatible with `new_value` aggregations.
        """
        pulumi.set(__self__, "rule_id", rule_id)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)
        if correlated_by_fields is not None:
            pulumi.set(__self__, "correlated_by_fields", correlated_by_fields)
        if correlated_query_index is not None:
            pulumi.set(__self__, "correlated_query_index", correlated_query_index)
        if default_rule_id is not None:
            pulumi.set(__self__, "default_rule_id", default_rule_id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> str:
        """
        Rule ID of the signal to correlate.
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[str]:
        """
        The aggregation type. For Signal Correlation rules, it must be event_count.
        """
        return pulumi.get(self, "aggregation")

    @property
    @pulumi.getter(name="correlatedByFields")
    def correlated_by_fields(self) -> Optional[Sequence[str]]:
        """
        Fields to correlate by.
        """
        return pulumi.get(self, "correlated_by_fields")

    @property
    @pulumi.getter(name="correlatedQueryIndex")
    def correlated_query_index(self) -> Optional[str]:
        """
        Index of the rule query used to retrieve the correlated field. An empty string applies correlation on the non-projected per query attributes of the rule.
        """
        return pulumi.get(self, "correlated_query_index")

    @property
    @pulumi.getter(name="defaultRuleId")
    def default_rule_id(self) -> Optional[str]:
        """
        Default Rule ID of the signal to correlate. This value is READ-ONLY.
        """
        return pulumi.get(self, "default_rule_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the query. Not compatible with `new_value` aggregations.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetSecurityMonitoringRulesRuleThirdPartyCaseResult(dict):
    def __init__(__self__, *,
                 status: str,
                 name: Optional[str] = None,
                 notifications: Optional[Sequence[str]] = None,
                 query: Optional[str] = None):
        """
        :param str status: Severity of the Security Signal.
        :param str name: Name of the case.
        :param Sequence[str] notifications: Notification targets for each rule case.
        :param str query: A query to associate a third-party event to this case.
        """
        pulumi.set(__self__, "status", status)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notifications is not None:
            pulumi.set(__self__, "notifications", notifications)
        if query is not None:
            pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Severity of the Security Signal.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the case.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def notifications(self) -> Optional[Sequence[str]]:
        """
        Notification targets for each rule case.
        """
        return pulumi.get(self, "notifications")

    @property
    @pulumi.getter
    def query(self) -> Optional[str]:
        """
        A query to associate a third-party event to this case.
        """
        return pulumi.get(self, "query")


@pulumi.output_type
class GetSecurityMonitoringSuppressionsSuppressionResult(dict):
    def __init__(__self__, *,
                 data_exclusion_query: str,
                 description: str,
                 enabled: bool,
                 expiration_date: str,
                 id: str,
                 name: str,
                 rule_query: str,
                 suppression_query: str):
        pulumi.set(__self__, "data_exclusion_query", data_exclusion_query)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "expiration_date", expiration_date)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "rule_query", rule_query)
        pulumi.set(__self__, "suppression_query", suppression_query)

    @property
    @pulumi.getter(name="dataExclusionQuery")
    def data_exclusion_query(self) -> str:
        return pulumi.get(self, "data_exclusion_query")

    @property
    @pulumi.getter
    def description(self) -> str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="expirationDate")
    def expiration_date(self) -> str:
        return pulumi.get(self, "expiration_date")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="ruleQuery")
    def rule_query(self) -> str:
        return pulumi.get(self, "rule_query")

    @property
    @pulumi.getter(name="suppressionQuery")
    def suppression_query(self) -> str:
        return pulumi.get(self, "suppression_query")


@pulumi.output_type
class GetServiceLevelObjectiveQueryResult(dict):
    def __init__(__self__, *,
                 denominator: str,
                 numerator: str):
        """
        :param str denominator: The sum of the `total` events.
        :param str numerator: The sum of all the `good` events.
        """
        pulumi.set(__self__, "denominator", denominator)
        pulumi.set(__self__, "numerator", numerator)

    @property
    @pulumi.getter
    def denominator(self) -> str:
        """
        The sum of the `total` events.
        """
        return pulumi.get(self, "denominator")

    @property
    @pulumi.getter
    def numerator(self) -> str:
        """
        The sum of all the `good` events.
        """
        return pulumi.get(self, "numerator")


@pulumi.output_type
class GetServiceLevelObjectivesSloResult(dict):
    def __init__(__self__, *,
                 id: str,
                 name: str,
                 type: str):
        """
        :param str id: ID of the Datadog service level objective
        :param str name: Name of the Datadog service level objective
        :param str type: The type of the service level objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API [documentation page](https://docs.datadoghq.com/api/v1/service-level-objectives/#create-a-slo-object). Available options to choose from are: `metric` and `monitor`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the Datadog service level objective
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the Datadog service level objective
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of the service level objective. The mapping from these types to the types found in the Datadog Web UI can be found in the Datadog API [documentation page](https://docs.datadoghq.com/api/v1/service-level-objectives/#create-a-slo-object). Available options to choose from are: `metric` and `monitor`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetTeamMembershipsTeamMembershipResult(dict):
    def __init__(__self__, *,
                 id: str,
                 role: str,
                 team_id: str,
                 user_id: str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "team_id", team_id)
        pulumi.set(__self__, "user_id", user_id)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def role(self) -> str:
        return pulumi.get(self, "role")

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> str:
        return pulumi.get(self, "team_id")

    @property
    @pulumi.getter(name="userId")
    def user_id(self) -> str:
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetUsersUserResult(dict):
    def __init__(__self__, *,
                 email: str,
                 id: str,
                 name: str):
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> str:
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")


